using System.Collections.Generic;
using System.IO;
using System.Linq;
using Datadog.CustomActions.Interfaces;
using WixToolset.Dtf.WindowsInstaller;

namespace Datadog.CustomActions.Extensions
{
    /// <summary>
    /// Taken from WixSharp since we need it in .Net 3.5
    /// </summary>
    public static class SessionExtensions
    {
        /// <summary>
        /// Determines whether the specified <see
        /// cref="T:Microsoft.Deployment.WindowsInstaller.Session"/> is active.
        /// <para>
        /// It is useful for checking if the session is terminated (e.g. in deferred custom actions).
        /// </para>
        /// </summary>
        /// <param name="session">The session.</param>
        /// <returns></returns>
        public static bool IsActive(this ISession session)
        {
            //if (!session.IsClosed) //unfortunately isClosed is always false even for the deferred actions
            try
            {
                var test = session.Components; //it will throw for the deferred action
                var text = session["INSTALLDIR"];
                return true;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Returns the value of the named property of the specified <see
        /// cref="T:Microsoft.Deployment.WindowsInstaller.Session"/> object.
        /// <para>
        /// It can be uses as a generic way of accessing the properties as it redirects
        /// (transparently) access to the <see
        /// cref="T:Microsoft.Deployment.WindowsInstaller.Session.CustomActionData"/> if the session
        /// is terminated (e.g. in deferred custom actions).
        /// </para>
        /// </summary>
        /// <param name="session">The session.</param>
        /// <param name="name">The name.</param>
        /// <returns></returns>
        public static string Property(this ISession session, string name)
        {
            if (session.IsActive())
            {
                return session[name];
            }
            else
            {
                return (session.CustomActionData.ContainsKey(name) ? session.CustomActionData[name] : "");
            }
        }

        /// <summary>
        /// The paths that are generated by the Agent / installer and that can be safely
        /// disposed of between installs.
        /// </summary>
        /// <param name="session">The session.</param>
        /// <returns>The list of paths.</returns>
        public static List<string> GeneratedPaths(this ISession session)
        {
            var configRoot = session.Property("APPLICATIONDATADIRECTORY");

            return new List<string>
            {
                Path.Combine(configRoot, "auth_token"),
                Path.Combine(configRoot, "python-cache"),
                Path.Combine(configRoot, "ipc_cert.pem"),
            };
        }

        /// <summary>
        /// The paths that the Agent should have access to (and that we should ensure
        /// the permissions are updated).
        /// </summary>
        /// <remarks>This includes the <see cref="GeneratedPaths"/> as well, even though they should get cleaned up.
        /// This is to ensure that if we didn't clean them, at least we would set the correct permissions on them.</remarks>
        /// <param name="session">The session.</param>
        /// <returns>The list of paths.</returns>
        public static List<string> PathsWithAgentAccess(this ISession session)
        {
            var configRoot = session.Property("APPLICATIONDATADIRECTORY");

            return new List<string>
            {
                Path.Combine(configRoot, "conf.d"),
                Path.Combine(configRoot, "checks.d"),
                Path.Combine(configRoot, "run"),
                Path.Combine(configRoot, "logs"),
                Path.Combine(configRoot, "datadog.yaml"),
                Path.Combine(configRoot, "system-probe.yaml"),
                Path.Combine(configRoot, "install_info"),
            }
            .Concat(session.GeneratedPaths()).ToList();
        }
    }
}
