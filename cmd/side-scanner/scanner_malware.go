package main

import (
	"bufio"
	"context"
	"fmt"
	"os/exec"
	"strings"

	"github.com/DataDog/datadog-agent/pkg/util/log"
)

func launchScannerMalwareLocal(ctx context.Context, scan *scanTask, mountPoint string) (*findings, error) {
	return runYara(ctx, "/tmp/rules.yar", fmt.Sprintf("%s", mountPoint)) // XXX %s/home
}

type yaraResult struct {
	File string
	Info string
	Rule string
}

func runYara(ctx context.Context, rules, dir string) (*findings, error) {
	args := []string{"-r", "-w", "-N", rules, dir}

	cmd := exec.CommandContext(ctx, "/opt/datadog-agent/embedded/bin/yara", args...)
	cmd.Dir = dir

	log.Debugf("running %s\n", cmd.String())

	stdout, err := cmd.StdoutPipe()
	if err != nil {
		return nil, err
	}

	stderr, err := cmd.StderrPipe()
	if err != nil {
		return nil, err
	}

	if err := cmd.Start(); err != nil {
		return nil, err
	}
	defer cmd.Wait()

	f := &findings{
		Results: make([]yaraResult, 0),
	}

	scannerErr := bufio.NewScanner(stderr)

	go func() {
		for scannerErr.Scan() {
			log.Warnf("yara: %s", scannerErr.Text())
		}
	}()

	scannerOut := bufio.NewScanner(stdout)

	for scannerOut.Scan() {
		log.Debugf("yara: %s", scannerOut.Text())
		s := strings.Split(scannerOut.Text(), " ")
		switch len(s) {
		case 2:
			result := yaraResult{
				Rule: s[0],
				File: s[1],
			}
			f.Results = append(f.Results, result)
		case 3:
			result := yaraResult{
				Rule: s[0],
				Info: s[1],
				File: s[2],
			}
			f.Results = append(f.Results, result)
		default:
			log.Warnf("invalid yara output: %s", scannerOut.Text())
		}
	}

	return f, nil
}
