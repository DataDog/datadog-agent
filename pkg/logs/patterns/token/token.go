// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

// Package token provides data structures and utilities for tokenizing log messages.
package token

import (
	"fmt"
)

//go:generate stringer -type=TokenType -trimprefix=Token

// TokenType.String() method is auto-generated by stringer
// Run: go generate ./pkg/logs/patterns/token to regenerate the stringer file if you make changes to the TokenType enum

// TokenType represents the type of a token
//
//nolint:revive
type TokenType int

const (
	// Basic token types
	//nolint:revive
	TokenUnknown     TokenType = iota // TokenUnknown is the unknown token type
	TokenWord                         // TokenWord is the word token type
	TokenNumeric                      // TokenNumeric is the numeric token type
	TokenWhitespace                   // TokenWhitespace is the whitespace token type
	TokenSpecialChar                  // TokenSpecialChar is the special character token type

	// Network-related tokens
	//nolint:revive
	TokenIPv4                     // TokenIPv4 is the IPv4 token type
	TokenIPv6                     // TokenIPv6 is the IPv6 token type
	TokenEmail                    // TokenEmail is the email token type
	TokenURI                      // TokenURI is the URI token type
	TokenAbsolutePath             // TokenAbsolutePath is the absolute path token type
	TokenAuthority                // TokenAuthority is the authority token type (domain:port)
	TokenPathWithQueryAndFragment // TokenPathWithQueryAndFragment is the path with query and fragment token type
	TokenRegularName              // TokenRegularName is the regular name token type

	// HTTP-related tokens
	//nolint:revive
	TokenHTTPMethod // TokenHTTPMethod is the HTTP method token type
	TokenHTTPStatus // TokenHTTPStatus is the HTTP status token type

	// Log-related tokens
	//nolint:revive
	TokenSeverityLevel  // TokenSeverityLevel is the severity level token type
	TokenDate           // TokenDate is the date token type
	TokenLocalDate      // TokenLocalDate is the local date token type (yyyy-MM-dd)
	TokenLocalTime      // TokenLocalTime is the local time token type (HH:mm:ss)
	TokenLocalDateTime  // TokenLocalDateTime is the local datetime token type
	TokenOffsetDateTime // TokenOffsetDateTime is the offset datetime token type

	// Composite tokens
	//nolint:revive
	TokenKeyValueSequence // TokenKeyValueSequence is the key-value sequence token type
	TokenCollapsedToken   // TokenCollapsedToken is the collapsed token type
)

// WildcardStatus describes a token's potential to become a wildcard
type WildcardStatus int

const (
	// NotWildcard - This token cannot become a wildcard
	// Examples: whitespace or first word token
	NotWildcard WildcardStatus = iota

	// PotentialWildcard - This token can become a wildcard
	// Examples: all non white space tokens
	PotentialWildcard

	// IsWildcard - This token is already a wildcard
	IsWildcard
)

// MergeResult describes the result of comparing two tokens
type MergeResult int

const (
	// Conflict - Tokens cannot merge, abort pattern creation
	// Examples: different types, words with different values
	Conflict MergeResult = iota

	// Identical - Tokens are the same, keep as-is
	// Examples: "Error" vs "Error", wildcard vs any value of same type
	Identical

	// Wildcard - Tokens can merge into wildcard
	// Examples: "connection" vs "replication", "user123" vs "admin456", "GET" vs "POST"
	Wildcard
)

// Token represents a single token in a log message
type Token struct {
	Type     TokenType
	Value    string
	Wildcard WildcardStatus

	// Flags from Rust tokenizer
	NeverWildcard bool // If true, this token should never become a wildcard
	HasDigits     bool // If true, this word token contains digits
}

// NewToken creates a token with the specified wildcard status
func NewToken(tokenType TokenType, value string, wildcard WildcardStatus) Token {
	return Token{
		Type:     tokenType,
		Value:    value,
		Wildcard: wildcard,
	}
}

// String returns a string representation of the token
func (t *Token) String() string {
	return fmt.Sprintf("%s(%s)", t.Type, t.Value)
}

// Compare checks if two tokens can merge
func (t *Token) Compare(t2 *Token) MergeResult {
	// Different types cannot merge
	if t.Type != t2.Type {
		return Conflict
	}

	// Same type same value - check this first before type-specific logic
	if t.Value == t2.Value {
		return Identical
	}

	// t is wildcard - matches any value of same type
	if t.Wildcard == IsWildcard {
		return Identical
	}

	// Whitespace never wildcards (structural)
	if t.Type == TokenWhitespace {
		return Conflict
	}

	// Words only wildcard if both are PotentialWildcard and neither has NeverWildcard flag
	if t.Type == TokenWord {
		if t.NeverWildcard || t2.NeverWildcard {
			return Conflict
		}
		if t.Wildcard == PotentialWildcard && t2.Wildcard == PotentialWildcard {
			return Wildcard
		}
		return Conflict
	}

	// Structured types (HTTP, IP, Numeric, Date, etc.) wildcard if same type
	// Same TokenDate type means same format structure (e.g., both RFC3339)
	return Wildcard
}
