// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2024-present Datadog, Inc.

package usm

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io/fs"
	"path"
	"regexp"

	"github.com/shirou/gopsutil/v4/process"

	"github.com/DataDog/datadog-agent/pkg/util/log"
)

var (
	moduleRegexp  = regexp.MustCompile(`module\s+([A-Z][a-zA-Z0-9_]*)`)
	matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
	matchAllCap   = regexp.MustCompile("([a-z0-9])([A-Z])")
)

type railsDetector struct {
	ctx DetectionContext
}

func newRailsDetector(ctx DetectionContext) detector {
	return &railsDetector{ctx}
}

func (r railsDetector) detect(cmdline []string) (ServiceMetadata, bool) {
	if result, ok := r.detectRails(); ok {
		return result, true
	}

	// If the Rails detection fails, try to extract the name from the Puma
	// command line.
	return extractPumaName(cmdline)
}

// detectRails checks if the service is a Rails application by looking for a
// `config/application.rb` file generated by `rails new` when a new rails
// project is created. This file should contain a `module` declaration with the
// application name.
func (r railsDetector) detectRails() (ServiceMetadata, bool) {
	var proc *process.Process
	if procEntry, ok := r.ctx.ContextMap[ServiceProc]; ok {
		if p, ok := procEntry.(*process.Process); ok {
			proc = p
		} else {
			log.Errorf("could not get process object in rails detector: got type %T", procEntry)
		}
	}

	if proc == nil {
		return ServiceMetadata{}, false
	}

	cwd, err := proc.Cwd()
	if err != nil {
		log.Debugf("could not get cwd of process: %s", err)
		return ServiceMetadata{}, false
	}

	absFile := path.Join(cwd, "config/application.rb")
	if _, err := fs.Stat(r.ctx.fs, absFile); err != nil {
		return ServiceMetadata{}, false
	}

	name, err := r.findRailsApplicationName(absFile)
	if err != nil {
		log.Debugf("could not find ruby application name: %s", err)
		return ServiceMetadata{}, false
	}

	return NewServiceMetadata(string(name), Rails), true
}

// extractPumaName attempts to extract the name from the Puma command line.
// The name is found in square brackets at the end of the command line.
func extractPumaName(cmdline []string) (ServiceMetadata, bool) {
	if len(cmdline) == 0 {
		return ServiceMetadata{}, false
	}

	lastArg := cmdline[len(cmdline)-1]
	if len(lastArg) >= 2 && lastArg[0] == '[' && lastArg[len(lastArg)-1] == ']' {
		// Extract the name between the brackets
		name := lastArg[1 : len(lastArg)-1]
		return NewServiceMetadata(name, CommandLine), true
	}

	return ServiceMetadata{}, false
}

// findRailsApplicationName scans the `config/application.rb` file to find the
// Rails application name.
func (r railsDetector) findRailsApplicationName(filename string) ([]byte, error) {
	file, err := r.ctx.fs.Open(filename)
	if err != nil {
		return nil, fmt.Errorf("could not open application.rb: %w", err)
	}
	defer file.Close()

	reader, err := SizeVerifiedReader(file)
	if err != nil {
		return nil, fmt.Errorf("skipping application.rb (%q): %w", filename, err)
	}

	scanner := bufio.NewScanner(reader)
	for scanner.Scan() {
		matches := moduleRegexp.FindSubmatch(scanner.Bytes())
		if len(matches) >= 2 {
			return railsUnderscore(matches[1]), nil
		}
	}

	// No match found
	return nil, errors.New("could not find Ruby module name")
}

// railsUnderscore converts a PascalCasedWord to a snake_cased_word.
// It keeps uppercase acronyms together when converting (e.g. "HTTPServer" -> "http_server").
func railsUnderscore(pascalCasedWord []byte) []byte {
	snake := matchFirstCap.ReplaceAll(pascalCasedWord, []byte("${1}_${2}"))
	snake = matchAllCap.ReplaceAll(snake, []byte("${1}_${2}"))
	return bytes.ToLower(snake)
}
