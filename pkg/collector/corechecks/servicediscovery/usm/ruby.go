// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package usm

import (
	"io"
	"io/fs"
	"regexp"
	"strings"

	"github.com/DataDog/datadog-agent/pkg/util/log"
)

var (
	moduleRegexp  = regexp.MustCompile(`module\s+([A-Z][a-zA-Z0-9_]*)`)
	matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
	matchAllCap   = regexp.MustCompile("([a-z0-9])([A-Z])")
)

type railsDetector struct {
	ctx DetectionContext
}

func newRailsDetector(ctx DetectionContext) detector {
	return &railsDetector{ctx}
}

// detect checks if the service is a Rails application by looking for a
// `config/application.rb` file generated by `rails new` when a new rails
// project is created. This file should contain a `module` declaration with the
// application name.
func (r railsDetector) detect(_ []string) (ServiceMetadata, bool) {
	cwd := r.ctx.contextMap[ServiceCwd].(string)
	absFile := abs("config/application.rb", cwd)
	if _, err := fs.Stat(r.ctx.fs, absFile); err != nil {
		return ServiceMetadata{}, false
	}

	name, ok := r.findRailsApplicationName(absFile)
	if !ok {
		return ServiceMetadata{}, false
	}

	return NewServiceMetadata(railsUnderscore(name)), true
}

// findRailsApplicationName scans the `config/application.rb` file to find the
// Rails application name.
func (r railsDetector) findRailsApplicationName(filename string) (string, bool) {
	log.Debugf("findRailsApplicationName")
	file, err := r.ctx.fs.Open(filename)
	if err != nil {
		log.Debugf("could not open application.rb")
		return "", false
	}
	defer file.Close()

	reader, err := SizeVerifiedReader(file)
	if err != nil {
		log.Debugf("skipping application.rb (%q): %v", filename, err)
		return "", true
	}

	bytes, err := io.ReadAll(reader)
	if err != nil {
		log.Debugf("unable to read application.rb (%q): %v", filename, err)
		return "", true
	}

	matches := moduleRegexp.FindSubmatch(bytes)
	if matches != nil {
		return string(matches[1]), true
	}

	// No match found
	return "", false
}

// Converts a PascalCasedWord to a snake_cased_word.
// It keeps uppercase acronyms together when converting (e.g. "HTTPServer" -> "http_server").
func railsUnderscore(pascalCasedWord string) string {
	snake := matchFirstCap.ReplaceAllString(pascalCasedWord, "${1}_${2}")
	snake = matchAllCap.ReplaceAllString(snake, "${1}_${2}")
	return strings.ToLower(snake)
}
