// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2024-present Datadog, Inc.

package usm

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io/fs"
	"path"
	"regexp"

	"github.com/shirou/gopsutil/v3/process"

	"github.com/DataDog/datadog-agent/pkg/util/log"
)

var (
	moduleRegexp  = regexp.MustCompile(`module\s+([A-Z][a-zA-Z0-9_]*)`)
	matchFirstCap = regexp.MustCompile("(.)([A-Z][a-z]+)")
	matchAllCap   = regexp.MustCompile("([a-z0-9])([A-Z])")
)

type railsDetector struct {
	ctx DetectionContext
}

func newRailsDetector(ctx DetectionContext) detector {
	return &railsDetector{ctx}
}

// detect checks if the service is a Rails application by looking for a
// `config/application.rb` file generated by `rails new` when a new rails
// project is created. This file should contain a `module` declaration with the
// application name.
func (r railsDetector) detect(_ []string) (ServiceMetadata, bool) {
	var proc *process.Process

	if procEntry, ok := r.ctx.ContextMap[ServiceProc]; ok {
		if p, ok := procEntry.(*process.Process); ok {
			proc = p
		} else {
			log.Errorf("could not get process object in rails detector: got type %T", procEntry)
		}
	}

	cwd, err := proc.Cwd()
	if err != nil {
		log.Debugf("could not get cwd of process: %s", err)
		return ServiceMetadata{}, false
	}

	absFile := path.Join(cwd, "config/application.rb")
	if _, err := fs.Stat(r.ctx.fs, absFile); err != nil {
		return ServiceMetadata{}, false
	}

	name, err := r.findRailsApplicationName(absFile)
	if err != nil {
		log.Debugf("could not find ruby application name: %s", err)
		return ServiceMetadata{}, false
	}

	return NewServiceMetadata(string(name)), true
}

// findRailsApplicationName scans the `config/application.rb` file to find the
// Rails application name.
func (r railsDetector) findRailsApplicationName(filename string) ([]byte, error) {
	file, err := r.ctx.fs.Open(filename)
	if err != nil {
		return nil, fmt.Errorf("could not open application.rb: %w", err)
	}
	defer file.Close()

	reader, err := SizeVerifiedReader(file)
	if err != nil {
		return nil, fmt.Errorf("skipping application.rb (%q): %w", filename, err)
	}

	scanner := bufio.NewScanner(reader)
	for scanner.Scan() {
		matches := moduleRegexp.FindSubmatch(scanner.Bytes())
		if len(matches) >= 2 {
			return railsUnderscore(matches[1]), nil
		}
	}

	// No match found
	return nil, errors.New("could not find Ruby module name")
}

// railsUnderscore converts a PascalCasedWord to a snake_cased_word.
// It keeps uppercase acronyms together when converting (e.g. "HTTPServer" -> "http_server").
func railsUnderscore(pascalCasedWord []byte) []byte {
	snake := matchFirstCap.ReplaceAll(pascalCasedWord, []byte("${1}_${2}"))
	snake = matchAllCap.ReplaceAll(snake, []byte("${1}_${2}"))
	return bytes.ToLower(snake)
}
