# GPU Metrics Specification
# Source of truth for all GPU metrics emitted by the Datadog Agent
#
# Data sources:
# - Code analysis of pkg/collector/corechecks/gpu/nvidia/ (Feb 2026)
# - Confluence page 4873584809: "List of metrics (current and historic)"
# - Datadog MCP: staging (74 metrics) and production (75 metrics)
#
# All metric names are relative to the "gpu." namespace prefix.
# Priority levels: low (0), medium_low (5), medium (10), high (20)
# device_support: physical/mig/vgpu - true, false, or unknown
#
# TODO: Add validation checks for:
# - integrations-core metadata.csv: verify all metrics are listed there
# - dd-analytics allowlist: verify metrics are in the analytics allowlist
# These are not yet checked by validate_live.py and should be validated separately.

namespace: "gpu"

# Tag definitions referenced by tagset field
tagsets:
  host:
    description: "Host-level tags only (no device or workload tags)"
    tags: []
  device:
    description: "Device-level tags from tagger"
    tags: ["gpu_uuid", "gpu_device", "gpu_vendor", "gpu_driver_version"]
    fallback_tags: ["gpu_uuid"]  # When tagger hasn't collected yet
  container:
    description: "Container-level tags from tagger (orchestrator cardinality for k8s, high for Docker)"
    inherits: device
    tags: ["container_id", "container_name"]  # Plus orchestrator tags
  process:
    description: "Process-level tags"
    inherits: device
    tags: ["pid", "nspid"]  # Plus container tags if process is in a container

# Deduplication groups - when multiple collectors emit the same metric,
# highest priority wins. All instances from winning collector are kept.
dedup_groups:
  gr_engine_active:
    metric: "gr_engine_active"
    collectors:
      - {collector: gpm, priority: high}
      - {collector: sampling, priority: low}
  sm_active:
    metric: "sm_active"
    collectors:
      - {collector: sampling, priority: medium}
      - {collector: ebpf, priority: low}
  process_sm_active:
    metric: "process.sm_active"
    collectors:
      - {collector: sampling, priority: medium}
      - {collector: ebpf, priority: low}
  process_memory_usage:
    metric: "process.memory.usage"
    collectors:
      - {collector: stateless_detail_list, priority: high}   # processDetailListSample (Hopper+)
      - {collector: stateless_process_mem, priority: medium}  # processMemorySample
      - {collector: ebpf, priority: low}
  memory_limit:
    metric: "memory.limit"
    note: "Priority depends on whether workloads are associated. If no workloads, drops to medium_low."
    collectors:
      - {collector: stateless_detail_list, priority: high}     # When workloads present
      - {collector: stateless_process_mem, priority: medium}   # When workloads present
      - {collector: stateless_detail_list_no_wl, priority: medium_low}  # No workloads
      - {collector: stateless_process_mem_no_wl, priority: medium_low}  # No workloads
      - {collector: ebpf, priority: low}
  core_limit:
    metric: "core.limit"
    collectors:
      - {collector: ebpf, priority: medium}
      - {collector: sampling, priority: low}

collectors:
  #############################################################################
  # STATELESS COLLECTOR
  #############################################################################
  - name: stateless
    code_name: "stateless"
    type: stateless
    description: "Memory, device info, clocks, process memory, NVLink, ECC errors"
    source_file: "pkg/collector/corechecks/gpu/nvidia/stateless.go"
    metrics:
      # BAR1 Memory
      - name: memory.bar1.total
        type: gauge
        priority: low
        source_api: GetBAR1MemoryInfo
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: unknown, vgpu: unknown}

      - name: memory.bar1.free
        type: gauge
        priority: low
        source_api: GetBAR1MemoryInfo
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: unknown, vgpu: unknown}

      - name: memory.bar1.used
        type: gauge
        priority: low
        source_api: GetBAR1MemoryInfo
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: unknown, vgpu: unknown}

      # Device Memory V2 (higher priority for memory.free)
      - name: memory.free
        type: gauge
        priority: medium
        source_api: GetMemoryInfoV2
        note: "V2 API. Falls back to V1 (low priority) if unsupported."
        min_architecture: ampere
        tagset: device
        per_process: false
        device_support: {physical: true, mig: unknown, vgpu: unknown}

      - name: memory.reserved
        type: gauge
        priority: low
        source_api: GetMemoryInfoV2
        note: "V2 only, no V1 fallback"
        min_architecture: ampere
        tagset: device
        per_process: false
        device_support: {physical: true, mig: unknown, vgpu: unknown}

      # Device Memory V1 (fallback for memory.free)
      # Note: memory.free is also emitted by V1 at low priority
      # The dedup system will keep V2 (medium) if available

      # PCI Throughput
      - name: pci.throughput.rx
        type: gauge
        priority: low
        source_api: GetPcieThroughput(RX_BYTES)
        note: "Value multiplied by 1024 (KB to bytes)"
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: pci.throughput.tx
        type: gauge
        priority: low
        source_api: GetPcieThroughput(TX_BYTES)
        note: "Value multiplied by 1024 (KB to bytes)"
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      # Device Info
      - name: fan_speed
        type: gauge
        priority: low
        source_api: GetFanSpeed
        min_architecture: fermi
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: power.management_limit
        type: gauge
        priority: low
        source_api: GetPowerManagementLimit
        min_architecture: fermi
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: power.usage
        type: gauge
        priority: low
        source_api: GetPowerUsage
        min_architecture: fermi
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: performance_state
        type: gauge
        priority: low
        source_api: GetPerformanceState
        note: "P-state 0-15"
        min_architecture: fermi
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: temperature
        type: gauge
        priority: low
        source_api: GetTemperature(GPU)
        min_architecture: fermi
        tagset: device
        per_process: false
        device_support: {physical: true, mig: unknown, vgpu: unknown}

      # Clock Speeds (current)
      - name: clock.speed.sm
        type: gauge
        priority: low
        source_api: GetClockInfo(SM)
        min_architecture: fermi
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: clock.speed.memory
        type: gauge
        priority: low
        source_api: GetClockInfo(MEM)
        min_architecture: fermi
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: clock.speed.graphics
        type: gauge
        priority: low
        source_api: GetClockInfo(GRAPHICS)
        min_architecture: fermi
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: clock.speed.video
        type: gauge
        priority: low
        source_api: GetClockInfo(VIDEO)
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      # Clock Speeds (max)
      - name: clock.speed.sm.max
        type: gauge
        priority: low
        source_api: GetMaxClockInfo(SM)
        min_architecture: fermi
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: clock.speed.memory.max
        type: gauge
        priority: low
        source_api: GetMaxClockInfo(MEM)
        min_architecture: fermi
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: clock.speed.graphics.max
        type: gauge
        priority: low
        source_api: GetMaxClockInfo(GRAPHICS)
        min_architecture: fermi
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: clock.speed.video.max
        type: gauge
        priority: low
        source_api: GetMaxClockInfo(VIDEO)
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      # Energy
      - name: total_energy_consumption
        type: gauge
        priority: low
        source_api: GetTotalEnergyConsumption
        note: "Cumulative value in millijoules"
        min_architecture: volta
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      # Device Count
      - name: device.total
        type: gauge
        priority: low
        source_api: constant
        note: "Always 1 per device"
        min_architecture: fermi
        tagset: device
        per_process: false
        device_support: {physical: true, mig: true, vgpu: true}

      - name: device.unhealthy
        type: gauge
        priority: low
        source_api: workloadmeta.GetGPU
        note: "0 or 1"
        min_architecture: fermi
        tagset: device
        per_process: false
        device_support: {physical: true, mig: unknown, vgpu: unknown}

      # Clock Throttle Reasons
      - name: clock.throttle_reasons.gpu_idle
        type: gauge
        priority: low
        source_api: GetCurrentClocksThrottleReasons
        note: "0 or 1 bitmask check"
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: clock.throttle_reasons.applications_clocks_setting
        type: gauge
        priority: low
        source_api: GetCurrentClocksThrottleReasons
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: clock.throttle_reasons.sw_power_cap
        type: gauge
        priority: low
        source_api: GetCurrentClocksThrottleReasons
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: clock.throttle_reasons.sync_boost
        type: gauge
        priority: low
        source_api: GetCurrentClocksThrottleReasons
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: clock.throttle_reasons.sw_thermal_slowdown
        type: gauge
        priority: low
        source_api: GetCurrentClocksThrottleReasons
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: clock.throttle_reasons.display_clock_setting
        type: gauge
        priority: low
        source_api: GetCurrentClocksThrottleReasons
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: clock.throttle_reasons.none
        type: gauge
        priority: low
        source_api: GetCurrentClocksThrottleReasons
        note: "1 when reasons == 0"
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      # Remapped Rows
      - name: remapped_rows.correctable
        type: gauge
        priority: low
        source_api: GetRemappedRows
        min_architecture: ampere
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: remapped_rows.uncorrectable
        type: gauge
        priority: low
        source_api: GetRemappedRows
        min_architecture: ampere
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: remapped_rows.pending
        type: gauge
        priority: low
        source_api: GetRemappedRows
        note: "0 or 1"
        min_architecture: ampere
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: remapped_rows.failed
        type: gauge
        priority: low
        source_api: GetRemappedRows
        note: "0 or 1"
        min_architecture: ampere
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      # Process Memory Usage (GetComputeRunningProcesses - Medium priority)
      - name: process.memory.usage
        type: gauge
        priority: medium
        source_api: GetComputeRunningProcesses
        note: "Per-process. Part of dedup group process_memory_usage."
        min_architecture: fermi
        tagset: process
        per_process: true
        dedup_group: process_memory_usage
        device_support: {physical: true, mig: false, vgpu: unknown}

      # Memory Limit (emitted alongside process.memory.usage)
      - name: memory.limit
        type: gauge
        priority: medium
        source_api: DeviceInfo.Memory
        note: "Per-device. Priority drops to medium_low if no workloads found. Part of dedup group."
        min_architecture: fermi
        tagset: process
        per_process: false
        dedup_group: memory_limit
        device_support: {physical: true, mig: false, vgpu: unknown}

      # Process Detail List (Hopper+ - High priority)
      - name: process.memory.usage
        type: gauge
        priority: high
        source_api: GetRunningProcessDetailList
        note: "Hopper+ only. Higher priority than GetComputeRunningProcesses. Part of dedup group."
        min_architecture: hopper
        tagset: process
        per_process: true
        dedup_group: process_memory_usage
        device_support: {physical: true, mig: true, vgpu: unknown}

      - name: memory.limit
        type: gauge
        priority: high
        source_api: DeviceInfo.Memory
        note: "Emitted alongside processDetailList. Hopper+ only."
        min_architecture: hopper
        tagset: process
        per_process: false
        dedup_group: memory_limit
        device_support: {physical: true, mig: true, vgpu: unknown}

      # NVLink Metrics
      - name: nvlink.count.total
        type: gauge
        priority: low
        source_api: "GetFieldValues(FI_DEV_NVLINK_LINK_COUNT) + GetNvLinkState"
        min_architecture: pascal
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: nvlink.count.active
        type: gauge
        priority: low
        source_api: GetNvLinkState
        min_architecture: pascal
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: nvlink.count.inactive
        type: gauge
        priority: low
        source_api: GetNvLinkState
        min_architecture: pascal
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      # ECC Errors
      # These emit with custom tags: memory_location:<location>
      # 2 error types x 8 memory locations = 16 API calls, but only 2 metric names
      - name: errors.ecc.corrected.total
        type: gauge
        priority: low
        source_api: GetMemoryErrorCounter(CORRECTED, AGGREGATE_ECC, <location>)
        note: "Tagged with memory_location. Emitted per memory location."
        min_architecture: fermi
        tagset: device
        per_process: false
        custom_tags: ["memory_location"]
        memory_locations: ["l1_cache", "l2_cache", "device_memory", "register_file", "texture_memory", "texture_shm", "cbu", "sram"]
        device_support: {physical: true, mig: unknown, vgpu: unknown}

      - name: errors.ecc.uncorrected.total
        type: gauge
        priority: low
        source_api: GetMemoryErrorCounter(UNCORRECTED, AGGREGATE_ECC, <location>)
        note: "Tagged with memory_location. Emitted per memory location."
        min_architecture: fermi
        tagset: device
        per_process: false
        custom_tags: ["memory_location"]
        memory_locations: ["l1_cache", "l2_cache", "device_memory", "register_file", "texture_memory", "texture_shm", "cbu", "sram"]
        device_support: {physical: true, mig: unknown, vgpu: unknown}

  #############################################################################
  # SAMPLING COLLECTOR
  #############################################################################
  - name: sampling
    code_name: "sampling"
    type: stateful_timestamps
    description: "Process utilization and device-wide utilization sampling"
    source_file: "pkg/collector/corechecks/gpu/nvidia/sampling.go"
    metrics:
      # Process Utilization (from GetProcessUtilization)
      - name: process.sm_active
        type: gauge
        priority: medium
        source_api: GetProcessUtilization
        note: "Per-process. Part of dedup group. eBPF fallback at low priority."
        min_architecture: kepler
        tagset: process
        per_process: true
        dedup_group: process_sm_active
        device_support: {physical: true, mig: false, vgpu: false}

      - name: process.dram_active
        type: gauge
        priority: low
        source_api: GetProcessUtilization
        min_architecture: kepler
        tagset: process
        per_process: true
        device_support: {physical: true, mig: false, vgpu: false}

      - name: process.encoder_active
        type: gauge
        priority: low
        source_api: GetProcessUtilization
        min_architecture: kepler
        tagset: process
        per_process: true
        device_support: {physical: true, mig: false, vgpu: false}

      - name: process.decoder_active
        type: gauge
        priority: low
        source_api: GetProcessUtilization
        min_architecture: kepler
        tagset: process
        per_process: true
        device_support: {physical: true, mig: false, vgpu: false}

      # Device-wide SM active (computed from process samples)
      - name: sm_active
        type: gauge
        priority: medium
        source_api: "computed from GetProcessUtilization: (max + capped_sum) / 2"
        note: "Part of dedup group. eBPF fallback at low priority."
        min_architecture: kepler
        tagset: device
        per_process: false
        dedup_group: sm_active
        device_support: {physical: true, mig: false, vgpu: false}

      # Core limit
      - name: core.limit
        type: gauge
        priority: low
        source_api: DeviceInfo.CoreCount
        note: "Per-device. Part of dedup group. eBPF version at medium priority."
        min_architecture: fermi
        tagset: process
        per_process: false
        dedup_group: core_limit
        device_support: {physical: true, mig: false, vgpu: unknown}

      # Device-wide samples (time-weighted averages)
      - name: gr_engine_active
        type: gauge
        priority: low
        source_api: GetSamples(GPU_UTILIZATION_SAMPLES)
        note: "Time-weighted average. Part of dedup group. GPM version at high priority."
        min_architecture: kepler
        tagset: device
        per_process: false
        dedup_group: gr_engine_active
        device_support: {physical: true, mig: false, vgpu: false}

      - name: dram_active
        type: gauge
        priority: low
        source_api: GetSamples(MEMORY_UTILIZATION_SAMPLES)
        note: "Time-weighted average"
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: false}

      - name: encoder_active
        type: gauge
        priority: low
        source_api: GetSamples(ENC_UTILIZATION_SAMPLES)
        note: "Time-weighted average"
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: false}

      - name: decoder_active
        type: gauge
        priority: low
        source_api: GetSamples(DEC_UTILIZATION_SAMPLES)
        note: "Time-weighted average"
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: false}

  #############################################################################
  # FIELDS COLLECTOR
  #############################################################################
  - name: fields
    code_name: "field"
    type: stateful_rates
    description: "NVML FieldValues API metrics (memory temp, NVLink throughput, etc.)"
    source_file: "pkg/collector/corechecks/gpu/nvidia/fields.go"
    metrics:
      - name: memory.temperature
        type: gauge
        priority: low
        source_api: FI_DEV_MEMORY_TEMP
        min_architecture: ampere
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      # NVLink throughput (rate computed in code from cumulative counters)
      - name: nvlink.throughput.data.rx
        type: gauge
        priority: low
        source_api: FI_DEV_NVLINK_THROUGHPUT_DATA_RX
        note: "Rate computed in code. Uses scopeID=MaxUint32 for aggregate across all links."
        min_architecture: pascal
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: nvlink.throughput.data.tx
        type: gauge
        priority: low
        source_api: FI_DEV_NVLINK_THROUGHPUT_DATA_TX
        note: "Rate computed in code"
        min_architecture: pascal
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: nvlink.throughput.raw.rx
        type: gauge
        priority: low
        source_api: FI_DEV_NVLINK_THROUGHPUT_RAW_RX
        note: "Rate computed in code"
        min_architecture: pascal
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: nvlink.throughput.raw.tx
        type: gauge
        priority: low
        source_api: FI_DEV_NVLINK_THROUGHPUT_RAW_TX
        note: "Rate computed in code"
        min_architecture: pascal
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: nvlink.speed
        type: gauge
        priority: low
        source_api: FI_DEV_NVLINK_SPEED_MBPS_COMMON
        min_architecture: pascal
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: nvlink.nvswitch_connected
        type: gauge
        priority: low
        source_api: FI_DEV_NVSWITCH_CONNECTED_LINK_COUNT
        min_architecture: volta
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      # NVLink Errors
      - name: nvlink.errors.crc.data
        type: gauge
        priority: low
        source_api: FI_DEV_NVLINK_CRC_DATA_ERROR_COUNT_TOTAL
        min_architecture: pascal
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: nvlink.errors.crc.flit
        type: gauge
        priority: low
        source_api: FI_DEV_NVLINK_CRC_FLIT_ERROR_COUNT_TOTAL
        min_architecture: pascal
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: nvlink.errors.ecc
        type: gauge
        priority: low
        source_api: FI_DEV_NVLINK_ECC_DATA_ERROR_COUNT_TOTAL
        min_architecture: pascal
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: nvlink.errors.recovery
        type: gauge
        priority: low
        source_api: FI_DEV_NVLINK_RECOVERY_ERROR_COUNT_TOTAL
        min_architecture: pascal
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      - name: nvlink.errors.replay
        type: gauge
        priority: low
        source_api: FI_DEV_NVLINK_REPLAY_ERROR_COUNT_TOTAL
        min_architecture: pascal
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      # PCI
      - name: pci.replay_counter
        type: gauge
        priority: low
        source_api: FI_DEV_PCIE_REPLAY_COUNTER
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

      # Thermal
      - name: slowdown_temperature
        type: gauge
        priority: low
        source_api: FI_DEV_PERF_POLICY_THERMAL
        min_architecture: kepler
        tagset: device
        per_process: false
        device_support: {physical: true, mig: false, vgpu: unknown}

  #############################################################################
  # GPM COLLECTOR (Hopper+ only, all High priority)
  #############################################################################
  - name: gpm
    code_name: "gpm"
    type: stateful_sample_buffer
    description: "GPU Performance Monitoring metrics (Hopper+ GPUs only)"
    source_file: "pkg/collector/corechecks/gpu/nvidia/gpm.go"
    note: "All GPM metrics are High priority and override lower-priority versions from other collectors."
    metrics:
      - name: gr_engine_active
        type: gauge
        priority: high
        source_api: GPM_METRIC_GRAPHICS_UTIL
        note: "Overrides sampling version (low priority). Part of dedup group."
        min_architecture: hopper
        tagset: device
        per_process: false
        dedup_group: gr_engine_active
        device_support: {physical: true, mig: true, vgpu: unknown}

      - name: sm_utilization
        type: gauge
        priority: high
        source_api: GPM_METRIC_SM_UTIL
        note: "Percentage of SMs in use (different from sm_active which is time-based)"
        min_architecture: hopper
        tagset: device
        per_process: false
        device_support: {physical: true, mig: true, vgpu: unknown}

      - name: sm_occupancy
        type: gauge
        priority: high
        source_api: GPM_METRIC_SM_OCCUPANCY
        min_architecture: hopper
        tagset: device
        per_process: false
        device_support: {physical: true, mig: true, vgpu: unknown}

      - name: integer_active
        type: gauge
        priority: high
        source_api: GPM_METRIC_INTEGER_UTIL
        min_architecture: hopper
        tagset: device
        per_process: false
        device_support: {physical: true, mig: true, vgpu: unknown}

      - name: fp16_active
        type: gauge
        priority: high
        source_api: GPM_METRIC_FP16_UTIL
        min_architecture: hopper
        tagset: device
        per_process: false
        device_support: {physical: true, mig: true, vgpu: unknown}

      - name: fp32_active
        type: gauge
        priority: high
        source_api: GPM_METRIC_FP32_UTIL
        min_architecture: hopper
        tagset: device
        per_process: false
        device_support: {physical: true, mig: true, vgpu: unknown}

      - name: fp64_active
        type: gauge
        priority: high
        source_api: GPM_METRIC_FP64_UTIL
        min_architecture: hopper
        tagset: device
        per_process: false
        device_support: {physical: true, mig: true, vgpu: unknown}

      - name: tensor_active
        type: gauge
        priority: high
        source_api: GPM_METRIC_ANY_TENSOR_UTIL
        min_architecture: hopper
        tagset: device
        per_process: false
        device_support: {physical: true, mig: true, vgpu: unknown}

  #############################################################################
  # EBPF COLLECTOR (from system-probe)
  #############################################################################
  - name: ebpf
    code_name: "ebpf"
    type: virtual
    description: "eBPF-based metrics from system-probe GPU monitoring module"
    source_file: "pkg/collector/corechecks/gpu/nvidia/ebpf.go"
    config_requirement: "gpu_monitoring.enabled: true (in system-probe config)"
    note: "Also emits zero metrics for previously-active processes (1 cycle grace period)."
    metrics:
      - name: process.core.usage
        type: gauge
        priority: low
        source_api: system-probe GPU module (UtilizationMetrics.UsedCores)
        min_architecture: fermi
        tagset: process
        per_process: true
        device_support: {physical: true, mig: unknown, vgpu: unknown}

      - name: process.memory.usage
        type: gauge
        priority: low
        source_api: system-probe GPU module (UtilizationMetrics.Memory.CurrentBytes)
        note: "Part of dedup group. Lowest priority fallback."
        min_architecture: fermi
        tagset: process
        per_process: true
        dedup_group: process_memory_usage
        device_support: {physical: true, mig: unknown, vgpu: unknown}

      - name: process.sm_active
        type: gauge
        priority: low
        source_api: system-probe GPU module (UtilizationMetrics.ActiveTimePct)
        note: "Part of dedup group. Lowest priority fallback."
        min_architecture: fermi
        tagset: process
        per_process: true
        dedup_group: process_sm_active
        device_support: {physical: true, mig: unknown, vgpu: unknown}

      - name: core.limit
        type: gauge
        priority: medium
        source_api: DeviceInfo.CoreCount
        note: "Part of dedup group. Higher priority than sampling version."
        min_architecture: fermi
        tagset: process
        per_process: false
        dedup_group: core_limit
        device_support: {physical: true, mig: unknown, vgpu: unknown}

      - name: memory.limit
        type: gauge
        priority: low
        source_api: DeviceInfo.Memory
        note: "Part of dedup group."
        min_architecture: fermi
        tagset: process
        per_process: false
        dedup_group: memory_limit
        device_support: {physical: true, mig: unknown, vgpu: unknown}

      - name: sm_active
        type: gauge
        priority: low
        source_api: system-probe GPU module (DeviceMetrics.ActiveTimePct)
        note: "Device-wide metric. Part of dedup group. Lowest priority fallback."
        min_architecture: fermi
        tagset: device
        per_process: false
        dedup_group: sm_active
        device_support: {physical: true, mig: unknown, vgpu: unknown}

  #############################################################################
  # DEVICE EVENTS COLLECTOR
  #############################################################################
  - name: device_events
    code_name: "deviceEvents"
    type: async_event_listener
    description: "XID critical error events"
    source_file: "pkg/collector/corechecks/gpu/nvidia/device_events.go"
    note: "Lazy device registration with up to 5 retry attempts across check runs."
    metrics:
      - name: errors.xid.total
        type: gauge
        priority: medium
        source_api: "NVML EventSet (EventTypeXidCriticalError)"
        note: "Cumulative counter per XID code. Tagged with type:<xid_code> and origin:<hardware|driver|unknown>."
        min_architecture: fermi
        tagset: device
        per_process: false
        custom_tags: ["type", "origin"]
        device_support: {physical: true, mig: false, vgpu: unknown}

# Deprecated metrics (still present in production from old agent versions)
deprecated_metrics:
  - name: core.usage
    replaced_by: process.core.usage
    note: "Renamed. Still present in prod from older agents."

  - name: memory.usage
    replaced_by: process.memory.usage
    note: "Renamed/deprecated. Still present in prod from older agents."
