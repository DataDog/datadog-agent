// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

// Package cdn provides access to the Remote Config CDN.
package cdn

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"runtime"

	"github.com/DataDog/datadog-agent/pkg/fleet/installer/env"
	"github.com/DataDog/datadog-agent/pkg/fleet/telemetry"
	pbgo "github.com/DataDog/datadog-agent/pkg/proto/pbgo/core"
	"gopkg.in/yaml.v2"
)

const (
	policyMetadataFilename    = "policy.metadata"
	doNotEditDisclaimer       = `# This configuration was generated by Datadog's Fleet Automation. DO NOT EDIT.`
	policyConfigRegexTemplate = `^datadog/\d+/INSTALLER_CONFIG/%s/[^/]+$`
)

var (
	// ErrProductNotSupported is returned when the product is not supported.
	ErrProductNotSupported = errors.New("product not supported")
)

// Config represents a configuration.
type Config interface {
	State() *pbgo.PoliciesState
	Write(dir string) error
}

// fetcher provides access to the Remote Config CDN.
type fetcher interface {
	get(ctx context.Context, policy string) ([]byte, error)
	close() error
}

// CDN provides access to the Remote Config CDN.
type CDN struct {
	fetcher        fetcher
	hostTagsGetter hostTagsGetter
}

type configLayer struct {
	ID      string          `json:"id"`
	Configs json.RawMessage `json:"configs"`
}

// New creates a new CDN and chooses the implementation depending
// on the environment
func New(env *env.Env, configDBPath string) (*CDN, error) {
	cdn := CDN{
		hostTagsGetter: newHostTagsGetter(env),
	}

	if runtime.GOOS == "windows" {
		// There's an assumption on windows that some directories are already there
		// but they are in fact created by the regular CDN implementation. Until
		// there is a fix on windows we keep the previous CDN behaviour for them
		fetcher, err := newHTTPFetcher(env, configDBPath)
		if err != nil {
			return nil, err
		}
		cdn.fetcher = fetcher
		return &cdn, nil
	}

	if !env.RemotePolicies {
		// Remote policies are not enabled -- we don't need the CDN
		// and we don't want to create the directories that the CDN
		// implementation would create. We return a no-op CDN to avoid
		// nil pointer dereference.
		fetcher, err := newNoopFetcher()
		if err != nil {
			return nil, err
		}
		cdn.fetcher = fetcher
		return &cdn, nil
	}

	if env.CDNLocalDirPath != "" {
		// Mock the CDN for local development or testing
		fetcher, err := newLocalFetcher(env)
		if err != nil {
			return nil, err
		}
		cdn.fetcher = fetcher
		return &cdn, nil
	}

	if !env.CDNEnabled {
		// Remote policies are enabled but we don't want to use the CDN
		// as it's still in development. We use standard remote config calls
		// instead (dubbed "direct" CDN).
		fetcher, err := newRCFetcher(env, configDBPath)
		if err != nil {
			return nil, err
		}
		cdn.fetcher = fetcher
		return &cdn, nil
	}

	// Regular CDN with the cloudfront distribution
	fetcher, err := newHTTPFetcher(env, configDBPath)
	if err != nil {
		return nil, err
	}
	cdn.fetcher = fetcher
	return &cdn, nil
}

// Get fetches the configuration for the given package.
func (c *CDN) Get(ctx context.Context, pkg string, policy string) (cfg Config, err error) {
	span, _ := telemetry.StartSpanFromContext(ctx, "cdn.Get")
	defer func() {
		spanErr := err
		if spanErr == ErrProductNotSupported {
			spanErr = nil
		}
		span.Finish(spanErr)
	}()

	if pkg == "datadog-agent" || pkg == "datadog-apm-libraries" {
		configBytes, err := c.GetBytes(ctx, policy)
		if err != nil {
			return nil, err
		}
		return c.FromBytes(pkg, configBytes)
	}

	return nil, ErrProductNotSupported
}

// Close closes the CDN.
func (c *CDN) Close() error {
	return c.fetcher.close()
}

// writePolicyMetadata writes the policy metadata to the given directory
// and makes it world-readable
func writePolicyMetadata(config Config, dir string) error {
	state := config.State()
	stateBytes, err := json.Marshal(state)
	if err != nil {
		return fmt.Errorf("could not marshal state: %w", err)
	}
	err = os.WriteFile(filepath.Join(dir, policyMetadataFilename), stateBytes, 0444)
	if err != nil {
		return fmt.Errorf("could not write %s: %w", policyMetadataFilename, err)
	}
	return nil
}

// marshalYAMLConfig marshals the config as YAML.
func marshalYAMLConfig(c map[string]interface{}) ([]byte, error) {
	if len(c) == 0 {
		return nil, nil
	}
	var b bytes.Buffer
	b.WriteString(doNotEditDisclaimer)
	b.WriteString("\n")
	rawConfig, err := yaml.Marshal(c)
	if err != nil {
		return nil, err
	}
	b.Write(rawConfig)
	return b.Bytes(), nil
}

// GetBytes fetches the configuration for the given package.
func (c *CDN) GetBytes(ctx context.Context, policy string) (cfg []byte, err error) {
	return c.fetcher.get(ctx, policy)
}

// FromBytes creates a Config from the given bytes.
func (c *CDN) FromBytes(pkg string, config []byte) (Config, error) {
	switch pkg {
	case "datadog-agent":
		return newAgentConfig(config)
	case "datadog-apm-libraries":
		return newAPMLibrariesConfig(c.hostTagsGetter.get(), config)
	default:
		return nil, ErrProductNotSupported
	}
}
