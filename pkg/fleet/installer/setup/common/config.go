// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package common

import "fmt"

const (
	disclaimerGenerated          = `# This file is generated by the Datadog Installer.`
	disclaimerDatadogYAMLExample = `# Other configuration options are available, see https://docs.datadoghq.com/agent/guide/agent-configuration-files/ for more information.`

	configDir              = "/etc/datadog-agent"
	datadogConfFile        = configDir + "/datadog.yaml"
	injectTracerConfigFile = configDir + "/inject/tracer.yaml"
)

// Config represents the configuration to write in /etc/datadog-agent
type Config struct {
	// DatadogYAML is the content of the datadog.yaml file
	DatadogYAML DatadogConfig
	// InjectTracerYAML is the content of the inject/tracer.yaml file
	InjectTracerYAML InjectTracerConfig
	// IntegrationConfigs is the content of the integration configuration files under conf.d/
	IntegrationConfigs map[string]IntegrationConfig
}

func (c *Config) write(confDir string) error {
	return nil
}

type DatadogConfig struct {
	APIKey               string                     `yaml:"api_key"`
	Site                 string                     `yaml:"site,omitempty"`
	Env                  string                     `yaml:"env,omitempty"`
	Tags                 []string                   `yaml:"tags,omitempty"`
	DJM                  DatadogConfigDJM           `yaml:"djm,omitempty"`
	ProcessConfig        DatadogConfigProcessConfig `yaml:"process_config,omitempty"`
	ExpectedTagsDuration string                     `yaml:"expected_tags_duration,omitempty"`
}

type DatadogConfigDJM struct {
	Enabled bool `yaml:"enabled,omitempty"`
}

type DatadogConfigProcessConfig struct {
	ExpvarPort int `yaml:"expvar_port,omitempty"`
}

// IntegrationConfig represents the configuration for an integration under conf.d/
type IntegrationConfig struct {
	InitConfig []any                   `yaml:"init_config"`
	Instances  []any                   `yaml:"instances"`
	Logs       []IntegrationConfigLogs `yaml:"logs"`
}

// IntegrationConfigLogs represents the configuration for the logs of an integration
type IntegrationConfigLogs struct {
	Type    string `yaml:"type"`
	Path    string `yaml:"path"`
	Service string `yaml:"service"`
	Source  string `yaml:"source"`
}

// IntegrationConfigInstanceSpark represents the configuration for the Spark integration
type IntegrationConfigInstanceSpark struct {
	SparkURL         string `yaml:"spark_url"`
	SparkClusterMode string `yaml:"spark_cluster_mode"`
	ClusterName      string `yaml:"cluster_name"`
	StreamingMetrics bool   `yaml:"streaming_metrics"`
}

// InjectTracerConfig represents the configuration to write in /etc/datadog-agent/inject/tracer.yaml
type InjectTracerConfig struct {
	Version       int                        `yaml:"version"`
	ConfigSources string                     `yaml:"config_sources"`
	EnvsToInject  []InjectTracerConfigEnvVar `yaml:"additional_environment_variables"`
}

// InjectTracerConfigEnvVar represents an environment variable to inject
type InjectTracerConfigEnvVar struct {
	Key   string `yaml:"key"`
	Value string `yaml:"value"`
}

// merge merges the current config with the setup config.
//
// The values are merged as follows:
// - Scalars: the override value is used
// - Lists: the override list is used
// - Maps: the override map is recursively merged into the base map
func merge(base interface{}, override interface{}) (interface{}, error) {
	if base == nil {
		return override, nil
	}
	if override == nil {
		// this allows to override a value with nil
		return nil, nil
	}
	if isScalar(base) && isScalar(override) {
		return override, nil
	}
	if isList(base) && isList(override) {
		return override, nil
	}
	if isMap(base) && isMap(override) {
		return mergeMap(base.(map[string]interface{}), override.(map[string]interface{}))
	}
	return nil, fmt.Errorf("could not merge %T with %T", base, override)
}

func mergeMap(base, override map[string]interface{}) (map[string]interface{}, error) {
	merged := make(map[string]interface{})
	for k, v := range base {
		merged[k] = v
	}
	for k := range override {
		v, err := merge(base[k], override[k])
		if err != nil {
			return nil, fmt.Errorf("could not merge key %v: %w", k, err)
		}
		merged[k] = v
	}
	return merged, nil
}

func isList(i interface{}) bool {
	_, ok := i.([]interface{})
	return ok
}

func isMap(i interface{}) bool {
	_, ok := i.(map[string]interface{})
	return ok
}

func isScalar(i interface{}) bool {
	return !isList(i) && !isMap(i)
}
