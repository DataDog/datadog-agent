// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

package util

import (
	"context"
	"crypto/tls"
	"errors"
	"io"
	"net/http"
	"sync"
	"time"
)

// ShouldCloseConnection is an option to DoGet to indicate whether to close the underlying
// connection after reading the response
type ShouldCloseConnection int

const (
	// LeaveConnectionOpen keeps the underlying connection open after reading the request response
	LeaveConnectionOpen ShouldCloseConnection = iota
	// CloseConnection closes the underlying connection after reading the request response
	CloseConnection
)

// ReqOptions are options when making a request
type ReqOptions struct {
	Conn      ShouldCloseConnection
	Ctx       context.Context
	Authtoken string
}

// ClientOption is a function type that takes an *http.Client as input and returns an *http.Client.
// It can be used to modify or configure an HTTP client.
type ClientOption func(*http.Client) *http.Client

// GetClient is a convenience function returning an http client
func GetClient(opts ...ClientOption) *http.Client {
	return GetClientWithTimeout(0, opts...)
}

// ipcRoundTripper is an implementation of http.RoundTripper interface
type ipcRoundTripper struct {
	sync.Once
	tr http.Transport
}

// RoundTrip implement the http.RoundTripper interface method to be used in http request context
// It is used to lazy load the TLS Client config, in order to let the time to initialize it before using it
// Due to historical reasons, the creation of artifacts (used to initialize TLS configuration) may be generated by another process, so their availability is unpredictable.
// We delay the fetch as much as possible to increase the chances of having them initialized.
func (i *ipcRoundTripper) RoundTrip(req *http.Request) (*http.Response, error) {
	i.Do(func() {
		i.tr.TLSClientConfig = GetTLSClientConfig()
	})

	return i.tr.RoundTrip(req)
}

// WithInsecureTransport modifies the provided HTTP client to use an insecure
// transport configuration. Specifically, it sets the TLSClientConfig to skip
// verification of the server's certificate.
// TODO IPC: remove this function
func WithInsecureTransport(c *http.Client) *http.Client {
	c.Transport = &http.Transport{
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: true,
		},
	}
	return c
}

// GetClientWithTimeout is a convenience function returning an http client
// Arguments correspond to the request timeout duration, and a boolean to
// verify the server TLS client (false should only be used on localhost
// trusted endpoints).
func GetClientWithTimeout(to time.Duration, opts ...ClientOption) *http.Client {
	transport := ipcRoundTripper{
		tr: http.Transport{},
	}

	c := &http.Client{
		Transport: &transport,
		Timeout:   to,
	}

	for _, opt := range opts {
		c = opt(c)
	}

	return c
}

// DoGet is a wrapper around performing HTTP GET requests
func DoGet(c *http.Client, url string, conn ShouldCloseConnection) (body []byte, e error) {
	return DoGetWithOptions(c, url, &ReqOptions{Conn: conn})
}

// DoGetWithOptions is a wrapper around performing HTTP GET requests
func DoGetWithOptions(c *http.Client, url string, options *ReqOptions) (body []byte, e error) {
	if options.Authtoken == "" {
		options.Authtoken = GetAuthToken()
	}

	if options.Ctx == nil {
		options.Ctx = context.Background()
	}

	req, e := http.NewRequestWithContext(options.Ctx, "GET", url, nil)
	if e != nil {
		return body, e
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Authorization", "Bearer "+options.Authtoken)
	if options.Conn == CloseConnection {
		req.Close = true
	}

	r, e := c.Do(req)
	if e != nil {
		return body, e
	}
	body, e = io.ReadAll(r.Body)
	r.Body.Close()
	if e != nil {
		return body, e
	}
	if r.StatusCode >= 400 {
		return body, errors.New(string(body))
	}
	return body, nil
}

// DoPost is a wrapper around performing HTTP POST requests
func DoPost(c *http.Client, url string, contentType string, body io.Reader) (resp []byte, e error) {
	req, e := http.NewRequest("POST", url, body)
	if e != nil {
		return resp, e
	}
	req.Header.Set("Content-Type", contentType)
	req.Header.Set("Authorization", "Bearer "+GetAuthToken())

	r, e := c.Do(req)
	if e != nil {
		return resp, e
	}
	resp, e = io.ReadAll(r.Body)
	r.Body.Close()
	if e != nil {
		return resp, e
	}
	if r.StatusCode >= 400 {
		return resp, errors.New(string(resp))
	}
	return resp, nil
}

// DoPostChunked is a wrapper around performing HTTP POST requests that stream chunked data
func DoPostChunked(c *http.Client, url string, contentType string, body io.Reader, onChunk func([]byte)) error {
	req, e := http.NewRequest("POST", url, body)
	if e != nil {
		return e
	}
	req.Header.Set("Content-Type", contentType)
	req.Header.Set("Authorization", "Bearer "+GetAuthToken())

	r, e := c.Do(req)
	if e != nil {
		return e
	}
	defer r.Body.Close()

	var m int
	buf := make([]byte, 4096)
	for {
		m, e = r.Body.Read(buf)
		if m < 0 || e != nil {
			break
		}
		onChunk(buf[:m])
	}

	if r.StatusCode == 200 {
		return nil
	}
	return e
}
