package traces

import (
	"fmt"
	"io"

	"github.com/DataDog/datadog-agent/pkg/trace/pb"
	"github.com/gogo/protobuf/proto"
)

type Trace struct {
	Spans []Span
}

func NewTrace(spans []Span) Trace {
	return Trace{
		Spans: spans,
	}
}

func EagerTracesToPBTrace(eagerTraces []Trace) pb.Traces {
	pbTraces := pb.Traces{}
	for _, t := range eagerTraces {
		pbTraces = append(pbTraces, EagerTraceToPBTrace(t))
	}
	return pbTraces
}

func EagerTraceToPBTrace(t Trace) pb.Trace {
	trace := pb.Trace{}
	for _, s := range t.Spans {
		trace = append(trace, &s.(*EagerSpan).Span)
	}
	return trace
}

func (t *Trace) WriteAsAPITrace(w io.Writer, traceID uint64, start, end int64) error {
	if len(t.Spans) == 0 {
		return nil
	}

	switch t.Spans[0].(type) {
	case *EagerSpan:
		spans := make([]*pb.Span, 0, len(t.Spans))
		for _, span := range t.Spans {
			eager := span.(*EagerSpan)
			spans = append(spans, &eager.Span)
		}
		apiTrace := pb.APITrace{
			TraceID: traceID,
			// TODO: Make this field not a pointer type in the protobuf with nullable=false.
			Spans:     spans,
			StartTime: start,
			EndTime:   end,
		}

		// TODO: This probably shouldn't alloc.
		marshaled, err := apiTrace.Marshal()
		if err != nil {
			return fmt.Errorf("Trace: WriteAsAPITrace: Error marshaling API trace: %v", err)
		}

		_, err = w.Write(marshaled)
		if err != nil {
			return fmt.Errorf("Trace: WriteAsAPITrace: Error writing marshaled API trace: %v", err)
		}

		return nil
	case *LazySpan:
		encoder := newProtoEncoder()
		encoder.encodeTagAndWireType(1, 0) // Field 1, varint
		encoder.encodeVarint(traceID)

		encoder.encodeTagAndWireType(3, 0) // Field 3, varint
		encoder.encodeVarint(uint64(start))

		encoder.encodeTagAndWireType(4, 0) // Field 3, varint
		encoder.encodeVarint(uint64(end))

		if _, err := w.Write(encoder.buf); err != nil {
			return fmt.Errorf("Trace: WriteAsAPITrace: Error writing APITrace scalars: %v", err)
		}

		for _, s := range t.Spans {
			if err := s.WriteProto(w); err != nil {
				return fmt.Errorf(
					"Trace: WriteAsAPITrace: error writing span: %s, err: %v",
					s.DebugString(), err)
			}
		}

		return nil
	default:
		return fmt.Errorf("Trace: WriteAsAPITrace: Unhandled span implementation: %T", t.Spans[0])
	}

}

func (t *Trace) WriteAsSpans(w io.Writer) error {
	if len(t.Spans) == 0 {
		return nil
	}

	switch t.Spans[0].(type) {
	case *EagerSpan:
		spans := make([]*pb.Span, 0, len(t.Spans))
		for _, span := range t.Spans {
			eager := span.(*EagerSpan)
			spans = append(spans, &eager.Span)
		}

		// TODO: This is dumb, but it works for now. Protobuf won't let us marshal a raw slice of messages,
		// but it will do it if its nested in a protobuf message and the generated bytes should be the same.
		trace := pb.TracePayload{
			Transactions: spans,
		}
		marshaled, err := proto.Marshal(&trace)
		if err != nil {
			return fmt.Errorf("Trace: WriteAsSpans: Error marshaling spans: %v", err)
		}

		_, err = w.Write(marshaled)
		if err != nil {
			return fmt.Errorf("Trace: WriteAsSpans: Error writing marshaled spans: %v", err)
		}

		return nil
	default:
		return fmt.Errorf("Trace: WriteAsSpans: Unhandled span implementation: %T", t.Spans[0])
	}

}

func (t *Trace) MsgSize() int {
	size := 0
	for _, s := range t.Spans {
		size += s.MsgSize()
	}
	return size
}
