package traces

import (
	"fmt"
	"io"

	"github.com/DataDog/datadog-agent/pkg/trace/pb"
	"github.com/gogo/protobuf/proto"
	"github.com/richardartoul/molecule/src/codec"
)

type Trace struct {
	Spans []Span
}

func NewTrace(spans []Span) Trace {
	return Trace{
		Spans: spans,
	}
}

func EagerTracesToPBTrace(eagerTraces []Trace) pb.Traces {
	pbTraces := pb.Traces{}
	for _, t := range eagerTraces {
		pbTraces = append(pbTraces, EagerTraceToPBTrace(t))
	}
	return pbTraces
}

func EagerTraceToPBTrace(t Trace) pb.Trace {
	trace := pb.Trace{}
	for _, s := range t.Spans {
		trace = append(trace, &s.(*EagerSpan).Span)
	}
	return trace
}

// TODO: Extract out helpers for this.
func NewLazyTracesFromProto(b []byte) ([]Trace, error) {
	var (
		traces  []Trace
		buf     = codec.NewBuffer(b)
		spanBuf = codec.NewBuffer(nil)
	)
	for !buf.EOF() {
		_, wireType, err := buf.DecodeTagAndWireType()
		if err == io.EOF {
			break
		}
		if err != nil {
			return nil, fmt.Errorf("NewLazyTraceFromProto: error decoding tag and wire type: %v", err)
		}
		if wireType != 2 {
			return nil, fmt.Errorf(
				"NewLazyTraceFromProto: expected wire type 2 (length delimited), but was: %d",
				wireType)
		}

		traceBytes, err := buf.DecodeRawBytes(false)
		if err != nil {
			return nil, fmt.Errorf(
				"NewLazyTraceFromProto: error reading trace bytes: %v", err)
		}

		var spans []Span
		spanBuf.Reset(traceBytes)
		for !spanBuf.EOF() {
			_, wireType, err := spanBuf.DecodeTagAndWireType()
			if err == io.EOF {
				break
			}
			if err != nil {
				return nil, fmt.Errorf("NewLazyTraceFromProto: error decoding span tag and wire type: %v", err)
			}
			if wireType != 2 {
				return nil, fmt.Errorf(
					"NewLazyTraceFromProto: expected wire type 2 (length delimited), but was: %d",
					wireType)
			}

			spanBytes, err := buf.DecodeRawBytes(false)
			if err != nil {
				return nil, fmt.Errorf(
					"NewLazyTraceFromProto: error reading trace bytes: %v", err)
			}

			span, err := NewLazySpan(spanBytes)
			if err != nil {
				return nil, fmt.Errorf("NewLazyTraceFromProto: error reading span: %v", err)
			}

			spans = append(spans, span)
		}

		traces = append(traces, NewTrace(spans))
	}

	return traces, nil
}

func (t *Trace) WriteAsAPITrace(w io.Writer, traceID uint64, start, end int64) error {
	if len(t.Spans) == 0 {
		return nil
	}

	switch t.Spans[0].(type) {
	case *EagerSpan:
		spans := make([]*pb.Span, 0, len(t.Spans))
		for _, span := range t.Spans {
			eager := span.(*EagerSpan)
			spans = append(spans, &eager.Span)
		}
		apiTrace := pb.APITrace{
			TraceID: traceID,
			// TODO: Make this field not a pointer type in the protobuf with nullable=false.
			Spans:     spans,
			StartTime: start,
			EndTime:   end,
		}

		// TODO: This probably shouldn't alloc.
		marshaled, err := apiTrace.Marshal()
		if err != nil {
			return fmt.Errorf("Trace: WriteAsAPITrace: Error marshaling API trace: %v", err)
		}

		_, err = w.Write(marshaled)
		if err != nil {
			return fmt.Errorf("Trace: WriteAsAPITrace: Error writing marshaled API trace: %v", err)
		}

		return nil
	case *LazySpan:
		encoder := newProtoEncoder()
		encoder.encodeTagAndWireType(1, 0) // Field 1, varint
		encoder.encodeVarint(traceID)

		encoder.encodeTagAndWireType(3, 0) // Field 3, varint
		encoder.encodeVarint(uint64(start))

		encoder.encodeTagAndWireType(4, 0) // Field 3, varint
		encoder.encodeVarint(uint64(end))

		if _, err := w.Write(encoder.buf); err != nil {
			return fmt.Errorf("Trace: WriteAsAPITrace: Error writing APITrace scalars: %v", err)
		}

		for _, s := range t.Spans {
			if err := s.WriteProto(w); err != nil {
				return fmt.Errorf(
					"Trace: WriteAsAPITrace: error writing span: %s, err: %v",
					s.DebugString(), err)
			}
		}

		return nil
	default:
		return fmt.Errorf("Trace: WriteAsAPITrace: Unhandled span implementation: %T", t.Spans[0])
	}

}

func (t *Trace) WriteAsSpans(w io.Writer) error {
	if len(t.Spans) == 0 {
		return nil
	}

	switch t.Spans[0].(type) {
	case *EagerSpan:
		spans := make([]*pb.Span, 0, len(t.Spans))
		for _, span := range t.Spans {
			eager := span.(*EagerSpan)
			spans = append(spans, &eager.Span)
		}

		// TODO: This is dumb, but it works for now. Protobuf won't let us marshal a raw slice of messages,
		// but it will do it if its nested in a protobuf message and the generated bytes should be the same.
		trace := pb.TracePayload{
			Transactions: spans,
		}
		marshaled, err := proto.Marshal(&trace)
		if err != nil {
			return fmt.Errorf("Trace: WriteAsSpans: Error marshaling spans: %v", err)
		}

		_, err = w.Write(marshaled)
		if err != nil {
			return fmt.Errorf("Trace: WriteAsSpans: Error writing marshaled spans: %v", err)
		}

		return nil
	default:
		return fmt.Errorf("Trace: WriteAsSpans: Unhandled span implementation: %T", t.Spans[0])
	}

}

func (t *Trace) MsgSize() int {
	size := 0
	for _, s := range t.Spans {
		size += s.MsgSize()
	}
	return size
}
