// Code generated by flatc. DO NOT EDIT.
//
// Generated from: fbs-schema/telemetry.fbs
// Namespace: dd.inject.telemetry

package injectortelemetry

import (
	flatbuffers "github.com/google/flatbuffers/go"
)

// MetricType enum values
type MetricType = int8

const (
	MetricTypeCounter      MetricType = 0
	MetricTypeDistribution MetricType = 1
)

// TelemetryMetric represents a single telemetry metric sent from the injector.
type TelemetryMetric struct {
	_tab flatbuffers.Table
}

// GetRootAsTelemetryMetric deserializes the root table from a flatbuffer byte slice.
func GetRootAsTelemetryMetric(buf []byte, offset flatbuffers.UOffsetT) *TelemetryMetric {
	n := flatbuffers.GetUOffsetT(buf[offset:])
	x := &TelemetryMetric{}
	x.Init(buf, n+offset)
	return x
}

func (rcv *TelemetryMetric) Init(buf []byte, i flatbuffers.UOffsetT) {
	rcv._tab.Bytes = buf
	rcv._tab.Pos = i
}

func (rcv *TelemetryMetric) Table() flatbuffers.Table {
	return rcv._tab
}

// Name returns the metric name (e.g. "inject.success").
func (rcv *TelemetryMetric) Name() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(4))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

// Type returns the metric type (Counter or Distribution).
func (rcv *TelemetryMetric) Type() MetricType {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(6))
	if o != 0 {
		return MetricType(rcv._tab.GetInt8(o + rcv._tab.Pos))
	}
	return 0
}

// Value returns the metric value.
func (rcv *TelemetryMetric) Value() float64 {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(8))
	if o != 0 {
		return rcv._tab.GetFloat64(o + rcv._tab.Pos)
	}
	return 0.0
}

// Tags returns the tag at the given index.
func (rcv *TelemetryMetric) Tags(j int) []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		a := rcv._tab.Vector(o)
		return rcv._tab.ByteVector(a + flatbuffers.UOffsetT(j)*4)
	}
	return nil
}

// TagsLength returns the number of tags.
func (rcv *TelemetryMetric) TagsLength() int {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(10))
	if o != 0 {
		return rcv._tab.VectorLen(o)
	}
	return 0
}

// RuntimeId returns the per-process runtime UUID.
func (rcv *TelemetryMetric) RuntimeId() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(12))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

// LanguageName returns the detected language (e.g. "python").
func (rcv *TelemetryMetric) LanguageName() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(14))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

// LanguageVersion returns the detected language version.
func (rcv *TelemetryMetric) LanguageVersion() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(16))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

// InjectorVersion returns the injector version string.
func (rcv *TelemetryMetric) InjectorVersion() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(18))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}

// ExternalEnv returns the optional external environment identifier.
func (rcv *TelemetryMetric) ExternalEnv() []byte {
	o := flatbuffers.UOffsetT(rcv._tab.Offset(20))
	if o != 0 {
		return rcv._tab.ByteVector(o + rcv._tab.Pos)
	}
	return nil
}
