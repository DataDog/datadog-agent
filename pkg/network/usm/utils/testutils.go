// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

//go:build linux && test

package utils

import (
	"sync"
	"testing"
	"unsafe"

	"github.com/cilium/ebpf"

	"github.com/DataDog/datadog-agent/pkg/network/config"
)

// CallbackRecorder is meant to assist with *testing* the `FileRegistry` code
// as well as code interacting with it such as `sharedlibraries.Watcher`.
// A callback "mock" can be generated by calling `Callback()`, which essentially
// counts the number of callback executions and returns an injected error when needed.
type CallbackRecorder struct {
	mux           sync.Mutex
	ReturnError   error
	callsByPathID map[PathIdentifier]int
}

// Callback returns a *testing* callback that can be used as an argument to
// `FileRegistry.Register()`
// Note that this method should be called only once.
func (r *CallbackRecorder) Callback() func(FilePath) error {
	return func(f FilePath) error {
		r.mux.Lock()
		defer r.mux.Unlock()

		if r.callsByPathID == nil {
			r.callsByPathID = make(map[PathIdentifier]int)
		}

		r.callsByPathID[f.ID]++

		return r.ReturnError
	}
}

// CallsForPathID returns the number of callback executions for a given `PathIdentifier`
func (r *CallbackRecorder) CallsForPathID(pathID PathIdentifier) int {
	r.mux.Lock()
	defer r.mux.Unlock()

	return r.callsByPathID[pathID]
}

// TotalCalls returns the total number of calls the callback has received
func (r *CallbackRecorder) TotalCalls() int {
	r.mux.Lock()
	defer r.mux.Unlock()

	total := 0
	for _, count := range r.callsByPathID {
		total += count
	}
	return total
}

// NewUSMEmptyConfig creates a new network config, with every USM protocols disabled.
func NewUSMEmptyConfig() *config.Config {
	cfg := config.New()
	cfg.ServiceMonitoringEnabled = true
	cfg.EnableHTTPMonitoring = false
	cfg.EnableHTTP2Monitoring = false
	cfg.EnableKafkaMonitoring = false
	cfg.EnablePostgresMonitoring = false
	cfg.EnableRedisMonitoring = false
	cfg.EnableNativeTLSMonitoring = false
	cfg.EnableIstioMonitoring = false
	cfg.EnableNodeJSMonitoring = false
	cfg.EnableGoTLSSupport = false

	return cfg
}

// CountMapEntries counts entries in a specific BPF map.
func CountMapEntries(t *testing.T, m *ebpf.Map) int {
	t.Helper()
	if m == nil {
		t.Logf("Map: %s provided to countMapEntries is nil", m.String())
		return -1
	}

	keySize := m.KeySize()
	valueSize := m.ValueSize()

	if keySize == 0 || valueSize == 0 {
		t.Logf("Invalid map sizes: keySize=%d, valueSize=%d", keySize, valueSize)
		return -1
	}

	count := 0
	value := make([]byte, valueSize)
	key := make([]byte, keySize)
	iter := m.Iterate()

	for iter.Next(unsafe.Pointer(&key[0]), unsafe.Pointer(&value[0])) {
		count++
	}

	if err := iter.Err(); err != nil {
		t.Logf("Error iterating map %s: %v", m.String(), err)
	}
	return count
}
