// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2022-present Datadog, Inc.
// Code generated - DO NOT EDIT.

//go:build unix

package model

import (
	"github.com/DataDog/datadog-agent/pkg/security/secl/compiler/eval"
	"github.com/DataDog/datadog-agent/pkg/security/secl/containerutils"
	"math"
	"net"
	"reflect"
	"strings"
)

// to always require the math package
var _ = math.MaxUint16
var _ = net.IP{}

func (_ *Model) GetEventTypes() []eval.EventType {
	return []eval.EventType{
		eval.EventType("accept"),
		eval.EventType("bind"),
		eval.EventType("bpf"),
		eval.EventType("capset"),
		eval.EventType("cgroup_write"),
		eval.EventType("chdir"),
		eval.EventType("chmod"),
		eval.EventType("chown"),
		eval.EventType("connect"),
		eval.EventType("dns"),
		eval.EventType("exec"),
		eval.EventType("exit"),
		eval.EventType("imds"),
		eval.EventType("link"),
		eval.EventType("load_module"),
		eval.EventType("mkdir"),
		eval.EventType("mmap"),
		eval.EventType("mount"),
		eval.EventType("mprotect"),
		eval.EventType("network_flow_monitor"),
		eval.EventType("ondemand"),
		eval.EventType("open"),
		eval.EventType("packet"),
		eval.EventType("ptrace"),
		eval.EventType("removexattr"),
		eval.EventType("rename"),
		eval.EventType("rmdir"),
		eval.EventType("selinux"),
		eval.EventType("setgid"),
		eval.EventType("setrlimit"),
		eval.EventType("setsockopt"),
		eval.EventType("setuid"),
		eval.EventType("setxattr"),
		eval.EventType("signal"),
		eval.EventType("splice"),
		eval.EventType("sysctl"),
		eval.EventType("unlink"),
		eval.EventType("unload_module"),
		eval.EventType("utimes"),
	}
}
func (_ *Model) GetFieldRestrictions(field eval.Field) []eval.EventType {
	switch field {
	case "network.destination.ip":
		return []eval.EventType{"dns", "imds"}
	case "network.destination.is_public":
		return []eval.EventType{"dns", "imds"}
	case "network.destination.port":
		return []eval.EventType{"dns", "imds"}
	case "network.device.ifname":
		return []eval.EventType{"dns", "imds"}
	case "network.l3_protocol":
		return []eval.EventType{"dns", "imds"}
	case "network.l4_protocol":
		return []eval.EventType{"dns", "imds"}
	case "network.network_direction":
		return []eval.EventType{"dns", "imds"}
	case "network.size":
		return []eval.EventType{"dns", "imds"}
	case "network.source.ip":
		return []eval.EventType{"dns", "imds"}
	case "network.source.is_public":
		return []eval.EventType{"dns", "imds"}
	case "network.source.port":
		return []eval.EventType{"dns", "imds"}
	}
	return nil
}
func (_ *Model) GetEvaluator(field eval.Field, regID eval.RegisterID, offset int) (eval.Evaluator, error) {
	switch field {
	case "accept.addr.family":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Accept.AddrFamily)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "accept.addr.hostname":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveAcceptHostnames(ev, &ev.Accept)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "accept.addr.ip":
		return &eval.CIDREvaluator{
			EvalFnc: func(ctx *eval.Context) net.IPNet {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Accept.Addr.IPNet
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "accept.addr.is_public":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveIsIPPublic(ev, &ev.Accept.Addr)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "accept.addr.port":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Accept.Addr.Port)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "accept.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Accept.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "bind.addr.family":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Bind.AddrFamily)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "bind.addr.ip":
		return &eval.CIDREvaluator{
			EvalFnc: func(ctx *eval.Context) net.IPNet {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Bind.Addr.IPNet
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "bind.addr.is_public":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveIsIPPublic(ev, &ev.Bind.Addr)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "bind.addr.port":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Bind.Addr.Port)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "bind.protocol":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Bind.Protocol)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "bind.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Bind.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "bpf.cmd":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BPF.Cmd)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "bpf.map.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BPF.Map.Name
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "bpf.map.type":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BPF.Map.Type)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "bpf.prog.attach_type":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BPF.Program.AttachType)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "bpf.prog.helpers":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				result := make([]int, len(ev.BPF.Program.Helpers))
				for i, v := range ev.BPF.Program.Helpers {
					result[i] = int(v)
				}
				return result
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "bpf.prog.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BPF.Program.Name
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "bpf.prog.tag":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BPF.Program.Tag
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "bpf.prog.type":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BPF.Program.Type)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "bpf.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BPF.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "capset.cap_effective":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Capset.CapEffective)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "capset.cap_permitted":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Capset.CapPermitted)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "cgroup.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.CGroupContext.CGroupFile.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "cgroup.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.CGroupContext.CGroupFile.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "cgroup.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupID(ev, ev.CGroupContext)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup.manager":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupManager(ev, ev.CGroupContext)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup.version":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupVersion(ev, ev.CGroupContext)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.CgroupWrite.File.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.CgroupWrite.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.CgroupWrite.File.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.CgroupWrite.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.CgroupWrite.File)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.CgroupWrite.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.CgroupWrite.File.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.CgroupWrite.File.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.CgroupWrite.File.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.CgroupWrite.File.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.CgroupWrite.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.CgroupWrite.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.CgroupWrite.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.CgroupWrite.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.CgroupWrite.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.CgroupWrite.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.CgroupWrite.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.CgroupWrite.File.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.CgroupWrite.File.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.CgroupWrite.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "cgroup_write.pid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.CgroupWrite.Pid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chdir.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chdir.File.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chdir.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Chdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chdir.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chdir.File.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chdir.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Chdir.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chdir.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Chdir.File)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chdir.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Chdir.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chdir.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chdir.File.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chdir.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chdir.File.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chdir.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chdir.File.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chdir.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chdir.File.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chdir.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Chdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chdir.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Chdir.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chdir.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Chdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chdir.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Chdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chdir.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Chdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chdir.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Chdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chdir.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Chdir.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chdir.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Chdir.File.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chdir.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chdir.File.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chdir.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Chdir.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chdir.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chdir.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chdir.syscall.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr1(ev, &ev.Chdir.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chmod.File.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chmod.file.destination.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chmod.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chmod.file.destination.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chmod.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chmod.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Chmod.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chmod.File.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chmod.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Chmod.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Chmod.File)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Chmod.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chmod.File.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chmod.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chmod.File.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chmod.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chmod.File.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chmod.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chmod.File.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chmod.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Chmod.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Chmod.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Chmod.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Chmod.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Chmod.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Chmod.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Chmod.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Chmod.File.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chmod.File.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chmod.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Chmod.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chmod.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chmod.syscall.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveSyscallCtxArgsInt2(ev, &ev.Chmod.SyscallContext))
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chmod.syscall.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr1(ev, &ev.Chmod.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chown.File.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chown.file.destination.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chown.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chown.file.destination.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveChownGID(ev, &ev.Chown)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.destination.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chown.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chown.file.destination.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveChownUID(ev, &ev.Chown)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Chown.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chown.File.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chown.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Chown.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Chown.File)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Chown.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chown.File.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chown.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chown.File.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chown.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chown.File.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chown.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chown.File.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chown.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Chown.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Chown.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Chown.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Chown.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Chown.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Chown.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Chown.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Chown.File.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chown.File.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chown.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Chown.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Chown.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "chown.syscall.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveSyscallCtxArgsInt3(ev, &ev.Chown.SyscallContext))
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.syscall.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr1(ev, &ev.Chown.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "chown.syscall.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveSyscallCtxArgsInt2(ev, &ev.Chown.SyscallContext))
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "connect.addr.family":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Connect.AddrFamily)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "connect.addr.hostname":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveConnectHostnames(ev, &ev.Connect)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "connect.addr.ip":
		return &eval.CIDREvaluator{
			EvalFnc: func(ctx *eval.Context) net.IPNet {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Connect.Addr.IPNet
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "connect.addr.is_public":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveIsIPPublic(ev, &ev.Connect.Addr)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "connect.addr.port":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Connect.Addr.Port)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "connect.protocol":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Connect.Protocol)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "connect.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Connect.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "container.created_at":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveContainerCreatedAt(ev, ev.BaseEvent.ContainerContext))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "container.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveContainerID(ev, ev.BaseEvent.ContainerContext)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "container.runtime":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveContainerRuntime(ev, ev.BaseEvent.ContainerContext)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "container.tags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveContainerTags(ev, ev.BaseEvent.ContainerContext)
			},
			Field:  field,
			Weight: 9999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "dns.id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.DNS.ID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "dns.question.class":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.DNS.Question.Class)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "dns.question.count":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.DNS.Question.Count)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "dns.question.length":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.DNS.Question.Size)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "dns.question.name":
		return &eval.StringEvaluator{
			OpOverrides: eval.CaseInsensitiveCmp,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.DNS.Question.Name
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "dns.question.name.length":
		return &eval.IntEvaluator{
			OpOverrides: eval.CaseInsensitiveCmp,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.DNS.Question.Name)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "dns.question.type":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.DNS.Question.Type)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "dns.response.code":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.DNS.HasResponse() {
					return 0
				}
				return int(ev.DNS.Response.ResponseCode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "event.async":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveAsync(ev)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "event.hostname":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHostname(ev, &ev.BaseEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "event.origin":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BaseEvent.Origin
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "event.os":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BaseEvent.Os
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "event.rule.tags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BaseEvent.RuleTags
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "event.service":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveService(ev, &ev.BaseEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "event.timestamp":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveEventTimestamp(ev, &ev.BaseEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.args":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgs(ev, ev.Exec.Process)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.args_flags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsFlags(ev, ev.Exec.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.args_options":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsOptions(ev, ev.Exec.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.args_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsTruncated(ev, ev.Exec.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgv(ev, ev.Exec.Process)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.argv0":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgv0(ev, ev.Exec.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.auid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exec.Process.Credentials.AUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.cap_effective":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exec.Process.Credentials.CapEffective)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.cap_permitted":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exec.Process.Credentials.CapPermitted)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.cgroup.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exec.Process.CGroup.CGroupFile.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.cgroup.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exec.Process.CGroup.CGroupFile.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.cgroup.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupID(ev, &ev.Exec.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.cgroup.manager":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupManager(ev, &ev.Exec.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.cgroup.version":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupVersion(ev, &ev.Exec.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.comm":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exec.Process.Comm
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.container.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessContainerID(ev, ev.Exec.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.created_at":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, ev.Exec.Process))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.egid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exec.Process.Credentials.EGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.egroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exec.Process.Credentials.EGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.envp":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvp(ev, ev.Exec.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.envs":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvs(ev, ev.Exec.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.envs_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, ev.Exec.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.euid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exec.Process.Credentials.EUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.euser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exec.Process.Credentials.EUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Exec.Process.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Exec.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Exec.Process.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Exec.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Exec.Process.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Exec.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Exec.Process.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.file.metadata.abi":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileMetadataABI(ev, &ev.Exec.FileMetadata)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.metadata.architecture":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileMetadataArchitecture(ev, &ev.Exec.FileMetadata)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.metadata.compression":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileMetadataCompression(ev, &ev.Exec.FileMetadata)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.metadata.is_executable":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileMetadataIsExecutable(ev, &ev.Exec.FileMetadata)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.metadata.is_garble_obfuscated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileMetadataIsGarbleObfuscated(ev, &ev.Exec.FileMetadata)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.metadata.is_upx_packed":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileMetadataIsUPXPacked(ev, &ev.Exec.FileMetadata)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.metadata.size":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveFileMetadataSize(ev, &ev.Exec.FileMetadata))
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.metadata.type":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileMetadataType(ev, &ev.Exec.FileMetadata)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Exec.Process.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Exec.Process.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Exec.Process.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Exec.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Exec.Process.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Exec.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Exec.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Exec.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Exec.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Exec.Process.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Exec.Process.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Exec.Process.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Exec.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.fsgid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exec.Process.Credentials.FSGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.fsgroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exec.Process.Credentials.FSGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.fsuid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exec.Process.Credentials.FSUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.fsuser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exec.Process.Credentials.FSUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exec.Process.Credentials.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exec.Process.Credentials.Group
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Exec.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Exec.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Exec.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Exec.Process.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Exec.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Exec.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Exec.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Exec.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Exec.Process.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.interpreter.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exec.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.is_exec":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exec.Process.IsExec
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.is_kworker":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exec.Process.PIDContext.IsKworker
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.is_thread":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessIsThread(ev, ev.Exec.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.pid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exec.Process.PIDContext.Pid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.ppid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exec.Process.PPid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.syscall.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr1(ev, &ev.Exec.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.tid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exec.Process.PIDContext.Tid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.tty_name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exec.Process.TTYName
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exec.Process.Credentials.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exec.Process.Credentials.User
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exec.user_session.k8s_groups":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SGroups(ev, &ev.Exec.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.user_session.k8s_uid":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SUID(ev, &ev.Exec.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exec.user_session.k8s_username":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SUsername(ev, &ev.Exec.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.args":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgs(ev, ev.Exit.Process)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.args_flags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsFlags(ev, ev.Exit.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.args_options":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsOptions(ev, ev.Exit.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.args_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsTruncated(ev, ev.Exit.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgv(ev, ev.Exit.Process)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.argv0":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgv0(ev, ev.Exit.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.auid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Process.Credentials.AUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.cap_effective":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Process.Credentials.CapEffective)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.cap_permitted":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Process.Credentials.CapPermitted)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.cause":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Cause)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.cgroup.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Process.CGroup.CGroupFile.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.cgroup.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Process.CGroup.CGroupFile.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.cgroup.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupID(ev, &ev.Exit.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.cgroup.manager":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupManager(ev, &ev.Exit.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.cgroup.version":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupVersion(ev, &ev.Exit.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.code":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Code)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.comm":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exit.Process.Comm
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.container.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessContainerID(ev, ev.Exit.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.created_at":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, ev.Exit.Process))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.egid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Process.Credentials.EGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.egroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exit.Process.Credentials.EGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.envp":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvp(ev, ev.Exit.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.envs":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvs(ev, ev.Exit.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.envs_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, ev.Exit.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.euid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Process.Credentials.EUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.euser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exit.Process.Credentials.EUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Exit.Process.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Exit.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Exit.Process.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Exit.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Exit.Process.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Exit.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Exit.Process.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Exit.Process.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Exit.Process.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Exit.Process.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Exit.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Exit.Process.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Exit.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Exit.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Exit.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Exit.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Exit.Process.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Exit.Process.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Exit.Process.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Exit.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.fsgid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Process.Credentials.FSGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.fsgroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exit.Process.Credentials.FSGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.fsuid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Process.Credentials.FSUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.fsuser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exit.Process.Credentials.FSUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Process.Credentials.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exit.Process.Credentials.Group
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Exit.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Exit.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Exit.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Exit.Process.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Exit.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Exit.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Exit.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Exit.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Exit.Process.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.interpreter.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Exit.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.is_exec":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exit.Process.IsExec
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.is_kworker":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exit.Process.PIDContext.IsKworker
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.is_thread":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessIsThread(ev, ev.Exit.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.pid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Process.PIDContext.Pid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.ppid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Process.PPid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.tid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Process.PIDContext.Tid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.tty_name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exit.Process.TTYName
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Exit.Process.Credentials.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Exit.Process.Credentials.User
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "exit.user_session.k8s_groups":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SGroups(ev, &ev.Exit.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.user_session.k8s_uid":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SUID(ev, &ev.Exit.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "exit.user_session.k8s_username":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SUsername(ev, &ev.Exit.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "imds.aws.is_imds_v2":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.IMDS.AWS.IsIMDSv2
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "imds.aws.security_credentials.type":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.IMDS.AWS.SecurityCredentials.Type
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "imds.cloud_provider":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.IMDS.CloudProvider
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "imds.host":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.IMDS.Host
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "imds.server":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.IMDS.Server
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "imds.type":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.IMDS.Type
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "imds.url":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.IMDS.URL
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "imds.user_agent":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.IMDS.UserAgent
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.Source.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.Target.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Link.Target)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.Target.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Link.Target.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Link.Target)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Link.Target.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.Target.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.Target.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.Target.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.Target.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Link.Target)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Link.Target))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Link.Target)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Link.Target)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Link.Target)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Link.Target)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Link.Target))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Link.Target.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.Target.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.destination.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Link.Target.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Link.Source)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.Source.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Link.Source.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Link.Source)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Link.Source.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.Source.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.Source.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.Source.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.Source.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Link.Source)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Link.Source))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Link.Source)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Link.Source)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Link.Source)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Link.Source)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Link.Source))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Link.Source.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.Source.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Link.Source.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Link.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "link.syscall.destination.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr2(ev, &ev.Link.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "link.syscall.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr1(ev, &ev.Link.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.args":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveModuleArgs(ev, &ev.LoadModule)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.args_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.LoadModule.ArgsTruncated
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "load_module.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveModuleArgv(ev, &ev.LoadModule)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.LoadModule.File.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "load_module.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.LoadModule.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.LoadModule.File.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "load_module.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.LoadModule.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.LoadModule.File)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.LoadModule.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.LoadModule.File.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "load_module.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.LoadModule.File.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "load_module.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.LoadModule.File.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "load_module.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.LoadModule.File.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "load_module.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.LoadModule.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.LoadModule.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.LoadModule.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.LoadModule.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.LoadModule.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.LoadModule.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.LoadModule.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.LoadModule.File.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.LoadModule.File.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "load_module.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.LoadModule.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "load_module.loaded_from_memory":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.LoadModule.LoadedFromMemory
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "load_module.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.LoadModule.Name
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "load_module.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.LoadModule.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Mkdir.File.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.destination.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Mkdir.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.destination.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Mkdir.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Mkdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Mkdir.File.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Mkdir.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Mkdir.File)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Mkdir.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Mkdir.File.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Mkdir.File.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Mkdir.File.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Mkdir.File.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Mkdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Mkdir.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Mkdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Mkdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Mkdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Mkdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Mkdir.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Mkdir.File.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Mkdir.File.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mkdir.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Mkdir.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mkdir.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Mkdir.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mkdir.syscall.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveSyscallCtxArgsInt2(ev, &ev.Mkdir.SyscallContext))
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mkdir.syscall.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr1(ev, &ev.Mkdir.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mmap.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.MMap.File.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mmap.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.MMap.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mmap.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.MMap.File.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mmap.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.MMap.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mmap.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.MMap.File)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mmap.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.MMap.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mmap.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.MMap.File.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mmap.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.MMap.File.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mmap.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.MMap.File.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mmap.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.MMap.File.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mmap.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.MMap.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mmap.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.MMap.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mmap.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.MMap.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mmap.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.MMap.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mmap.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.MMap.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mmap.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.MMap.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mmap.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.MMap.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mmap.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.MMap.File.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mmap.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.MMap.File.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mmap.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.MMap.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mmap.flags":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.MMap.Flags)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mmap.protection":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.MMap.Protection)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mmap.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.MMap.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mount.fs_type":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Mount.Mount.FSType
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mount.mountpoint.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveMountPointPath(ev, &ev.Mount)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mount.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Mount.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mount.root.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveMountRootPath(ev, &ev.Mount)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mount.source.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveMountSourcePath(ev, &ev.Mount)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mount.syscall.fs_type":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr3(ev, &ev.Mount.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mount.syscall.mountpoint.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr2(ev, &ev.Mount.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mount.syscall.source.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr1(ev, &ev.Mount.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "mprotect.req_protection":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.MProtect.ReqProtection
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mprotect.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.MProtect.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "mprotect.vm_protection":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.MProtect.VMProtection
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "network.destination.ip":
		return &eval.CIDREvaluator{
			EvalFnc: func(ctx *eval.Context) net.IPNet {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.NetworkContext.Destination.IPNet
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "network.destination.is_public":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveIsIPPublic(ev, &ev.NetworkContext.Destination)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "network.destination.port":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.NetworkContext.Destination.Port)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "network.device.ifname":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveNetworkDeviceIfName(ev, &ev.NetworkContext.Device)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "network.l3_protocol":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.NetworkContext.L3Protocol)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "network.l4_protocol":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.NetworkContext.L4Protocol)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "network.network_direction":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.NetworkContext.NetworkDirection)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "network.size":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.NetworkContext.Size)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "network.source.ip":
		return &eval.CIDREvaluator{
			EvalFnc: func(ctx *eval.Context) net.IPNet {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.NetworkContext.Source.IPNet
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "network.source.is_public":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveIsIPPublic(ev, &ev.NetworkContext.Source)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "network.source.port":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.NetworkContext.Source.Port)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "network_flow_monitor.device.ifname":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveNetworkDeviceIfName(ev, &ev.NetworkFlowMonitor.Device)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "network_flow_monitor.flows.destination.ip":
		return &eval.CIDRArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []net.IPNet {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &FlowsIterator{Root: ev.NetworkFlowMonitor.Flows}
				if regID != "" {
					value := iterator.At(ctx, regID, ctx.Registers[regID])
					if value == nil {
						return nil
					}
					element := *value
					result := element.Destination.IPNet
					return []net.IPNet{result}
				}
				if result, ok := ctx.IPNetCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "NetworkFlowMonitor.Flows", ctx, nil, func(ev *Event, current *Flow) net.IPNet {
					return current.Destination.IPNet
				})
				ctx.IPNetCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "network_flow_monitor.flows.destination.is_public":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &FlowsIterator{Root: ev.NetworkFlowMonitor.Flows}
				if regID != "" {
					value := iterator.At(ctx, regID, ctx.Registers[regID])
					if value == nil {
						return nil
					}
					element := *value
					result := ev.FieldHandlers.ResolveIsIPPublic(ev, &element.Destination)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "NetworkFlowMonitor.Flows", ctx, ev, func(ev *Event, current *Flow) bool {
					return ev.FieldHandlers.ResolveIsIPPublic(ev, &current.Destination)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "network_flow_monitor.flows.destination.port":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &FlowsIterator{Root: ev.NetworkFlowMonitor.Flows}
				if regID != "" {
					value := iterator.At(ctx, regID, ctx.Registers[regID])
					if value == nil {
						return nil
					}
					element := *value
					result := int(element.Destination.Port)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "NetworkFlowMonitor.Flows", ctx, nil, func(ev *Event, current *Flow) int {
					return int(current.Destination.Port)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "network_flow_monitor.flows.egress.data_size":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &FlowsIterator{Root: ev.NetworkFlowMonitor.Flows}
				if regID != "" {
					value := iterator.At(ctx, regID, ctx.Registers[regID])
					if value == nil {
						return nil
					}
					element := *value
					result := int(element.Egress.DataSize)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "NetworkFlowMonitor.Flows", ctx, nil, func(ev *Event, current *Flow) int {
					return int(current.Egress.DataSize)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "network_flow_monitor.flows.egress.packet_count":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &FlowsIterator{Root: ev.NetworkFlowMonitor.Flows}
				if regID != "" {
					value := iterator.At(ctx, regID, ctx.Registers[regID])
					if value == nil {
						return nil
					}
					element := *value
					result := int(element.Egress.PacketCount)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "NetworkFlowMonitor.Flows", ctx, nil, func(ev *Event, current *Flow) int {
					return int(current.Egress.PacketCount)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "network_flow_monitor.flows.ingress.data_size":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &FlowsIterator{Root: ev.NetworkFlowMonitor.Flows}
				if regID != "" {
					value := iterator.At(ctx, regID, ctx.Registers[regID])
					if value == nil {
						return nil
					}
					element := *value
					result := int(element.Ingress.DataSize)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "NetworkFlowMonitor.Flows", ctx, nil, func(ev *Event, current *Flow) int {
					return int(current.Ingress.DataSize)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "network_flow_monitor.flows.ingress.packet_count":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &FlowsIterator{Root: ev.NetworkFlowMonitor.Flows}
				if regID != "" {
					value := iterator.At(ctx, regID, ctx.Registers[regID])
					if value == nil {
						return nil
					}
					element := *value
					result := int(element.Ingress.PacketCount)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "NetworkFlowMonitor.Flows", ctx, nil, func(ev *Event, current *Flow) int {
					return int(current.Ingress.PacketCount)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "network_flow_monitor.flows.l3_protocol":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &FlowsIterator{Root: ev.NetworkFlowMonitor.Flows}
				if regID != "" {
					value := iterator.At(ctx, regID, ctx.Registers[regID])
					if value == nil {
						return nil
					}
					element := *value
					result := int(element.L3Protocol)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "NetworkFlowMonitor.Flows", ctx, nil, func(ev *Event, current *Flow) int {
					return int(current.L3Protocol)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "network_flow_monitor.flows.l4_protocol":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &FlowsIterator{Root: ev.NetworkFlowMonitor.Flows}
				if regID != "" {
					value := iterator.At(ctx, regID, ctx.Registers[regID])
					if value == nil {
						return nil
					}
					element := *value
					result := int(element.L4Protocol)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "NetworkFlowMonitor.Flows", ctx, nil, func(ev *Event, current *Flow) int {
					return int(current.L4Protocol)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "network_flow_monitor.flows.length":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				iterator := &FlowsIterator{}
				return iterator.Len(ctx)
			},
			Field:  field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "network_flow_monitor.flows.source.ip":
		return &eval.CIDRArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []net.IPNet {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &FlowsIterator{Root: ev.NetworkFlowMonitor.Flows}
				if regID != "" {
					value := iterator.At(ctx, regID, ctx.Registers[regID])
					if value == nil {
						return nil
					}
					element := *value
					result := element.Source.IPNet
					return []net.IPNet{result}
				}
				if result, ok := ctx.IPNetCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "NetworkFlowMonitor.Flows", ctx, nil, func(ev *Event, current *Flow) net.IPNet {
					return current.Source.IPNet
				})
				ctx.IPNetCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "network_flow_monitor.flows.source.is_public":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &FlowsIterator{Root: ev.NetworkFlowMonitor.Flows}
				if regID != "" {
					value := iterator.At(ctx, regID, ctx.Registers[regID])
					if value == nil {
						return nil
					}
					element := *value
					result := ev.FieldHandlers.ResolveIsIPPublic(ev, &element.Source)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "NetworkFlowMonitor.Flows", ctx, ev, func(ev *Event, current *Flow) bool {
					return ev.FieldHandlers.ResolveIsIPPublic(ev, &current.Source)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "network_flow_monitor.flows.source.port":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &FlowsIterator{Root: ev.NetworkFlowMonitor.Flows}
				if regID != "" {
					value := iterator.At(ctx, regID, ctx.Registers[regID])
					if value == nil {
						return nil
					}
					element := *value
					result := int(element.Source.Port)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "NetworkFlowMonitor.Flows", ctx, nil, func(ev *Event, current *Flow) int {
					return int(current.Source.Port)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ondemand.arg1.str":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveOnDemandArg1Str(ev, &ev.OnDemand)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ondemand.arg1.uint":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveOnDemandArg1Uint(ev, &ev.OnDemand))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ondemand.arg2.str":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveOnDemandArg2Str(ev, &ev.OnDemand)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ondemand.arg2.uint":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveOnDemandArg2Uint(ev, &ev.OnDemand))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ondemand.arg3.str":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveOnDemandArg3Str(ev, &ev.OnDemand)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ondemand.arg3.uint":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveOnDemandArg3Uint(ev, &ev.OnDemand))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ondemand.arg4.str":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveOnDemandArg4Str(ev, &ev.OnDemand)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ondemand.arg4.uint":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveOnDemandArg4Uint(ev, &ev.OnDemand))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ondemand.arg5.str":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveOnDemandArg5Str(ev, &ev.OnDemand)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ondemand.arg5.uint":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveOnDemandArg5Uint(ev, &ev.OnDemand))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ondemand.arg6.str":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveOnDemandArg6Str(ev, &ev.OnDemand)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ondemand.arg6.uint":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveOnDemandArg6Uint(ev, &ev.OnDemand))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ondemand.name":
		return &eval.StringEvaluator{
			OpOverrides: OnDemandNameOverrides,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveOnDemandName(ev, &ev.OnDemand)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Open.File.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "open.file.destination.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Open.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "open.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Open.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Open.File.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "open.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Open.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Open.File)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Open.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Open.File.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "open.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Open.File.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "open.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Open.File.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "open.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Open.File.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "open.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Open.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Open.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Open.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Open.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Open.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Open.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Open.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Open.File.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Open.File.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "open.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Open.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.flags":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Open.Flags)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "open.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Open.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "open.syscall.flags":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveSyscallCtxArgsInt2(ev, &ev.Open.SyscallContext))
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.syscall.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveSyscallCtxArgsInt3(ev, &ev.Open.SyscallContext))
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "open.syscall.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr1(ev, &ev.Open.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "packet.destination.ip":
		return &eval.CIDREvaluator{
			EvalFnc: func(ctx *eval.Context) net.IPNet {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.RawPacket.NetworkContext.Destination.IPNet
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "packet.destination.is_public":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveIsIPPublic(ev, &ev.RawPacket.NetworkContext.Destination)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "packet.destination.port":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RawPacket.NetworkContext.Destination.Port)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "packet.device.ifname":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveNetworkDeviceIfName(ev, &ev.RawPacket.NetworkContext.Device)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "packet.filter":
		return &eval.StringEvaluator{
			OpOverrides: PacketFilterMatching,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.RawPacket.Filter
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "packet.l3_protocol":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RawPacket.NetworkContext.L3Protocol)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "packet.l4_protocol":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RawPacket.NetworkContext.L4Protocol)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "packet.network_direction":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RawPacket.NetworkContext.NetworkDirection)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "packet.size":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RawPacket.NetworkContext.Size)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "packet.source.ip":
		return &eval.CIDREvaluator{
			EvalFnc: func(ctx *eval.Context) net.IPNet {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.RawPacket.NetworkContext.Source.IPNet
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "packet.source.is_public":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveIsIPPublic(ev, &ev.RawPacket.NetworkContext.Source)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "packet.source.port":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RawPacket.NetworkContext.Source.Port)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "packet.tls.version":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RawPacket.TLSContext.Version)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.args":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgs(ev, &element.ProcessContext.Process)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveProcessArgs(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 500 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.args_flags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgsFlags(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessArgsFlags(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.args_options":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgsOptions(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessArgsOptions(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.args_truncated":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgsTruncated(ev, &element.ProcessContext.Process)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					return ev.FieldHandlers.ResolveProcessArgsTruncated(ev, &current.ProcessContext.Process)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgv(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessArgv(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 500 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.argv0":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgv0(ev, &element.ProcessContext.Process)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveProcessArgv0(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 100 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.auid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.AUID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.AUID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.cap_effective":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.CapEffective)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.CapEffective)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.cap_permitted":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.CapPermitted)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.CapPermitted)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.cgroup.file.inode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.CGroup.CGroupFile.Inode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.CGroup.CGroupFile.Inode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.cgroup.file.mount_id":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.CGroup.CGroupFile.MountID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.CGroup.CGroupFile.MountID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.cgroup.id":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveCGroupID(ev, &element.ProcessContext.Process.CGroup)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveCGroupID(ev, &current.ProcessContext.Process.CGroup)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.cgroup.manager":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveCGroupManager(ev, &element.ProcessContext.Process.CGroup)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveCGroupManager(ev, &current.ProcessContext.Process.CGroup)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.cgroup.version":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(ev.FieldHandlers.ResolveCGroupVersion(ev, &element.ProcessContext.Process.CGroup))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return int(ev.FieldHandlers.ResolveCGroupVersion(ev, &current.ProcessContext.Process.CGroup))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.comm":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Comm
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Comm
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.container.id":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessContainerID(ev, &element.ProcessContext.Process)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveProcessContainerID(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.created_at":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, &element.ProcessContext.Process))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, &current.ProcessContext.Process))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.egid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.EGID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.EGID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.egroup":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.EGroup
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.EGroup
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.envp":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessEnvp(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessEnvp(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 100 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.envs":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessEnvs(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessEnvs(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 100 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.envs_truncated":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, &element.ProcessContext.Process)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					return ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, &current.ProcessContext.Process)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.euid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.EUID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.EUID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.euser":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.EUser
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.EUser
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.change_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.CTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.CTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.filesystem":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFilesystem(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFilesystem(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.gid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.GID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.GID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.group":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsGroup(ev, &element.ProcessContext.Process.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &current.ProcessContext.Process.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveHashesFromEvent(ev, &element.ProcessContext.Process.FileEvent)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return nil
					}
					return ev.FieldHandlers.ResolveHashesFromEvent(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 999 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.in_upper_layer":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []bool{false}
					}
					result := ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &element.ProcessContext.Process.FileEvent.FileFields)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					if !current.ProcessContext.Process.IsNotKworker() {
						return false
					}
					return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &current.ProcessContext.Process.FileEvent.FileFields)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.inode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.PathKey.Inode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.PathKey.Inode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.mode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.Mode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.Mode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.modification_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.MTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.MTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.mount_id":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.PathKey.MountID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.PathKey.MountID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.name":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.name.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.package.name":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageName(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageName(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.package.source_version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageSourceVersion(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.package.version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageVersion(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageVersion(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.path":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.path.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.rights":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(ev.FieldHandlers.ResolveRights(ev, &element.ProcessContext.Process.FileEvent.FileFields))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(ev.FieldHandlers.ResolveRights(ev, &current.ProcessContext.Process.FileEvent.FileFields))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.uid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.UID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.UID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.file.user":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsUser(ev, &element.ProcessContext.Process.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsUser(ev, &current.ProcessContext.Process.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.fsgid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.FSGID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.FSGID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.fsgroup":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.FSGroup
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.FSGroup
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.fsuid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.FSUID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.FSUID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.fsuser":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.FSUser
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.FSUser
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.gid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.GID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.GID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.group":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.Group
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.Group
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.change_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.CTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.CTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.filesystem":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFilesystem(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFilesystem(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.gid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.GID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.GID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.group":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsGroup(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveHashesFromEvent(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return nil
					}
					return ev.FieldHandlers.ResolveHashesFromEvent(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 999 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.in_upper_layer":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []bool{false}
					}
					result := ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					if !current.ProcessContext.Process.HasInterpreter() {
						return false
					}
					return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.inode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.mode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.modification_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.MTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.MTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.mount_id":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.name":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.name.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.package.name":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageName(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageName(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.package.source_version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageSourceVersion(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.package.version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageVersion(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageVersion(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.path":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.path.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.rights":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(ev.FieldHandlers.ResolveRights(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(ev.FieldHandlers.ResolveRights(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.uid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.UID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.UID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.interpreter.file.user":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsUser(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsUser(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.is_exec":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.IsExec
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) bool {
					return current.ProcessContext.Process.IsExec
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.is_kworker":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.PIDContext.IsKworker
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) bool {
					return current.ProcessContext.Process.PIDContext.IsKworker
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.is_thread":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessIsThread(ev, &element.ProcessContext.Process)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					return ev.FieldHandlers.ResolveProcessIsThread(ev, &current.ProcessContext.Process)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.length":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				iterator := &ProcessAncestorsIterator{}
				return iterator.Len(ctx)
			},
			Field:  field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.pid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.PIDContext.Pid)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.PIDContext.Pid)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.ppid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.PPid)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.PPid)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.tid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.PIDContext.Tid)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.PIDContext.Tid)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.tty_name":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.TTYName
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.TTYName
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.uid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.UID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.UID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.user":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.User
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.User
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.user_session.k8s_groups":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveK8SGroups(ev, &element.ProcessContext.Process.UserSession)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveK8SGroups(ev, &current.ProcessContext.Process.UserSession)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.user_session.k8s_uid":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveK8SUID(ev, &element.ProcessContext.Process.UserSession)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveK8SUID(ev, &current.ProcessContext.Process.UserSession)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.ancestors.user_session.k8s_username":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.BaseEvent.ProcessContext.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveK8SUsername(ev, &element.ProcessContext.Process.UserSession)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "BaseEvent.ProcessContext.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveK8SUsername(ev, &current.ProcessContext.Process.UserSession)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "process.args":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgs(ev, &ev.BaseEvent.ProcessContext.Process)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.args_flags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsFlags(ev, &ev.BaseEvent.ProcessContext.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.args_options":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsOptions(ev, &ev.BaseEvent.ProcessContext.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.args_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsTruncated(ev, &ev.BaseEvent.ProcessContext.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgv(ev, &ev.BaseEvent.ProcessContext.Process)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.argv0":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgv0(ev, &ev.BaseEvent.ProcessContext.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.auid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BaseEvent.ProcessContext.Process.Credentials.AUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.cap_effective":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BaseEvent.ProcessContext.Process.Credentials.CapEffective)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.cap_permitted":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BaseEvent.ProcessContext.Process.Credentials.CapPermitted)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.cgroup.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BaseEvent.ProcessContext.Process.CGroup.CGroupFile.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.cgroup.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BaseEvent.ProcessContext.Process.CGroup.CGroupFile.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.cgroup.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupID(ev, &ev.BaseEvent.ProcessContext.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.cgroup.manager":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupManager(ev, &ev.BaseEvent.ProcessContext.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.cgroup.version":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupVersion(ev, &ev.BaseEvent.ProcessContext.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.comm":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BaseEvent.ProcessContext.Process.Comm
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.container.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessContainerID(ev, &ev.BaseEvent.ProcessContext.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.created_at":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, &ev.BaseEvent.ProcessContext.Process))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.egid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BaseEvent.ProcessContext.Process.Credentials.EGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.egroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BaseEvent.ProcessContext.Process.Credentials.EGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.envp":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvp(ev, &ev.BaseEvent.ProcessContext.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.envs":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvs(ev, &ev.BaseEvent.ProcessContext.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.envs_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, &ev.BaseEvent.ProcessContext.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.euid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BaseEvent.ProcessContext.Process.Credentials.EUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.euser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BaseEvent.ProcessContext.Process.Credentials.EUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.BaseEvent.ProcessContext.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.BaseEvent.ProcessContext.Process.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.BaseEvent.ProcessContext.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.BaseEvent.ProcessContext.Process.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.BaseEvent.ProcessContext.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.BaseEvent.ProcessContext.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.BaseEvent.ProcessContext.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.BaseEvent.ProcessContext.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.BaseEvent.ProcessContext.Process.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.fsgid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BaseEvent.ProcessContext.Process.Credentials.FSGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.fsgroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BaseEvent.ProcessContext.Process.Credentials.FSGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.fsuid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BaseEvent.ProcessContext.Process.Credentials.FSUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.fsuser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BaseEvent.ProcessContext.Process.Credentials.FSUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BaseEvent.ProcessContext.Process.Credentials.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BaseEvent.ProcessContext.Process.Credentials.Group
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.interpreter.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.is_exec":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BaseEvent.ProcessContext.Process.IsExec
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.is_kworker":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BaseEvent.ProcessContext.Process.PIDContext.IsKworker
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.is_thread":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessIsThread(ev, &ev.BaseEvent.ProcessContext.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.args":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveProcessArgs(ev, ev.BaseEvent.ProcessContext.Parent)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.args_flags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessArgsFlags(ev, ev.BaseEvent.ProcessContext.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.args_options":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessArgsOptions(ev, ev.BaseEvent.ProcessContext.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.args_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return false
				}
				return ev.FieldHandlers.ResolveProcessArgsTruncated(ev, ev.BaseEvent.ProcessContext.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessArgv(ev, ev.BaseEvent.ProcessContext.Parent)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.argv0":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveProcessArgv0(ev, ev.BaseEvent.ProcessContext.Parent)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.auid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.Credentials.AUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.cap_effective":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.Credentials.CapEffective)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.cap_permitted":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.Credentials.CapPermitted)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.cgroup.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.CGroup.CGroupFile.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.cgroup.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.CGroup.CGroupFile.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.cgroup.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveCGroupID(ev, &ev.BaseEvent.ProcessContext.Parent.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.cgroup.manager":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveCGroupManager(ev, &ev.BaseEvent.ProcessContext.Parent.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.cgroup.version":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return ev.FieldHandlers.ResolveCGroupVersion(ev, &ev.BaseEvent.ProcessContext.Parent.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.comm":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.BaseEvent.ProcessContext.Parent.Comm
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.container.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveProcessContainerID(ev, ev.BaseEvent.ProcessContext.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.created_at":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, ev.BaseEvent.ProcessContext.Parent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.egid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.Credentials.EGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.egroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.BaseEvent.ProcessContext.Parent.Credentials.EGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.envp":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessEnvp(ev, ev.BaseEvent.ProcessContext.Parent)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.envs":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessEnvs(ev, ev.BaseEvent.ProcessContext.Parent)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.envs_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return false
				}
				return ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, ev.BaseEvent.ProcessContext.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.euid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.Credentials.EUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.euser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.BaseEvent.ProcessContext.Parent.Credentials.EUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.BaseEvent.ProcessContext.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return []string{}
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.BaseEvent.ProcessContext.Parent.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return false
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.BaseEvent.ProcessContext.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.BaseEvent.ProcessContext.Parent.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.BaseEvent.ProcessContext.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.BaseEvent.ProcessContext.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.BaseEvent.ProcessContext.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.BaseEvent.ProcessContext.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.BaseEvent.ProcessContext.Parent.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.fsgid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.Credentials.FSGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.fsgroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.BaseEvent.ProcessContext.Parent.Credentials.FSGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.fsuid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.Credentials.FSUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.fsuser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.BaseEvent.ProcessContext.Parent.Credentials.FSUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.Credentials.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.BaseEvent.ProcessContext.Parent.Credentials.Group
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return []string{}
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return false
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.interpreter.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				if !ev.BaseEvent.ProcessContext.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.is_exec":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return false
				}
				return ev.BaseEvent.ProcessContext.Parent.IsExec
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.is_kworker":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return false
				}
				return ev.BaseEvent.ProcessContext.Parent.PIDContext.IsKworker
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.is_thread":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return false
				}
				return ev.FieldHandlers.ResolveProcessIsThread(ev, ev.BaseEvent.ProcessContext.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.pid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.PIDContext.Pid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.ppid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.PPid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.tid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.PIDContext.Tid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.tty_name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.BaseEvent.ProcessContext.Parent.TTYName
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return 0
				}
				return int(ev.BaseEvent.ProcessContext.Parent.Credentials.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.BaseEvent.ProcessContext.Parent.Credentials.User
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.parent.user_session.k8s_groups":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveK8SGroups(ev, &ev.BaseEvent.ProcessContext.Parent.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.user_session.k8s_uid":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveK8SUID(ev, &ev.BaseEvent.ProcessContext.Parent.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.parent.user_session.k8s_username":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.BaseEvent.ProcessContext.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveK8SUsername(ev, &ev.BaseEvent.ProcessContext.Parent.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.pid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BaseEvent.ProcessContext.Process.PIDContext.Pid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.ppid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BaseEvent.ProcessContext.Process.PPid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.tid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BaseEvent.ProcessContext.Process.PIDContext.Tid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.tty_name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BaseEvent.ProcessContext.Process.TTYName
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.BaseEvent.ProcessContext.Process.Credentials.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.BaseEvent.ProcessContext.Process.Credentials.User
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "process.user_session.k8s_groups":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SGroups(ev, &ev.BaseEvent.ProcessContext.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.user_session.k8s_uid":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SUID(ev, &ev.BaseEvent.ProcessContext.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "process.user_session.k8s_username":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SUsername(ev, &ev.BaseEvent.ProcessContext.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.request":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Request)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.args":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgs(ev, &element.ProcessContext.Process)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveProcessArgs(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 500 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.args_flags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgsFlags(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessArgsFlags(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.args_options":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgsOptions(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessArgsOptions(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.args_truncated":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgsTruncated(ev, &element.ProcessContext.Process)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					return ev.FieldHandlers.ResolveProcessArgsTruncated(ev, &current.ProcessContext.Process)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgv(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessArgv(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 500 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.argv0":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgv0(ev, &element.ProcessContext.Process)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveProcessArgv0(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 100 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.auid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.AUID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.AUID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.cap_effective":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.CapEffective)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.CapEffective)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.cap_permitted":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.CapPermitted)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.CapPermitted)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.cgroup.file.inode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.CGroup.CGroupFile.Inode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.CGroup.CGroupFile.Inode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.cgroup.file.mount_id":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.CGroup.CGroupFile.MountID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.CGroup.CGroupFile.MountID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.cgroup.id":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveCGroupID(ev, &element.ProcessContext.Process.CGroup)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveCGroupID(ev, &current.ProcessContext.Process.CGroup)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.cgroup.manager":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveCGroupManager(ev, &element.ProcessContext.Process.CGroup)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveCGroupManager(ev, &current.ProcessContext.Process.CGroup)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.cgroup.version":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(ev.FieldHandlers.ResolveCGroupVersion(ev, &element.ProcessContext.Process.CGroup))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return int(ev.FieldHandlers.ResolveCGroupVersion(ev, &current.ProcessContext.Process.CGroup))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.comm":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Comm
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Comm
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.container.id":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessContainerID(ev, &element.ProcessContext.Process)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveProcessContainerID(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.created_at":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, &element.ProcessContext.Process))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, &current.ProcessContext.Process))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.egid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.EGID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.EGID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.egroup":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.EGroup
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.EGroup
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.envp":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessEnvp(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessEnvp(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 100 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.envs":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessEnvs(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessEnvs(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 100 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.envs_truncated":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, &element.ProcessContext.Process)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					return ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, &current.ProcessContext.Process)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.euid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.EUID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.EUID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.euser":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.EUser
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.EUser
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.change_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.CTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.CTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.filesystem":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFilesystem(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFilesystem(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.gid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.GID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.GID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.group":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsGroup(ev, &element.ProcessContext.Process.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &current.ProcessContext.Process.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveHashesFromEvent(ev, &element.ProcessContext.Process.FileEvent)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return nil
					}
					return ev.FieldHandlers.ResolveHashesFromEvent(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 999 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.in_upper_layer":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []bool{false}
					}
					result := ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &element.ProcessContext.Process.FileEvent.FileFields)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					if !current.ProcessContext.Process.IsNotKworker() {
						return false
					}
					return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &current.ProcessContext.Process.FileEvent.FileFields)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.inode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.PathKey.Inode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.PathKey.Inode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.mode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.Mode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.Mode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.modification_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.MTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.MTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.mount_id":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.PathKey.MountID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.PathKey.MountID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.name":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.name.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.package.name":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageName(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageName(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.package.source_version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageSourceVersion(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.package.version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageVersion(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageVersion(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.path":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.path.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.rights":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(ev.FieldHandlers.ResolveRights(ev, &element.ProcessContext.Process.FileEvent.FileFields))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(ev.FieldHandlers.ResolveRights(ev, &current.ProcessContext.Process.FileEvent.FileFields))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.uid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.UID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.UID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.file.user":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsUser(ev, &element.ProcessContext.Process.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsUser(ev, &current.ProcessContext.Process.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.fsgid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.FSGID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.FSGID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.fsgroup":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.FSGroup
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.FSGroup
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.fsuid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.FSUID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.FSUID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.fsuser":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.FSUser
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.FSUser
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.gid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.GID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.GID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.group":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.Group
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.Group
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.change_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.CTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.CTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.filesystem":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFilesystem(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFilesystem(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.gid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.GID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.GID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.group":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsGroup(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveHashesFromEvent(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return nil
					}
					return ev.FieldHandlers.ResolveHashesFromEvent(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 999 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.in_upper_layer":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []bool{false}
					}
					result := ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					if !current.ProcessContext.Process.HasInterpreter() {
						return false
					}
					return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.inode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.mode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.modification_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.MTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.MTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.mount_id":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.name":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.name.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.package.name":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageName(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageName(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.package.source_version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageSourceVersion(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.package.version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageVersion(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageVersion(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.path":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.path.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.rights":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(ev.FieldHandlers.ResolveRights(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(ev.FieldHandlers.ResolveRights(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.uid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.UID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.UID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.interpreter.file.user":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsUser(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsUser(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.is_exec":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.IsExec
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) bool {
					return current.ProcessContext.Process.IsExec
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.is_kworker":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.PIDContext.IsKworker
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) bool {
					return current.ProcessContext.Process.PIDContext.IsKworker
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.is_thread":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessIsThread(ev, &element.ProcessContext.Process)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					return ev.FieldHandlers.ResolveProcessIsThread(ev, &current.ProcessContext.Process)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.length":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				iterator := &ProcessAncestorsIterator{}
				return iterator.Len(ctx)
			},
			Field:  field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.pid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.PIDContext.Pid)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.PIDContext.Pid)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.ppid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.PPid)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.PPid)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.tid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.PIDContext.Tid)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.PIDContext.Tid)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.tty_name":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.TTYName
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.TTYName
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.uid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.UID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.UID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.user":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.User
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.User
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.user_session.k8s_groups":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveK8SGroups(ev, &element.ProcessContext.Process.UserSession)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveK8SGroups(ev, &current.ProcessContext.Process.UserSession)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.user_session.k8s_uid":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveK8SUID(ev, &element.ProcessContext.Process.UserSession)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveK8SUID(ev, &current.ProcessContext.Process.UserSession)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ancestors.user_session.k8s_username":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.PTrace.Tracee.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveK8SUsername(ev, &element.ProcessContext.Process.UserSession)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "PTrace.Tracee.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveK8SUsername(ev, &current.ProcessContext.Process.UserSession)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.args":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgs(ev, &ev.PTrace.Tracee.Process)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.args_flags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsFlags(ev, &ev.PTrace.Tracee.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.args_options":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsOptions(ev, &ev.PTrace.Tracee.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.args_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsTruncated(ev, &ev.PTrace.Tracee.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgv(ev, &ev.PTrace.Tracee.Process)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.argv0":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgv0(ev, &ev.PTrace.Tracee.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.auid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Tracee.Process.Credentials.AUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.cap_effective":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Tracee.Process.Credentials.CapEffective)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.cap_permitted":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Tracee.Process.Credentials.CapPermitted)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.cgroup.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Tracee.Process.CGroup.CGroupFile.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.cgroup.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Tracee.Process.CGroup.CGroupFile.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.cgroup.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupID(ev, &ev.PTrace.Tracee.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.cgroup.manager":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupManager(ev, &ev.PTrace.Tracee.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.cgroup.version":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupVersion(ev, &ev.PTrace.Tracee.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.comm":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.PTrace.Tracee.Process.Comm
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.container.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessContainerID(ev, &ev.PTrace.Tracee.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.created_at":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, &ev.PTrace.Tracee.Process))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.egid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Tracee.Process.Credentials.EGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.egroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.PTrace.Tracee.Process.Credentials.EGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.envp":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvp(ev, &ev.PTrace.Tracee.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.envs":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvs(ev, &ev.PTrace.Tracee.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.envs_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, &ev.PTrace.Tracee.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.euid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Tracee.Process.Credentials.EUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.euser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.PTrace.Tracee.Process.Credentials.EUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return 0
				}
				return int(ev.PTrace.Tracee.Process.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.PTrace.Tracee.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return 0
				}
				return int(ev.PTrace.Tracee.Process.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.PTrace.Tracee.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.PTrace.Tracee.Process.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.PTrace.Tracee.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return 0
				}
				return int(ev.PTrace.Tracee.Process.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return 0
				}
				return int(ev.PTrace.Tracee.Process.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return 0
				}
				return int(ev.PTrace.Tracee.Process.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return 0
				}
				return int(ev.PTrace.Tracee.Process.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.PTrace.Tracee.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.PTrace.Tracee.Process.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.PTrace.Tracee.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.PTrace.Tracee.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.PTrace.Tracee.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.PTrace.Tracee.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.PTrace.Tracee.Process.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.PTrace.Tracee.Process.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return 0
				}
				return int(ev.PTrace.Tracee.Process.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.PTrace.Tracee.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.fsgid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Tracee.Process.Credentials.FSGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.fsgroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.PTrace.Tracee.Process.Credentials.FSGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.fsuid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Tracee.Process.Credentials.FSUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.fsuser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.PTrace.Tracee.Process.Credentials.FSUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Tracee.Process.Credentials.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.PTrace.Tracee.Process.Credentials.Group
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return 0
				}
				return int(ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return 0
				}
				return int(ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return 0
				}
				return int(ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return 0
				}
				return int(ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return 0
				}
				return int(ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return 0
				}
				return int(ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return 0
				}
				return int(ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.interpreter.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.is_exec":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.PTrace.Tracee.Process.IsExec
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.is_kworker":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.PTrace.Tracee.Process.PIDContext.IsKworker
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.is_thread":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessIsThread(ev, &ev.PTrace.Tracee.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.args":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveProcessArgs(ev, ev.PTrace.Tracee.Parent)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.args_flags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessArgsFlags(ev, ev.PTrace.Tracee.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.args_options":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessArgsOptions(ev, ev.PTrace.Tracee.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.args_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return false
				}
				return ev.FieldHandlers.ResolveProcessArgsTruncated(ev, ev.PTrace.Tracee.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessArgv(ev, ev.PTrace.Tracee.Parent)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.argv0":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveProcessArgv0(ev, ev.PTrace.Tracee.Parent)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.auid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.Credentials.AUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.cap_effective":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.Credentials.CapEffective)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.cap_permitted":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.Credentials.CapPermitted)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.cgroup.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.CGroup.CGroupFile.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.cgroup.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.CGroup.CGroupFile.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.cgroup.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveCGroupID(ev, &ev.PTrace.Tracee.Parent.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.cgroup.manager":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveCGroupManager(ev, &ev.PTrace.Tracee.Parent.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.cgroup.version":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return ev.FieldHandlers.ResolveCGroupVersion(ev, &ev.PTrace.Tracee.Parent.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.comm":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.PTrace.Tracee.Parent.Comm
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.container.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveProcessContainerID(ev, ev.PTrace.Tracee.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.created_at":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, ev.PTrace.Tracee.Parent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.egid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.Credentials.EGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.egroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.PTrace.Tracee.Parent.Credentials.EGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.envp":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessEnvp(ev, ev.PTrace.Tracee.Parent)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.envs":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessEnvs(ev, ev.PTrace.Tracee.Parent)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.envs_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return false
				}
				return ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, ev.PTrace.Tracee.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.euid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.Credentials.EUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.euser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.PTrace.Tracee.Parent.Credentials.EUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.PTrace.Tracee.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.PTrace.Tracee.Parent.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return []string{}
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.PTrace.Tracee.Parent.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return false
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.PTrace.Tracee.Parent.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.PTrace.Tracee.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.PTrace.Tracee.Parent.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.PTrace.Tracee.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.PTrace.Tracee.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.PTrace.Tracee.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.PTrace.Tracee.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.PTrace.Tracee.Parent.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.PTrace.Tracee.Parent.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.PTrace.Tracee.Parent.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.fsgid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.Credentials.FSGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.fsgroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.PTrace.Tracee.Parent.Credentials.FSGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.fsuid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.Credentials.FSUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.fsuser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.PTrace.Tracee.Parent.Credentials.FSUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.Credentials.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.PTrace.Tracee.Parent.Credentials.Group
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return []string{}
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return false
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.interpreter.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				if !ev.PTrace.Tracee.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.is_exec":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return false
				}
				return ev.PTrace.Tracee.Parent.IsExec
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.is_kworker":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return false
				}
				return ev.PTrace.Tracee.Parent.PIDContext.IsKworker
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.is_thread":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return false
				}
				return ev.FieldHandlers.ResolveProcessIsThread(ev, ev.PTrace.Tracee.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.pid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.PIDContext.Pid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.ppid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.PPid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.tid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.PIDContext.Tid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.tty_name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.PTrace.Tracee.Parent.TTYName
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return 0
				}
				return int(ev.PTrace.Tracee.Parent.Credentials.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.PTrace.Tracee.Parent.Credentials.User
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.user_session.k8s_groups":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveK8SGroups(ev, &ev.PTrace.Tracee.Parent.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.user_session.k8s_uid":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveK8SUID(ev, &ev.PTrace.Tracee.Parent.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.parent.user_session.k8s_username":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.PTrace.Tracee.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveK8SUsername(ev, &ev.PTrace.Tracee.Parent.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.pid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Tracee.Process.PIDContext.Pid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.ppid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Tracee.Process.PPid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.tid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Tracee.Process.PIDContext.Tid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.tty_name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.PTrace.Tracee.Process.TTYName
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.PTrace.Tracee.Process.Credentials.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.PTrace.Tracee.Process.Credentials.User
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.user_session.k8s_groups":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SGroups(ev, &ev.PTrace.Tracee.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.user_session.k8s_uid":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SUID(ev, &ev.PTrace.Tracee.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "ptrace.tracee.user_session.k8s_username":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SUsername(ev, &ev.PTrace.Tracee.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RemoveXAttr.File.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.destination.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveXAttrName(ev, &ev.RemoveXAttr)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.destination.namespace":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveXAttrNamespace(ev, &ev.RemoveXAttr)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.RemoveXAttr.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RemoveXAttr.File.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.RemoveXAttr.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.RemoveXAttr.File)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.RemoveXAttr.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RemoveXAttr.File.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RemoveXAttr.File.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RemoveXAttr.File.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RemoveXAttr.File.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.RemoveXAttr.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.RemoveXAttr.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.RemoveXAttr.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.RemoveXAttr.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.RemoveXAttr.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.RemoveXAttr.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.RemoveXAttr.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.RemoveXAttr.File.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RemoveXAttr.File.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "removexattr.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.RemoveXAttr.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "removexattr.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.RemoveXAttr.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.Old.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.New.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Rename.New)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.New.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Rename.New.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Rename.New)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Rename.New.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.New.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.New.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.New.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.New.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Rename.New)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Rename.New))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Rename.New)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Rename.New)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Rename.New)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Rename.New)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Rename.New))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Rename.New.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.New.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.destination.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Rename.New.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Rename.Old)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.Old.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Rename.Old.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Rename.Old)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Rename.Old.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.Old.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.Old.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.Old.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.Old.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Rename.Old)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Rename.Old))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Rename.Old)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Rename.Old)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Rename.Old)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Rename.Old)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Rename.Old))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Rename.Old.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.Old.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Rename.Old.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rename.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rename.syscall.destination.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr2(ev, &ev.Rename.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rename.syscall.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr1(ev, &ev.Rename.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rmdir.File.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Rmdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rmdir.File.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Rmdir.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Rmdir.File)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Rmdir.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rmdir.File.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rmdir.File.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rmdir.File.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rmdir.File.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Rmdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Rmdir.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Rmdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Rmdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Rmdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Rmdir.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Rmdir.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Rmdir.File.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rmdir.File.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rmdir.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Rmdir.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "rmdir.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Rmdir.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "rmdir.syscall.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr1(ev, &ev.Rmdir.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "selinux.bool.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSELinuxBoolName(ev, &ev.SELinux)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "selinux.bool.state":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.SELinux.BoolChangeValue
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "selinux.bool_commit.state":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.SELinux.BoolCommitValue
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "selinux.enforce.status":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.SELinux.EnforceStatus
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setgid.egid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetGID.EGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setgid.egroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSetgidEGroup(ev, &ev.SetGID)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setgid.fsgid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetGID.FSGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setgid.fsgroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSetgidFSGroup(ev, &ev.SetGID)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setgid.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetGID.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setgid.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSetgidGroup(ev, &ev.SetGID)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.resource":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Setrlimit.Resource
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.rlim_cur":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.RlimCur)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.rlim_max":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.RlimMax)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.args":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgs(ev, &element.ProcessContext.Process)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveProcessArgs(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 500 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.args_flags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgsFlags(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessArgsFlags(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.args_options":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgsOptions(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessArgsOptions(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.args_truncated":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgsTruncated(ev, &element.ProcessContext.Process)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					return ev.FieldHandlers.ResolveProcessArgsTruncated(ev, &current.ProcessContext.Process)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgv(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessArgv(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 500 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.argv0":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgv0(ev, &element.ProcessContext.Process)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveProcessArgv0(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 100 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.auid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.AUID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.AUID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.cap_effective":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.CapEffective)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.CapEffective)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.cap_permitted":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.CapPermitted)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.CapPermitted)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.cgroup.file.inode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.CGroup.CGroupFile.Inode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.CGroup.CGroupFile.Inode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.cgroup.file.mount_id":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.CGroup.CGroupFile.MountID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.CGroup.CGroupFile.MountID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.cgroup.id":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveCGroupID(ev, &element.ProcessContext.Process.CGroup)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveCGroupID(ev, &current.ProcessContext.Process.CGroup)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.cgroup.manager":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveCGroupManager(ev, &element.ProcessContext.Process.CGroup)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveCGroupManager(ev, &current.ProcessContext.Process.CGroup)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.cgroup.version":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(ev.FieldHandlers.ResolveCGroupVersion(ev, &element.ProcessContext.Process.CGroup))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return int(ev.FieldHandlers.ResolveCGroupVersion(ev, &current.ProcessContext.Process.CGroup))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.comm":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Comm
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Comm
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.container.id":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessContainerID(ev, &element.ProcessContext.Process)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveProcessContainerID(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.created_at":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, &element.ProcessContext.Process))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, &current.ProcessContext.Process))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.egid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.EGID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.EGID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.egroup":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.EGroup
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.EGroup
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.envp":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessEnvp(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessEnvp(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 100 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.envs":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessEnvs(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessEnvs(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 100 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.envs_truncated":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, &element.ProcessContext.Process)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					return ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, &current.ProcessContext.Process)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.euid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.EUID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.EUID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.euser":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.EUser
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.EUser
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.change_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.CTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.CTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.filesystem":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFilesystem(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFilesystem(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.gid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.GID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.GID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.group":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsGroup(ev, &element.ProcessContext.Process.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &current.ProcessContext.Process.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveHashesFromEvent(ev, &element.ProcessContext.Process.FileEvent)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return nil
					}
					return ev.FieldHandlers.ResolveHashesFromEvent(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 999 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.in_upper_layer":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []bool{false}
					}
					result := ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &element.ProcessContext.Process.FileEvent.FileFields)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					if !current.ProcessContext.Process.IsNotKworker() {
						return false
					}
					return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &current.ProcessContext.Process.FileEvent.FileFields)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.inode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.PathKey.Inode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.PathKey.Inode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.mode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.Mode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.Mode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.modification_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.MTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.MTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.mount_id":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.PathKey.MountID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.PathKey.MountID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.name":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.name.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.package.name":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageName(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageName(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.package.source_version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageSourceVersion(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.package.version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageVersion(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageVersion(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.path":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.path.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.rights":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(ev.FieldHandlers.ResolveRights(ev, &element.ProcessContext.Process.FileEvent.FileFields))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(ev.FieldHandlers.ResolveRights(ev, &current.ProcessContext.Process.FileEvent.FileFields))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.uid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.UID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.UID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.file.user":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsUser(ev, &element.ProcessContext.Process.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsUser(ev, &current.ProcessContext.Process.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.fsgid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.FSGID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.FSGID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.fsgroup":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.FSGroup
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.FSGroup
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.fsuid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.FSUID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.FSUID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.fsuser":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.FSUser
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.FSUser
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.gid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.GID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.GID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.group":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.Group
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.Group
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.change_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.CTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.CTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.filesystem":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFilesystem(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFilesystem(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.gid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.GID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.GID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.group":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsGroup(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveHashesFromEvent(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return nil
					}
					return ev.FieldHandlers.ResolveHashesFromEvent(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 999 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.in_upper_layer":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []bool{false}
					}
					result := ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					if !current.ProcessContext.Process.HasInterpreter() {
						return false
					}
					return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.inode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.mode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.modification_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.MTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.MTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.mount_id":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.name":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.name.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.package.name":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageName(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageName(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.package.source_version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageSourceVersion(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.package.version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageVersion(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageVersion(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.path":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.path.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.rights":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(ev.FieldHandlers.ResolveRights(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(ev.FieldHandlers.ResolveRights(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.uid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.UID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.UID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.interpreter.file.user":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsUser(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsUser(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.is_exec":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.IsExec
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) bool {
					return current.ProcessContext.Process.IsExec
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.is_kworker":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.PIDContext.IsKworker
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) bool {
					return current.ProcessContext.Process.PIDContext.IsKworker
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.is_thread":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessIsThread(ev, &element.ProcessContext.Process)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					return ev.FieldHandlers.ResolveProcessIsThread(ev, &current.ProcessContext.Process)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.length":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				iterator := &ProcessAncestorsIterator{}
				return iterator.Len(ctx)
			},
			Field:  field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.pid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.PIDContext.Pid)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.PIDContext.Pid)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.ppid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.PPid)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.PPid)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.tid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.PIDContext.Tid)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.PIDContext.Tid)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.tty_name":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.TTYName
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.TTYName
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.uid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.UID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.UID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.user":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.User
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.User
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.user_session.k8s_groups":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveK8SGroups(ev, &element.ProcessContext.Process.UserSession)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveK8SGroups(ev, &current.ProcessContext.Process.UserSession)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.user_session.k8s_uid":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveK8SUID(ev, &element.ProcessContext.Process.UserSession)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveK8SUID(ev, &current.ProcessContext.Process.UserSession)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ancestors.user_session.k8s_username":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Setrlimit.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveK8SUsername(ev, &element.ProcessContext.Process.UserSession)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Setrlimit.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveK8SUsername(ev, &current.ProcessContext.Process.UserSession)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.args":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgs(ev, &ev.Setrlimit.Target.Process)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.args_flags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsFlags(ev, &ev.Setrlimit.Target.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.args_options":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsOptions(ev, &ev.Setrlimit.Target.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.args_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsTruncated(ev, &ev.Setrlimit.Target.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgv(ev, &ev.Setrlimit.Target.Process)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.argv0":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgv0(ev, &ev.Setrlimit.Target.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.auid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.Target.Process.Credentials.AUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.cap_effective":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.Target.Process.Credentials.CapEffective)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.cap_permitted":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.Target.Process.Credentials.CapPermitted)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.cgroup.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.Target.Process.CGroup.CGroupFile.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.cgroup.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.Target.Process.CGroup.CGroupFile.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.cgroup.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupID(ev, &ev.Setrlimit.Target.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.cgroup.manager":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupManager(ev, &ev.Setrlimit.Target.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.cgroup.version":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupVersion(ev, &ev.Setrlimit.Target.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.comm":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Setrlimit.Target.Process.Comm
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.container.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessContainerID(ev, &ev.Setrlimit.Target.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.created_at":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, &ev.Setrlimit.Target.Process))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.egid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.Target.Process.Credentials.EGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.egroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Setrlimit.Target.Process.Credentials.EGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.envp":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvp(ev, &ev.Setrlimit.Target.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.envs":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvs(ev, &ev.Setrlimit.Target.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.envs_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, &ev.Setrlimit.Target.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.euid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.Target.Process.Credentials.EUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.euser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Setrlimit.Target.Process.Credentials.EUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Setrlimit.Target.Process.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Setrlimit.Target.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Setrlimit.Target.Process.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Setrlimit.Target.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Setrlimit.Target.Process.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Setrlimit.Target.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Setrlimit.Target.Process.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Setrlimit.Target.Process.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Setrlimit.Target.Process.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Setrlimit.Target.Process.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Setrlimit.Target.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Setrlimit.Target.Process.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Setrlimit.Target.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Setrlimit.Target.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Setrlimit.Target.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Setrlimit.Target.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Setrlimit.Target.Process.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Setrlimit.Target.Process.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Setrlimit.Target.Process.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Setrlimit.Target.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.fsgid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.Target.Process.Credentials.FSGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.fsgroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Setrlimit.Target.Process.Credentials.FSGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.fsuid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.Target.Process.Credentials.FSUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.fsuser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Setrlimit.Target.Process.Credentials.FSUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.Target.Process.Credentials.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Setrlimit.Target.Process.Credentials.Group
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.interpreter.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.is_exec":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Setrlimit.Target.Process.IsExec
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.is_kworker":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Setrlimit.Target.Process.PIDContext.IsKworker
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.is_thread":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessIsThread(ev, &ev.Setrlimit.Target.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.args":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveProcessArgs(ev, ev.Setrlimit.Target.Parent)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.args_flags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessArgsFlags(ev, ev.Setrlimit.Target.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.args_options":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessArgsOptions(ev, ev.Setrlimit.Target.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.args_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return false
				}
				return ev.FieldHandlers.ResolveProcessArgsTruncated(ev, ev.Setrlimit.Target.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessArgv(ev, ev.Setrlimit.Target.Parent)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.argv0":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveProcessArgv0(ev, ev.Setrlimit.Target.Parent)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.auid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.Credentials.AUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.cap_effective":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.Credentials.CapEffective)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.cap_permitted":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.Credentials.CapPermitted)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.cgroup.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.CGroup.CGroupFile.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.cgroup.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.CGroup.CGroupFile.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.cgroup.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveCGroupID(ev, &ev.Setrlimit.Target.Parent.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.cgroup.manager":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveCGroupManager(ev, &ev.Setrlimit.Target.Parent.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.cgroup.version":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return ev.FieldHandlers.ResolveCGroupVersion(ev, &ev.Setrlimit.Target.Parent.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.comm":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.Setrlimit.Target.Parent.Comm
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.container.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveProcessContainerID(ev, ev.Setrlimit.Target.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.created_at":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, ev.Setrlimit.Target.Parent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.egid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.Credentials.EGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.egroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.Setrlimit.Target.Parent.Credentials.EGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.envp":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessEnvp(ev, ev.Setrlimit.Target.Parent)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.envs":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessEnvs(ev, ev.Setrlimit.Target.Parent)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.envs_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return false
				}
				return ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, ev.Setrlimit.Target.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.euid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.Credentials.EUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.euser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.Setrlimit.Target.Parent.Credentials.EUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Setrlimit.Target.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Setrlimit.Target.Parent.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return []string{}
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Setrlimit.Target.Parent.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return false
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Setrlimit.Target.Parent.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Setrlimit.Target.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Setrlimit.Target.Parent.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Setrlimit.Target.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Setrlimit.Target.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Setrlimit.Target.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Setrlimit.Target.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Setrlimit.Target.Parent.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Setrlimit.Target.Parent.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Setrlimit.Target.Parent.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.fsgid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.Credentials.FSGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.fsgroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.Setrlimit.Target.Parent.Credentials.FSGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.fsuid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.Credentials.FSUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.fsuser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.Setrlimit.Target.Parent.Credentials.FSUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.Credentials.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.Setrlimit.Target.Parent.Credentials.Group
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return []string{}
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return false
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.interpreter.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				if !ev.Setrlimit.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.is_exec":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return false
				}
				return ev.Setrlimit.Target.Parent.IsExec
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.is_kworker":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return false
				}
				return ev.Setrlimit.Target.Parent.PIDContext.IsKworker
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.is_thread":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return false
				}
				return ev.FieldHandlers.ResolveProcessIsThread(ev, ev.Setrlimit.Target.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.pid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.PIDContext.Pid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.ppid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.PPid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.tid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.PIDContext.Tid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.tty_name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.Setrlimit.Target.Parent.TTYName
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return 0
				}
				return int(ev.Setrlimit.Target.Parent.Credentials.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.Setrlimit.Target.Parent.Credentials.User
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.user_session.k8s_groups":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveK8SGroups(ev, &ev.Setrlimit.Target.Parent.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.user_session.k8s_uid":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveK8SUID(ev, &ev.Setrlimit.Target.Parent.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.parent.user_session.k8s_username":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Setrlimit.Target.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveK8SUsername(ev, &ev.Setrlimit.Target.Parent.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.pid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.Target.Process.PIDContext.Pid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.ppid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.Target.Process.PPid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.tid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.Target.Process.PIDContext.Tid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.tty_name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Setrlimit.Target.Process.TTYName
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Setrlimit.Target.Process.Credentials.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Setrlimit.Target.Process.Credentials.User
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.user_session.k8s_groups":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SGroups(ev, &ev.Setrlimit.Target.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.user_session.k8s_uid":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SUID(ev, &ev.Setrlimit.Target.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setrlimit.target.user_session.k8s_username":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SUsername(ev, &ev.Setrlimit.Target.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setsockopt.filter_hash":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSetSockOptFilterHash(ev, &ev.SetSockOpt)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setsockopt.filter_instructions":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSetSockOptFilterInstructions(ev, &ev.SetSockOpt)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setsockopt.filter_len":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetSockOpt.FilterLen)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setsockopt.is_filter_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.SetSockOpt.IsFilterTruncated
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setsockopt.level":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetSockOpt.Level)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setsockopt.optname":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetSockOpt.OptName)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setsockopt.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetSockOpt.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setsockopt.socket_family":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetSockOpt.SocketFamily)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setsockopt.socket_protocol":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetSockOpt.SocketProtocol)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setsockopt.socket_type":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetSockOpt.SocketType)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setuid.euid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetUID.EUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setuid.euser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSetuidEUser(ev, &ev.SetUID)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setuid.fsuid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetUID.FSUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setuid.fsuser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSetuidFSUser(ev, &ev.SetUID)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setuid.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetUID.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setuid.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSetuidUser(ev, &ev.SetUID)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetXAttr.File.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.destination.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveXAttrName(ev, &ev.SetXAttr)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.destination.namespace":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveXAttrNamespace(ev, &ev.SetXAttr)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.SetXAttr.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetXAttr.File.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.SetXAttr.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.SetXAttr.File)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.SetXAttr.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetXAttr.File.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetXAttr.File.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetXAttr.File.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetXAttr.File.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.SetXAttr.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.SetXAttr.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.SetXAttr.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.SetXAttr.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.SetXAttr.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.SetXAttr.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.SetXAttr.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.SetXAttr.File.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetXAttr.File.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "setxattr.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.SetXAttr.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "setxattr.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SetXAttr.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.pid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.PID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.args":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgs(ev, &element.ProcessContext.Process)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveProcessArgs(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 500 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.args_flags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgsFlags(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessArgsFlags(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.args_options":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgsOptions(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessArgsOptions(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.args_truncated":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgsTruncated(ev, &element.ProcessContext.Process)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					return ev.FieldHandlers.ResolveProcessArgsTruncated(ev, &current.ProcessContext.Process)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgv(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessArgv(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 500 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.argv0":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessArgv0(ev, &element.ProcessContext.Process)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveProcessArgv0(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 100 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.auid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.AUID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.AUID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.cap_effective":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.CapEffective)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.CapEffective)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.cap_permitted":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.CapPermitted)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.CapPermitted)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.cgroup.file.inode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.CGroup.CGroupFile.Inode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.CGroup.CGroupFile.Inode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.cgroup.file.mount_id":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.CGroup.CGroupFile.MountID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.CGroup.CGroupFile.MountID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.cgroup.id":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveCGroupID(ev, &element.ProcessContext.Process.CGroup)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveCGroupID(ev, &current.ProcessContext.Process.CGroup)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.cgroup.manager":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveCGroupManager(ev, &element.ProcessContext.Process.CGroup)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveCGroupManager(ev, &current.ProcessContext.Process.CGroup)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.cgroup.version":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(ev.FieldHandlers.ResolveCGroupVersion(ev, &element.ProcessContext.Process.CGroup))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return int(ev.FieldHandlers.ResolveCGroupVersion(ev, &current.ProcessContext.Process.CGroup))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.comm":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Comm
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Comm
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.container.id":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessContainerID(ev, &element.ProcessContext.Process)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveProcessContainerID(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.created_at":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, &element.ProcessContext.Process))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, &current.ProcessContext.Process))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.egid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.EGID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.EGID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.egroup":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.EGroup
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.EGroup
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.envp":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessEnvp(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessEnvp(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 100 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.envs":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessEnvs(ev, &element.ProcessContext.Process)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveProcessEnvs(ev, &current.ProcessContext.Process)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 100 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.envs_truncated":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, &element.ProcessContext.Process)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					return ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, &current.ProcessContext.Process)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.euid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.EUID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.EUID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.euser":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.EUser
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.EUser
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.change_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.CTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.CTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.filesystem":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFilesystem(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFilesystem(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.gid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.GID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.GID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.group":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsGroup(ev, &element.ProcessContext.Process.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &current.ProcessContext.Process.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveHashesFromEvent(ev, &element.ProcessContext.Process.FileEvent)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return nil
					}
					return ev.FieldHandlers.ResolveHashesFromEvent(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 999 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.in_upper_layer":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []bool{false}
					}
					result := ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &element.ProcessContext.Process.FileEvent.FileFields)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					if !current.ProcessContext.Process.IsNotKworker() {
						return false
					}
					return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &current.ProcessContext.Process.FileEvent.FileFields)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.inode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.PathKey.Inode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.PathKey.Inode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.mode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.Mode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.Mode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.modification_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.MTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.MTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.mount_id":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.PathKey.MountID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.PathKey.MountID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.name":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.name.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.package.name":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageName(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageName(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.package.source_version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageSourceVersion(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.package.version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageVersion(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageVersion(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.path":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.path.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.rights":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(ev.FieldHandlers.ResolveRights(ev, &element.ProcessContext.Process.FileEvent.FileFields))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(ev.FieldHandlers.ResolveRights(ev, &current.ProcessContext.Process.FileEvent.FileFields))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.uid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.FileEvent.FileFields.UID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.IsNotKworker() {
						return 0
					}
					return int(current.ProcessContext.Process.FileEvent.FileFields.UID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.file.user":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.IsNotKworker() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsUser(ev, &element.ProcessContext.Process.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.IsNotKworker() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsUser(ev, &current.ProcessContext.Process.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.fsgid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.FSGID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.FSGID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.fsgroup":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.FSGroup
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.FSGroup
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.fsuid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.FSUID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.FSUID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.fsuser":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.FSUser
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.FSUser
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.gid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.GID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.GID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.group":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.Group
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.Group
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.change_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.CTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.CTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.filesystem":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFilesystem(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFilesystem(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.gid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.GID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.GID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.group":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsGroup(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveHashesFromEvent(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return nil
					}
					return ev.FieldHandlers.ResolveHashesFromEvent(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: 999 * eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.in_upper_layer":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []bool{false}
					}
					result := ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					if !current.ProcessContext.Process.HasInterpreter() {
						return false
					}
					return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.inode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.mode":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.modification_time":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.MTime)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.MTime)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.mount_id":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.name":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.name.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFileBasename(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFileBasename(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.package.name":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageName(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageName(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.package.source_version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageSourceVersion(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.package.version":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolvePackageVersion(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolvePackageVersion(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.path":
		return &eval.StringArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.path.length":
		return &eval.IntArrayEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := len(ev.FieldHandlers.ResolveFilePath(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					return len(ev.FieldHandlers.ResolveFilePath(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.rights":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(ev.FieldHandlers.ResolveRights(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields))
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(ev.FieldHandlers.ResolveRights(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields))
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.uid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []int{0}
					}
					result := int(element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.UID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					if !current.ProcessContext.Process.HasInterpreter() {
						return 0
					}
					return int(current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.UID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.interpreter.file.user":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					if !element.ProcessContext.Process.HasInterpreter() {
						return []string{""}
					}
					result := ev.FieldHandlers.ResolveFileFieldsUser(ev, &element.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					if !current.ProcessContext.Process.HasInterpreter() {
						return ""
					}
					return ev.FieldHandlers.ResolveFileFieldsUser(ev, &current.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.is_exec":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.IsExec
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) bool {
					return current.ProcessContext.Process.IsExec
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.is_kworker":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.PIDContext.IsKworker
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) bool {
					return current.ProcessContext.Process.PIDContext.IsKworker
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.is_thread":
		return &eval.BoolArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveProcessIsThread(ev, &element.ProcessContext.Process)
					return []bool{result}
				}
				if result, ok := ctx.BoolCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) bool {
					return ev.FieldHandlers.ResolveProcessIsThread(ev, &current.ProcessContext.Process)
				})
				ctx.BoolCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.length":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				iterator := &ProcessAncestorsIterator{}
				return iterator.Len(ctx)
			},
			Field:  field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.pid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.PIDContext.Pid)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.PIDContext.Pid)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.ppid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.PPid)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.PPid)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.tid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.PIDContext.Tid)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.PIDContext.Tid)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.tty_name":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.TTYName
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.TTYName
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.uid":
		return &eval.IntArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := int(element.ProcessContext.Process.Credentials.UID)
					return []int{result}
				}
				if result, ok := ctx.IntCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) int {
					return int(current.ProcessContext.Process.Credentials.UID)
				})
				ctx.IntCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.user":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := element.ProcessContext.Process.Credentials.User
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, nil, func(ev *Event, current *ProcessCacheEntry) string {
					return current.ProcessContext.Process.Credentials.User
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.user_session.k8s_groups":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveK8SGroups(ev, &element.ProcessContext.Process.UserSession)
					return result
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIteratorArray(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) []string {
					return ev.FieldHandlers.ResolveK8SGroups(ev, &current.ProcessContext.Process.UserSession)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.user_session.k8s_uid":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveK8SUID(ev, &element.ProcessContext.Process.UserSession)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveK8SUID(ev, &current.ProcessContext.Process.UserSession)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.ancestors.user_session.k8s_username":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				iterator := &ProcessAncestorsIterator{Root: ev.Signal.Target.Ancestor}
				if regID != "" {
					element := iterator.At(ctx, regID, ctx.Registers[regID])
					if element == nil {
						return nil
					}
					result := ev.FieldHandlers.ResolveK8SUsername(ev, &element.ProcessContext.Process.UserSession)
					return []string{result}
				}
				if result, ok := ctx.StringCache[field]; ok {
					return result
				}
				results := newIterator(iterator, "Signal.Target.Ancestor", ctx, ev, func(ev *Event, current *ProcessCacheEntry) string {
					return ev.FieldHandlers.ResolveK8SUsername(ev, &current.ProcessContext.Process.UserSession)
				})
				ctx.StringCache[field] = results
				return results
			}, Field: field,
			Weight: eval.IteratorWeight,
			Offset: offset,
		}, nil
	case "signal.target.args":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgs(ev, &ev.Signal.Target.Process)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.args_flags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsFlags(ev, &ev.Signal.Target.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.args_options":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsOptions(ev, &ev.Signal.Target.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.args_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgsTruncated(ev, &ev.Signal.Target.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgv(ev, &ev.Signal.Target.Process)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.argv0":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessArgv0(ev, &ev.Signal.Target.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.auid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Target.Process.Credentials.AUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.cap_effective":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Target.Process.Credentials.CapEffective)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.cap_permitted":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Target.Process.Credentials.CapPermitted)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.cgroup.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Target.Process.CGroup.CGroupFile.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.cgroup.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Target.Process.CGroup.CGroupFile.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.cgroup.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupID(ev, &ev.Signal.Target.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.cgroup.manager":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupManager(ev, &ev.Signal.Target.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.cgroup.version":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveCGroupVersion(ev, &ev.Signal.Target.Process.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.comm":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Signal.Target.Process.Comm
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.container.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessContainerID(ev, &ev.Signal.Target.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.created_at":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, &ev.Signal.Target.Process))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.egid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Target.Process.Credentials.EGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.egroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Signal.Target.Process.Credentials.EGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.envp":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvp(ev, &ev.Signal.Target.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.envs":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvs(ev, &ev.Signal.Target.Process)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.envs_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, &ev.Signal.Target.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.euid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Target.Process.Credentials.EUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.euser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Signal.Target.Process.Credentials.EUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Signal.Target.Process.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Signal.Target.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Signal.Target.Process.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Signal.Target.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Signal.Target.Process.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Signal.Target.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Signal.Target.Process.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Signal.Target.Process.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Signal.Target.Process.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Signal.Target.Process.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Signal.Target.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Signal.Target.Process.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Signal.Target.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Signal.Target.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Signal.Target.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Signal.Target.Process.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Signal.Target.Process.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Signal.Target.Process.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return 0
				}
				return int(ev.Signal.Target.Process.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Signal.Target.Process.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.fsgid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Target.Process.Credentials.FSGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.fsgroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Signal.Target.Process.Credentials.FSGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.fsuid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Target.Process.Credentials.FSUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.fsuser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Signal.Target.Process.Credentials.FSUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Target.Process.Credentials.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Signal.Target.Process.Credentials.Group
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Signal.Target.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Signal.Target.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Signal.Target.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Signal.Target.Process.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Signal.Target.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Signal.Target.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Signal.Target.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Signal.Target.Process.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Signal.Target.Process.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return 0
				}
				return int(ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.interpreter.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.Process.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.is_exec":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Signal.Target.Process.IsExec
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.is_kworker":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Signal.Target.Process.PIDContext.IsKworker
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.is_thread":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveProcessIsThread(ev, &ev.Signal.Target.Process)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.args":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveProcessArgs(ev, ev.Signal.Target.Parent)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.args_flags":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessArgsFlags(ev, ev.Signal.Target.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.args_options":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessArgsOptions(ev, ev.Signal.Target.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.args_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return false
				}
				return ev.FieldHandlers.ResolveProcessArgsTruncated(ev, ev.Signal.Target.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.argv":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessArgv(ev, ev.Signal.Target.Parent)
			},
			Field:  field,
			Weight: 500 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.argv0":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveProcessArgv0(ev, ev.Signal.Target.Parent)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.auid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.Signal.Target.Parent.Credentials.AUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.cap_effective":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.Signal.Target.Parent.Credentials.CapEffective)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.cap_permitted":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.Signal.Target.Parent.Credentials.CapPermitted)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.cgroup.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.Signal.Target.Parent.CGroup.CGroupFile.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.cgroup.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.Signal.Target.Parent.CGroup.CGroupFile.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.cgroup.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveCGroupID(ev, &ev.Signal.Target.Parent.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.cgroup.manager":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveCGroupManager(ev, &ev.Signal.Target.Parent.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.cgroup.version":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return ev.FieldHandlers.ResolveCGroupVersion(ev, &ev.Signal.Target.Parent.CGroup)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.comm":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.Signal.Target.Parent.Comm
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.container.id":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveProcessContainerID(ev, ev.Signal.Target.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.created_at":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveProcessCreatedAt(ev, ev.Signal.Target.Parent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.egid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.Signal.Target.Parent.Credentials.EGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.egroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.Signal.Target.Parent.Credentials.EGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.envp":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessEnvp(ev, ev.Signal.Target.Parent)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.envs":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveProcessEnvs(ev, ev.Signal.Target.Parent)
			},
			Field:  field,
			Weight: 100 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.envs_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return false
				}
				return ev.FieldHandlers.ResolveProcessEnvsTruncated(ev, ev.Signal.Target.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.euid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.Signal.Target.Parent.Credentials.EUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.euser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.Signal.Target.Parent.Credentials.EUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.Signal.Target.Parent.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Signal.Target.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.Signal.Target.Parent.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Signal.Target.Parent.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return []string{}
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Signal.Target.Parent.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return false
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Signal.Target.Parent.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.Signal.Target.Parent.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.Signal.Target.Parent.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.Signal.Target.Parent.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.Signal.Target.Parent.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Signal.Target.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Signal.Target.Parent.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Signal.Target.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Signal.Target.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Signal.Target.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Signal.Target.Parent.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Signal.Target.Parent.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Signal.Target.Parent.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return 0
				}
				return int(ev.Signal.Target.Parent.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.IsNotKworker() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Signal.Target.Parent.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.fsgid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.Signal.Target.Parent.Credentials.FSGID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.fsgroup":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.Signal.Target.Parent.Credentials.FSGroup
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.fsuid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.Signal.Target.Parent.Credentials.FSUID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.fsuser":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.Signal.Target.Parent.Credentials.FSUser
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.Signal.Target.Parent.Credentials.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.Signal.Target.Parent.Credentials.Group
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Signal.Target.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return []string{}
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Signal.Target.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return false
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return false
				}
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Signal.Target.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Signal.Target.Parent.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Signal.Target.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Signal.Target.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Signal.Target.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Signal.Target.Parent.LinuxBinprm.FileEvent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Signal.Target.Parent.LinuxBinprm.FileEvent))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return 0
				}
				return int(ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.interpreter.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				if !ev.Signal.Target.Parent.HasInterpreter() {
					return ""
				}
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.is_exec":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return false
				}
				return ev.Signal.Target.Parent.IsExec
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.is_kworker":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return false
				}
				return ev.Signal.Target.Parent.PIDContext.IsKworker
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.is_thread":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return false
				}
				return ev.FieldHandlers.ResolveProcessIsThread(ev, ev.Signal.Target.Parent)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.pid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.Signal.Target.Parent.PIDContext.Pid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.ppid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.Signal.Target.Parent.PPid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.tid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.Signal.Target.Parent.PIDContext.Tid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.tty_name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.Signal.Target.Parent.TTYName
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return 0
				}
				return int(ev.Signal.Target.Parent.Credentials.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.Signal.Target.Parent.Credentials.User
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.user_session.k8s_groups":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return []string{}
				}
				return ev.FieldHandlers.ResolveK8SGroups(ev, &ev.Signal.Target.Parent.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.user_session.k8s_uid":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveK8SUID(ev, &ev.Signal.Target.Parent.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.parent.user_session.k8s_username":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				if !ev.Signal.Target.HasParent() {
					return ""
				}
				return ev.FieldHandlers.ResolveK8SUsername(ev, &ev.Signal.Target.Parent.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.pid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Target.Process.PIDContext.Pid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.ppid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Target.Process.PPid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.tid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Target.Process.PIDContext.Tid)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.tty_name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Signal.Target.Process.TTYName
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Target.Process.Credentials.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.Signal.Target.Process.Credentials.User
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "signal.target.user_session.k8s_groups":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SGroups(ev, &ev.Signal.Target.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.user_session.k8s_uid":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SUID(ev, &ev.Signal.Target.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.target.user_session.k8s_username":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveK8SUsername(ev, &ev.Signal.Target.Process.UserSession)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "signal.type":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Signal.Type)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "splice.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Splice.File.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "splice.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Splice.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "splice.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Splice.File.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "splice.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Splice.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "splice.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Splice.File)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "splice.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Splice.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "splice.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Splice.File.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "splice.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Splice.File.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "splice.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Splice.File.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "splice.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Splice.File.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "splice.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Splice.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "splice.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Splice.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "splice.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Splice.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "splice.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Splice.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "splice.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Splice.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "splice.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Splice.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "splice.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Splice.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "splice.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Splice.File.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "splice.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Splice.File.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "splice.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Splice.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "splice.pipe_entry_flag":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Splice.PipeEntryFlag)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "splice.pipe_exit_flag":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Splice.PipeExitFlag)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "splice.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Splice.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "sysctl.action":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SysCtl.Action)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "sysctl.file_position":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.SysCtl.FilePosition)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "sysctl.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.SysCtl.Name
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "sysctl.name_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.SysCtl.NameTruncated
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "sysctl.old_value":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.SysCtl.OldValue
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "sysctl.old_value_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.SysCtl.OldValueTruncated
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "sysctl.value":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.SysCtl.Value
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "sysctl.value_truncated":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.SysCtl.ValueTruncated
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "unlink.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Unlink.File.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "unlink.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Unlink.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Unlink.File.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "unlink.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Unlink.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Unlink.File)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Unlink.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Unlink.File.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "unlink.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Unlink.File.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "unlink.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Unlink.File.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "unlink.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Unlink.File.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "unlink.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Unlink.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Unlink.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Unlink.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Unlink.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Unlink.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Unlink.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Unlink.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Unlink.File.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Unlink.File.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "unlink.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Unlink.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.flags":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Unlink.Flags)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "unlink.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Unlink.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "unlink.syscall.dirfd":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveSyscallCtxArgsInt1(ev, &ev.Unlink.SyscallContext))
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.syscall.flags":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveSyscallCtxArgsInt3(ev, &ev.Unlink.SyscallContext))
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unlink.syscall.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr2(ev, &ev.Unlink.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "unload_module.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.UnloadModule.Name
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "unload_module.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.UnloadModule.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "utimes.file.change_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Utimes.File.FileFields.CTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "utimes.file.filesystem":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFilesystem(ev, &ev.Utimes.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "utimes.file.gid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Utimes.File.FileFields.GID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "utimes.file.group":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsGroup(ev, &ev.Utimes.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "utimes.file.hashes":
		return &eval.StringArrayEvaluator{
			EvalFnc: func(ctx *eval.Context) []string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveHashesFromEvent(ev, &ev.Utimes.File)
			},
			Field:  field,
			Weight: 999 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "utimes.file.in_upper_layer":
		return &eval.BoolEvaluator{
			EvalFnc: func(ctx *eval.Context) bool {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsInUpperLayer(ev, &ev.Utimes.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "utimes.file.inode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Utimes.File.FileFields.PathKey.Inode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "utimes.file.mode":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Utimes.File.FileFields.Mode)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "utimes.file.modification_time":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Utimes.File.FileFields.MTime)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "utimes.file.mount_id":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Utimes.File.FileFields.PathKey.MountID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "utimes.file.name":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileBasename(ev, &ev.Utimes.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "utimes.file.name.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkBasename,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFileBasename(ev, &ev.Utimes.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "utimes.file.package.name":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageName(ev, &ev.Utimes.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "utimes.file.package.source_version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageSourceVersion(ev, &ev.Utimes.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "utimes.file.package.version":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolvePackageVersion(ev, &ev.Utimes.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "utimes.file.path":
		return &eval.StringEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFilePath(ev, &ev.Utimes.File)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "utimes.file.path.length":
		return &eval.IntEvaluator{
			OpOverrides: ProcessSymlinkPathname,
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return len(ev.FieldHandlers.ResolveFilePath(ev, &ev.Utimes.File))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "utimes.file.rights":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.FieldHandlers.ResolveRights(ev, &ev.Utimes.File.FileFields))
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "utimes.file.uid":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Utimes.File.FileFields.UID)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "utimes.file.user":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveFileFieldsUser(ev, &ev.Utimes.File.FileFields)
			},
			Field:  field,
			Weight: eval.HandlerWeight,
			Offset: offset,
		}, nil
	case "utimes.retval":
		return &eval.IntEvaluator{
			EvalFnc: func(ctx *eval.Context) int {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return int(ev.Utimes.SyscallEvent.Retval)
			},
			Field:  field,
			Weight: eval.FunctionWeight,
			Offset: offset,
		}, nil
	case "utimes.syscall.path":
		return &eval.StringEvaluator{
			EvalFnc: func(ctx *eval.Context) string {
				ctx.AppendResolvedField(field)
				ev := ctx.Event.(*Event)
				return ev.FieldHandlers.ResolveSyscallCtxArgsStr1(ev, &ev.Utimes.SyscallContext)
			},
			Field:  field,
			Weight: 900 * eval.HandlerWeight,
			Offset: offset,
		}, nil
	}
	return nil, &eval.ErrFieldNotFound{Field: field}
}
func (ev *Event) GetFields() []eval.Field {
	return []eval.Field{
		"accept.addr.family",
		"accept.addr.hostname",
		"accept.addr.ip",
		"accept.addr.is_public",
		"accept.addr.port",
		"accept.retval",
		"bind.addr.family",
		"bind.addr.ip",
		"bind.addr.is_public",
		"bind.addr.port",
		"bind.protocol",
		"bind.retval",
		"bpf.cmd",
		"bpf.map.name",
		"bpf.map.type",
		"bpf.prog.attach_type",
		"bpf.prog.helpers",
		"bpf.prog.name",
		"bpf.prog.tag",
		"bpf.prog.type",
		"bpf.retval",
		"capset.cap_effective",
		"capset.cap_permitted",
		"cgroup.file.inode",
		"cgroup.file.mount_id",
		"cgroup.id",
		"cgroup.manager",
		"cgroup.version",
		"cgroup_write.file.change_time",
		"cgroup_write.file.filesystem",
		"cgroup_write.file.gid",
		"cgroup_write.file.group",
		"cgroup_write.file.hashes",
		"cgroup_write.file.in_upper_layer",
		"cgroup_write.file.inode",
		"cgroup_write.file.mode",
		"cgroup_write.file.modification_time",
		"cgroup_write.file.mount_id",
		"cgroup_write.file.name",
		"cgroup_write.file.name.length",
		"cgroup_write.file.package.name",
		"cgroup_write.file.package.source_version",
		"cgroup_write.file.package.version",
		"cgroup_write.file.path",
		"cgroup_write.file.path.length",
		"cgroup_write.file.rights",
		"cgroup_write.file.uid",
		"cgroup_write.file.user",
		"cgroup_write.pid",
		"chdir.file.change_time",
		"chdir.file.filesystem",
		"chdir.file.gid",
		"chdir.file.group",
		"chdir.file.hashes",
		"chdir.file.in_upper_layer",
		"chdir.file.inode",
		"chdir.file.mode",
		"chdir.file.modification_time",
		"chdir.file.mount_id",
		"chdir.file.name",
		"chdir.file.name.length",
		"chdir.file.package.name",
		"chdir.file.package.source_version",
		"chdir.file.package.version",
		"chdir.file.path",
		"chdir.file.path.length",
		"chdir.file.rights",
		"chdir.file.uid",
		"chdir.file.user",
		"chdir.retval",
		"chdir.syscall.path",
		"chmod.file.change_time",
		"chmod.file.destination.mode",
		"chmod.file.destination.rights",
		"chmod.file.filesystem",
		"chmod.file.gid",
		"chmod.file.group",
		"chmod.file.hashes",
		"chmod.file.in_upper_layer",
		"chmod.file.inode",
		"chmod.file.mode",
		"chmod.file.modification_time",
		"chmod.file.mount_id",
		"chmod.file.name",
		"chmod.file.name.length",
		"chmod.file.package.name",
		"chmod.file.package.source_version",
		"chmod.file.package.version",
		"chmod.file.path",
		"chmod.file.path.length",
		"chmod.file.rights",
		"chmod.file.uid",
		"chmod.file.user",
		"chmod.retval",
		"chmod.syscall.mode",
		"chmod.syscall.path",
		"chown.file.change_time",
		"chown.file.destination.gid",
		"chown.file.destination.group",
		"chown.file.destination.uid",
		"chown.file.destination.user",
		"chown.file.filesystem",
		"chown.file.gid",
		"chown.file.group",
		"chown.file.hashes",
		"chown.file.in_upper_layer",
		"chown.file.inode",
		"chown.file.mode",
		"chown.file.modification_time",
		"chown.file.mount_id",
		"chown.file.name",
		"chown.file.name.length",
		"chown.file.package.name",
		"chown.file.package.source_version",
		"chown.file.package.version",
		"chown.file.path",
		"chown.file.path.length",
		"chown.file.rights",
		"chown.file.uid",
		"chown.file.user",
		"chown.retval",
		"chown.syscall.gid",
		"chown.syscall.path",
		"chown.syscall.uid",
		"connect.addr.family",
		"connect.addr.hostname",
		"connect.addr.ip",
		"connect.addr.is_public",
		"connect.addr.port",
		"connect.protocol",
		"connect.retval",
		"container.created_at",
		"container.id",
		"container.runtime",
		"container.tags",
		"dns.id",
		"dns.question.class",
		"dns.question.count",
		"dns.question.length",
		"dns.question.name",
		"dns.question.name.length",
		"dns.question.type",
		"dns.response.code",
		"event.async",
		"event.hostname",
		"event.origin",
		"event.os",
		"event.rule.tags",
		"event.service",
		"event.timestamp",
		"exec.args",
		"exec.args_flags",
		"exec.args_options",
		"exec.args_truncated",
		"exec.argv",
		"exec.argv0",
		"exec.auid",
		"exec.cap_effective",
		"exec.cap_permitted",
		"exec.cgroup.file.inode",
		"exec.cgroup.file.mount_id",
		"exec.cgroup.id",
		"exec.cgroup.manager",
		"exec.cgroup.version",
		"exec.comm",
		"exec.container.id",
		"exec.created_at",
		"exec.egid",
		"exec.egroup",
		"exec.envp",
		"exec.envs",
		"exec.envs_truncated",
		"exec.euid",
		"exec.euser",
		"exec.file.change_time",
		"exec.file.filesystem",
		"exec.file.gid",
		"exec.file.group",
		"exec.file.hashes",
		"exec.file.in_upper_layer",
		"exec.file.inode",
		"exec.file.metadata.abi",
		"exec.file.metadata.architecture",
		"exec.file.metadata.compression",
		"exec.file.metadata.is_executable",
		"exec.file.metadata.is_garble_obfuscated",
		"exec.file.metadata.is_upx_packed",
		"exec.file.metadata.size",
		"exec.file.metadata.type",
		"exec.file.mode",
		"exec.file.modification_time",
		"exec.file.mount_id",
		"exec.file.name",
		"exec.file.name.length",
		"exec.file.package.name",
		"exec.file.package.source_version",
		"exec.file.package.version",
		"exec.file.path",
		"exec.file.path.length",
		"exec.file.rights",
		"exec.file.uid",
		"exec.file.user",
		"exec.fsgid",
		"exec.fsgroup",
		"exec.fsuid",
		"exec.fsuser",
		"exec.gid",
		"exec.group",
		"exec.interpreter.file.change_time",
		"exec.interpreter.file.filesystem",
		"exec.interpreter.file.gid",
		"exec.interpreter.file.group",
		"exec.interpreter.file.hashes",
		"exec.interpreter.file.in_upper_layer",
		"exec.interpreter.file.inode",
		"exec.interpreter.file.mode",
		"exec.interpreter.file.modification_time",
		"exec.interpreter.file.mount_id",
		"exec.interpreter.file.name",
		"exec.interpreter.file.name.length",
		"exec.interpreter.file.package.name",
		"exec.interpreter.file.package.source_version",
		"exec.interpreter.file.package.version",
		"exec.interpreter.file.path",
		"exec.interpreter.file.path.length",
		"exec.interpreter.file.rights",
		"exec.interpreter.file.uid",
		"exec.interpreter.file.user",
		"exec.is_exec",
		"exec.is_kworker",
		"exec.is_thread",
		"exec.pid",
		"exec.ppid",
		"exec.syscall.path",
		"exec.tid",
		"exec.tty_name",
		"exec.uid",
		"exec.user",
		"exec.user_session.k8s_groups",
		"exec.user_session.k8s_uid",
		"exec.user_session.k8s_username",
		"exit.args",
		"exit.args_flags",
		"exit.args_options",
		"exit.args_truncated",
		"exit.argv",
		"exit.argv0",
		"exit.auid",
		"exit.cap_effective",
		"exit.cap_permitted",
		"exit.cause",
		"exit.cgroup.file.inode",
		"exit.cgroup.file.mount_id",
		"exit.cgroup.id",
		"exit.cgroup.manager",
		"exit.cgroup.version",
		"exit.code",
		"exit.comm",
		"exit.container.id",
		"exit.created_at",
		"exit.egid",
		"exit.egroup",
		"exit.envp",
		"exit.envs",
		"exit.envs_truncated",
		"exit.euid",
		"exit.euser",
		"exit.file.change_time",
		"exit.file.filesystem",
		"exit.file.gid",
		"exit.file.group",
		"exit.file.hashes",
		"exit.file.in_upper_layer",
		"exit.file.inode",
		"exit.file.mode",
		"exit.file.modification_time",
		"exit.file.mount_id",
		"exit.file.name",
		"exit.file.name.length",
		"exit.file.package.name",
		"exit.file.package.source_version",
		"exit.file.package.version",
		"exit.file.path",
		"exit.file.path.length",
		"exit.file.rights",
		"exit.file.uid",
		"exit.file.user",
		"exit.fsgid",
		"exit.fsgroup",
		"exit.fsuid",
		"exit.fsuser",
		"exit.gid",
		"exit.group",
		"exit.interpreter.file.change_time",
		"exit.interpreter.file.filesystem",
		"exit.interpreter.file.gid",
		"exit.interpreter.file.group",
		"exit.interpreter.file.hashes",
		"exit.interpreter.file.in_upper_layer",
		"exit.interpreter.file.inode",
		"exit.interpreter.file.mode",
		"exit.interpreter.file.modification_time",
		"exit.interpreter.file.mount_id",
		"exit.interpreter.file.name",
		"exit.interpreter.file.name.length",
		"exit.interpreter.file.package.name",
		"exit.interpreter.file.package.source_version",
		"exit.interpreter.file.package.version",
		"exit.interpreter.file.path",
		"exit.interpreter.file.path.length",
		"exit.interpreter.file.rights",
		"exit.interpreter.file.uid",
		"exit.interpreter.file.user",
		"exit.is_exec",
		"exit.is_kworker",
		"exit.is_thread",
		"exit.pid",
		"exit.ppid",
		"exit.tid",
		"exit.tty_name",
		"exit.uid",
		"exit.user",
		"exit.user_session.k8s_groups",
		"exit.user_session.k8s_uid",
		"exit.user_session.k8s_username",
		"imds.aws.is_imds_v2",
		"imds.aws.security_credentials.type",
		"imds.cloud_provider",
		"imds.host",
		"imds.server",
		"imds.type",
		"imds.url",
		"imds.user_agent",
		"link.file.change_time",
		"link.file.destination.change_time",
		"link.file.destination.filesystem",
		"link.file.destination.gid",
		"link.file.destination.group",
		"link.file.destination.hashes",
		"link.file.destination.in_upper_layer",
		"link.file.destination.inode",
		"link.file.destination.mode",
		"link.file.destination.modification_time",
		"link.file.destination.mount_id",
		"link.file.destination.name",
		"link.file.destination.name.length",
		"link.file.destination.package.name",
		"link.file.destination.package.source_version",
		"link.file.destination.package.version",
		"link.file.destination.path",
		"link.file.destination.path.length",
		"link.file.destination.rights",
		"link.file.destination.uid",
		"link.file.destination.user",
		"link.file.filesystem",
		"link.file.gid",
		"link.file.group",
		"link.file.hashes",
		"link.file.in_upper_layer",
		"link.file.inode",
		"link.file.mode",
		"link.file.modification_time",
		"link.file.mount_id",
		"link.file.name",
		"link.file.name.length",
		"link.file.package.name",
		"link.file.package.source_version",
		"link.file.package.version",
		"link.file.path",
		"link.file.path.length",
		"link.file.rights",
		"link.file.uid",
		"link.file.user",
		"link.retval",
		"link.syscall.destination.path",
		"link.syscall.path",
		"load_module.args",
		"load_module.args_truncated",
		"load_module.argv",
		"load_module.file.change_time",
		"load_module.file.filesystem",
		"load_module.file.gid",
		"load_module.file.group",
		"load_module.file.hashes",
		"load_module.file.in_upper_layer",
		"load_module.file.inode",
		"load_module.file.mode",
		"load_module.file.modification_time",
		"load_module.file.mount_id",
		"load_module.file.name",
		"load_module.file.name.length",
		"load_module.file.package.name",
		"load_module.file.package.source_version",
		"load_module.file.package.version",
		"load_module.file.path",
		"load_module.file.path.length",
		"load_module.file.rights",
		"load_module.file.uid",
		"load_module.file.user",
		"load_module.loaded_from_memory",
		"load_module.name",
		"load_module.retval",
		"mkdir.file.change_time",
		"mkdir.file.destination.mode",
		"mkdir.file.destination.rights",
		"mkdir.file.filesystem",
		"mkdir.file.gid",
		"mkdir.file.group",
		"mkdir.file.hashes",
		"mkdir.file.in_upper_layer",
		"mkdir.file.inode",
		"mkdir.file.mode",
		"mkdir.file.modification_time",
		"mkdir.file.mount_id",
		"mkdir.file.name",
		"mkdir.file.name.length",
		"mkdir.file.package.name",
		"mkdir.file.package.source_version",
		"mkdir.file.package.version",
		"mkdir.file.path",
		"mkdir.file.path.length",
		"mkdir.file.rights",
		"mkdir.file.uid",
		"mkdir.file.user",
		"mkdir.retval",
		"mkdir.syscall.mode",
		"mkdir.syscall.path",
		"mmap.file.change_time",
		"mmap.file.filesystem",
		"mmap.file.gid",
		"mmap.file.group",
		"mmap.file.hashes",
		"mmap.file.in_upper_layer",
		"mmap.file.inode",
		"mmap.file.mode",
		"mmap.file.modification_time",
		"mmap.file.mount_id",
		"mmap.file.name",
		"mmap.file.name.length",
		"mmap.file.package.name",
		"mmap.file.package.source_version",
		"mmap.file.package.version",
		"mmap.file.path",
		"mmap.file.path.length",
		"mmap.file.rights",
		"mmap.file.uid",
		"mmap.file.user",
		"mmap.flags",
		"mmap.protection",
		"mmap.retval",
		"mount.fs_type",
		"mount.mountpoint.path",
		"mount.retval",
		"mount.root.path",
		"mount.source.path",
		"mount.syscall.fs_type",
		"mount.syscall.mountpoint.path",
		"mount.syscall.source.path",
		"mprotect.req_protection",
		"mprotect.retval",
		"mprotect.vm_protection",
		"network.destination.ip",
		"network.destination.is_public",
		"network.destination.port",
		"network.device.ifname",
		"network.l3_protocol",
		"network.l4_protocol",
		"network.network_direction",
		"network.size",
		"network.source.ip",
		"network.source.is_public",
		"network.source.port",
		"network_flow_monitor.device.ifname",
		"network_flow_monitor.flows.destination.ip",
		"network_flow_monitor.flows.destination.is_public",
		"network_flow_monitor.flows.destination.port",
		"network_flow_monitor.flows.egress.data_size",
		"network_flow_monitor.flows.egress.packet_count",
		"network_flow_monitor.flows.ingress.data_size",
		"network_flow_monitor.flows.ingress.packet_count",
		"network_flow_monitor.flows.l3_protocol",
		"network_flow_monitor.flows.l4_protocol",
		"network_flow_monitor.flows.length",
		"network_flow_monitor.flows.source.ip",
		"network_flow_monitor.flows.source.is_public",
		"network_flow_monitor.flows.source.port",
		"ondemand.arg1.str",
		"ondemand.arg1.uint",
		"ondemand.arg2.str",
		"ondemand.arg2.uint",
		"ondemand.arg3.str",
		"ondemand.arg3.uint",
		"ondemand.arg4.str",
		"ondemand.arg4.uint",
		"ondemand.arg5.str",
		"ondemand.arg5.uint",
		"ondemand.arg6.str",
		"ondemand.arg6.uint",
		"ondemand.name",
		"open.file.change_time",
		"open.file.destination.mode",
		"open.file.filesystem",
		"open.file.gid",
		"open.file.group",
		"open.file.hashes",
		"open.file.in_upper_layer",
		"open.file.inode",
		"open.file.mode",
		"open.file.modification_time",
		"open.file.mount_id",
		"open.file.name",
		"open.file.name.length",
		"open.file.package.name",
		"open.file.package.source_version",
		"open.file.package.version",
		"open.file.path",
		"open.file.path.length",
		"open.file.rights",
		"open.file.uid",
		"open.file.user",
		"open.flags",
		"open.retval",
		"open.syscall.flags",
		"open.syscall.mode",
		"open.syscall.path",
		"packet.destination.ip",
		"packet.destination.is_public",
		"packet.destination.port",
		"packet.device.ifname",
		"packet.filter",
		"packet.l3_protocol",
		"packet.l4_protocol",
		"packet.network_direction",
		"packet.size",
		"packet.source.ip",
		"packet.source.is_public",
		"packet.source.port",
		"packet.tls.version",
		"process.ancestors.args",
		"process.ancestors.args_flags",
		"process.ancestors.args_options",
		"process.ancestors.args_truncated",
		"process.ancestors.argv",
		"process.ancestors.argv0",
		"process.ancestors.auid",
		"process.ancestors.cap_effective",
		"process.ancestors.cap_permitted",
		"process.ancestors.cgroup.file.inode",
		"process.ancestors.cgroup.file.mount_id",
		"process.ancestors.cgroup.id",
		"process.ancestors.cgroup.manager",
		"process.ancestors.cgroup.version",
		"process.ancestors.comm",
		"process.ancestors.container.id",
		"process.ancestors.created_at",
		"process.ancestors.egid",
		"process.ancestors.egroup",
		"process.ancestors.envp",
		"process.ancestors.envs",
		"process.ancestors.envs_truncated",
		"process.ancestors.euid",
		"process.ancestors.euser",
		"process.ancestors.file.change_time",
		"process.ancestors.file.filesystem",
		"process.ancestors.file.gid",
		"process.ancestors.file.group",
		"process.ancestors.file.hashes",
		"process.ancestors.file.in_upper_layer",
		"process.ancestors.file.inode",
		"process.ancestors.file.mode",
		"process.ancestors.file.modification_time",
		"process.ancestors.file.mount_id",
		"process.ancestors.file.name",
		"process.ancestors.file.name.length",
		"process.ancestors.file.package.name",
		"process.ancestors.file.package.source_version",
		"process.ancestors.file.package.version",
		"process.ancestors.file.path",
		"process.ancestors.file.path.length",
		"process.ancestors.file.rights",
		"process.ancestors.file.uid",
		"process.ancestors.file.user",
		"process.ancestors.fsgid",
		"process.ancestors.fsgroup",
		"process.ancestors.fsuid",
		"process.ancestors.fsuser",
		"process.ancestors.gid",
		"process.ancestors.group",
		"process.ancestors.interpreter.file.change_time",
		"process.ancestors.interpreter.file.filesystem",
		"process.ancestors.interpreter.file.gid",
		"process.ancestors.interpreter.file.group",
		"process.ancestors.interpreter.file.hashes",
		"process.ancestors.interpreter.file.in_upper_layer",
		"process.ancestors.interpreter.file.inode",
		"process.ancestors.interpreter.file.mode",
		"process.ancestors.interpreter.file.modification_time",
		"process.ancestors.interpreter.file.mount_id",
		"process.ancestors.interpreter.file.name",
		"process.ancestors.interpreter.file.name.length",
		"process.ancestors.interpreter.file.package.name",
		"process.ancestors.interpreter.file.package.source_version",
		"process.ancestors.interpreter.file.package.version",
		"process.ancestors.interpreter.file.path",
		"process.ancestors.interpreter.file.path.length",
		"process.ancestors.interpreter.file.rights",
		"process.ancestors.interpreter.file.uid",
		"process.ancestors.interpreter.file.user",
		"process.ancestors.is_exec",
		"process.ancestors.is_kworker",
		"process.ancestors.is_thread",
		"process.ancestors.length",
		"process.ancestors.pid",
		"process.ancestors.ppid",
		"process.ancestors.tid",
		"process.ancestors.tty_name",
		"process.ancestors.uid",
		"process.ancestors.user",
		"process.ancestors.user_session.k8s_groups",
		"process.ancestors.user_session.k8s_uid",
		"process.ancestors.user_session.k8s_username",
		"process.args",
		"process.args_flags",
		"process.args_options",
		"process.args_truncated",
		"process.argv",
		"process.argv0",
		"process.auid",
		"process.cap_effective",
		"process.cap_permitted",
		"process.cgroup.file.inode",
		"process.cgroup.file.mount_id",
		"process.cgroup.id",
		"process.cgroup.manager",
		"process.cgroup.version",
		"process.comm",
		"process.container.id",
		"process.created_at",
		"process.egid",
		"process.egroup",
		"process.envp",
		"process.envs",
		"process.envs_truncated",
		"process.euid",
		"process.euser",
		"process.file.change_time",
		"process.file.filesystem",
		"process.file.gid",
		"process.file.group",
		"process.file.hashes",
		"process.file.in_upper_layer",
		"process.file.inode",
		"process.file.mode",
		"process.file.modification_time",
		"process.file.mount_id",
		"process.file.name",
		"process.file.name.length",
		"process.file.package.name",
		"process.file.package.source_version",
		"process.file.package.version",
		"process.file.path",
		"process.file.path.length",
		"process.file.rights",
		"process.file.uid",
		"process.file.user",
		"process.fsgid",
		"process.fsgroup",
		"process.fsuid",
		"process.fsuser",
		"process.gid",
		"process.group",
		"process.interpreter.file.change_time",
		"process.interpreter.file.filesystem",
		"process.interpreter.file.gid",
		"process.interpreter.file.group",
		"process.interpreter.file.hashes",
		"process.interpreter.file.in_upper_layer",
		"process.interpreter.file.inode",
		"process.interpreter.file.mode",
		"process.interpreter.file.modification_time",
		"process.interpreter.file.mount_id",
		"process.interpreter.file.name",
		"process.interpreter.file.name.length",
		"process.interpreter.file.package.name",
		"process.interpreter.file.package.source_version",
		"process.interpreter.file.package.version",
		"process.interpreter.file.path",
		"process.interpreter.file.path.length",
		"process.interpreter.file.rights",
		"process.interpreter.file.uid",
		"process.interpreter.file.user",
		"process.is_exec",
		"process.is_kworker",
		"process.is_thread",
		"process.parent.args",
		"process.parent.args_flags",
		"process.parent.args_options",
		"process.parent.args_truncated",
		"process.parent.argv",
		"process.parent.argv0",
		"process.parent.auid",
		"process.parent.cap_effective",
		"process.parent.cap_permitted",
		"process.parent.cgroup.file.inode",
		"process.parent.cgroup.file.mount_id",
		"process.parent.cgroup.id",
		"process.parent.cgroup.manager",
		"process.parent.cgroup.version",
		"process.parent.comm",
		"process.parent.container.id",
		"process.parent.created_at",
		"process.parent.egid",
		"process.parent.egroup",
		"process.parent.envp",
		"process.parent.envs",
		"process.parent.envs_truncated",
		"process.parent.euid",
		"process.parent.euser",
		"process.parent.file.change_time",
		"process.parent.file.filesystem",
		"process.parent.file.gid",
		"process.parent.file.group",
		"process.parent.file.hashes",
		"process.parent.file.in_upper_layer",
		"process.parent.file.inode",
		"process.parent.file.mode",
		"process.parent.file.modification_time",
		"process.parent.file.mount_id",
		"process.parent.file.name",
		"process.parent.file.name.length",
		"process.parent.file.package.name",
		"process.parent.file.package.source_version",
		"process.parent.file.package.version",
		"process.parent.file.path",
		"process.parent.file.path.length",
		"process.parent.file.rights",
		"process.parent.file.uid",
		"process.parent.file.user",
		"process.parent.fsgid",
		"process.parent.fsgroup",
		"process.parent.fsuid",
		"process.parent.fsuser",
		"process.parent.gid",
		"process.parent.group",
		"process.parent.interpreter.file.change_time",
		"process.parent.interpreter.file.filesystem",
		"process.parent.interpreter.file.gid",
		"process.parent.interpreter.file.group",
		"process.parent.interpreter.file.hashes",
		"process.parent.interpreter.file.in_upper_layer",
		"process.parent.interpreter.file.inode",
		"process.parent.interpreter.file.mode",
		"process.parent.interpreter.file.modification_time",
		"process.parent.interpreter.file.mount_id",
		"process.parent.interpreter.file.name",
		"process.parent.interpreter.file.name.length",
		"process.parent.interpreter.file.package.name",
		"process.parent.interpreter.file.package.source_version",
		"process.parent.interpreter.file.package.version",
		"process.parent.interpreter.file.path",
		"process.parent.interpreter.file.path.length",
		"process.parent.interpreter.file.rights",
		"process.parent.interpreter.file.uid",
		"process.parent.interpreter.file.user",
		"process.parent.is_exec",
		"process.parent.is_kworker",
		"process.parent.is_thread",
		"process.parent.pid",
		"process.parent.ppid",
		"process.parent.tid",
		"process.parent.tty_name",
		"process.parent.uid",
		"process.parent.user",
		"process.parent.user_session.k8s_groups",
		"process.parent.user_session.k8s_uid",
		"process.parent.user_session.k8s_username",
		"process.pid",
		"process.ppid",
		"process.tid",
		"process.tty_name",
		"process.uid",
		"process.user",
		"process.user_session.k8s_groups",
		"process.user_session.k8s_uid",
		"process.user_session.k8s_username",
		"ptrace.request",
		"ptrace.retval",
		"ptrace.tracee.ancestors.args",
		"ptrace.tracee.ancestors.args_flags",
		"ptrace.tracee.ancestors.args_options",
		"ptrace.tracee.ancestors.args_truncated",
		"ptrace.tracee.ancestors.argv",
		"ptrace.tracee.ancestors.argv0",
		"ptrace.tracee.ancestors.auid",
		"ptrace.tracee.ancestors.cap_effective",
		"ptrace.tracee.ancestors.cap_permitted",
		"ptrace.tracee.ancestors.cgroup.file.inode",
		"ptrace.tracee.ancestors.cgroup.file.mount_id",
		"ptrace.tracee.ancestors.cgroup.id",
		"ptrace.tracee.ancestors.cgroup.manager",
		"ptrace.tracee.ancestors.cgroup.version",
		"ptrace.tracee.ancestors.comm",
		"ptrace.tracee.ancestors.container.id",
		"ptrace.tracee.ancestors.created_at",
		"ptrace.tracee.ancestors.egid",
		"ptrace.tracee.ancestors.egroup",
		"ptrace.tracee.ancestors.envp",
		"ptrace.tracee.ancestors.envs",
		"ptrace.tracee.ancestors.envs_truncated",
		"ptrace.tracee.ancestors.euid",
		"ptrace.tracee.ancestors.euser",
		"ptrace.tracee.ancestors.file.change_time",
		"ptrace.tracee.ancestors.file.filesystem",
		"ptrace.tracee.ancestors.file.gid",
		"ptrace.tracee.ancestors.file.group",
		"ptrace.tracee.ancestors.file.hashes",
		"ptrace.tracee.ancestors.file.in_upper_layer",
		"ptrace.tracee.ancestors.file.inode",
		"ptrace.tracee.ancestors.file.mode",
		"ptrace.tracee.ancestors.file.modification_time",
		"ptrace.tracee.ancestors.file.mount_id",
		"ptrace.tracee.ancestors.file.name",
		"ptrace.tracee.ancestors.file.name.length",
		"ptrace.tracee.ancestors.file.package.name",
		"ptrace.tracee.ancestors.file.package.source_version",
		"ptrace.tracee.ancestors.file.package.version",
		"ptrace.tracee.ancestors.file.path",
		"ptrace.tracee.ancestors.file.path.length",
		"ptrace.tracee.ancestors.file.rights",
		"ptrace.tracee.ancestors.file.uid",
		"ptrace.tracee.ancestors.file.user",
		"ptrace.tracee.ancestors.fsgid",
		"ptrace.tracee.ancestors.fsgroup",
		"ptrace.tracee.ancestors.fsuid",
		"ptrace.tracee.ancestors.fsuser",
		"ptrace.tracee.ancestors.gid",
		"ptrace.tracee.ancestors.group",
		"ptrace.tracee.ancestors.interpreter.file.change_time",
		"ptrace.tracee.ancestors.interpreter.file.filesystem",
		"ptrace.tracee.ancestors.interpreter.file.gid",
		"ptrace.tracee.ancestors.interpreter.file.group",
		"ptrace.tracee.ancestors.interpreter.file.hashes",
		"ptrace.tracee.ancestors.interpreter.file.in_upper_layer",
		"ptrace.tracee.ancestors.interpreter.file.inode",
		"ptrace.tracee.ancestors.interpreter.file.mode",
		"ptrace.tracee.ancestors.interpreter.file.modification_time",
		"ptrace.tracee.ancestors.interpreter.file.mount_id",
		"ptrace.tracee.ancestors.interpreter.file.name",
		"ptrace.tracee.ancestors.interpreter.file.name.length",
		"ptrace.tracee.ancestors.interpreter.file.package.name",
		"ptrace.tracee.ancestors.interpreter.file.package.source_version",
		"ptrace.tracee.ancestors.interpreter.file.package.version",
		"ptrace.tracee.ancestors.interpreter.file.path",
		"ptrace.tracee.ancestors.interpreter.file.path.length",
		"ptrace.tracee.ancestors.interpreter.file.rights",
		"ptrace.tracee.ancestors.interpreter.file.uid",
		"ptrace.tracee.ancestors.interpreter.file.user",
		"ptrace.tracee.ancestors.is_exec",
		"ptrace.tracee.ancestors.is_kworker",
		"ptrace.tracee.ancestors.is_thread",
		"ptrace.tracee.ancestors.length",
		"ptrace.tracee.ancestors.pid",
		"ptrace.tracee.ancestors.ppid",
		"ptrace.tracee.ancestors.tid",
		"ptrace.tracee.ancestors.tty_name",
		"ptrace.tracee.ancestors.uid",
		"ptrace.tracee.ancestors.user",
		"ptrace.tracee.ancestors.user_session.k8s_groups",
		"ptrace.tracee.ancestors.user_session.k8s_uid",
		"ptrace.tracee.ancestors.user_session.k8s_username",
		"ptrace.tracee.args",
		"ptrace.tracee.args_flags",
		"ptrace.tracee.args_options",
		"ptrace.tracee.args_truncated",
		"ptrace.tracee.argv",
		"ptrace.tracee.argv0",
		"ptrace.tracee.auid",
		"ptrace.tracee.cap_effective",
		"ptrace.tracee.cap_permitted",
		"ptrace.tracee.cgroup.file.inode",
		"ptrace.tracee.cgroup.file.mount_id",
		"ptrace.tracee.cgroup.id",
		"ptrace.tracee.cgroup.manager",
		"ptrace.tracee.cgroup.version",
		"ptrace.tracee.comm",
		"ptrace.tracee.container.id",
		"ptrace.tracee.created_at",
		"ptrace.tracee.egid",
		"ptrace.tracee.egroup",
		"ptrace.tracee.envp",
		"ptrace.tracee.envs",
		"ptrace.tracee.envs_truncated",
		"ptrace.tracee.euid",
		"ptrace.tracee.euser",
		"ptrace.tracee.file.change_time",
		"ptrace.tracee.file.filesystem",
		"ptrace.tracee.file.gid",
		"ptrace.tracee.file.group",
		"ptrace.tracee.file.hashes",
		"ptrace.tracee.file.in_upper_layer",
		"ptrace.tracee.file.inode",
		"ptrace.tracee.file.mode",
		"ptrace.tracee.file.modification_time",
		"ptrace.tracee.file.mount_id",
		"ptrace.tracee.file.name",
		"ptrace.tracee.file.name.length",
		"ptrace.tracee.file.package.name",
		"ptrace.tracee.file.package.source_version",
		"ptrace.tracee.file.package.version",
		"ptrace.tracee.file.path",
		"ptrace.tracee.file.path.length",
		"ptrace.tracee.file.rights",
		"ptrace.tracee.file.uid",
		"ptrace.tracee.file.user",
		"ptrace.tracee.fsgid",
		"ptrace.tracee.fsgroup",
		"ptrace.tracee.fsuid",
		"ptrace.tracee.fsuser",
		"ptrace.tracee.gid",
		"ptrace.tracee.group",
		"ptrace.tracee.interpreter.file.change_time",
		"ptrace.tracee.interpreter.file.filesystem",
		"ptrace.tracee.interpreter.file.gid",
		"ptrace.tracee.interpreter.file.group",
		"ptrace.tracee.interpreter.file.hashes",
		"ptrace.tracee.interpreter.file.in_upper_layer",
		"ptrace.tracee.interpreter.file.inode",
		"ptrace.tracee.interpreter.file.mode",
		"ptrace.tracee.interpreter.file.modification_time",
		"ptrace.tracee.interpreter.file.mount_id",
		"ptrace.tracee.interpreter.file.name",
		"ptrace.tracee.interpreter.file.name.length",
		"ptrace.tracee.interpreter.file.package.name",
		"ptrace.tracee.interpreter.file.package.source_version",
		"ptrace.tracee.interpreter.file.package.version",
		"ptrace.tracee.interpreter.file.path",
		"ptrace.tracee.interpreter.file.path.length",
		"ptrace.tracee.interpreter.file.rights",
		"ptrace.tracee.interpreter.file.uid",
		"ptrace.tracee.interpreter.file.user",
		"ptrace.tracee.is_exec",
		"ptrace.tracee.is_kworker",
		"ptrace.tracee.is_thread",
		"ptrace.tracee.parent.args",
		"ptrace.tracee.parent.args_flags",
		"ptrace.tracee.parent.args_options",
		"ptrace.tracee.parent.args_truncated",
		"ptrace.tracee.parent.argv",
		"ptrace.tracee.parent.argv0",
		"ptrace.tracee.parent.auid",
		"ptrace.tracee.parent.cap_effective",
		"ptrace.tracee.parent.cap_permitted",
		"ptrace.tracee.parent.cgroup.file.inode",
		"ptrace.tracee.parent.cgroup.file.mount_id",
		"ptrace.tracee.parent.cgroup.id",
		"ptrace.tracee.parent.cgroup.manager",
		"ptrace.tracee.parent.cgroup.version",
		"ptrace.tracee.parent.comm",
		"ptrace.tracee.parent.container.id",
		"ptrace.tracee.parent.created_at",
		"ptrace.tracee.parent.egid",
		"ptrace.tracee.parent.egroup",
		"ptrace.tracee.parent.envp",
		"ptrace.tracee.parent.envs",
		"ptrace.tracee.parent.envs_truncated",
		"ptrace.tracee.parent.euid",
		"ptrace.tracee.parent.euser",
		"ptrace.tracee.parent.file.change_time",
		"ptrace.tracee.parent.file.filesystem",
		"ptrace.tracee.parent.file.gid",
		"ptrace.tracee.parent.file.group",
		"ptrace.tracee.parent.file.hashes",
		"ptrace.tracee.parent.file.in_upper_layer",
		"ptrace.tracee.parent.file.inode",
		"ptrace.tracee.parent.file.mode",
		"ptrace.tracee.parent.file.modification_time",
		"ptrace.tracee.parent.file.mount_id",
		"ptrace.tracee.parent.file.name",
		"ptrace.tracee.parent.file.name.length",
		"ptrace.tracee.parent.file.package.name",
		"ptrace.tracee.parent.file.package.source_version",
		"ptrace.tracee.parent.file.package.version",
		"ptrace.tracee.parent.file.path",
		"ptrace.tracee.parent.file.path.length",
		"ptrace.tracee.parent.file.rights",
		"ptrace.tracee.parent.file.uid",
		"ptrace.tracee.parent.file.user",
		"ptrace.tracee.parent.fsgid",
		"ptrace.tracee.parent.fsgroup",
		"ptrace.tracee.parent.fsuid",
		"ptrace.tracee.parent.fsuser",
		"ptrace.tracee.parent.gid",
		"ptrace.tracee.parent.group",
		"ptrace.tracee.parent.interpreter.file.change_time",
		"ptrace.tracee.parent.interpreter.file.filesystem",
		"ptrace.tracee.parent.interpreter.file.gid",
		"ptrace.tracee.parent.interpreter.file.group",
		"ptrace.tracee.parent.interpreter.file.hashes",
		"ptrace.tracee.parent.interpreter.file.in_upper_layer",
		"ptrace.tracee.parent.interpreter.file.inode",
		"ptrace.tracee.parent.interpreter.file.mode",
		"ptrace.tracee.parent.interpreter.file.modification_time",
		"ptrace.tracee.parent.interpreter.file.mount_id",
		"ptrace.tracee.parent.interpreter.file.name",
		"ptrace.tracee.parent.interpreter.file.name.length",
		"ptrace.tracee.parent.interpreter.file.package.name",
		"ptrace.tracee.parent.interpreter.file.package.source_version",
		"ptrace.tracee.parent.interpreter.file.package.version",
		"ptrace.tracee.parent.interpreter.file.path",
		"ptrace.tracee.parent.interpreter.file.path.length",
		"ptrace.tracee.parent.interpreter.file.rights",
		"ptrace.tracee.parent.interpreter.file.uid",
		"ptrace.tracee.parent.interpreter.file.user",
		"ptrace.tracee.parent.is_exec",
		"ptrace.tracee.parent.is_kworker",
		"ptrace.tracee.parent.is_thread",
		"ptrace.tracee.parent.pid",
		"ptrace.tracee.parent.ppid",
		"ptrace.tracee.parent.tid",
		"ptrace.tracee.parent.tty_name",
		"ptrace.tracee.parent.uid",
		"ptrace.tracee.parent.user",
		"ptrace.tracee.parent.user_session.k8s_groups",
		"ptrace.tracee.parent.user_session.k8s_uid",
		"ptrace.tracee.parent.user_session.k8s_username",
		"ptrace.tracee.pid",
		"ptrace.tracee.ppid",
		"ptrace.tracee.tid",
		"ptrace.tracee.tty_name",
		"ptrace.tracee.uid",
		"ptrace.tracee.user",
		"ptrace.tracee.user_session.k8s_groups",
		"ptrace.tracee.user_session.k8s_uid",
		"ptrace.tracee.user_session.k8s_username",
		"removexattr.file.change_time",
		"removexattr.file.destination.name",
		"removexattr.file.destination.namespace",
		"removexattr.file.filesystem",
		"removexattr.file.gid",
		"removexattr.file.group",
		"removexattr.file.hashes",
		"removexattr.file.in_upper_layer",
		"removexattr.file.inode",
		"removexattr.file.mode",
		"removexattr.file.modification_time",
		"removexattr.file.mount_id",
		"removexattr.file.name",
		"removexattr.file.name.length",
		"removexattr.file.package.name",
		"removexattr.file.package.source_version",
		"removexattr.file.package.version",
		"removexattr.file.path",
		"removexattr.file.path.length",
		"removexattr.file.rights",
		"removexattr.file.uid",
		"removexattr.file.user",
		"removexattr.retval",
		"rename.file.change_time",
		"rename.file.destination.change_time",
		"rename.file.destination.filesystem",
		"rename.file.destination.gid",
		"rename.file.destination.group",
		"rename.file.destination.hashes",
		"rename.file.destination.in_upper_layer",
		"rename.file.destination.inode",
		"rename.file.destination.mode",
		"rename.file.destination.modification_time",
		"rename.file.destination.mount_id",
		"rename.file.destination.name",
		"rename.file.destination.name.length",
		"rename.file.destination.package.name",
		"rename.file.destination.package.source_version",
		"rename.file.destination.package.version",
		"rename.file.destination.path",
		"rename.file.destination.path.length",
		"rename.file.destination.rights",
		"rename.file.destination.uid",
		"rename.file.destination.user",
		"rename.file.filesystem",
		"rename.file.gid",
		"rename.file.group",
		"rename.file.hashes",
		"rename.file.in_upper_layer",
		"rename.file.inode",
		"rename.file.mode",
		"rename.file.modification_time",
		"rename.file.mount_id",
		"rename.file.name",
		"rename.file.name.length",
		"rename.file.package.name",
		"rename.file.package.source_version",
		"rename.file.package.version",
		"rename.file.path",
		"rename.file.path.length",
		"rename.file.rights",
		"rename.file.uid",
		"rename.file.user",
		"rename.retval",
		"rename.syscall.destination.path",
		"rename.syscall.path",
		"rmdir.file.change_time",
		"rmdir.file.filesystem",
		"rmdir.file.gid",
		"rmdir.file.group",
		"rmdir.file.hashes",
		"rmdir.file.in_upper_layer",
		"rmdir.file.inode",
		"rmdir.file.mode",
		"rmdir.file.modification_time",
		"rmdir.file.mount_id",
		"rmdir.file.name",
		"rmdir.file.name.length",
		"rmdir.file.package.name",
		"rmdir.file.package.source_version",
		"rmdir.file.package.version",
		"rmdir.file.path",
		"rmdir.file.path.length",
		"rmdir.file.rights",
		"rmdir.file.uid",
		"rmdir.file.user",
		"rmdir.retval",
		"rmdir.syscall.path",
		"selinux.bool.name",
		"selinux.bool.state",
		"selinux.bool_commit.state",
		"selinux.enforce.status",
		"setgid.egid",
		"setgid.egroup",
		"setgid.fsgid",
		"setgid.fsgroup",
		"setgid.gid",
		"setgid.group",
		"setrlimit.resource",
		"setrlimit.retval",
		"setrlimit.rlim_cur",
		"setrlimit.rlim_max",
		"setrlimit.target.ancestors.args",
		"setrlimit.target.ancestors.args_flags",
		"setrlimit.target.ancestors.args_options",
		"setrlimit.target.ancestors.args_truncated",
		"setrlimit.target.ancestors.argv",
		"setrlimit.target.ancestors.argv0",
		"setrlimit.target.ancestors.auid",
		"setrlimit.target.ancestors.cap_effective",
		"setrlimit.target.ancestors.cap_permitted",
		"setrlimit.target.ancestors.cgroup.file.inode",
		"setrlimit.target.ancestors.cgroup.file.mount_id",
		"setrlimit.target.ancestors.cgroup.id",
		"setrlimit.target.ancestors.cgroup.manager",
		"setrlimit.target.ancestors.cgroup.version",
		"setrlimit.target.ancestors.comm",
		"setrlimit.target.ancestors.container.id",
		"setrlimit.target.ancestors.created_at",
		"setrlimit.target.ancestors.egid",
		"setrlimit.target.ancestors.egroup",
		"setrlimit.target.ancestors.envp",
		"setrlimit.target.ancestors.envs",
		"setrlimit.target.ancestors.envs_truncated",
		"setrlimit.target.ancestors.euid",
		"setrlimit.target.ancestors.euser",
		"setrlimit.target.ancestors.file.change_time",
		"setrlimit.target.ancestors.file.filesystem",
		"setrlimit.target.ancestors.file.gid",
		"setrlimit.target.ancestors.file.group",
		"setrlimit.target.ancestors.file.hashes",
		"setrlimit.target.ancestors.file.in_upper_layer",
		"setrlimit.target.ancestors.file.inode",
		"setrlimit.target.ancestors.file.mode",
		"setrlimit.target.ancestors.file.modification_time",
		"setrlimit.target.ancestors.file.mount_id",
		"setrlimit.target.ancestors.file.name",
		"setrlimit.target.ancestors.file.name.length",
		"setrlimit.target.ancestors.file.package.name",
		"setrlimit.target.ancestors.file.package.source_version",
		"setrlimit.target.ancestors.file.package.version",
		"setrlimit.target.ancestors.file.path",
		"setrlimit.target.ancestors.file.path.length",
		"setrlimit.target.ancestors.file.rights",
		"setrlimit.target.ancestors.file.uid",
		"setrlimit.target.ancestors.file.user",
		"setrlimit.target.ancestors.fsgid",
		"setrlimit.target.ancestors.fsgroup",
		"setrlimit.target.ancestors.fsuid",
		"setrlimit.target.ancestors.fsuser",
		"setrlimit.target.ancestors.gid",
		"setrlimit.target.ancestors.group",
		"setrlimit.target.ancestors.interpreter.file.change_time",
		"setrlimit.target.ancestors.interpreter.file.filesystem",
		"setrlimit.target.ancestors.interpreter.file.gid",
		"setrlimit.target.ancestors.interpreter.file.group",
		"setrlimit.target.ancestors.interpreter.file.hashes",
		"setrlimit.target.ancestors.interpreter.file.in_upper_layer",
		"setrlimit.target.ancestors.interpreter.file.inode",
		"setrlimit.target.ancestors.interpreter.file.mode",
		"setrlimit.target.ancestors.interpreter.file.modification_time",
		"setrlimit.target.ancestors.interpreter.file.mount_id",
		"setrlimit.target.ancestors.interpreter.file.name",
		"setrlimit.target.ancestors.interpreter.file.name.length",
		"setrlimit.target.ancestors.interpreter.file.package.name",
		"setrlimit.target.ancestors.interpreter.file.package.source_version",
		"setrlimit.target.ancestors.interpreter.file.package.version",
		"setrlimit.target.ancestors.interpreter.file.path",
		"setrlimit.target.ancestors.interpreter.file.path.length",
		"setrlimit.target.ancestors.interpreter.file.rights",
		"setrlimit.target.ancestors.interpreter.file.uid",
		"setrlimit.target.ancestors.interpreter.file.user",
		"setrlimit.target.ancestors.is_exec",
		"setrlimit.target.ancestors.is_kworker",
		"setrlimit.target.ancestors.is_thread",
		"setrlimit.target.ancestors.length",
		"setrlimit.target.ancestors.pid",
		"setrlimit.target.ancestors.ppid",
		"setrlimit.target.ancestors.tid",
		"setrlimit.target.ancestors.tty_name",
		"setrlimit.target.ancestors.uid",
		"setrlimit.target.ancestors.user",
		"setrlimit.target.ancestors.user_session.k8s_groups",
		"setrlimit.target.ancestors.user_session.k8s_uid",
		"setrlimit.target.ancestors.user_session.k8s_username",
		"setrlimit.target.args",
		"setrlimit.target.args_flags",
		"setrlimit.target.args_options",
		"setrlimit.target.args_truncated",
		"setrlimit.target.argv",
		"setrlimit.target.argv0",
		"setrlimit.target.auid",
		"setrlimit.target.cap_effective",
		"setrlimit.target.cap_permitted",
		"setrlimit.target.cgroup.file.inode",
		"setrlimit.target.cgroup.file.mount_id",
		"setrlimit.target.cgroup.id",
		"setrlimit.target.cgroup.manager",
		"setrlimit.target.cgroup.version",
		"setrlimit.target.comm",
		"setrlimit.target.container.id",
		"setrlimit.target.created_at",
		"setrlimit.target.egid",
		"setrlimit.target.egroup",
		"setrlimit.target.envp",
		"setrlimit.target.envs",
		"setrlimit.target.envs_truncated",
		"setrlimit.target.euid",
		"setrlimit.target.euser",
		"setrlimit.target.file.change_time",
		"setrlimit.target.file.filesystem",
		"setrlimit.target.file.gid",
		"setrlimit.target.file.group",
		"setrlimit.target.file.hashes",
		"setrlimit.target.file.in_upper_layer",
		"setrlimit.target.file.inode",
		"setrlimit.target.file.mode",
		"setrlimit.target.file.modification_time",
		"setrlimit.target.file.mount_id",
		"setrlimit.target.file.name",
		"setrlimit.target.file.name.length",
		"setrlimit.target.file.package.name",
		"setrlimit.target.file.package.source_version",
		"setrlimit.target.file.package.version",
		"setrlimit.target.file.path",
		"setrlimit.target.file.path.length",
		"setrlimit.target.file.rights",
		"setrlimit.target.file.uid",
		"setrlimit.target.file.user",
		"setrlimit.target.fsgid",
		"setrlimit.target.fsgroup",
		"setrlimit.target.fsuid",
		"setrlimit.target.fsuser",
		"setrlimit.target.gid",
		"setrlimit.target.group",
		"setrlimit.target.interpreter.file.change_time",
		"setrlimit.target.interpreter.file.filesystem",
		"setrlimit.target.interpreter.file.gid",
		"setrlimit.target.interpreter.file.group",
		"setrlimit.target.interpreter.file.hashes",
		"setrlimit.target.interpreter.file.in_upper_layer",
		"setrlimit.target.interpreter.file.inode",
		"setrlimit.target.interpreter.file.mode",
		"setrlimit.target.interpreter.file.modification_time",
		"setrlimit.target.interpreter.file.mount_id",
		"setrlimit.target.interpreter.file.name",
		"setrlimit.target.interpreter.file.name.length",
		"setrlimit.target.interpreter.file.package.name",
		"setrlimit.target.interpreter.file.package.source_version",
		"setrlimit.target.interpreter.file.package.version",
		"setrlimit.target.interpreter.file.path",
		"setrlimit.target.interpreter.file.path.length",
		"setrlimit.target.interpreter.file.rights",
		"setrlimit.target.interpreter.file.uid",
		"setrlimit.target.interpreter.file.user",
		"setrlimit.target.is_exec",
		"setrlimit.target.is_kworker",
		"setrlimit.target.is_thread",
		"setrlimit.target.parent.args",
		"setrlimit.target.parent.args_flags",
		"setrlimit.target.parent.args_options",
		"setrlimit.target.parent.args_truncated",
		"setrlimit.target.parent.argv",
		"setrlimit.target.parent.argv0",
		"setrlimit.target.parent.auid",
		"setrlimit.target.parent.cap_effective",
		"setrlimit.target.parent.cap_permitted",
		"setrlimit.target.parent.cgroup.file.inode",
		"setrlimit.target.parent.cgroup.file.mount_id",
		"setrlimit.target.parent.cgroup.id",
		"setrlimit.target.parent.cgroup.manager",
		"setrlimit.target.parent.cgroup.version",
		"setrlimit.target.parent.comm",
		"setrlimit.target.parent.container.id",
		"setrlimit.target.parent.created_at",
		"setrlimit.target.parent.egid",
		"setrlimit.target.parent.egroup",
		"setrlimit.target.parent.envp",
		"setrlimit.target.parent.envs",
		"setrlimit.target.parent.envs_truncated",
		"setrlimit.target.parent.euid",
		"setrlimit.target.parent.euser",
		"setrlimit.target.parent.file.change_time",
		"setrlimit.target.parent.file.filesystem",
		"setrlimit.target.parent.file.gid",
		"setrlimit.target.parent.file.group",
		"setrlimit.target.parent.file.hashes",
		"setrlimit.target.parent.file.in_upper_layer",
		"setrlimit.target.parent.file.inode",
		"setrlimit.target.parent.file.mode",
		"setrlimit.target.parent.file.modification_time",
		"setrlimit.target.parent.file.mount_id",
		"setrlimit.target.parent.file.name",
		"setrlimit.target.parent.file.name.length",
		"setrlimit.target.parent.file.package.name",
		"setrlimit.target.parent.file.package.source_version",
		"setrlimit.target.parent.file.package.version",
		"setrlimit.target.parent.file.path",
		"setrlimit.target.parent.file.path.length",
		"setrlimit.target.parent.file.rights",
		"setrlimit.target.parent.file.uid",
		"setrlimit.target.parent.file.user",
		"setrlimit.target.parent.fsgid",
		"setrlimit.target.parent.fsgroup",
		"setrlimit.target.parent.fsuid",
		"setrlimit.target.parent.fsuser",
		"setrlimit.target.parent.gid",
		"setrlimit.target.parent.group",
		"setrlimit.target.parent.interpreter.file.change_time",
		"setrlimit.target.parent.interpreter.file.filesystem",
		"setrlimit.target.parent.interpreter.file.gid",
		"setrlimit.target.parent.interpreter.file.group",
		"setrlimit.target.parent.interpreter.file.hashes",
		"setrlimit.target.parent.interpreter.file.in_upper_layer",
		"setrlimit.target.parent.interpreter.file.inode",
		"setrlimit.target.parent.interpreter.file.mode",
		"setrlimit.target.parent.interpreter.file.modification_time",
		"setrlimit.target.parent.interpreter.file.mount_id",
		"setrlimit.target.parent.interpreter.file.name",
		"setrlimit.target.parent.interpreter.file.name.length",
		"setrlimit.target.parent.interpreter.file.package.name",
		"setrlimit.target.parent.interpreter.file.package.source_version",
		"setrlimit.target.parent.interpreter.file.package.version",
		"setrlimit.target.parent.interpreter.file.path",
		"setrlimit.target.parent.interpreter.file.path.length",
		"setrlimit.target.parent.interpreter.file.rights",
		"setrlimit.target.parent.interpreter.file.uid",
		"setrlimit.target.parent.interpreter.file.user",
		"setrlimit.target.parent.is_exec",
		"setrlimit.target.parent.is_kworker",
		"setrlimit.target.parent.is_thread",
		"setrlimit.target.parent.pid",
		"setrlimit.target.parent.ppid",
		"setrlimit.target.parent.tid",
		"setrlimit.target.parent.tty_name",
		"setrlimit.target.parent.uid",
		"setrlimit.target.parent.user",
		"setrlimit.target.parent.user_session.k8s_groups",
		"setrlimit.target.parent.user_session.k8s_uid",
		"setrlimit.target.parent.user_session.k8s_username",
		"setrlimit.target.pid",
		"setrlimit.target.ppid",
		"setrlimit.target.tid",
		"setrlimit.target.tty_name",
		"setrlimit.target.uid",
		"setrlimit.target.user",
		"setrlimit.target.user_session.k8s_groups",
		"setrlimit.target.user_session.k8s_uid",
		"setrlimit.target.user_session.k8s_username",
		"setsockopt.filter_hash",
		"setsockopt.filter_instructions",
		"setsockopt.filter_len",
		"setsockopt.is_filter_truncated",
		"setsockopt.level",
		"setsockopt.optname",
		"setsockopt.retval",
		"setsockopt.socket_family",
		"setsockopt.socket_protocol",
		"setsockopt.socket_type",
		"setuid.euid",
		"setuid.euser",
		"setuid.fsuid",
		"setuid.fsuser",
		"setuid.uid",
		"setuid.user",
		"setxattr.file.change_time",
		"setxattr.file.destination.name",
		"setxattr.file.destination.namespace",
		"setxattr.file.filesystem",
		"setxattr.file.gid",
		"setxattr.file.group",
		"setxattr.file.hashes",
		"setxattr.file.in_upper_layer",
		"setxattr.file.inode",
		"setxattr.file.mode",
		"setxattr.file.modification_time",
		"setxattr.file.mount_id",
		"setxattr.file.name",
		"setxattr.file.name.length",
		"setxattr.file.package.name",
		"setxattr.file.package.source_version",
		"setxattr.file.package.version",
		"setxattr.file.path",
		"setxattr.file.path.length",
		"setxattr.file.rights",
		"setxattr.file.uid",
		"setxattr.file.user",
		"setxattr.retval",
		"signal.pid",
		"signal.retval",
		"signal.target.ancestors.args",
		"signal.target.ancestors.args_flags",
		"signal.target.ancestors.args_options",
		"signal.target.ancestors.args_truncated",
		"signal.target.ancestors.argv",
		"signal.target.ancestors.argv0",
		"signal.target.ancestors.auid",
		"signal.target.ancestors.cap_effective",
		"signal.target.ancestors.cap_permitted",
		"signal.target.ancestors.cgroup.file.inode",
		"signal.target.ancestors.cgroup.file.mount_id",
		"signal.target.ancestors.cgroup.id",
		"signal.target.ancestors.cgroup.manager",
		"signal.target.ancestors.cgroup.version",
		"signal.target.ancestors.comm",
		"signal.target.ancestors.container.id",
		"signal.target.ancestors.created_at",
		"signal.target.ancestors.egid",
		"signal.target.ancestors.egroup",
		"signal.target.ancestors.envp",
		"signal.target.ancestors.envs",
		"signal.target.ancestors.envs_truncated",
		"signal.target.ancestors.euid",
		"signal.target.ancestors.euser",
		"signal.target.ancestors.file.change_time",
		"signal.target.ancestors.file.filesystem",
		"signal.target.ancestors.file.gid",
		"signal.target.ancestors.file.group",
		"signal.target.ancestors.file.hashes",
		"signal.target.ancestors.file.in_upper_layer",
		"signal.target.ancestors.file.inode",
		"signal.target.ancestors.file.mode",
		"signal.target.ancestors.file.modification_time",
		"signal.target.ancestors.file.mount_id",
		"signal.target.ancestors.file.name",
		"signal.target.ancestors.file.name.length",
		"signal.target.ancestors.file.package.name",
		"signal.target.ancestors.file.package.source_version",
		"signal.target.ancestors.file.package.version",
		"signal.target.ancestors.file.path",
		"signal.target.ancestors.file.path.length",
		"signal.target.ancestors.file.rights",
		"signal.target.ancestors.file.uid",
		"signal.target.ancestors.file.user",
		"signal.target.ancestors.fsgid",
		"signal.target.ancestors.fsgroup",
		"signal.target.ancestors.fsuid",
		"signal.target.ancestors.fsuser",
		"signal.target.ancestors.gid",
		"signal.target.ancestors.group",
		"signal.target.ancestors.interpreter.file.change_time",
		"signal.target.ancestors.interpreter.file.filesystem",
		"signal.target.ancestors.interpreter.file.gid",
		"signal.target.ancestors.interpreter.file.group",
		"signal.target.ancestors.interpreter.file.hashes",
		"signal.target.ancestors.interpreter.file.in_upper_layer",
		"signal.target.ancestors.interpreter.file.inode",
		"signal.target.ancestors.interpreter.file.mode",
		"signal.target.ancestors.interpreter.file.modification_time",
		"signal.target.ancestors.interpreter.file.mount_id",
		"signal.target.ancestors.interpreter.file.name",
		"signal.target.ancestors.interpreter.file.name.length",
		"signal.target.ancestors.interpreter.file.package.name",
		"signal.target.ancestors.interpreter.file.package.source_version",
		"signal.target.ancestors.interpreter.file.package.version",
		"signal.target.ancestors.interpreter.file.path",
		"signal.target.ancestors.interpreter.file.path.length",
		"signal.target.ancestors.interpreter.file.rights",
		"signal.target.ancestors.interpreter.file.uid",
		"signal.target.ancestors.interpreter.file.user",
		"signal.target.ancestors.is_exec",
		"signal.target.ancestors.is_kworker",
		"signal.target.ancestors.is_thread",
		"signal.target.ancestors.length",
		"signal.target.ancestors.pid",
		"signal.target.ancestors.ppid",
		"signal.target.ancestors.tid",
		"signal.target.ancestors.tty_name",
		"signal.target.ancestors.uid",
		"signal.target.ancestors.user",
		"signal.target.ancestors.user_session.k8s_groups",
		"signal.target.ancestors.user_session.k8s_uid",
		"signal.target.ancestors.user_session.k8s_username",
		"signal.target.args",
		"signal.target.args_flags",
		"signal.target.args_options",
		"signal.target.args_truncated",
		"signal.target.argv",
		"signal.target.argv0",
		"signal.target.auid",
		"signal.target.cap_effective",
		"signal.target.cap_permitted",
		"signal.target.cgroup.file.inode",
		"signal.target.cgroup.file.mount_id",
		"signal.target.cgroup.id",
		"signal.target.cgroup.manager",
		"signal.target.cgroup.version",
		"signal.target.comm",
		"signal.target.container.id",
		"signal.target.created_at",
		"signal.target.egid",
		"signal.target.egroup",
		"signal.target.envp",
		"signal.target.envs",
		"signal.target.envs_truncated",
		"signal.target.euid",
		"signal.target.euser",
		"signal.target.file.change_time",
		"signal.target.file.filesystem",
		"signal.target.file.gid",
		"signal.target.file.group",
		"signal.target.file.hashes",
		"signal.target.file.in_upper_layer",
		"signal.target.file.inode",
		"signal.target.file.mode",
		"signal.target.file.modification_time",
		"signal.target.file.mount_id",
		"signal.target.file.name",
		"signal.target.file.name.length",
		"signal.target.file.package.name",
		"signal.target.file.package.source_version",
		"signal.target.file.package.version",
		"signal.target.file.path",
		"signal.target.file.path.length",
		"signal.target.file.rights",
		"signal.target.file.uid",
		"signal.target.file.user",
		"signal.target.fsgid",
		"signal.target.fsgroup",
		"signal.target.fsuid",
		"signal.target.fsuser",
		"signal.target.gid",
		"signal.target.group",
		"signal.target.interpreter.file.change_time",
		"signal.target.interpreter.file.filesystem",
		"signal.target.interpreter.file.gid",
		"signal.target.interpreter.file.group",
		"signal.target.interpreter.file.hashes",
		"signal.target.interpreter.file.in_upper_layer",
		"signal.target.interpreter.file.inode",
		"signal.target.interpreter.file.mode",
		"signal.target.interpreter.file.modification_time",
		"signal.target.interpreter.file.mount_id",
		"signal.target.interpreter.file.name",
		"signal.target.interpreter.file.name.length",
		"signal.target.interpreter.file.package.name",
		"signal.target.interpreter.file.package.source_version",
		"signal.target.interpreter.file.package.version",
		"signal.target.interpreter.file.path",
		"signal.target.interpreter.file.path.length",
		"signal.target.interpreter.file.rights",
		"signal.target.interpreter.file.uid",
		"signal.target.interpreter.file.user",
		"signal.target.is_exec",
		"signal.target.is_kworker",
		"signal.target.is_thread",
		"signal.target.parent.args",
		"signal.target.parent.args_flags",
		"signal.target.parent.args_options",
		"signal.target.parent.args_truncated",
		"signal.target.parent.argv",
		"signal.target.parent.argv0",
		"signal.target.parent.auid",
		"signal.target.parent.cap_effective",
		"signal.target.parent.cap_permitted",
		"signal.target.parent.cgroup.file.inode",
		"signal.target.parent.cgroup.file.mount_id",
		"signal.target.parent.cgroup.id",
		"signal.target.parent.cgroup.manager",
		"signal.target.parent.cgroup.version",
		"signal.target.parent.comm",
		"signal.target.parent.container.id",
		"signal.target.parent.created_at",
		"signal.target.parent.egid",
		"signal.target.parent.egroup",
		"signal.target.parent.envp",
		"signal.target.parent.envs",
		"signal.target.parent.envs_truncated",
		"signal.target.parent.euid",
		"signal.target.parent.euser",
		"signal.target.parent.file.change_time",
		"signal.target.parent.file.filesystem",
		"signal.target.parent.file.gid",
		"signal.target.parent.file.group",
		"signal.target.parent.file.hashes",
		"signal.target.parent.file.in_upper_layer",
		"signal.target.parent.file.inode",
		"signal.target.parent.file.mode",
		"signal.target.parent.file.modification_time",
		"signal.target.parent.file.mount_id",
		"signal.target.parent.file.name",
		"signal.target.parent.file.name.length",
		"signal.target.parent.file.package.name",
		"signal.target.parent.file.package.source_version",
		"signal.target.parent.file.package.version",
		"signal.target.parent.file.path",
		"signal.target.parent.file.path.length",
		"signal.target.parent.file.rights",
		"signal.target.parent.file.uid",
		"signal.target.parent.file.user",
		"signal.target.parent.fsgid",
		"signal.target.parent.fsgroup",
		"signal.target.parent.fsuid",
		"signal.target.parent.fsuser",
		"signal.target.parent.gid",
		"signal.target.parent.group",
		"signal.target.parent.interpreter.file.change_time",
		"signal.target.parent.interpreter.file.filesystem",
		"signal.target.parent.interpreter.file.gid",
		"signal.target.parent.interpreter.file.group",
		"signal.target.parent.interpreter.file.hashes",
		"signal.target.parent.interpreter.file.in_upper_layer",
		"signal.target.parent.interpreter.file.inode",
		"signal.target.parent.interpreter.file.mode",
		"signal.target.parent.interpreter.file.modification_time",
		"signal.target.parent.interpreter.file.mount_id",
		"signal.target.parent.interpreter.file.name",
		"signal.target.parent.interpreter.file.name.length",
		"signal.target.parent.interpreter.file.package.name",
		"signal.target.parent.interpreter.file.package.source_version",
		"signal.target.parent.interpreter.file.package.version",
		"signal.target.parent.interpreter.file.path",
		"signal.target.parent.interpreter.file.path.length",
		"signal.target.parent.interpreter.file.rights",
		"signal.target.parent.interpreter.file.uid",
		"signal.target.parent.interpreter.file.user",
		"signal.target.parent.is_exec",
		"signal.target.parent.is_kworker",
		"signal.target.parent.is_thread",
		"signal.target.parent.pid",
		"signal.target.parent.ppid",
		"signal.target.parent.tid",
		"signal.target.parent.tty_name",
		"signal.target.parent.uid",
		"signal.target.parent.user",
		"signal.target.parent.user_session.k8s_groups",
		"signal.target.parent.user_session.k8s_uid",
		"signal.target.parent.user_session.k8s_username",
		"signal.target.pid",
		"signal.target.ppid",
		"signal.target.tid",
		"signal.target.tty_name",
		"signal.target.uid",
		"signal.target.user",
		"signal.target.user_session.k8s_groups",
		"signal.target.user_session.k8s_uid",
		"signal.target.user_session.k8s_username",
		"signal.type",
		"splice.file.change_time",
		"splice.file.filesystem",
		"splice.file.gid",
		"splice.file.group",
		"splice.file.hashes",
		"splice.file.in_upper_layer",
		"splice.file.inode",
		"splice.file.mode",
		"splice.file.modification_time",
		"splice.file.mount_id",
		"splice.file.name",
		"splice.file.name.length",
		"splice.file.package.name",
		"splice.file.package.source_version",
		"splice.file.package.version",
		"splice.file.path",
		"splice.file.path.length",
		"splice.file.rights",
		"splice.file.uid",
		"splice.file.user",
		"splice.pipe_entry_flag",
		"splice.pipe_exit_flag",
		"splice.retval",
		"sysctl.action",
		"sysctl.file_position",
		"sysctl.name",
		"sysctl.name_truncated",
		"sysctl.old_value",
		"sysctl.old_value_truncated",
		"sysctl.value",
		"sysctl.value_truncated",
		"unlink.file.change_time",
		"unlink.file.filesystem",
		"unlink.file.gid",
		"unlink.file.group",
		"unlink.file.hashes",
		"unlink.file.in_upper_layer",
		"unlink.file.inode",
		"unlink.file.mode",
		"unlink.file.modification_time",
		"unlink.file.mount_id",
		"unlink.file.name",
		"unlink.file.name.length",
		"unlink.file.package.name",
		"unlink.file.package.source_version",
		"unlink.file.package.version",
		"unlink.file.path",
		"unlink.file.path.length",
		"unlink.file.rights",
		"unlink.file.uid",
		"unlink.file.user",
		"unlink.flags",
		"unlink.retval",
		"unlink.syscall.dirfd",
		"unlink.syscall.flags",
		"unlink.syscall.path",
		"unload_module.name",
		"unload_module.retval",
		"utimes.file.change_time",
		"utimes.file.filesystem",
		"utimes.file.gid",
		"utimes.file.group",
		"utimes.file.hashes",
		"utimes.file.in_upper_layer",
		"utimes.file.inode",
		"utimes.file.mode",
		"utimes.file.modification_time",
		"utimes.file.mount_id",
		"utimes.file.name",
		"utimes.file.name.length",
		"utimes.file.package.name",
		"utimes.file.package.source_version",
		"utimes.file.package.version",
		"utimes.file.path",
		"utimes.file.path.length",
		"utimes.file.rights",
		"utimes.file.uid",
		"utimes.file.user",
		"utimes.retval",
		"utimes.syscall.path",
	}
}
func (ev *Event) GetFieldValue(field eval.Field) (interface{}, error) {
	m := &Model{}
	evaluator, err := m.GetEvaluator(field, "", 0)
	if err != nil {
		return nil, err
	}
	ctx := eval.NewContext(ev)
	value := evaluator.Eval(ctx)
	return value, nil
}
func (ev *Event) GetFieldMetadata(field eval.Field) (eval.EventType, reflect.Kind, string, error) {
	switch field {
	case "accept.addr.family":
		return "accept", reflect.Int, "int", nil
	case "accept.addr.hostname":
		return "accept", reflect.String, "string", nil
	case "accept.addr.ip":
		return "accept", reflect.Struct, "net.IPNet", nil
	case "accept.addr.is_public":
		return "accept", reflect.Bool, "bool", nil
	case "accept.addr.port":
		return "accept", reflect.Int, "int", nil
	case "accept.retval":
		return "accept", reflect.Int, "int", nil
	case "bind.addr.family":
		return "bind", reflect.Int, "int", nil
	case "bind.addr.ip":
		return "bind", reflect.Struct, "net.IPNet", nil
	case "bind.addr.is_public":
		return "bind", reflect.Bool, "bool", nil
	case "bind.addr.port":
		return "bind", reflect.Int, "int", nil
	case "bind.protocol":
		return "bind", reflect.Int, "int", nil
	case "bind.retval":
		return "bind", reflect.Int, "int", nil
	case "bpf.cmd":
		return "bpf", reflect.Int, "int", nil
	case "bpf.map.name":
		return "bpf", reflect.String, "string", nil
	case "bpf.map.type":
		return "bpf", reflect.Int, "int", nil
	case "bpf.prog.attach_type":
		return "bpf", reflect.Int, "int", nil
	case "bpf.prog.helpers":
		return "bpf", reflect.Int, "int", nil
	case "bpf.prog.name":
		return "bpf", reflect.String, "string", nil
	case "bpf.prog.tag":
		return "bpf", reflect.String, "string", nil
	case "bpf.prog.type":
		return "bpf", reflect.Int, "int", nil
	case "bpf.retval":
		return "bpf", reflect.Int, "int", nil
	case "capset.cap_effective":
		return "capset", reflect.Int, "int", nil
	case "capset.cap_permitted":
		return "capset", reflect.Int, "int", nil
	case "cgroup.file.inode":
		return "", reflect.Int, "int", nil
	case "cgroup.file.mount_id":
		return "", reflect.Int, "int", nil
	case "cgroup.id":
		return "", reflect.String, "string", nil
	case "cgroup.manager":
		return "", reflect.String, "string", nil
	case "cgroup.version":
		return "", reflect.Int, "int", nil
	case "cgroup_write.file.change_time":
		return "cgroup_write", reflect.Int, "int", nil
	case "cgroup_write.file.filesystem":
		return "cgroup_write", reflect.String, "string", nil
	case "cgroup_write.file.gid":
		return "cgroup_write", reflect.Int, "int", nil
	case "cgroup_write.file.group":
		return "cgroup_write", reflect.String, "string", nil
	case "cgroup_write.file.hashes":
		return "cgroup_write", reflect.String, "string", nil
	case "cgroup_write.file.in_upper_layer":
		return "cgroup_write", reflect.Bool, "bool", nil
	case "cgroup_write.file.inode":
		return "cgroup_write", reflect.Int, "int", nil
	case "cgroup_write.file.mode":
		return "cgroup_write", reflect.Int, "int", nil
	case "cgroup_write.file.modification_time":
		return "cgroup_write", reflect.Int, "int", nil
	case "cgroup_write.file.mount_id":
		return "cgroup_write", reflect.Int, "int", nil
	case "cgroup_write.file.name":
		return "cgroup_write", reflect.String, "string", nil
	case "cgroup_write.file.name.length":
		return "cgroup_write", reflect.Int, "int", nil
	case "cgroup_write.file.package.name":
		return "cgroup_write", reflect.String, "string", nil
	case "cgroup_write.file.package.source_version":
		return "cgroup_write", reflect.String, "string", nil
	case "cgroup_write.file.package.version":
		return "cgroup_write", reflect.String, "string", nil
	case "cgroup_write.file.path":
		return "cgroup_write", reflect.String, "string", nil
	case "cgroup_write.file.path.length":
		return "cgroup_write", reflect.Int, "int", nil
	case "cgroup_write.file.rights":
		return "cgroup_write", reflect.Int, "int", nil
	case "cgroup_write.file.uid":
		return "cgroup_write", reflect.Int, "int", nil
	case "cgroup_write.file.user":
		return "cgroup_write", reflect.String, "string", nil
	case "cgroup_write.pid":
		return "cgroup_write", reflect.Int, "int", nil
	case "chdir.file.change_time":
		return "chdir", reflect.Int, "int", nil
	case "chdir.file.filesystem":
		return "chdir", reflect.String, "string", nil
	case "chdir.file.gid":
		return "chdir", reflect.Int, "int", nil
	case "chdir.file.group":
		return "chdir", reflect.String, "string", nil
	case "chdir.file.hashes":
		return "chdir", reflect.String, "string", nil
	case "chdir.file.in_upper_layer":
		return "chdir", reflect.Bool, "bool", nil
	case "chdir.file.inode":
		return "chdir", reflect.Int, "int", nil
	case "chdir.file.mode":
		return "chdir", reflect.Int, "int", nil
	case "chdir.file.modification_time":
		return "chdir", reflect.Int, "int", nil
	case "chdir.file.mount_id":
		return "chdir", reflect.Int, "int", nil
	case "chdir.file.name":
		return "chdir", reflect.String, "string", nil
	case "chdir.file.name.length":
		return "chdir", reflect.Int, "int", nil
	case "chdir.file.package.name":
		return "chdir", reflect.String, "string", nil
	case "chdir.file.package.source_version":
		return "chdir", reflect.String, "string", nil
	case "chdir.file.package.version":
		return "chdir", reflect.String, "string", nil
	case "chdir.file.path":
		return "chdir", reflect.String, "string", nil
	case "chdir.file.path.length":
		return "chdir", reflect.Int, "int", nil
	case "chdir.file.rights":
		return "chdir", reflect.Int, "int", nil
	case "chdir.file.uid":
		return "chdir", reflect.Int, "int", nil
	case "chdir.file.user":
		return "chdir", reflect.String, "string", nil
	case "chdir.retval":
		return "chdir", reflect.Int, "int", nil
	case "chdir.syscall.path":
		return "chdir", reflect.String, "string", nil
	case "chmod.file.change_time":
		return "chmod", reflect.Int, "int", nil
	case "chmod.file.destination.mode":
		return "chmod", reflect.Int, "int", nil
	case "chmod.file.destination.rights":
		return "chmod", reflect.Int, "int", nil
	case "chmod.file.filesystem":
		return "chmod", reflect.String, "string", nil
	case "chmod.file.gid":
		return "chmod", reflect.Int, "int", nil
	case "chmod.file.group":
		return "chmod", reflect.String, "string", nil
	case "chmod.file.hashes":
		return "chmod", reflect.String, "string", nil
	case "chmod.file.in_upper_layer":
		return "chmod", reflect.Bool, "bool", nil
	case "chmod.file.inode":
		return "chmod", reflect.Int, "int", nil
	case "chmod.file.mode":
		return "chmod", reflect.Int, "int", nil
	case "chmod.file.modification_time":
		return "chmod", reflect.Int, "int", nil
	case "chmod.file.mount_id":
		return "chmod", reflect.Int, "int", nil
	case "chmod.file.name":
		return "chmod", reflect.String, "string", nil
	case "chmod.file.name.length":
		return "chmod", reflect.Int, "int", nil
	case "chmod.file.package.name":
		return "chmod", reflect.String, "string", nil
	case "chmod.file.package.source_version":
		return "chmod", reflect.String, "string", nil
	case "chmod.file.package.version":
		return "chmod", reflect.String, "string", nil
	case "chmod.file.path":
		return "chmod", reflect.String, "string", nil
	case "chmod.file.path.length":
		return "chmod", reflect.Int, "int", nil
	case "chmod.file.rights":
		return "chmod", reflect.Int, "int", nil
	case "chmod.file.uid":
		return "chmod", reflect.Int, "int", nil
	case "chmod.file.user":
		return "chmod", reflect.String, "string", nil
	case "chmod.retval":
		return "chmod", reflect.Int, "int", nil
	case "chmod.syscall.mode":
		return "chmod", reflect.Int, "int", nil
	case "chmod.syscall.path":
		return "chmod", reflect.String, "string", nil
	case "chown.file.change_time":
		return "chown", reflect.Int, "int", nil
	case "chown.file.destination.gid":
		return "chown", reflect.Int, "int", nil
	case "chown.file.destination.group":
		return "chown", reflect.String, "string", nil
	case "chown.file.destination.uid":
		return "chown", reflect.Int, "int", nil
	case "chown.file.destination.user":
		return "chown", reflect.String, "string", nil
	case "chown.file.filesystem":
		return "chown", reflect.String, "string", nil
	case "chown.file.gid":
		return "chown", reflect.Int, "int", nil
	case "chown.file.group":
		return "chown", reflect.String, "string", nil
	case "chown.file.hashes":
		return "chown", reflect.String, "string", nil
	case "chown.file.in_upper_layer":
		return "chown", reflect.Bool, "bool", nil
	case "chown.file.inode":
		return "chown", reflect.Int, "int", nil
	case "chown.file.mode":
		return "chown", reflect.Int, "int", nil
	case "chown.file.modification_time":
		return "chown", reflect.Int, "int", nil
	case "chown.file.mount_id":
		return "chown", reflect.Int, "int", nil
	case "chown.file.name":
		return "chown", reflect.String, "string", nil
	case "chown.file.name.length":
		return "chown", reflect.Int, "int", nil
	case "chown.file.package.name":
		return "chown", reflect.String, "string", nil
	case "chown.file.package.source_version":
		return "chown", reflect.String, "string", nil
	case "chown.file.package.version":
		return "chown", reflect.String, "string", nil
	case "chown.file.path":
		return "chown", reflect.String, "string", nil
	case "chown.file.path.length":
		return "chown", reflect.Int, "int", nil
	case "chown.file.rights":
		return "chown", reflect.Int, "int", nil
	case "chown.file.uid":
		return "chown", reflect.Int, "int", nil
	case "chown.file.user":
		return "chown", reflect.String, "string", nil
	case "chown.retval":
		return "chown", reflect.Int, "int", nil
	case "chown.syscall.gid":
		return "chown", reflect.Int, "int", nil
	case "chown.syscall.path":
		return "chown", reflect.String, "string", nil
	case "chown.syscall.uid":
		return "chown", reflect.Int, "int", nil
	case "connect.addr.family":
		return "connect", reflect.Int, "int", nil
	case "connect.addr.hostname":
		return "connect", reflect.String, "string", nil
	case "connect.addr.ip":
		return "connect", reflect.Struct, "net.IPNet", nil
	case "connect.addr.is_public":
		return "connect", reflect.Bool, "bool", nil
	case "connect.addr.port":
		return "connect", reflect.Int, "int", nil
	case "connect.protocol":
		return "connect", reflect.Int, "int", nil
	case "connect.retval":
		return "connect", reflect.Int, "int", nil
	case "container.created_at":
		return "", reflect.Int, "int", nil
	case "container.id":
		return "", reflect.String, "string", nil
	case "container.runtime":
		return "", reflect.String, "string", nil
	case "container.tags":
		return "", reflect.String, "string", nil
	case "dns.id":
		return "dns", reflect.Int, "int", nil
	case "dns.question.class":
		return "dns", reflect.Int, "int", nil
	case "dns.question.count":
		return "dns", reflect.Int, "int", nil
	case "dns.question.length":
		return "dns", reflect.Int, "int", nil
	case "dns.question.name":
		return "dns", reflect.String, "string", nil
	case "dns.question.name.length":
		return "dns", reflect.Int, "int", nil
	case "dns.question.type":
		return "dns", reflect.Int, "int", nil
	case "dns.response.code":
		return "dns", reflect.Int, "int", nil
	case "event.async":
		return "", reflect.Bool, "bool", nil
	case "event.hostname":
		return "", reflect.String, "string", nil
	case "event.origin":
		return "", reflect.String, "string", nil
	case "event.os":
		return "", reflect.String, "string", nil
	case "event.rule.tags":
		return "", reflect.String, "string", nil
	case "event.service":
		return "", reflect.String, "string", nil
	case "event.timestamp":
		return "", reflect.Int, "int", nil
	case "exec.args":
		return "exec", reflect.String, "string", nil
	case "exec.args_flags":
		return "exec", reflect.String, "string", nil
	case "exec.args_options":
		return "exec", reflect.String, "string", nil
	case "exec.args_truncated":
		return "exec", reflect.Bool, "bool", nil
	case "exec.argv":
		return "exec", reflect.String, "string", nil
	case "exec.argv0":
		return "exec", reflect.String, "string", nil
	case "exec.auid":
		return "exec", reflect.Int, "int", nil
	case "exec.cap_effective":
		return "exec", reflect.Int, "int", nil
	case "exec.cap_permitted":
		return "exec", reflect.Int, "int", nil
	case "exec.cgroup.file.inode":
		return "exec", reflect.Int, "int", nil
	case "exec.cgroup.file.mount_id":
		return "exec", reflect.Int, "int", nil
	case "exec.cgroup.id":
		return "exec", reflect.String, "string", nil
	case "exec.cgroup.manager":
		return "exec", reflect.String, "string", nil
	case "exec.cgroup.version":
		return "exec", reflect.Int, "int", nil
	case "exec.comm":
		return "exec", reflect.String, "string", nil
	case "exec.container.id":
		return "exec", reflect.String, "string", nil
	case "exec.created_at":
		return "exec", reflect.Int, "int", nil
	case "exec.egid":
		return "exec", reflect.Int, "int", nil
	case "exec.egroup":
		return "exec", reflect.String, "string", nil
	case "exec.envp":
		return "exec", reflect.String, "string", nil
	case "exec.envs":
		return "exec", reflect.String, "string", nil
	case "exec.envs_truncated":
		return "exec", reflect.Bool, "bool", nil
	case "exec.euid":
		return "exec", reflect.Int, "int", nil
	case "exec.euser":
		return "exec", reflect.String, "string", nil
	case "exec.file.change_time":
		return "exec", reflect.Int, "int", nil
	case "exec.file.filesystem":
		return "exec", reflect.String, "string", nil
	case "exec.file.gid":
		return "exec", reflect.Int, "int", nil
	case "exec.file.group":
		return "exec", reflect.String, "string", nil
	case "exec.file.hashes":
		return "exec", reflect.String, "string", nil
	case "exec.file.in_upper_layer":
		return "exec", reflect.Bool, "bool", nil
	case "exec.file.inode":
		return "exec", reflect.Int, "int", nil
	case "exec.file.metadata.abi":
		return "exec", reflect.Int, "int", nil
	case "exec.file.metadata.architecture":
		return "exec", reflect.Int, "int", nil
	case "exec.file.metadata.compression":
		return "exec", reflect.Int, "int", nil
	case "exec.file.metadata.is_executable":
		return "exec", reflect.Bool, "bool", nil
	case "exec.file.metadata.is_garble_obfuscated":
		return "exec", reflect.Bool, "bool", nil
	case "exec.file.metadata.is_upx_packed":
		return "exec", reflect.Bool, "bool", nil
	case "exec.file.metadata.size":
		return "exec", reflect.Int, "int", nil
	case "exec.file.metadata.type":
		return "exec", reflect.Int, "int", nil
	case "exec.file.mode":
		return "exec", reflect.Int, "int", nil
	case "exec.file.modification_time":
		return "exec", reflect.Int, "int", nil
	case "exec.file.mount_id":
		return "exec", reflect.Int, "int", nil
	case "exec.file.name":
		return "exec", reflect.String, "string", nil
	case "exec.file.name.length":
		return "exec", reflect.Int, "int", nil
	case "exec.file.package.name":
		return "exec", reflect.String, "string", nil
	case "exec.file.package.source_version":
		return "exec", reflect.String, "string", nil
	case "exec.file.package.version":
		return "exec", reflect.String, "string", nil
	case "exec.file.path":
		return "exec", reflect.String, "string", nil
	case "exec.file.path.length":
		return "exec", reflect.Int, "int", nil
	case "exec.file.rights":
		return "exec", reflect.Int, "int", nil
	case "exec.file.uid":
		return "exec", reflect.Int, "int", nil
	case "exec.file.user":
		return "exec", reflect.String, "string", nil
	case "exec.fsgid":
		return "exec", reflect.Int, "int", nil
	case "exec.fsgroup":
		return "exec", reflect.String, "string", nil
	case "exec.fsuid":
		return "exec", reflect.Int, "int", nil
	case "exec.fsuser":
		return "exec", reflect.String, "string", nil
	case "exec.gid":
		return "exec", reflect.Int, "int", nil
	case "exec.group":
		return "exec", reflect.String, "string", nil
	case "exec.interpreter.file.change_time":
		return "exec", reflect.Int, "int", nil
	case "exec.interpreter.file.filesystem":
		return "exec", reflect.String, "string", nil
	case "exec.interpreter.file.gid":
		return "exec", reflect.Int, "int", nil
	case "exec.interpreter.file.group":
		return "exec", reflect.String, "string", nil
	case "exec.interpreter.file.hashes":
		return "exec", reflect.String, "string", nil
	case "exec.interpreter.file.in_upper_layer":
		return "exec", reflect.Bool, "bool", nil
	case "exec.interpreter.file.inode":
		return "exec", reflect.Int, "int", nil
	case "exec.interpreter.file.mode":
		return "exec", reflect.Int, "int", nil
	case "exec.interpreter.file.modification_time":
		return "exec", reflect.Int, "int", nil
	case "exec.interpreter.file.mount_id":
		return "exec", reflect.Int, "int", nil
	case "exec.interpreter.file.name":
		return "exec", reflect.String, "string", nil
	case "exec.interpreter.file.name.length":
		return "exec", reflect.Int, "int", nil
	case "exec.interpreter.file.package.name":
		return "exec", reflect.String, "string", nil
	case "exec.interpreter.file.package.source_version":
		return "exec", reflect.String, "string", nil
	case "exec.interpreter.file.package.version":
		return "exec", reflect.String, "string", nil
	case "exec.interpreter.file.path":
		return "exec", reflect.String, "string", nil
	case "exec.interpreter.file.path.length":
		return "exec", reflect.Int, "int", nil
	case "exec.interpreter.file.rights":
		return "exec", reflect.Int, "int", nil
	case "exec.interpreter.file.uid":
		return "exec", reflect.Int, "int", nil
	case "exec.interpreter.file.user":
		return "exec", reflect.String, "string", nil
	case "exec.is_exec":
		return "exec", reflect.Bool, "bool", nil
	case "exec.is_kworker":
		return "exec", reflect.Bool, "bool", nil
	case "exec.is_thread":
		return "exec", reflect.Bool, "bool", nil
	case "exec.pid":
		return "exec", reflect.Int, "int", nil
	case "exec.ppid":
		return "exec", reflect.Int, "int", nil
	case "exec.syscall.path":
		return "exec", reflect.String, "string", nil
	case "exec.tid":
		return "exec", reflect.Int, "int", nil
	case "exec.tty_name":
		return "exec", reflect.String, "string", nil
	case "exec.uid":
		return "exec", reflect.Int, "int", nil
	case "exec.user":
		return "exec", reflect.String, "string", nil
	case "exec.user_session.k8s_groups":
		return "exec", reflect.String, "string", nil
	case "exec.user_session.k8s_uid":
		return "exec", reflect.String, "string", nil
	case "exec.user_session.k8s_username":
		return "exec", reflect.String, "string", nil
	case "exit.args":
		return "exit", reflect.String, "string", nil
	case "exit.args_flags":
		return "exit", reflect.String, "string", nil
	case "exit.args_options":
		return "exit", reflect.String, "string", nil
	case "exit.args_truncated":
		return "exit", reflect.Bool, "bool", nil
	case "exit.argv":
		return "exit", reflect.String, "string", nil
	case "exit.argv0":
		return "exit", reflect.String, "string", nil
	case "exit.auid":
		return "exit", reflect.Int, "int", nil
	case "exit.cap_effective":
		return "exit", reflect.Int, "int", nil
	case "exit.cap_permitted":
		return "exit", reflect.Int, "int", nil
	case "exit.cause":
		return "exit", reflect.Int, "int", nil
	case "exit.cgroup.file.inode":
		return "exit", reflect.Int, "int", nil
	case "exit.cgroup.file.mount_id":
		return "exit", reflect.Int, "int", nil
	case "exit.cgroup.id":
		return "exit", reflect.String, "string", nil
	case "exit.cgroup.manager":
		return "exit", reflect.String, "string", nil
	case "exit.cgroup.version":
		return "exit", reflect.Int, "int", nil
	case "exit.code":
		return "exit", reflect.Int, "int", nil
	case "exit.comm":
		return "exit", reflect.String, "string", nil
	case "exit.container.id":
		return "exit", reflect.String, "string", nil
	case "exit.created_at":
		return "exit", reflect.Int, "int", nil
	case "exit.egid":
		return "exit", reflect.Int, "int", nil
	case "exit.egroup":
		return "exit", reflect.String, "string", nil
	case "exit.envp":
		return "exit", reflect.String, "string", nil
	case "exit.envs":
		return "exit", reflect.String, "string", nil
	case "exit.envs_truncated":
		return "exit", reflect.Bool, "bool", nil
	case "exit.euid":
		return "exit", reflect.Int, "int", nil
	case "exit.euser":
		return "exit", reflect.String, "string", nil
	case "exit.file.change_time":
		return "exit", reflect.Int, "int", nil
	case "exit.file.filesystem":
		return "exit", reflect.String, "string", nil
	case "exit.file.gid":
		return "exit", reflect.Int, "int", nil
	case "exit.file.group":
		return "exit", reflect.String, "string", nil
	case "exit.file.hashes":
		return "exit", reflect.String, "string", nil
	case "exit.file.in_upper_layer":
		return "exit", reflect.Bool, "bool", nil
	case "exit.file.inode":
		return "exit", reflect.Int, "int", nil
	case "exit.file.mode":
		return "exit", reflect.Int, "int", nil
	case "exit.file.modification_time":
		return "exit", reflect.Int, "int", nil
	case "exit.file.mount_id":
		return "exit", reflect.Int, "int", nil
	case "exit.file.name":
		return "exit", reflect.String, "string", nil
	case "exit.file.name.length":
		return "exit", reflect.Int, "int", nil
	case "exit.file.package.name":
		return "exit", reflect.String, "string", nil
	case "exit.file.package.source_version":
		return "exit", reflect.String, "string", nil
	case "exit.file.package.version":
		return "exit", reflect.String, "string", nil
	case "exit.file.path":
		return "exit", reflect.String, "string", nil
	case "exit.file.path.length":
		return "exit", reflect.Int, "int", nil
	case "exit.file.rights":
		return "exit", reflect.Int, "int", nil
	case "exit.file.uid":
		return "exit", reflect.Int, "int", nil
	case "exit.file.user":
		return "exit", reflect.String, "string", nil
	case "exit.fsgid":
		return "exit", reflect.Int, "int", nil
	case "exit.fsgroup":
		return "exit", reflect.String, "string", nil
	case "exit.fsuid":
		return "exit", reflect.Int, "int", nil
	case "exit.fsuser":
		return "exit", reflect.String, "string", nil
	case "exit.gid":
		return "exit", reflect.Int, "int", nil
	case "exit.group":
		return "exit", reflect.String, "string", nil
	case "exit.interpreter.file.change_time":
		return "exit", reflect.Int, "int", nil
	case "exit.interpreter.file.filesystem":
		return "exit", reflect.String, "string", nil
	case "exit.interpreter.file.gid":
		return "exit", reflect.Int, "int", nil
	case "exit.interpreter.file.group":
		return "exit", reflect.String, "string", nil
	case "exit.interpreter.file.hashes":
		return "exit", reflect.String, "string", nil
	case "exit.interpreter.file.in_upper_layer":
		return "exit", reflect.Bool, "bool", nil
	case "exit.interpreter.file.inode":
		return "exit", reflect.Int, "int", nil
	case "exit.interpreter.file.mode":
		return "exit", reflect.Int, "int", nil
	case "exit.interpreter.file.modification_time":
		return "exit", reflect.Int, "int", nil
	case "exit.interpreter.file.mount_id":
		return "exit", reflect.Int, "int", nil
	case "exit.interpreter.file.name":
		return "exit", reflect.String, "string", nil
	case "exit.interpreter.file.name.length":
		return "exit", reflect.Int, "int", nil
	case "exit.interpreter.file.package.name":
		return "exit", reflect.String, "string", nil
	case "exit.interpreter.file.package.source_version":
		return "exit", reflect.String, "string", nil
	case "exit.interpreter.file.package.version":
		return "exit", reflect.String, "string", nil
	case "exit.interpreter.file.path":
		return "exit", reflect.String, "string", nil
	case "exit.interpreter.file.path.length":
		return "exit", reflect.Int, "int", nil
	case "exit.interpreter.file.rights":
		return "exit", reflect.Int, "int", nil
	case "exit.interpreter.file.uid":
		return "exit", reflect.Int, "int", nil
	case "exit.interpreter.file.user":
		return "exit", reflect.String, "string", nil
	case "exit.is_exec":
		return "exit", reflect.Bool, "bool", nil
	case "exit.is_kworker":
		return "exit", reflect.Bool, "bool", nil
	case "exit.is_thread":
		return "exit", reflect.Bool, "bool", nil
	case "exit.pid":
		return "exit", reflect.Int, "int", nil
	case "exit.ppid":
		return "exit", reflect.Int, "int", nil
	case "exit.tid":
		return "exit", reflect.Int, "int", nil
	case "exit.tty_name":
		return "exit", reflect.String, "string", nil
	case "exit.uid":
		return "exit", reflect.Int, "int", nil
	case "exit.user":
		return "exit", reflect.String, "string", nil
	case "exit.user_session.k8s_groups":
		return "exit", reflect.String, "string", nil
	case "exit.user_session.k8s_uid":
		return "exit", reflect.String, "string", nil
	case "exit.user_session.k8s_username":
		return "exit", reflect.String, "string", nil
	case "imds.aws.is_imds_v2":
		return "imds", reflect.Bool, "bool", nil
	case "imds.aws.security_credentials.type":
		return "imds", reflect.String, "string", nil
	case "imds.cloud_provider":
		return "imds", reflect.String, "string", nil
	case "imds.host":
		return "imds", reflect.String, "string", nil
	case "imds.server":
		return "imds", reflect.String, "string", nil
	case "imds.type":
		return "imds", reflect.String, "string", nil
	case "imds.url":
		return "imds", reflect.String, "string", nil
	case "imds.user_agent":
		return "imds", reflect.String, "string", nil
	case "link.file.change_time":
		return "link", reflect.Int, "int", nil
	case "link.file.destination.change_time":
		return "link", reflect.Int, "int", nil
	case "link.file.destination.filesystem":
		return "link", reflect.String, "string", nil
	case "link.file.destination.gid":
		return "link", reflect.Int, "int", nil
	case "link.file.destination.group":
		return "link", reflect.String, "string", nil
	case "link.file.destination.hashes":
		return "link", reflect.String, "string", nil
	case "link.file.destination.in_upper_layer":
		return "link", reflect.Bool, "bool", nil
	case "link.file.destination.inode":
		return "link", reflect.Int, "int", nil
	case "link.file.destination.mode":
		return "link", reflect.Int, "int", nil
	case "link.file.destination.modification_time":
		return "link", reflect.Int, "int", nil
	case "link.file.destination.mount_id":
		return "link", reflect.Int, "int", nil
	case "link.file.destination.name":
		return "link", reflect.String, "string", nil
	case "link.file.destination.name.length":
		return "link", reflect.Int, "int", nil
	case "link.file.destination.package.name":
		return "link", reflect.String, "string", nil
	case "link.file.destination.package.source_version":
		return "link", reflect.String, "string", nil
	case "link.file.destination.package.version":
		return "link", reflect.String, "string", nil
	case "link.file.destination.path":
		return "link", reflect.String, "string", nil
	case "link.file.destination.path.length":
		return "link", reflect.Int, "int", nil
	case "link.file.destination.rights":
		return "link", reflect.Int, "int", nil
	case "link.file.destination.uid":
		return "link", reflect.Int, "int", nil
	case "link.file.destination.user":
		return "link", reflect.String, "string", nil
	case "link.file.filesystem":
		return "link", reflect.String, "string", nil
	case "link.file.gid":
		return "link", reflect.Int, "int", nil
	case "link.file.group":
		return "link", reflect.String, "string", nil
	case "link.file.hashes":
		return "link", reflect.String, "string", nil
	case "link.file.in_upper_layer":
		return "link", reflect.Bool, "bool", nil
	case "link.file.inode":
		return "link", reflect.Int, "int", nil
	case "link.file.mode":
		return "link", reflect.Int, "int", nil
	case "link.file.modification_time":
		return "link", reflect.Int, "int", nil
	case "link.file.mount_id":
		return "link", reflect.Int, "int", nil
	case "link.file.name":
		return "link", reflect.String, "string", nil
	case "link.file.name.length":
		return "link", reflect.Int, "int", nil
	case "link.file.package.name":
		return "link", reflect.String, "string", nil
	case "link.file.package.source_version":
		return "link", reflect.String, "string", nil
	case "link.file.package.version":
		return "link", reflect.String, "string", nil
	case "link.file.path":
		return "link", reflect.String, "string", nil
	case "link.file.path.length":
		return "link", reflect.Int, "int", nil
	case "link.file.rights":
		return "link", reflect.Int, "int", nil
	case "link.file.uid":
		return "link", reflect.Int, "int", nil
	case "link.file.user":
		return "link", reflect.String, "string", nil
	case "link.retval":
		return "link", reflect.Int, "int", nil
	case "link.syscall.destination.path":
		return "link", reflect.String, "string", nil
	case "link.syscall.path":
		return "link", reflect.String, "string", nil
	case "load_module.args":
		return "load_module", reflect.String, "string", nil
	case "load_module.args_truncated":
		return "load_module", reflect.Bool, "bool", nil
	case "load_module.argv":
		return "load_module", reflect.String, "string", nil
	case "load_module.file.change_time":
		return "load_module", reflect.Int, "int", nil
	case "load_module.file.filesystem":
		return "load_module", reflect.String, "string", nil
	case "load_module.file.gid":
		return "load_module", reflect.Int, "int", nil
	case "load_module.file.group":
		return "load_module", reflect.String, "string", nil
	case "load_module.file.hashes":
		return "load_module", reflect.String, "string", nil
	case "load_module.file.in_upper_layer":
		return "load_module", reflect.Bool, "bool", nil
	case "load_module.file.inode":
		return "load_module", reflect.Int, "int", nil
	case "load_module.file.mode":
		return "load_module", reflect.Int, "int", nil
	case "load_module.file.modification_time":
		return "load_module", reflect.Int, "int", nil
	case "load_module.file.mount_id":
		return "load_module", reflect.Int, "int", nil
	case "load_module.file.name":
		return "load_module", reflect.String, "string", nil
	case "load_module.file.name.length":
		return "load_module", reflect.Int, "int", nil
	case "load_module.file.package.name":
		return "load_module", reflect.String, "string", nil
	case "load_module.file.package.source_version":
		return "load_module", reflect.String, "string", nil
	case "load_module.file.package.version":
		return "load_module", reflect.String, "string", nil
	case "load_module.file.path":
		return "load_module", reflect.String, "string", nil
	case "load_module.file.path.length":
		return "load_module", reflect.Int, "int", nil
	case "load_module.file.rights":
		return "load_module", reflect.Int, "int", nil
	case "load_module.file.uid":
		return "load_module", reflect.Int, "int", nil
	case "load_module.file.user":
		return "load_module", reflect.String, "string", nil
	case "load_module.loaded_from_memory":
		return "load_module", reflect.Bool, "bool", nil
	case "load_module.name":
		return "load_module", reflect.String, "string", nil
	case "load_module.retval":
		return "load_module", reflect.Int, "int", nil
	case "mkdir.file.change_time":
		return "mkdir", reflect.Int, "int", nil
	case "mkdir.file.destination.mode":
		return "mkdir", reflect.Int, "int", nil
	case "mkdir.file.destination.rights":
		return "mkdir", reflect.Int, "int", nil
	case "mkdir.file.filesystem":
		return "mkdir", reflect.String, "string", nil
	case "mkdir.file.gid":
		return "mkdir", reflect.Int, "int", nil
	case "mkdir.file.group":
		return "mkdir", reflect.String, "string", nil
	case "mkdir.file.hashes":
		return "mkdir", reflect.String, "string", nil
	case "mkdir.file.in_upper_layer":
		return "mkdir", reflect.Bool, "bool", nil
	case "mkdir.file.inode":
		return "mkdir", reflect.Int, "int", nil
	case "mkdir.file.mode":
		return "mkdir", reflect.Int, "int", nil
	case "mkdir.file.modification_time":
		return "mkdir", reflect.Int, "int", nil
	case "mkdir.file.mount_id":
		return "mkdir", reflect.Int, "int", nil
	case "mkdir.file.name":
		return "mkdir", reflect.String, "string", nil
	case "mkdir.file.name.length":
		return "mkdir", reflect.Int, "int", nil
	case "mkdir.file.package.name":
		return "mkdir", reflect.String, "string", nil
	case "mkdir.file.package.source_version":
		return "mkdir", reflect.String, "string", nil
	case "mkdir.file.package.version":
		return "mkdir", reflect.String, "string", nil
	case "mkdir.file.path":
		return "mkdir", reflect.String, "string", nil
	case "mkdir.file.path.length":
		return "mkdir", reflect.Int, "int", nil
	case "mkdir.file.rights":
		return "mkdir", reflect.Int, "int", nil
	case "mkdir.file.uid":
		return "mkdir", reflect.Int, "int", nil
	case "mkdir.file.user":
		return "mkdir", reflect.String, "string", nil
	case "mkdir.retval":
		return "mkdir", reflect.Int, "int", nil
	case "mkdir.syscall.mode":
		return "mkdir", reflect.Int, "int", nil
	case "mkdir.syscall.path":
		return "mkdir", reflect.String, "string", nil
	case "mmap.file.change_time":
		return "mmap", reflect.Int, "int", nil
	case "mmap.file.filesystem":
		return "mmap", reflect.String, "string", nil
	case "mmap.file.gid":
		return "mmap", reflect.Int, "int", nil
	case "mmap.file.group":
		return "mmap", reflect.String, "string", nil
	case "mmap.file.hashes":
		return "mmap", reflect.String, "string", nil
	case "mmap.file.in_upper_layer":
		return "mmap", reflect.Bool, "bool", nil
	case "mmap.file.inode":
		return "mmap", reflect.Int, "int", nil
	case "mmap.file.mode":
		return "mmap", reflect.Int, "int", nil
	case "mmap.file.modification_time":
		return "mmap", reflect.Int, "int", nil
	case "mmap.file.mount_id":
		return "mmap", reflect.Int, "int", nil
	case "mmap.file.name":
		return "mmap", reflect.String, "string", nil
	case "mmap.file.name.length":
		return "mmap", reflect.Int, "int", nil
	case "mmap.file.package.name":
		return "mmap", reflect.String, "string", nil
	case "mmap.file.package.source_version":
		return "mmap", reflect.String, "string", nil
	case "mmap.file.package.version":
		return "mmap", reflect.String, "string", nil
	case "mmap.file.path":
		return "mmap", reflect.String, "string", nil
	case "mmap.file.path.length":
		return "mmap", reflect.Int, "int", nil
	case "mmap.file.rights":
		return "mmap", reflect.Int, "int", nil
	case "mmap.file.uid":
		return "mmap", reflect.Int, "int", nil
	case "mmap.file.user":
		return "mmap", reflect.String, "string", nil
	case "mmap.flags":
		return "mmap", reflect.Int, "int", nil
	case "mmap.protection":
		return "mmap", reflect.Int, "int", nil
	case "mmap.retval":
		return "mmap", reflect.Int, "int", nil
	case "mount.fs_type":
		return "mount", reflect.String, "string", nil
	case "mount.mountpoint.path":
		return "mount", reflect.String, "string", nil
	case "mount.retval":
		return "mount", reflect.Int, "int", nil
	case "mount.root.path":
		return "mount", reflect.String, "string", nil
	case "mount.source.path":
		return "mount", reflect.String, "string", nil
	case "mount.syscall.fs_type":
		return "mount", reflect.String, "string", nil
	case "mount.syscall.mountpoint.path":
		return "mount", reflect.String, "string", nil
	case "mount.syscall.source.path":
		return "mount", reflect.String, "string", nil
	case "mprotect.req_protection":
		return "mprotect", reflect.Int, "int", nil
	case "mprotect.retval":
		return "mprotect", reflect.Int, "int", nil
	case "mprotect.vm_protection":
		return "mprotect", reflect.Int, "int", nil
	case "network.destination.ip":
		return "", reflect.Struct, "net.IPNet", nil
	case "network.destination.is_public":
		return "", reflect.Bool, "bool", nil
	case "network.destination.port":
		return "", reflect.Int, "int", nil
	case "network.device.ifname":
		return "", reflect.String, "string", nil
	case "network.l3_protocol":
		return "", reflect.Int, "int", nil
	case "network.l4_protocol":
		return "", reflect.Int, "int", nil
	case "network.network_direction":
		return "", reflect.Int, "int", nil
	case "network.size":
		return "", reflect.Int, "int", nil
	case "network.source.ip":
		return "", reflect.Struct, "net.IPNet", nil
	case "network.source.is_public":
		return "", reflect.Bool, "bool", nil
	case "network.source.port":
		return "", reflect.Int, "int", nil
	case "network_flow_monitor.device.ifname":
		return "network_flow_monitor", reflect.String, "string", nil
	case "network_flow_monitor.flows.destination.ip":
		return "network_flow_monitor", reflect.Struct, "net.IPNet", nil
	case "network_flow_monitor.flows.destination.is_public":
		return "network_flow_monitor", reflect.Bool, "bool", nil
	case "network_flow_monitor.flows.destination.port":
		return "network_flow_monitor", reflect.Int, "int", nil
	case "network_flow_monitor.flows.egress.data_size":
		return "network_flow_monitor", reflect.Int, "int", nil
	case "network_flow_monitor.flows.egress.packet_count":
		return "network_flow_monitor", reflect.Int, "int", nil
	case "network_flow_monitor.flows.ingress.data_size":
		return "network_flow_monitor", reflect.Int, "int", nil
	case "network_flow_monitor.flows.ingress.packet_count":
		return "network_flow_monitor", reflect.Int, "int", nil
	case "network_flow_monitor.flows.l3_protocol":
		return "network_flow_monitor", reflect.Int, "int", nil
	case "network_flow_monitor.flows.l4_protocol":
		return "network_flow_monitor", reflect.Int, "int", nil
	case "network_flow_monitor.flows.length":
		return "network_flow_monitor", reflect.Int, "int", nil
	case "network_flow_monitor.flows.source.ip":
		return "network_flow_monitor", reflect.Struct, "net.IPNet", nil
	case "network_flow_monitor.flows.source.is_public":
		return "network_flow_monitor", reflect.Bool, "bool", nil
	case "network_flow_monitor.flows.source.port":
		return "network_flow_monitor", reflect.Int, "int", nil
	case "ondemand.arg1.str":
		return "ondemand", reflect.String, "string", nil
	case "ondemand.arg1.uint":
		return "ondemand", reflect.Int, "int", nil
	case "ondemand.arg2.str":
		return "ondemand", reflect.String, "string", nil
	case "ondemand.arg2.uint":
		return "ondemand", reflect.Int, "int", nil
	case "ondemand.arg3.str":
		return "ondemand", reflect.String, "string", nil
	case "ondemand.arg3.uint":
		return "ondemand", reflect.Int, "int", nil
	case "ondemand.arg4.str":
		return "ondemand", reflect.String, "string", nil
	case "ondemand.arg4.uint":
		return "ondemand", reflect.Int, "int", nil
	case "ondemand.arg5.str":
		return "ondemand", reflect.String, "string", nil
	case "ondemand.arg5.uint":
		return "ondemand", reflect.Int, "int", nil
	case "ondemand.arg6.str":
		return "ondemand", reflect.String, "string", nil
	case "ondemand.arg6.uint":
		return "ondemand", reflect.Int, "int", nil
	case "ondemand.name":
		return "ondemand", reflect.String, "string", nil
	case "open.file.change_time":
		return "open", reflect.Int, "int", nil
	case "open.file.destination.mode":
		return "open", reflect.Int, "int", nil
	case "open.file.filesystem":
		return "open", reflect.String, "string", nil
	case "open.file.gid":
		return "open", reflect.Int, "int", nil
	case "open.file.group":
		return "open", reflect.String, "string", nil
	case "open.file.hashes":
		return "open", reflect.String, "string", nil
	case "open.file.in_upper_layer":
		return "open", reflect.Bool, "bool", nil
	case "open.file.inode":
		return "open", reflect.Int, "int", nil
	case "open.file.mode":
		return "open", reflect.Int, "int", nil
	case "open.file.modification_time":
		return "open", reflect.Int, "int", nil
	case "open.file.mount_id":
		return "open", reflect.Int, "int", nil
	case "open.file.name":
		return "open", reflect.String, "string", nil
	case "open.file.name.length":
		return "open", reflect.Int, "int", nil
	case "open.file.package.name":
		return "open", reflect.String, "string", nil
	case "open.file.package.source_version":
		return "open", reflect.String, "string", nil
	case "open.file.package.version":
		return "open", reflect.String, "string", nil
	case "open.file.path":
		return "open", reflect.String, "string", nil
	case "open.file.path.length":
		return "open", reflect.Int, "int", nil
	case "open.file.rights":
		return "open", reflect.Int, "int", nil
	case "open.file.uid":
		return "open", reflect.Int, "int", nil
	case "open.file.user":
		return "open", reflect.String, "string", nil
	case "open.flags":
		return "open", reflect.Int, "int", nil
	case "open.retval":
		return "open", reflect.Int, "int", nil
	case "open.syscall.flags":
		return "open", reflect.Int, "int", nil
	case "open.syscall.mode":
		return "open", reflect.Int, "int", nil
	case "open.syscall.path":
		return "open", reflect.String, "string", nil
	case "packet.destination.ip":
		return "packet", reflect.Struct, "net.IPNet", nil
	case "packet.destination.is_public":
		return "packet", reflect.Bool, "bool", nil
	case "packet.destination.port":
		return "packet", reflect.Int, "int", nil
	case "packet.device.ifname":
		return "packet", reflect.String, "string", nil
	case "packet.filter":
		return "packet", reflect.String, "string", nil
	case "packet.l3_protocol":
		return "packet", reflect.Int, "int", nil
	case "packet.l4_protocol":
		return "packet", reflect.Int, "int", nil
	case "packet.network_direction":
		return "packet", reflect.Int, "int", nil
	case "packet.size":
		return "packet", reflect.Int, "int", nil
	case "packet.source.ip":
		return "packet", reflect.Struct, "net.IPNet", nil
	case "packet.source.is_public":
		return "packet", reflect.Bool, "bool", nil
	case "packet.source.port":
		return "packet", reflect.Int, "int", nil
	case "packet.tls.version":
		return "packet", reflect.Int, "int", nil
	case "process.ancestors.args":
		return "", reflect.String, "string", nil
	case "process.ancestors.args_flags":
		return "", reflect.String, "string", nil
	case "process.ancestors.args_options":
		return "", reflect.String, "string", nil
	case "process.ancestors.args_truncated":
		return "", reflect.Bool, "bool", nil
	case "process.ancestors.argv":
		return "", reflect.String, "string", nil
	case "process.ancestors.argv0":
		return "", reflect.String, "string", nil
	case "process.ancestors.auid":
		return "", reflect.Int, "int", nil
	case "process.ancestors.cap_effective":
		return "", reflect.Int, "int", nil
	case "process.ancestors.cap_permitted":
		return "", reflect.Int, "int", nil
	case "process.ancestors.cgroup.file.inode":
		return "", reflect.Int, "int", nil
	case "process.ancestors.cgroup.file.mount_id":
		return "", reflect.Int, "int", nil
	case "process.ancestors.cgroup.id":
		return "", reflect.String, "string", nil
	case "process.ancestors.cgroup.manager":
		return "", reflect.String, "string", nil
	case "process.ancestors.cgroup.version":
		return "", reflect.Int, "int", nil
	case "process.ancestors.comm":
		return "", reflect.String, "string", nil
	case "process.ancestors.container.id":
		return "", reflect.String, "string", nil
	case "process.ancestors.created_at":
		return "", reflect.Int, "int", nil
	case "process.ancestors.egid":
		return "", reflect.Int, "int", nil
	case "process.ancestors.egroup":
		return "", reflect.String, "string", nil
	case "process.ancestors.envp":
		return "", reflect.String, "string", nil
	case "process.ancestors.envs":
		return "", reflect.String, "string", nil
	case "process.ancestors.envs_truncated":
		return "", reflect.Bool, "bool", nil
	case "process.ancestors.euid":
		return "", reflect.Int, "int", nil
	case "process.ancestors.euser":
		return "", reflect.String, "string", nil
	case "process.ancestors.file.change_time":
		return "", reflect.Int, "int", nil
	case "process.ancestors.file.filesystem":
		return "", reflect.String, "string", nil
	case "process.ancestors.file.gid":
		return "", reflect.Int, "int", nil
	case "process.ancestors.file.group":
		return "", reflect.String, "string", nil
	case "process.ancestors.file.hashes":
		return "", reflect.String, "string", nil
	case "process.ancestors.file.in_upper_layer":
		return "", reflect.Bool, "bool", nil
	case "process.ancestors.file.inode":
		return "", reflect.Int, "int", nil
	case "process.ancestors.file.mode":
		return "", reflect.Int, "int", nil
	case "process.ancestors.file.modification_time":
		return "", reflect.Int, "int", nil
	case "process.ancestors.file.mount_id":
		return "", reflect.Int, "int", nil
	case "process.ancestors.file.name":
		return "", reflect.String, "string", nil
	case "process.ancestors.file.name.length":
		return "", reflect.Int, "int", nil
	case "process.ancestors.file.package.name":
		return "", reflect.String, "string", nil
	case "process.ancestors.file.package.source_version":
		return "", reflect.String, "string", nil
	case "process.ancestors.file.package.version":
		return "", reflect.String, "string", nil
	case "process.ancestors.file.path":
		return "", reflect.String, "string", nil
	case "process.ancestors.file.path.length":
		return "", reflect.Int, "int", nil
	case "process.ancestors.file.rights":
		return "", reflect.Int, "int", nil
	case "process.ancestors.file.uid":
		return "", reflect.Int, "int", nil
	case "process.ancestors.file.user":
		return "", reflect.String, "string", nil
	case "process.ancestors.fsgid":
		return "", reflect.Int, "int", nil
	case "process.ancestors.fsgroup":
		return "", reflect.String, "string", nil
	case "process.ancestors.fsuid":
		return "", reflect.Int, "int", nil
	case "process.ancestors.fsuser":
		return "", reflect.String, "string", nil
	case "process.ancestors.gid":
		return "", reflect.Int, "int", nil
	case "process.ancestors.group":
		return "", reflect.String, "string", nil
	case "process.ancestors.interpreter.file.change_time":
		return "", reflect.Int, "int", nil
	case "process.ancestors.interpreter.file.filesystem":
		return "", reflect.String, "string", nil
	case "process.ancestors.interpreter.file.gid":
		return "", reflect.Int, "int", nil
	case "process.ancestors.interpreter.file.group":
		return "", reflect.String, "string", nil
	case "process.ancestors.interpreter.file.hashes":
		return "", reflect.String, "string", nil
	case "process.ancestors.interpreter.file.in_upper_layer":
		return "", reflect.Bool, "bool", nil
	case "process.ancestors.interpreter.file.inode":
		return "", reflect.Int, "int", nil
	case "process.ancestors.interpreter.file.mode":
		return "", reflect.Int, "int", nil
	case "process.ancestors.interpreter.file.modification_time":
		return "", reflect.Int, "int", nil
	case "process.ancestors.interpreter.file.mount_id":
		return "", reflect.Int, "int", nil
	case "process.ancestors.interpreter.file.name":
		return "", reflect.String, "string", nil
	case "process.ancestors.interpreter.file.name.length":
		return "", reflect.Int, "int", nil
	case "process.ancestors.interpreter.file.package.name":
		return "", reflect.String, "string", nil
	case "process.ancestors.interpreter.file.package.source_version":
		return "", reflect.String, "string", nil
	case "process.ancestors.interpreter.file.package.version":
		return "", reflect.String, "string", nil
	case "process.ancestors.interpreter.file.path":
		return "", reflect.String, "string", nil
	case "process.ancestors.interpreter.file.path.length":
		return "", reflect.Int, "int", nil
	case "process.ancestors.interpreter.file.rights":
		return "", reflect.Int, "int", nil
	case "process.ancestors.interpreter.file.uid":
		return "", reflect.Int, "int", nil
	case "process.ancestors.interpreter.file.user":
		return "", reflect.String, "string", nil
	case "process.ancestors.is_exec":
		return "", reflect.Bool, "bool", nil
	case "process.ancestors.is_kworker":
		return "", reflect.Bool, "bool", nil
	case "process.ancestors.is_thread":
		return "", reflect.Bool, "bool", nil
	case "process.ancestors.length":
		return "", reflect.Int, "int", nil
	case "process.ancestors.pid":
		return "", reflect.Int, "int", nil
	case "process.ancestors.ppid":
		return "", reflect.Int, "int", nil
	case "process.ancestors.tid":
		return "", reflect.Int, "int", nil
	case "process.ancestors.tty_name":
		return "", reflect.String, "string", nil
	case "process.ancestors.uid":
		return "", reflect.Int, "int", nil
	case "process.ancestors.user":
		return "", reflect.String, "string", nil
	case "process.ancestors.user_session.k8s_groups":
		return "", reflect.String, "string", nil
	case "process.ancestors.user_session.k8s_uid":
		return "", reflect.String, "string", nil
	case "process.ancestors.user_session.k8s_username":
		return "", reflect.String, "string", nil
	case "process.args":
		return "", reflect.String, "string", nil
	case "process.args_flags":
		return "", reflect.String, "string", nil
	case "process.args_options":
		return "", reflect.String, "string", nil
	case "process.args_truncated":
		return "", reflect.Bool, "bool", nil
	case "process.argv":
		return "", reflect.String, "string", nil
	case "process.argv0":
		return "", reflect.String, "string", nil
	case "process.auid":
		return "", reflect.Int, "int", nil
	case "process.cap_effective":
		return "", reflect.Int, "int", nil
	case "process.cap_permitted":
		return "", reflect.Int, "int", nil
	case "process.cgroup.file.inode":
		return "", reflect.Int, "int", nil
	case "process.cgroup.file.mount_id":
		return "", reflect.Int, "int", nil
	case "process.cgroup.id":
		return "", reflect.String, "string", nil
	case "process.cgroup.manager":
		return "", reflect.String, "string", nil
	case "process.cgroup.version":
		return "", reflect.Int, "int", nil
	case "process.comm":
		return "", reflect.String, "string", nil
	case "process.container.id":
		return "", reflect.String, "string", nil
	case "process.created_at":
		return "", reflect.Int, "int", nil
	case "process.egid":
		return "", reflect.Int, "int", nil
	case "process.egroup":
		return "", reflect.String, "string", nil
	case "process.envp":
		return "", reflect.String, "string", nil
	case "process.envs":
		return "", reflect.String, "string", nil
	case "process.envs_truncated":
		return "", reflect.Bool, "bool", nil
	case "process.euid":
		return "", reflect.Int, "int", nil
	case "process.euser":
		return "", reflect.String, "string", nil
	case "process.file.change_time":
		return "", reflect.Int, "int", nil
	case "process.file.filesystem":
		return "", reflect.String, "string", nil
	case "process.file.gid":
		return "", reflect.Int, "int", nil
	case "process.file.group":
		return "", reflect.String, "string", nil
	case "process.file.hashes":
		return "", reflect.String, "string", nil
	case "process.file.in_upper_layer":
		return "", reflect.Bool, "bool", nil
	case "process.file.inode":
		return "", reflect.Int, "int", nil
	case "process.file.mode":
		return "", reflect.Int, "int", nil
	case "process.file.modification_time":
		return "", reflect.Int, "int", nil
	case "process.file.mount_id":
		return "", reflect.Int, "int", nil
	case "process.file.name":
		return "", reflect.String, "string", nil
	case "process.file.name.length":
		return "", reflect.Int, "int", nil
	case "process.file.package.name":
		return "", reflect.String, "string", nil
	case "process.file.package.source_version":
		return "", reflect.String, "string", nil
	case "process.file.package.version":
		return "", reflect.String, "string", nil
	case "process.file.path":
		return "", reflect.String, "string", nil
	case "process.file.path.length":
		return "", reflect.Int, "int", nil
	case "process.file.rights":
		return "", reflect.Int, "int", nil
	case "process.file.uid":
		return "", reflect.Int, "int", nil
	case "process.file.user":
		return "", reflect.String, "string", nil
	case "process.fsgid":
		return "", reflect.Int, "int", nil
	case "process.fsgroup":
		return "", reflect.String, "string", nil
	case "process.fsuid":
		return "", reflect.Int, "int", nil
	case "process.fsuser":
		return "", reflect.String, "string", nil
	case "process.gid":
		return "", reflect.Int, "int", nil
	case "process.group":
		return "", reflect.String, "string", nil
	case "process.interpreter.file.change_time":
		return "", reflect.Int, "int", nil
	case "process.interpreter.file.filesystem":
		return "", reflect.String, "string", nil
	case "process.interpreter.file.gid":
		return "", reflect.Int, "int", nil
	case "process.interpreter.file.group":
		return "", reflect.String, "string", nil
	case "process.interpreter.file.hashes":
		return "", reflect.String, "string", nil
	case "process.interpreter.file.in_upper_layer":
		return "", reflect.Bool, "bool", nil
	case "process.interpreter.file.inode":
		return "", reflect.Int, "int", nil
	case "process.interpreter.file.mode":
		return "", reflect.Int, "int", nil
	case "process.interpreter.file.modification_time":
		return "", reflect.Int, "int", nil
	case "process.interpreter.file.mount_id":
		return "", reflect.Int, "int", nil
	case "process.interpreter.file.name":
		return "", reflect.String, "string", nil
	case "process.interpreter.file.name.length":
		return "", reflect.Int, "int", nil
	case "process.interpreter.file.package.name":
		return "", reflect.String, "string", nil
	case "process.interpreter.file.package.source_version":
		return "", reflect.String, "string", nil
	case "process.interpreter.file.package.version":
		return "", reflect.String, "string", nil
	case "process.interpreter.file.path":
		return "", reflect.String, "string", nil
	case "process.interpreter.file.path.length":
		return "", reflect.Int, "int", nil
	case "process.interpreter.file.rights":
		return "", reflect.Int, "int", nil
	case "process.interpreter.file.uid":
		return "", reflect.Int, "int", nil
	case "process.interpreter.file.user":
		return "", reflect.String, "string", nil
	case "process.is_exec":
		return "", reflect.Bool, "bool", nil
	case "process.is_kworker":
		return "", reflect.Bool, "bool", nil
	case "process.is_thread":
		return "", reflect.Bool, "bool", nil
	case "process.parent.args":
		return "", reflect.String, "string", nil
	case "process.parent.args_flags":
		return "", reflect.String, "string", nil
	case "process.parent.args_options":
		return "", reflect.String, "string", nil
	case "process.parent.args_truncated":
		return "", reflect.Bool, "bool", nil
	case "process.parent.argv":
		return "", reflect.String, "string", nil
	case "process.parent.argv0":
		return "", reflect.String, "string", nil
	case "process.parent.auid":
		return "", reflect.Int, "int", nil
	case "process.parent.cap_effective":
		return "", reflect.Int, "int", nil
	case "process.parent.cap_permitted":
		return "", reflect.Int, "int", nil
	case "process.parent.cgroup.file.inode":
		return "", reflect.Int, "int", nil
	case "process.parent.cgroup.file.mount_id":
		return "", reflect.Int, "int", nil
	case "process.parent.cgroup.id":
		return "", reflect.String, "string", nil
	case "process.parent.cgroup.manager":
		return "", reflect.String, "string", nil
	case "process.parent.cgroup.version":
		return "", reflect.Int, "int", nil
	case "process.parent.comm":
		return "", reflect.String, "string", nil
	case "process.parent.container.id":
		return "", reflect.String, "string", nil
	case "process.parent.created_at":
		return "", reflect.Int, "int", nil
	case "process.parent.egid":
		return "", reflect.Int, "int", nil
	case "process.parent.egroup":
		return "", reflect.String, "string", nil
	case "process.parent.envp":
		return "", reflect.String, "string", nil
	case "process.parent.envs":
		return "", reflect.String, "string", nil
	case "process.parent.envs_truncated":
		return "", reflect.Bool, "bool", nil
	case "process.parent.euid":
		return "", reflect.Int, "int", nil
	case "process.parent.euser":
		return "", reflect.String, "string", nil
	case "process.parent.file.change_time":
		return "", reflect.Int, "int", nil
	case "process.parent.file.filesystem":
		return "", reflect.String, "string", nil
	case "process.parent.file.gid":
		return "", reflect.Int, "int", nil
	case "process.parent.file.group":
		return "", reflect.String, "string", nil
	case "process.parent.file.hashes":
		return "", reflect.String, "string", nil
	case "process.parent.file.in_upper_layer":
		return "", reflect.Bool, "bool", nil
	case "process.parent.file.inode":
		return "", reflect.Int, "int", nil
	case "process.parent.file.mode":
		return "", reflect.Int, "int", nil
	case "process.parent.file.modification_time":
		return "", reflect.Int, "int", nil
	case "process.parent.file.mount_id":
		return "", reflect.Int, "int", nil
	case "process.parent.file.name":
		return "", reflect.String, "string", nil
	case "process.parent.file.name.length":
		return "", reflect.Int, "int", nil
	case "process.parent.file.package.name":
		return "", reflect.String, "string", nil
	case "process.parent.file.package.source_version":
		return "", reflect.String, "string", nil
	case "process.parent.file.package.version":
		return "", reflect.String, "string", nil
	case "process.parent.file.path":
		return "", reflect.String, "string", nil
	case "process.parent.file.path.length":
		return "", reflect.Int, "int", nil
	case "process.parent.file.rights":
		return "", reflect.Int, "int", nil
	case "process.parent.file.uid":
		return "", reflect.Int, "int", nil
	case "process.parent.file.user":
		return "", reflect.String, "string", nil
	case "process.parent.fsgid":
		return "", reflect.Int, "int", nil
	case "process.parent.fsgroup":
		return "", reflect.String, "string", nil
	case "process.parent.fsuid":
		return "", reflect.Int, "int", nil
	case "process.parent.fsuser":
		return "", reflect.String, "string", nil
	case "process.parent.gid":
		return "", reflect.Int, "int", nil
	case "process.parent.group":
		return "", reflect.String, "string", nil
	case "process.parent.interpreter.file.change_time":
		return "", reflect.Int, "int", nil
	case "process.parent.interpreter.file.filesystem":
		return "", reflect.String, "string", nil
	case "process.parent.interpreter.file.gid":
		return "", reflect.Int, "int", nil
	case "process.parent.interpreter.file.group":
		return "", reflect.String, "string", nil
	case "process.parent.interpreter.file.hashes":
		return "", reflect.String, "string", nil
	case "process.parent.interpreter.file.in_upper_layer":
		return "", reflect.Bool, "bool", nil
	case "process.parent.interpreter.file.inode":
		return "", reflect.Int, "int", nil
	case "process.parent.interpreter.file.mode":
		return "", reflect.Int, "int", nil
	case "process.parent.interpreter.file.modification_time":
		return "", reflect.Int, "int", nil
	case "process.parent.interpreter.file.mount_id":
		return "", reflect.Int, "int", nil
	case "process.parent.interpreter.file.name":
		return "", reflect.String, "string", nil
	case "process.parent.interpreter.file.name.length":
		return "", reflect.Int, "int", nil
	case "process.parent.interpreter.file.package.name":
		return "", reflect.String, "string", nil
	case "process.parent.interpreter.file.package.source_version":
		return "", reflect.String, "string", nil
	case "process.parent.interpreter.file.package.version":
		return "", reflect.String, "string", nil
	case "process.parent.interpreter.file.path":
		return "", reflect.String, "string", nil
	case "process.parent.interpreter.file.path.length":
		return "", reflect.Int, "int", nil
	case "process.parent.interpreter.file.rights":
		return "", reflect.Int, "int", nil
	case "process.parent.interpreter.file.uid":
		return "", reflect.Int, "int", nil
	case "process.parent.interpreter.file.user":
		return "", reflect.String, "string", nil
	case "process.parent.is_exec":
		return "", reflect.Bool, "bool", nil
	case "process.parent.is_kworker":
		return "", reflect.Bool, "bool", nil
	case "process.parent.is_thread":
		return "", reflect.Bool, "bool", nil
	case "process.parent.pid":
		return "", reflect.Int, "int", nil
	case "process.parent.ppid":
		return "", reflect.Int, "int", nil
	case "process.parent.tid":
		return "", reflect.Int, "int", nil
	case "process.parent.tty_name":
		return "", reflect.String, "string", nil
	case "process.parent.uid":
		return "", reflect.Int, "int", nil
	case "process.parent.user":
		return "", reflect.String, "string", nil
	case "process.parent.user_session.k8s_groups":
		return "", reflect.String, "string", nil
	case "process.parent.user_session.k8s_uid":
		return "", reflect.String, "string", nil
	case "process.parent.user_session.k8s_username":
		return "", reflect.String, "string", nil
	case "process.pid":
		return "", reflect.Int, "int", nil
	case "process.ppid":
		return "", reflect.Int, "int", nil
	case "process.tid":
		return "", reflect.Int, "int", nil
	case "process.tty_name":
		return "", reflect.String, "string", nil
	case "process.uid":
		return "", reflect.Int, "int", nil
	case "process.user":
		return "", reflect.String, "string", nil
	case "process.user_session.k8s_groups":
		return "", reflect.String, "string", nil
	case "process.user_session.k8s_uid":
		return "", reflect.String, "string", nil
	case "process.user_session.k8s_username":
		return "", reflect.String, "string", nil
	case "ptrace.request":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.retval":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.args":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.args_flags":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.args_options":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.args_truncated":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.ancestors.argv":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.argv0":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.auid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.cap_effective":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.cap_permitted":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.cgroup.file.inode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.cgroup.file.mount_id":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.cgroup.id":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.cgroup.manager":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.cgroup.version":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.comm":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.container.id":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.created_at":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.egid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.egroup":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.envp":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.envs":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.envs_truncated":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.ancestors.euid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.euser":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.file.change_time":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.file.filesystem":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.file.gid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.file.group":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.file.hashes":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.file.in_upper_layer":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.ancestors.file.inode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.file.mode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.file.modification_time":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.file.mount_id":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.file.name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.file.name.length":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.file.package.name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.file.package.source_version":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.file.package.version":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.file.path":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.file.path.length":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.file.rights":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.file.uid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.file.user":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.fsgid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.fsgroup":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.fsuid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.fsuser":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.gid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.group":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.interpreter.file.change_time":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.interpreter.file.filesystem":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.interpreter.file.gid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.interpreter.file.group":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.interpreter.file.hashes":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.interpreter.file.in_upper_layer":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.ancestors.interpreter.file.inode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.interpreter.file.mode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.interpreter.file.modification_time":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.interpreter.file.mount_id":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.interpreter.file.name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.interpreter.file.name.length":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.interpreter.file.package.name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.interpreter.file.package.source_version":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.interpreter.file.package.version":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.interpreter.file.path":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.interpreter.file.path.length":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.interpreter.file.rights":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.interpreter.file.uid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.interpreter.file.user":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.is_exec":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.ancestors.is_kworker":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.ancestors.is_thread":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.ancestors.length":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.pid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.ppid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.tid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.tty_name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.uid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ancestors.user":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.user_session.k8s_groups":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.user_session.k8s_uid":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.ancestors.user_session.k8s_username":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.args":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.args_flags":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.args_options":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.args_truncated":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.argv":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.argv0":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.auid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.cap_effective":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.cap_permitted":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.cgroup.file.inode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.cgroup.file.mount_id":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.cgroup.id":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.cgroup.manager":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.cgroup.version":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.comm":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.container.id":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.created_at":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.egid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.egroup":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.envp":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.envs":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.envs_truncated":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.euid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.euser":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.file.change_time":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.file.filesystem":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.file.gid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.file.group":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.file.hashes":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.file.in_upper_layer":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.file.inode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.file.mode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.file.modification_time":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.file.mount_id":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.file.name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.file.name.length":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.file.package.name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.file.package.source_version":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.file.package.version":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.file.path":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.file.path.length":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.file.rights":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.file.uid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.file.user":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.fsgid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.fsgroup":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.fsuid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.fsuser":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.gid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.group":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.interpreter.file.change_time":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.interpreter.file.filesystem":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.interpreter.file.gid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.interpreter.file.group":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.interpreter.file.hashes":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.interpreter.file.in_upper_layer":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.interpreter.file.inode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.interpreter.file.mode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.interpreter.file.modification_time":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.interpreter.file.mount_id":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.interpreter.file.name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.interpreter.file.name.length":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.interpreter.file.package.name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.interpreter.file.package.source_version":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.interpreter.file.package.version":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.interpreter.file.path":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.interpreter.file.path.length":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.interpreter.file.rights":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.interpreter.file.uid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.interpreter.file.user":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.is_exec":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.is_kworker":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.is_thread":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.parent.args":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.args_flags":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.args_options":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.args_truncated":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.parent.argv":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.argv0":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.auid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.cap_effective":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.cap_permitted":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.cgroup.file.inode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.cgroup.file.mount_id":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.cgroup.id":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.cgroup.manager":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.cgroup.version":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.comm":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.container.id":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.created_at":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.egid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.egroup":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.envp":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.envs":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.envs_truncated":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.parent.euid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.euser":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.file.change_time":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.file.filesystem":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.file.gid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.file.group":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.file.hashes":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.file.in_upper_layer":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.parent.file.inode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.file.mode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.file.modification_time":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.file.mount_id":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.file.name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.file.name.length":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.file.package.name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.file.package.source_version":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.file.package.version":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.file.path":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.file.path.length":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.file.rights":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.file.uid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.file.user":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.fsgid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.fsgroup":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.fsuid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.fsuser":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.gid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.group":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.interpreter.file.change_time":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.interpreter.file.filesystem":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.interpreter.file.gid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.interpreter.file.group":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.interpreter.file.hashes":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.interpreter.file.in_upper_layer":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.parent.interpreter.file.inode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.interpreter.file.mode":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.interpreter.file.modification_time":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.interpreter.file.mount_id":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.interpreter.file.name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.interpreter.file.name.length":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.interpreter.file.package.name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.interpreter.file.package.source_version":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.interpreter.file.package.version":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.interpreter.file.path":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.interpreter.file.path.length":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.interpreter.file.rights":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.interpreter.file.uid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.interpreter.file.user":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.is_exec":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.parent.is_kworker":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.parent.is_thread":
		return "ptrace", reflect.Bool, "bool", nil
	case "ptrace.tracee.parent.pid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.ppid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.tid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.tty_name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.uid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.parent.user":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.user_session.k8s_groups":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.user_session.k8s_uid":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.parent.user_session.k8s_username":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.pid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.ppid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.tid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.tty_name":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.uid":
		return "ptrace", reflect.Int, "int", nil
	case "ptrace.tracee.user":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.user_session.k8s_groups":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.user_session.k8s_uid":
		return "ptrace", reflect.String, "string", nil
	case "ptrace.tracee.user_session.k8s_username":
		return "ptrace", reflect.String, "string", nil
	case "removexattr.file.change_time":
		return "removexattr", reflect.Int, "int", nil
	case "removexattr.file.destination.name":
		return "removexattr", reflect.String, "string", nil
	case "removexattr.file.destination.namespace":
		return "removexattr", reflect.String, "string", nil
	case "removexattr.file.filesystem":
		return "removexattr", reflect.String, "string", nil
	case "removexattr.file.gid":
		return "removexattr", reflect.Int, "int", nil
	case "removexattr.file.group":
		return "removexattr", reflect.String, "string", nil
	case "removexattr.file.hashes":
		return "removexattr", reflect.String, "string", nil
	case "removexattr.file.in_upper_layer":
		return "removexattr", reflect.Bool, "bool", nil
	case "removexattr.file.inode":
		return "removexattr", reflect.Int, "int", nil
	case "removexattr.file.mode":
		return "removexattr", reflect.Int, "int", nil
	case "removexattr.file.modification_time":
		return "removexattr", reflect.Int, "int", nil
	case "removexattr.file.mount_id":
		return "removexattr", reflect.Int, "int", nil
	case "removexattr.file.name":
		return "removexattr", reflect.String, "string", nil
	case "removexattr.file.name.length":
		return "removexattr", reflect.Int, "int", nil
	case "removexattr.file.package.name":
		return "removexattr", reflect.String, "string", nil
	case "removexattr.file.package.source_version":
		return "removexattr", reflect.String, "string", nil
	case "removexattr.file.package.version":
		return "removexattr", reflect.String, "string", nil
	case "removexattr.file.path":
		return "removexattr", reflect.String, "string", nil
	case "removexattr.file.path.length":
		return "removexattr", reflect.Int, "int", nil
	case "removexattr.file.rights":
		return "removexattr", reflect.Int, "int", nil
	case "removexattr.file.uid":
		return "removexattr", reflect.Int, "int", nil
	case "removexattr.file.user":
		return "removexattr", reflect.String, "string", nil
	case "removexattr.retval":
		return "removexattr", reflect.Int, "int", nil
	case "rename.file.change_time":
		return "rename", reflect.Int, "int", nil
	case "rename.file.destination.change_time":
		return "rename", reflect.Int, "int", nil
	case "rename.file.destination.filesystem":
		return "rename", reflect.String, "string", nil
	case "rename.file.destination.gid":
		return "rename", reflect.Int, "int", nil
	case "rename.file.destination.group":
		return "rename", reflect.String, "string", nil
	case "rename.file.destination.hashes":
		return "rename", reflect.String, "string", nil
	case "rename.file.destination.in_upper_layer":
		return "rename", reflect.Bool, "bool", nil
	case "rename.file.destination.inode":
		return "rename", reflect.Int, "int", nil
	case "rename.file.destination.mode":
		return "rename", reflect.Int, "int", nil
	case "rename.file.destination.modification_time":
		return "rename", reflect.Int, "int", nil
	case "rename.file.destination.mount_id":
		return "rename", reflect.Int, "int", nil
	case "rename.file.destination.name":
		return "rename", reflect.String, "string", nil
	case "rename.file.destination.name.length":
		return "rename", reflect.Int, "int", nil
	case "rename.file.destination.package.name":
		return "rename", reflect.String, "string", nil
	case "rename.file.destination.package.source_version":
		return "rename", reflect.String, "string", nil
	case "rename.file.destination.package.version":
		return "rename", reflect.String, "string", nil
	case "rename.file.destination.path":
		return "rename", reflect.String, "string", nil
	case "rename.file.destination.path.length":
		return "rename", reflect.Int, "int", nil
	case "rename.file.destination.rights":
		return "rename", reflect.Int, "int", nil
	case "rename.file.destination.uid":
		return "rename", reflect.Int, "int", nil
	case "rename.file.destination.user":
		return "rename", reflect.String, "string", nil
	case "rename.file.filesystem":
		return "rename", reflect.String, "string", nil
	case "rename.file.gid":
		return "rename", reflect.Int, "int", nil
	case "rename.file.group":
		return "rename", reflect.String, "string", nil
	case "rename.file.hashes":
		return "rename", reflect.String, "string", nil
	case "rename.file.in_upper_layer":
		return "rename", reflect.Bool, "bool", nil
	case "rename.file.inode":
		return "rename", reflect.Int, "int", nil
	case "rename.file.mode":
		return "rename", reflect.Int, "int", nil
	case "rename.file.modification_time":
		return "rename", reflect.Int, "int", nil
	case "rename.file.mount_id":
		return "rename", reflect.Int, "int", nil
	case "rename.file.name":
		return "rename", reflect.String, "string", nil
	case "rename.file.name.length":
		return "rename", reflect.Int, "int", nil
	case "rename.file.package.name":
		return "rename", reflect.String, "string", nil
	case "rename.file.package.source_version":
		return "rename", reflect.String, "string", nil
	case "rename.file.package.version":
		return "rename", reflect.String, "string", nil
	case "rename.file.path":
		return "rename", reflect.String, "string", nil
	case "rename.file.path.length":
		return "rename", reflect.Int, "int", nil
	case "rename.file.rights":
		return "rename", reflect.Int, "int", nil
	case "rename.file.uid":
		return "rename", reflect.Int, "int", nil
	case "rename.file.user":
		return "rename", reflect.String, "string", nil
	case "rename.retval":
		return "rename", reflect.Int, "int", nil
	case "rename.syscall.destination.path":
		return "rename", reflect.String, "string", nil
	case "rename.syscall.path":
		return "rename", reflect.String, "string", nil
	case "rmdir.file.change_time":
		return "rmdir", reflect.Int, "int", nil
	case "rmdir.file.filesystem":
		return "rmdir", reflect.String, "string", nil
	case "rmdir.file.gid":
		return "rmdir", reflect.Int, "int", nil
	case "rmdir.file.group":
		return "rmdir", reflect.String, "string", nil
	case "rmdir.file.hashes":
		return "rmdir", reflect.String, "string", nil
	case "rmdir.file.in_upper_layer":
		return "rmdir", reflect.Bool, "bool", nil
	case "rmdir.file.inode":
		return "rmdir", reflect.Int, "int", nil
	case "rmdir.file.mode":
		return "rmdir", reflect.Int, "int", nil
	case "rmdir.file.modification_time":
		return "rmdir", reflect.Int, "int", nil
	case "rmdir.file.mount_id":
		return "rmdir", reflect.Int, "int", nil
	case "rmdir.file.name":
		return "rmdir", reflect.String, "string", nil
	case "rmdir.file.name.length":
		return "rmdir", reflect.Int, "int", nil
	case "rmdir.file.package.name":
		return "rmdir", reflect.String, "string", nil
	case "rmdir.file.package.source_version":
		return "rmdir", reflect.String, "string", nil
	case "rmdir.file.package.version":
		return "rmdir", reflect.String, "string", nil
	case "rmdir.file.path":
		return "rmdir", reflect.String, "string", nil
	case "rmdir.file.path.length":
		return "rmdir", reflect.Int, "int", nil
	case "rmdir.file.rights":
		return "rmdir", reflect.Int, "int", nil
	case "rmdir.file.uid":
		return "rmdir", reflect.Int, "int", nil
	case "rmdir.file.user":
		return "rmdir", reflect.String, "string", nil
	case "rmdir.retval":
		return "rmdir", reflect.Int, "int", nil
	case "rmdir.syscall.path":
		return "rmdir", reflect.String, "string", nil
	case "selinux.bool.name":
		return "selinux", reflect.String, "string", nil
	case "selinux.bool.state":
		return "selinux", reflect.String, "string", nil
	case "selinux.bool_commit.state":
		return "selinux", reflect.Bool, "bool", nil
	case "selinux.enforce.status":
		return "selinux", reflect.String, "string", nil
	case "setgid.egid":
		return "setgid", reflect.Int, "int", nil
	case "setgid.egroup":
		return "setgid", reflect.String, "string", nil
	case "setgid.fsgid":
		return "setgid", reflect.Int, "int", nil
	case "setgid.fsgroup":
		return "setgid", reflect.String, "string", nil
	case "setgid.gid":
		return "setgid", reflect.Int, "int", nil
	case "setgid.group":
		return "setgid", reflect.String, "string", nil
	case "setrlimit.resource":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.retval":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.rlim_cur":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.rlim_max":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.args":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.args_flags":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.args_options":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.args_truncated":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.ancestors.argv":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.argv0":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.auid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.cap_effective":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.cap_permitted":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.cgroup.file.inode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.cgroup.file.mount_id":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.cgroup.id":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.cgroup.manager":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.cgroup.version":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.comm":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.container.id":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.created_at":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.egid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.egroup":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.envp":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.envs":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.envs_truncated":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.ancestors.euid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.euser":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.file.change_time":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.file.filesystem":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.file.gid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.file.group":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.file.hashes":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.file.in_upper_layer":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.ancestors.file.inode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.file.mode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.file.modification_time":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.file.mount_id":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.file.name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.file.name.length":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.file.package.name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.file.package.source_version":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.file.package.version":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.file.path":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.file.path.length":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.file.rights":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.file.uid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.file.user":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.fsgid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.fsgroup":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.fsuid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.fsuser":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.gid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.group":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.interpreter.file.change_time":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.interpreter.file.filesystem":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.interpreter.file.gid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.interpreter.file.group":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.interpreter.file.hashes":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.interpreter.file.in_upper_layer":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.ancestors.interpreter.file.inode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.interpreter.file.mode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.interpreter.file.modification_time":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.interpreter.file.mount_id":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.interpreter.file.name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.interpreter.file.name.length":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.interpreter.file.package.name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.interpreter.file.package.source_version":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.interpreter.file.package.version":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.interpreter.file.path":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.interpreter.file.path.length":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.interpreter.file.rights":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.interpreter.file.uid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.interpreter.file.user":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.is_exec":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.ancestors.is_kworker":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.ancestors.is_thread":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.ancestors.length":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.pid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.ppid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.tid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.tty_name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.uid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ancestors.user":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.user_session.k8s_groups":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.user_session.k8s_uid":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.ancestors.user_session.k8s_username":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.args":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.args_flags":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.args_options":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.args_truncated":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.argv":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.argv0":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.auid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.cap_effective":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.cap_permitted":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.cgroup.file.inode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.cgroup.file.mount_id":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.cgroup.id":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.cgroup.manager":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.cgroup.version":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.comm":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.container.id":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.created_at":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.egid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.egroup":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.envp":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.envs":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.envs_truncated":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.euid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.euser":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.file.change_time":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.file.filesystem":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.file.gid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.file.group":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.file.hashes":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.file.in_upper_layer":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.file.inode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.file.mode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.file.modification_time":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.file.mount_id":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.file.name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.file.name.length":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.file.package.name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.file.package.source_version":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.file.package.version":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.file.path":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.file.path.length":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.file.rights":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.file.uid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.file.user":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.fsgid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.fsgroup":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.fsuid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.fsuser":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.gid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.group":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.interpreter.file.change_time":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.interpreter.file.filesystem":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.interpreter.file.gid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.interpreter.file.group":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.interpreter.file.hashes":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.interpreter.file.in_upper_layer":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.interpreter.file.inode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.interpreter.file.mode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.interpreter.file.modification_time":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.interpreter.file.mount_id":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.interpreter.file.name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.interpreter.file.name.length":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.interpreter.file.package.name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.interpreter.file.package.source_version":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.interpreter.file.package.version":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.interpreter.file.path":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.interpreter.file.path.length":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.interpreter.file.rights":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.interpreter.file.uid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.interpreter.file.user":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.is_exec":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.is_kworker":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.is_thread":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.parent.args":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.args_flags":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.args_options":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.args_truncated":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.parent.argv":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.argv0":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.auid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.cap_effective":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.cap_permitted":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.cgroup.file.inode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.cgroup.file.mount_id":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.cgroup.id":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.cgroup.manager":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.cgroup.version":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.comm":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.container.id":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.created_at":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.egid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.egroup":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.envp":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.envs":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.envs_truncated":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.parent.euid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.euser":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.file.change_time":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.file.filesystem":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.file.gid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.file.group":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.file.hashes":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.file.in_upper_layer":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.parent.file.inode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.file.mode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.file.modification_time":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.file.mount_id":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.file.name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.file.name.length":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.file.package.name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.file.package.source_version":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.file.package.version":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.file.path":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.file.path.length":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.file.rights":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.file.uid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.file.user":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.fsgid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.fsgroup":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.fsuid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.fsuser":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.gid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.group":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.interpreter.file.change_time":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.interpreter.file.filesystem":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.interpreter.file.gid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.interpreter.file.group":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.interpreter.file.hashes":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.interpreter.file.in_upper_layer":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.parent.interpreter.file.inode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.interpreter.file.mode":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.interpreter.file.modification_time":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.interpreter.file.mount_id":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.interpreter.file.name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.interpreter.file.name.length":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.interpreter.file.package.name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.interpreter.file.package.source_version":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.interpreter.file.package.version":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.interpreter.file.path":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.interpreter.file.path.length":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.interpreter.file.rights":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.interpreter.file.uid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.interpreter.file.user":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.is_exec":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.parent.is_kworker":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.parent.is_thread":
		return "setrlimit", reflect.Bool, "bool", nil
	case "setrlimit.target.parent.pid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.ppid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.tid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.tty_name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.uid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.parent.user":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.user_session.k8s_groups":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.user_session.k8s_uid":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.parent.user_session.k8s_username":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.pid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.ppid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.tid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.tty_name":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.uid":
		return "setrlimit", reflect.Int, "int", nil
	case "setrlimit.target.user":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.user_session.k8s_groups":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.user_session.k8s_uid":
		return "setrlimit", reflect.String, "string", nil
	case "setrlimit.target.user_session.k8s_username":
		return "setrlimit", reflect.String, "string", nil
	case "setsockopt.filter_hash":
		return "setsockopt", reflect.String, "string", nil
	case "setsockopt.filter_instructions":
		return "setsockopt", reflect.String, "string", nil
	case "setsockopt.filter_len":
		return "setsockopt", reflect.Int, "int", nil
	case "setsockopt.is_filter_truncated":
		return "setsockopt", reflect.Bool, "bool", nil
	case "setsockopt.level":
		return "setsockopt", reflect.Int, "int", nil
	case "setsockopt.optname":
		return "setsockopt", reflect.Int, "int", nil
	case "setsockopt.retval":
		return "setsockopt", reflect.Int, "int", nil
	case "setsockopt.socket_family":
		return "setsockopt", reflect.Int, "int", nil
	case "setsockopt.socket_protocol":
		return "setsockopt", reflect.Int, "int", nil
	case "setsockopt.socket_type":
		return "setsockopt", reflect.Int, "int", nil
	case "setuid.euid":
		return "setuid", reflect.Int, "int", nil
	case "setuid.euser":
		return "setuid", reflect.String, "string", nil
	case "setuid.fsuid":
		return "setuid", reflect.Int, "int", nil
	case "setuid.fsuser":
		return "setuid", reflect.String, "string", nil
	case "setuid.uid":
		return "setuid", reflect.Int, "int", nil
	case "setuid.user":
		return "setuid", reflect.String, "string", nil
	case "setxattr.file.change_time":
		return "setxattr", reflect.Int, "int", nil
	case "setxattr.file.destination.name":
		return "setxattr", reflect.String, "string", nil
	case "setxattr.file.destination.namespace":
		return "setxattr", reflect.String, "string", nil
	case "setxattr.file.filesystem":
		return "setxattr", reflect.String, "string", nil
	case "setxattr.file.gid":
		return "setxattr", reflect.Int, "int", nil
	case "setxattr.file.group":
		return "setxattr", reflect.String, "string", nil
	case "setxattr.file.hashes":
		return "setxattr", reflect.String, "string", nil
	case "setxattr.file.in_upper_layer":
		return "setxattr", reflect.Bool, "bool", nil
	case "setxattr.file.inode":
		return "setxattr", reflect.Int, "int", nil
	case "setxattr.file.mode":
		return "setxattr", reflect.Int, "int", nil
	case "setxattr.file.modification_time":
		return "setxattr", reflect.Int, "int", nil
	case "setxattr.file.mount_id":
		return "setxattr", reflect.Int, "int", nil
	case "setxattr.file.name":
		return "setxattr", reflect.String, "string", nil
	case "setxattr.file.name.length":
		return "setxattr", reflect.Int, "int", nil
	case "setxattr.file.package.name":
		return "setxattr", reflect.String, "string", nil
	case "setxattr.file.package.source_version":
		return "setxattr", reflect.String, "string", nil
	case "setxattr.file.package.version":
		return "setxattr", reflect.String, "string", nil
	case "setxattr.file.path":
		return "setxattr", reflect.String, "string", nil
	case "setxattr.file.path.length":
		return "setxattr", reflect.Int, "int", nil
	case "setxattr.file.rights":
		return "setxattr", reflect.Int, "int", nil
	case "setxattr.file.uid":
		return "setxattr", reflect.Int, "int", nil
	case "setxattr.file.user":
		return "setxattr", reflect.String, "string", nil
	case "setxattr.retval":
		return "setxattr", reflect.Int, "int", nil
	case "signal.pid":
		return "signal", reflect.Int, "int", nil
	case "signal.retval":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.args":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.args_flags":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.args_options":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.args_truncated":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.ancestors.argv":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.argv0":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.auid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.cap_effective":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.cap_permitted":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.cgroup.file.inode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.cgroup.file.mount_id":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.cgroup.id":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.cgroup.manager":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.cgroup.version":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.comm":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.container.id":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.created_at":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.egid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.egroup":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.envp":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.envs":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.envs_truncated":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.ancestors.euid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.euser":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.file.change_time":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.file.filesystem":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.file.gid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.file.group":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.file.hashes":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.file.in_upper_layer":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.ancestors.file.inode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.file.mode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.file.modification_time":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.file.mount_id":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.file.name":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.file.name.length":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.file.package.name":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.file.package.source_version":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.file.package.version":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.file.path":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.file.path.length":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.file.rights":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.file.uid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.file.user":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.fsgid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.fsgroup":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.fsuid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.fsuser":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.gid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.group":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.interpreter.file.change_time":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.interpreter.file.filesystem":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.interpreter.file.gid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.interpreter.file.group":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.interpreter.file.hashes":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.interpreter.file.in_upper_layer":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.ancestors.interpreter.file.inode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.interpreter.file.mode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.interpreter.file.modification_time":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.interpreter.file.mount_id":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.interpreter.file.name":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.interpreter.file.name.length":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.interpreter.file.package.name":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.interpreter.file.package.source_version":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.interpreter.file.package.version":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.interpreter.file.path":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.interpreter.file.path.length":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.interpreter.file.rights":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.interpreter.file.uid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.interpreter.file.user":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.is_exec":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.ancestors.is_kworker":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.ancestors.is_thread":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.ancestors.length":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.pid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.ppid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.tid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.tty_name":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.uid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ancestors.user":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.user_session.k8s_groups":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.user_session.k8s_uid":
		return "signal", reflect.String, "string", nil
	case "signal.target.ancestors.user_session.k8s_username":
		return "signal", reflect.String, "string", nil
	case "signal.target.args":
		return "signal", reflect.String, "string", nil
	case "signal.target.args_flags":
		return "signal", reflect.String, "string", nil
	case "signal.target.args_options":
		return "signal", reflect.String, "string", nil
	case "signal.target.args_truncated":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.argv":
		return "signal", reflect.String, "string", nil
	case "signal.target.argv0":
		return "signal", reflect.String, "string", nil
	case "signal.target.auid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.cap_effective":
		return "signal", reflect.Int, "int", nil
	case "signal.target.cap_permitted":
		return "signal", reflect.Int, "int", nil
	case "signal.target.cgroup.file.inode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.cgroup.file.mount_id":
		return "signal", reflect.Int, "int", nil
	case "signal.target.cgroup.id":
		return "signal", reflect.String, "string", nil
	case "signal.target.cgroup.manager":
		return "signal", reflect.String, "string", nil
	case "signal.target.cgroup.version":
		return "signal", reflect.Int, "int", nil
	case "signal.target.comm":
		return "signal", reflect.String, "string", nil
	case "signal.target.container.id":
		return "signal", reflect.String, "string", nil
	case "signal.target.created_at":
		return "signal", reflect.Int, "int", nil
	case "signal.target.egid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.egroup":
		return "signal", reflect.String, "string", nil
	case "signal.target.envp":
		return "signal", reflect.String, "string", nil
	case "signal.target.envs":
		return "signal", reflect.String, "string", nil
	case "signal.target.envs_truncated":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.euid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.euser":
		return "signal", reflect.String, "string", nil
	case "signal.target.file.change_time":
		return "signal", reflect.Int, "int", nil
	case "signal.target.file.filesystem":
		return "signal", reflect.String, "string", nil
	case "signal.target.file.gid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.file.group":
		return "signal", reflect.String, "string", nil
	case "signal.target.file.hashes":
		return "signal", reflect.String, "string", nil
	case "signal.target.file.in_upper_layer":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.file.inode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.file.mode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.file.modification_time":
		return "signal", reflect.Int, "int", nil
	case "signal.target.file.mount_id":
		return "signal", reflect.Int, "int", nil
	case "signal.target.file.name":
		return "signal", reflect.String, "string", nil
	case "signal.target.file.name.length":
		return "signal", reflect.Int, "int", nil
	case "signal.target.file.package.name":
		return "signal", reflect.String, "string", nil
	case "signal.target.file.package.source_version":
		return "signal", reflect.String, "string", nil
	case "signal.target.file.package.version":
		return "signal", reflect.String, "string", nil
	case "signal.target.file.path":
		return "signal", reflect.String, "string", nil
	case "signal.target.file.path.length":
		return "signal", reflect.Int, "int", nil
	case "signal.target.file.rights":
		return "signal", reflect.Int, "int", nil
	case "signal.target.file.uid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.file.user":
		return "signal", reflect.String, "string", nil
	case "signal.target.fsgid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.fsgroup":
		return "signal", reflect.String, "string", nil
	case "signal.target.fsuid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.fsuser":
		return "signal", reflect.String, "string", nil
	case "signal.target.gid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.group":
		return "signal", reflect.String, "string", nil
	case "signal.target.interpreter.file.change_time":
		return "signal", reflect.Int, "int", nil
	case "signal.target.interpreter.file.filesystem":
		return "signal", reflect.String, "string", nil
	case "signal.target.interpreter.file.gid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.interpreter.file.group":
		return "signal", reflect.String, "string", nil
	case "signal.target.interpreter.file.hashes":
		return "signal", reflect.String, "string", nil
	case "signal.target.interpreter.file.in_upper_layer":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.interpreter.file.inode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.interpreter.file.mode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.interpreter.file.modification_time":
		return "signal", reflect.Int, "int", nil
	case "signal.target.interpreter.file.mount_id":
		return "signal", reflect.Int, "int", nil
	case "signal.target.interpreter.file.name":
		return "signal", reflect.String, "string", nil
	case "signal.target.interpreter.file.name.length":
		return "signal", reflect.Int, "int", nil
	case "signal.target.interpreter.file.package.name":
		return "signal", reflect.String, "string", nil
	case "signal.target.interpreter.file.package.source_version":
		return "signal", reflect.String, "string", nil
	case "signal.target.interpreter.file.package.version":
		return "signal", reflect.String, "string", nil
	case "signal.target.interpreter.file.path":
		return "signal", reflect.String, "string", nil
	case "signal.target.interpreter.file.path.length":
		return "signal", reflect.Int, "int", nil
	case "signal.target.interpreter.file.rights":
		return "signal", reflect.Int, "int", nil
	case "signal.target.interpreter.file.uid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.interpreter.file.user":
		return "signal", reflect.String, "string", nil
	case "signal.target.is_exec":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.is_kworker":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.is_thread":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.parent.args":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.args_flags":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.args_options":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.args_truncated":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.parent.argv":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.argv0":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.auid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.cap_effective":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.cap_permitted":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.cgroup.file.inode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.cgroup.file.mount_id":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.cgroup.id":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.cgroup.manager":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.cgroup.version":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.comm":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.container.id":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.created_at":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.egid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.egroup":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.envp":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.envs":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.envs_truncated":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.parent.euid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.euser":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.file.change_time":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.file.filesystem":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.file.gid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.file.group":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.file.hashes":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.file.in_upper_layer":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.parent.file.inode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.file.mode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.file.modification_time":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.file.mount_id":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.file.name":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.file.name.length":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.file.package.name":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.file.package.source_version":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.file.package.version":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.file.path":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.file.path.length":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.file.rights":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.file.uid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.file.user":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.fsgid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.fsgroup":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.fsuid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.fsuser":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.gid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.group":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.interpreter.file.change_time":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.interpreter.file.filesystem":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.interpreter.file.gid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.interpreter.file.group":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.interpreter.file.hashes":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.interpreter.file.in_upper_layer":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.parent.interpreter.file.inode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.interpreter.file.mode":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.interpreter.file.modification_time":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.interpreter.file.mount_id":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.interpreter.file.name":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.interpreter.file.name.length":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.interpreter.file.package.name":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.interpreter.file.package.source_version":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.interpreter.file.package.version":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.interpreter.file.path":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.interpreter.file.path.length":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.interpreter.file.rights":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.interpreter.file.uid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.interpreter.file.user":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.is_exec":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.parent.is_kworker":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.parent.is_thread":
		return "signal", reflect.Bool, "bool", nil
	case "signal.target.parent.pid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.ppid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.tid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.tty_name":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.uid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.parent.user":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.user_session.k8s_groups":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.user_session.k8s_uid":
		return "signal", reflect.String, "string", nil
	case "signal.target.parent.user_session.k8s_username":
		return "signal", reflect.String, "string", nil
	case "signal.target.pid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.ppid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.tid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.tty_name":
		return "signal", reflect.String, "string", nil
	case "signal.target.uid":
		return "signal", reflect.Int, "int", nil
	case "signal.target.user":
		return "signal", reflect.String, "string", nil
	case "signal.target.user_session.k8s_groups":
		return "signal", reflect.String, "string", nil
	case "signal.target.user_session.k8s_uid":
		return "signal", reflect.String, "string", nil
	case "signal.target.user_session.k8s_username":
		return "signal", reflect.String, "string", nil
	case "signal.type":
		return "signal", reflect.Int, "int", nil
	case "splice.file.change_time":
		return "splice", reflect.Int, "int", nil
	case "splice.file.filesystem":
		return "splice", reflect.String, "string", nil
	case "splice.file.gid":
		return "splice", reflect.Int, "int", nil
	case "splice.file.group":
		return "splice", reflect.String, "string", nil
	case "splice.file.hashes":
		return "splice", reflect.String, "string", nil
	case "splice.file.in_upper_layer":
		return "splice", reflect.Bool, "bool", nil
	case "splice.file.inode":
		return "splice", reflect.Int, "int", nil
	case "splice.file.mode":
		return "splice", reflect.Int, "int", nil
	case "splice.file.modification_time":
		return "splice", reflect.Int, "int", nil
	case "splice.file.mount_id":
		return "splice", reflect.Int, "int", nil
	case "splice.file.name":
		return "splice", reflect.String, "string", nil
	case "splice.file.name.length":
		return "splice", reflect.Int, "int", nil
	case "splice.file.package.name":
		return "splice", reflect.String, "string", nil
	case "splice.file.package.source_version":
		return "splice", reflect.String, "string", nil
	case "splice.file.package.version":
		return "splice", reflect.String, "string", nil
	case "splice.file.path":
		return "splice", reflect.String, "string", nil
	case "splice.file.path.length":
		return "splice", reflect.Int, "int", nil
	case "splice.file.rights":
		return "splice", reflect.Int, "int", nil
	case "splice.file.uid":
		return "splice", reflect.Int, "int", nil
	case "splice.file.user":
		return "splice", reflect.String, "string", nil
	case "splice.pipe_entry_flag":
		return "splice", reflect.Int, "int", nil
	case "splice.pipe_exit_flag":
		return "splice", reflect.Int, "int", nil
	case "splice.retval":
		return "splice", reflect.Int, "int", nil
	case "sysctl.action":
		return "sysctl", reflect.Int, "int", nil
	case "sysctl.file_position":
		return "sysctl", reflect.Int, "int", nil
	case "sysctl.name":
		return "sysctl", reflect.String, "string", nil
	case "sysctl.name_truncated":
		return "sysctl", reflect.Bool, "bool", nil
	case "sysctl.old_value":
		return "sysctl", reflect.String, "string", nil
	case "sysctl.old_value_truncated":
		return "sysctl", reflect.Bool, "bool", nil
	case "sysctl.value":
		return "sysctl", reflect.String, "string", nil
	case "sysctl.value_truncated":
		return "sysctl", reflect.Bool, "bool", nil
	case "unlink.file.change_time":
		return "unlink", reflect.Int, "int", nil
	case "unlink.file.filesystem":
		return "unlink", reflect.String, "string", nil
	case "unlink.file.gid":
		return "unlink", reflect.Int, "int", nil
	case "unlink.file.group":
		return "unlink", reflect.String, "string", nil
	case "unlink.file.hashes":
		return "unlink", reflect.String, "string", nil
	case "unlink.file.in_upper_layer":
		return "unlink", reflect.Bool, "bool", nil
	case "unlink.file.inode":
		return "unlink", reflect.Int, "int", nil
	case "unlink.file.mode":
		return "unlink", reflect.Int, "int", nil
	case "unlink.file.modification_time":
		return "unlink", reflect.Int, "int", nil
	case "unlink.file.mount_id":
		return "unlink", reflect.Int, "int", nil
	case "unlink.file.name":
		return "unlink", reflect.String, "string", nil
	case "unlink.file.name.length":
		return "unlink", reflect.Int, "int", nil
	case "unlink.file.package.name":
		return "unlink", reflect.String, "string", nil
	case "unlink.file.package.source_version":
		return "unlink", reflect.String, "string", nil
	case "unlink.file.package.version":
		return "unlink", reflect.String, "string", nil
	case "unlink.file.path":
		return "unlink", reflect.String, "string", nil
	case "unlink.file.path.length":
		return "unlink", reflect.Int, "int", nil
	case "unlink.file.rights":
		return "unlink", reflect.Int, "int", nil
	case "unlink.file.uid":
		return "unlink", reflect.Int, "int", nil
	case "unlink.file.user":
		return "unlink", reflect.String, "string", nil
	case "unlink.flags":
		return "unlink", reflect.Int, "int", nil
	case "unlink.retval":
		return "unlink", reflect.Int, "int", nil
	case "unlink.syscall.dirfd":
		return "unlink", reflect.Int, "int", nil
	case "unlink.syscall.flags":
		return "unlink", reflect.Int, "int", nil
	case "unlink.syscall.path":
		return "unlink", reflect.String, "string", nil
	case "unload_module.name":
		return "unload_module", reflect.String, "string", nil
	case "unload_module.retval":
		return "unload_module", reflect.Int, "int", nil
	case "utimes.file.change_time":
		return "utimes", reflect.Int, "int", nil
	case "utimes.file.filesystem":
		return "utimes", reflect.String, "string", nil
	case "utimes.file.gid":
		return "utimes", reflect.Int, "int", nil
	case "utimes.file.group":
		return "utimes", reflect.String, "string", nil
	case "utimes.file.hashes":
		return "utimes", reflect.String, "string", nil
	case "utimes.file.in_upper_layer":
		return "utimes", reflect.Bool, "bool", nil
	case "utimes.file.inode":
		return "utimes", reflect.Int, "int", nil
	case "utimes.file.mode":
		return "utimes", reflect.Int, "int", nil
	case "utimes.file.modification_time":
		return "utimes", reflect.Int, "int", nil
	case "utimes.file.mount_id":
		return "utimes", reflect.Int, "int", nil
	case "utimes.file.name":
		return "utimes", reflect.String, "string", nil
	case "utimes.file.name.length":
		return "utimes", reflect.Int, "int", nil
	case "utimes.file.package.name":
		return "utimes", reflect.String, "string", nil
	case "utimes.file.package.source_version":
		return "utimes", reflect.String, "string", nil
	case "utimes.file.package.version":
		return "utimes", reflect.String, "string", nil
	case "utimes.file.path":
		return "utimes", reflect.String, "string", nil
	case "utimes.file.path.length":
		return "utimes", reflect.Int, "int", nil
	case "utimes.file.rights":
		return "utimes", reflect.Int, "int", nil
	case "utimes.file.uid":
		return "utimes", reflect.Int, "int", nil
	case "utimes.file.user":
		return "utimes", reflect.String, "string", nil
	case "utimes.retval":
		return "utimes", reflect.Int, "int", nil
	case "utimes.syscall.path":
		return "utimes", reflect.String, "string", nil
	}
	return "", reflect.Invalid, "", &eval.ErrFieldNotFound{Field: field}
}
func (ev *Event) initProcess() {
	if ev.BaseEvent.ProcessContext == nil {
		ev.BaseEvent.ProcessContext = &ProcessContext{}
	}
	if ev.BaseEvent.ProcessContext.Ancestor == nil {
		ev.BaseEvent.ProcessContext.Ancestor = &ProcessCacheEntry{}
	}
	if ev.BaseEvent.ProcessContext.Parent == nil {
		ev.BaseEvent.ProcessContext.Parent = &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process
	}
	if ev.Exec.Process == nil {
		ev.Exec.Process = &Process{}
	}
}
func (ev *Event) SetFieldValue(field eval.Field, value interface{}) error {
	if strings.HasPrefix(field, "process.") || strings.HasPrefix(field, "exec.") {
		ev.initProcess()
	}
	switch field {
	case "accept.addr.family":
		return ev.setUint16FieldValue("accept.addr.family", &ev.Accept.AddrFamily, value)
	case "accept.addr.hostname":
		return ev.setStringArrayFieldValue("accept.addr.hostname", &ev.Accept.Hostnames, value)
	case "accept.addr.ip":
		rv, ok := value.(net.IPNet)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "accept.addr.ip"}
		}
		ev.Accept.Addr.IPNet = rv
		return nil
	case "accept.addr.is_public":
		return ev.setBoolFieldValue("accept.addr.is_public", &ev.Accept.Addr.IsPublic, value)
	case "accept.addr.port":
		return ev.setUint16FieldValue("accept.addr.port", &ev.Accept.Addr.Port, value)
	case "accept.retval":
		return ev.setInt64FieldValue("accept.retval", &ev.Accept.SyscallEvent.Retval, value)
	case "bind.addr.family":
		return ev.setUint16FieldValue("bind.addr.family", &ev.Bind.AddrFamily, value)
	case "bind.addr.ip":
		rv, ok := value.(net.IPNet)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "bind.addr.ip"}
		}
		ev.Bind.Addr.IPNet = rv
		return nil
	case "bind.addr.is_public":
		return ev.setBoolFieldValue("bind.addr.is_public", &ev.Bind.Addr.IsPublic, value)
	case "bind.addr.port":
		return ev.setUint16FieldValue("bind.addr.port", &ev.Bind.Addr.Port, value)
	case "bind.protocol":
		return ev.setUint16FieldValue("bind.protocol", &ev.Bind.Protocol, value)
	case "bind.retval":
		return ev.setInt64FieldValue("bind.retval", &ev.Bind.SyscallEvent.Retval, value)
	case "bpf.cmd":
		return ev.setUint32FieldValue("bpf.cmd", &ev.BPF.Cmd, value)
	case "bpf.map.name":
		return ev.setStringFieldValue("bpf.map.name", &ev.BPF.Map.Name, value)
	case "bpf.map.type":
		return ev.setUint32FieldValue("bpf.map.type", &ev.BPF.Map.Type, value)
	case "bpf.prog.attach_type":
		return ev.setUint32FieldValue("bpf.prog.attach_type", &ev.BPF.Program.AttachType, value)
	case "bpf.prog.helpers":
		switch rv := value.(type) {
		case int:
			ev.BPF.Program.Helpers = append(ev.BPF.Program.Helpers, uint32(rv))
		case []int:
			for _, i := range rv {
				ev.BPF.Program.Helpers = append(ev.BPF.Program.Helpers, uint32(i))
			}
		default:
			return &eval.ErrValueTypeMismatch{Field: "bpf.prog.helpers"}
		}
		return nil
	case "bpf.prog.name":
		return ev.setStringFieldValue("bpf.prog.name", &ev.BPF.Program.Name, value)
	case "bpf.prog.tag":
		return ev.setStringFieldValue("bpf.prog.tag", &ev.BPF.Program.Tag, value)
	case "bpf.prog.type":
		return ev.setUint32FieldValue("bpf.prog.type", &ev.BPF.Program.Type, value)
	case "bpf.retval":
		return ev.setInt64FieldValue("bpf.retval", &ev.BPF.SyscallEvent.Retval, value)
	case "capset.cap_effective":
		return ev.setUint64FieldValue("capset.cap_effective", &ev.Capset.CapEffective, value)
	case "capset.cap_permitted":
		return ev.setUint64FieldValue("capset.cap_permitted", &ev.Capset.CapPermitted, value)
	case "cgroup.file.inode":
		if ev.CGroupContext == nil {
			ev.CGroupContext = &CGroupContext{}
		}
		return ev.setUint64FieldValue("cgroup.file.inode", &ev.CGroupContext.CGroupFile.Inode, value)
	case "cgroup.file.mount_id":
		if ev.CGroupContext == nil {
			ev.CGroupContext = &CGroupContext{}
		}
		return ev.setUint32FieldValue("cgroup.file.mount_id", &ev.CGroupContext.CGroupFile.MountID, value)
	case "cgroup.id":
		if ev.CGroupContext == nil {
			ev.CGroupContext = &CGroupContext{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "cgroup.id"}
		}
		ev.CGroupContext.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "cgroup.manager":
		if ev.CGroupContext == nil {
			ev.CGroupContext = &CGroupContext{}
		}
		return ev.setStringFieldValue("cgroup.manager", &ev.CGroupContext.CGroupManager, value)
	case "cgroup.version":
		if ev.CGroupContext == nil {
			ev.CGroupContext = &CGroupContext{}
		}
		return ev.setIntFieldValue("cgroup.version", &ev.CGroupContext.CGroupVersion, value)
	case "cgroup_write.file.change_time":
		return ev.setUint64FieldValue("cgroup_write.file.change_time", &ev.CgroupWrite.File.FileFields.CTime, value)
	case "cgroup_write.file.filesystem":
		return ev.setStringFieldValue("cgroup_write.file.filesystem", &ev.CgroupWrite.File.Filesystem, value)
	case "cgroup_write.file.gid":
		return ev.setUint32FieldValue("cgroup_write.file.gid", &ev.CgroupWrite.File.FileFields.GID, value)
	case "cgroup_write.file.group":
		return ev.setStringFieldValue("cgroup_write.file.group", &ev.CgroupWrite.File.FileFields.Group, value)
	case "cgroup_write.file.hashes":
		return ev.setStringArrayFieldValue("cgroup_write.file.hashes", &ev.CgroupWrite.File.Hashes, value)
	case "cgroup_write.file.in_upper_layer":
		return ev.setBoolFieldValue("cgroup_write.file.in_upper_layer", &ev.CgroupWrite.File.FileFields.InUpperLayer, value)
	case "cgroup_write.file.inode":
		return ev.setUint64FieldValue("cgroup_write.file.inode", &ev.CgroupWrite.File.FileFields.PathKey.Inode, value)
	case "cgroup_write.file.mode":
		return ev.setUint16FieldValue("cgroup_write.file.mode", &ev.CgroupWrite.File.FileFields.Mode, value)
	case "cgroup_write.file.modification_time":
		return ev.setUint64FieldValue("cgroup_write.file.modification_time", &ev.CgroupWrite.File.FileFields.MTime, value)
	case "cgroup_write.file.mount_id":
		return ev.setUint32FieldValue("cgroup_write.file.mount_id", &ev.CgroupWrite.File.FileFields.PathKey.MountID, value)
	case "cgroup_write.file.name":
		return ev.setStringFieldValue("cgroup_write.file.name", &ev.CgroupWrite.File.BasenameStr, value)
	case "cgroup_write.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "cgroup_write.file.name.length"}
	case "cgroup_write.file.package.name":
		return ev.setStringFieldValue("cgroup_write.file.package.name", &ev.CgroupWrite.File.PkgName, value)
	case "cgroup_write.file.package.source_version":
		return ev.setStringFieldValue("cgroup_write.file.package.source_version", &ev.CgroupWrite.File.PkgSrcVersion, value)
	case "cgroup_write.file.package.version":
		return ev.setStringFieldValue("cgroup_write.file.package.version", &ev.CgroupWrite.File.PkgVersion, value)
	case "cgroup_write.file.path":
		return ev.setStringFieldValue("cgroup_write.file.path", &ev.CgroupWrite.File.PathnameStr, value)
	case "cgroup_write.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "cgroup_write.file.path.length"}
	case "cgroup_write.file.rights":
		return ev.setUint16FieldValue("cgroup_write.file.rights", &ev.CgroupWrite.File.FileFields.Mode, value)
	case "cgroup_write.file.uid":
		return ev.setUint32FieldValue("cgroup_write.file.uid", &ev.CgroupWrite.File.FileFields.UID, value)
	case "cgroup_write.file.user":
		return ev.setStringFieldValue("cgroup_write.file.user", &ev.CgroupWrite.File.FileFields.User, value)
	case "cgroup_write.pid":
		return ev.setUint32FieldValue("cgroup_write.pid", &ev.CgroupWrite.Pid, value)
	case "chdir.file.change_time":
		return ev.setUint64FieldValue("chdir.file.change_time", &ev.Chdir.File.FileFields.CTime, value)
	case "chdir.file.filesystem":
		return ev.setStringFieldValue("chdir.file.filesystem", &ev.Chdir.File.Filesystem, value)
	case "chdir.file.gid":
		return ev.setUint32FieldValue("chdir.file.gid", &ev.Chdir.File.FileFields.GID, value)
	case "chdir.file.group":
		return ev.setStringFieldValue("chdir.file.group", &ev.Chdir.File.FileFields.Group, value)
	case "chdir.file.hashes":
		return ev.setStringArrayFieldValue("chdir.file.hashes", &ev.Chdir.File.Hashes, value)
	case "chdir.file.in_upper_layer":
		return ev.setBoolFieldValue("chdir.file.in_upper_layer", &ev.Chdir.File.FileFields.InUpperLayer, value)
	case "chdir.file.inode":
		return ev.setUint64FieldValue("chdir.file.inode", &ev.Chdir.File.FileFields.PathKey.Inode, value)
	case "chdir.file.mode":
		return ev.setUint16FieldValue("chdir.file.mode", &ev.Chdir.File.FileFields.Mode, value)
	case "chdir.file.modification_time":
		return ev.setUint64FieldValue("chdir.file.modification_time", &ev.Chdir.File.FileFields.MTime, value)
	case "chdir.file.mount_id":
		return ev.setUint32FieldValue("chdir.file.mount_id", &ev.Chdir.File.FileFields.PathKey.MountID, value)
	case "chdir.file.name":
		return ev.setStringFieldValue("chdir.file.name", &ev.Chdir.File.BasenameStr, value)
	case "chdir.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "chdir.file.name.length"}
	case "chdir.file.package.name":
		return ev.setStringFieldValue("chdir.file.package.name", &ev.Chdir.File.PkgName, value)
	case "chdir.file.package.source_version":
		return ev.setStringFieldValue("chdir.file.package.source_version", &ev.Chdir.File.PkgSrcVersion, value)
	case "chdir.file.package.version":
		return ev.setStringFieldValue("chdir.file.package.version", &ev.Chdir.File.PkgVersion, value)
	case "chdir.file.path":
		return ev.setStringFieldValue("chdir.file.path", &ev.Chdir.File.PathnameStr, value)
	case "chdir.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "chdir.file.path.length"}
	case "chdir.file.rights":
		return ev.setUint16FieldValue("chdir.file.rights", &ev.Chdir.File.FileFields.Mode, value)
	case "chdir.file.uid":
		return ev.setUint32FieldValue("chdir.file.uid", &ev.Chdir.File.FileFields.UID, value)
	case "chdir.file.user":
		return ev.setStringFieldValue("chdir.file.user", &ev.Chdir.File.FileFields.User, value)
	case "chdir.retval":
		return ev.setInt64FieldValue("chdir.retval", &ev.Chdir.SyscallEvent.Retval, value)
	case "chdir.syscall.path":
		return ev.setStringFieldValue("chdir.syscall.path", &ev.Chdir.SyscallContext.StrArg1, value)
	case "chmod.file.change_time":
		return ev.setUint64FieldValue("chmod.file.change_time", &ev.Chmod.File.FileFields.CTime, value)
	case "chmod.file.destination.mode":
		return ev.setUint32FieldValue("chmod.file.destination.mode", &ev.Chmod.Mode, value)
	case "chmod.file.destination.rights":
		return ev.setUint32FieldValue("chmod.file.destination.rights", &ev.Chmod.Mode, value)
	case "chmod.file.filesystem":
		return ev.setStringFieldValue("chmod.file.filesystem", &ev.Chmod.File.Filesystem, value)
	case "chmod.file.gid":
		return ev.setUint32FieldValue("chmod.file.gid", &ev.Chmod.File.FileFields.GID, value)
	case "chmod.file.group":
		return ev.setStringFieldValue("chmod.file.group", &ev.Chmod.File.FileFields.Group, value)
	case "chmod.file.hashes":
		return ev.setStringArrayFieldValue("chmod.file.hashes", &ev.Chmod.File.Hashes, value)
	case "chmod.file.in_upper_layer":
		return ev.setBoolFieldValue("chmod.file.in_upper_layer", &ev.Chmod.File.FileFields.InUpperLayer, value)
	case "chmod.file.inode":
		return ev.setUint64FieldValue("chmod.file.inode", &ev.Chmod.File.FileFields.PathKey.Inode, value)
	case "chmod.file.mode":
		return ev.setUint16FieldValue("chmod.file.mode", &ev.Chmod.File.FileFields.Mode, value)
	case "chmod.file.modification_time":
		return ev.setUint64FieldValue("chmod.file.modification_time", &ev.Chmod.File.FileFields.MTime, value)
	case "chmod.file.mount_id":
		return ev.setUint32FieldValue("chmod.file.mount_id", &ev.Chmod.File.FileFields.PathKey.MountID, value)
	case "chmod.file.name":
		return ev.setStringFieldValue("chmod.file.name", &ev.Chmod.File.BasenameStr, value)
	case "chmod.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "chmod.file.name.length"}
	case "chmod.file.package.name":
		return ev.setStringFieldValue("chmod.file.package.name", &ev.Chmod.File.PkgName, value)
	case "chmod.file.package.source_version":
		return ev.setStringFieldValue("chmod.file.package.source_version", &ev.Chmod.File.PkgSrcVersion, value)
	case "chmod.file.package.version":
		return ev.setStringFieldValue("chmod.file.package.version", &ev.Chmod.File.PkgVersion, value)
	case "chmod.file.path":
		return ev.setStringFieldValue("chmod.file.path", &ev.Chmod.File.PathnameStr, value)
	case "chmod.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "chmod.file.path.length"}
	case "chmod.file.rights":
		return ev.setUint16FieldValue("chmod.file.rights", &ev.Chmod.File.FileFields.Mode, value)
	case "chmod.file.uid":
		return ev.setUint32FieldValue("chmod.file.uid", &ev.Chmod.File.FileFields.UID, value)
	case "chmod.file.user":
		return ev.setStringFieldValue("chmod.file.user", &ev.Chmod.File.FileFields.User, value)
	case "chmod.retval":
		return ev.setInt64FieldValue("chmod.retval", &ev.Chmod.SyscallEvent.Retval, value)
	case "chmod.syscall.mode":
		return ev.setInt64FieldValue("chmod.syscall.mode", &ev.Chmod.SyscallContext.IntArg2, value)
	case "chmod.syscall.path":
		return ev.setStringFieldValue("chmod.syscall.path", &ev.Chmod.SyscallContext.StrArg1, value)
	case "chown.file.change_time":
		return ev.setUint64FieldValue("chown.file.change_time", &ev.Chown.File.FileFields.CTime, value)
	case "chown.file.destination.gid":
		return ev.setInt64FieldValue("chown.file.destination.gid", &ev.Chown.GID, value)
	case "chown.file.destination.group":
		return ev.setStringFieldValue("chown.file.destination.group", &ev.Chown.Group, value)
	case "chown.file.destination.uid":
		return ev.setInt64FieldValue("chown.file.destination.uid", &ev.Chown.UID, value)
	case "chown.file.destination.user":
		return ev.setStringFieldValue("chown.file.destination.user", &ev.Chown.User, value)
	case "chown.file.filesystem":
		return ev.setStringFieldValue("chown.file.filesystem", &ev.Chown.File.Filesystem, value)
	case "chown.file.gid":
		return ev.setUint32FieldValue("chown.file.gid", &ev.Chown.File.FileFields.GID, value)
	case "chown.file.group":
		return ev.setStringFieldValue("chown.file.group", &ev.Chown.File.FileFields.Group, value)
	case "chown.file.hashes":
		return ev.setStringArrayFieldValue("chown.file.hashes", &ev.Chown.File.Hashes, value)
	case "chown.file.in_upper_layer":
		return ev.setBoolFieldValue("chown.file.in_upper_layer", &ev.Chown.File.FileFields.InUpperLayer, value)
	case "chown.file.inode":
		return ev.setUint64FieldValue("chown.file.inode", &ev.Chown.File.FileFields.PathKey.Inode, value)
	case "chown.file.mode":
		return ev.setUint16FieldValue("chown.file.mode", &ev.Chown.File.FileFields.Mode, value)
	case "chown.file.modification_time":
		return ev.setUint64FieldValue("chown.file.modification_time", &ev.Chown.File.FileFields.MTime, value)
	case "chown.file.mount_id":
		return ev.setUint32FieldValue("chown.file.mount_id", &ev.Chown.File.FileFields.PathKey.MountID, value)
	case "chown.file.name":
		return ev.setStringFieldValue("chown.file.name", &ev.Chown.File.BasenameStr, value)
	case "chown.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "chown.file.name.length"}
	case "chown.file.package.name":
		return ev.setStringFieldValue("chown.file.package.name", &ev.Chown.File.PkgName, value)
	case "chown.file.package.source_version":
		return ev.setStringFieldValue("chown.file.package.source_version", &ev.Chown.File.PkgSrcVersion, value)
	case "chown.file.package.version":
		return ev.setStringFieldValue("chown.file.package.version", &ev.Chown.File.PkgVersion, value)
	case "chown.file.path":
		return ev.setStringFieldValue("chown.file.path", &ev.Chown.File.PathnameStr, value)
	case "chown.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "chown.file.path.length"}
	case "chown.file.rights":
		return ev.setUint16FieldValue("chown.file.rights", &ev.Chown.File.FileFields.Mode, value)
	case "chown.file.uid":
		return ev.setUint32FieldValue("chown.file.uid", &ev.Chown.File.FileFields.UID, value)
	case "chown.file.user":
		return ev.setStringFieldValue("chown.file.user", &ev.Chown.File.FileFields.User, value)
	case "chown.retval":
		return ev.setInt64FieldValue("chown.retval", &ev.Chown.SyscallEvent.Retval, value)
	case "chown.syscall.gid":
		return ev.setInt64FieldValue("chown.syscall.gid", &ev.Chown.SyscallContext.IntArg3, value)
	case "chown.syscall.path":
		return ev.setStringFieldValue("chown.syscall.path", &ev.Chown.SyscallContext.StrArg1, value)
	case "chown.syscall.uid":
		return ev.setInt64FieldValue("chown.syscall.uid", &ev.Chown.SyscallContext.IntArg2, value)
	case "connect.addr.family":
		return ev.setUint16FieldValue("connect.addr.family", &ev.Connect.AddrFamily, value)
	case "connect.addr.hostname":
		return ev.setStringArrayFieldValue("connect.addr.hostname", &ev.Connect.Hostnames, value)
	case "connect.addr.ip":
		rv, ok := value.(net.IPNet)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "connect.addr.ip"}
		}
		ev.Connect.Addr.IPNet = rv
		return nil
	case "connect.addr.is_public":
		return ev.setBoolFieldValue("connect.addr.is_public", &ev.Connect.Addr.IsPublic, value)
	case "connect.addr.port":
		return ev.setUint16FieldValue("connect.addr.port", &ev.Connect.Addr.Port, value)
	case "connect.protocol":
		return ev.setUint16FieldValue("connect.protocol", &ev.Connect.Protocol, value)
	case "connect.retval":
		return ev.setInt64FieldValue("connect.retval", &ev.Connect.SyscallEvent.Retval, value)
	case "container.created_at":
		if ev.BaseEvent.ContainerContext == nil {
			ev.BaseEvent.ContainerContext = &ContainerContext{}
		}
		return ev.setUint64FieldValue("container.created_at", &ev.BaseEvent.ContainerContext.CreatedAt, value)
	case "container.id":
		if ev.BaseEvent.ContainerContext == nil {
			ev.BaseEvent.ContainerContext = &ContainerContext{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "container.id"}
		}
		ev.BaseEvent.ContainerContext.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "container.runtime":
		if ev.BaseEvent.ContainerContext == nil {
			ev.BaseEvent.ContainerContext = &ContainerContext{}
		}
		return ev.setStringFieldValue("container.runtime", &ev.BaseEvent.ContainerContext.Runtime, value)
	case "container.tags":
		if ev.BaseEvent.ContainerContext == nil {
			ev.BaseEvent.ContainerContext = &ContainerContext{}
		}
		return ev.setStringArrayFieldValue("container.tags", &ev.BaseEvent.ContainerContext.Tags, value)
	case "dns.id":
		return ev.setUint16FieldValue("dns.id", &ev.DNS.ID, value)
	case "dns.question.class":
		return ev.setUint16FieldValue("dns.question.class", &ev.DNS.Question.Class, value)
	case "dns.question.count":
		return ev.setUint16FieldValue("dns.question.count", &ev.DNS.Question.Count, value)
	case "dns.question.length":
		return ev.setUint16FieldValue("dns.question.length", &ev.DNS.Question.Size, value)
	case "dns.question.name":
		return ev.setStringFieldValue("dns.question.name", &ev.DNS.Question.Name, value)
	case "dns.question.name.length":
		return &eval.ErrFieldReadOnly{Field: "dns.question.name.length"}
	case "dns.question.type":
		return ev.setUint16FieldValue("dns.question.type", &ev.DNS.Question.Type, value)
	case "dns.response.code":
		if ev.DNS.Response == nil {
			ev.DNS.Response = &DNSResponse{}
		}
		return ev.setUint8FieldValue("dns.response.code", &ev.DNS.Response.ResponseCode, value)
	case "event.async":
		return ev.setBoolFieldValue("event.async", &ev.Async, value)
	case "event.hostname":
		return ev.setStringFieldValue("event.hostname", &ev.BaseEvent.Hostname, value)
	case "event.origin":
		return ev.setStringFieldValue("event.origin", &ev.BaseEvent.Origin, value)
	case "event.os":
		return ev.setStringFieldValue("event.os", &ev.BaseEvent.Os, value)
	case "event.rule.tags":
		return ev.setStringArrayFieldValue("event.rule.tags", &ev.BaseEvent.RuleTags, value)
	case "event.service":
		return ev.setStringFieldValue("event.service", &ev.BaseEvent.Service, value)
	case "event.timestamp":
		return ev.setUint64FieldValue("event.timestamp", &ev.BaseEvent.TimestampRaw, value)
	case "exec.args":
		return ev.setStringFieldValue("exec.args", &ev.Exec.Process.Args, value)
	case "exec.args_flags":
		return ev.setStringArrayFieldValue("exec.args_flags", &ev.Exec.Process.Argv, value)
	case "exec.args_options":
		return ev.setStringArrayFieldValue("exec.args_options", &ev.Exec.Process.Argv, value)
	case "exec.args_truncated":
		return ev.setBoolFieldValue("exec.args_truncated", &ev.Exec.Process.ArgsTruncated, value)
	case "exec.argv":
		return ev.setStringArrayFieldValue("exec.argv", &ev.Exec.Process.Argv, value)
	case "exec.argv0":
		return ev.setStringFieldValue("exec.argv0", &ev.Exec.Process.Argv0, value)
	case "exec.auid":
		return ev.setUint32FieldValue("exec.auid", &ev.Exec.Process.Credentials.AUID, value)
	case "exec.cap_effective":
		return ev.setUint64FieldValue("exec.cap_effective", &ev.Exec.Process.Credentials.CapEffective, value)
	case "exec.cap_permitted":
		return ev.setUint64FieldValue("exec.cap_permitted", &ev.Exec.Process.Credentials.CapPermitted, value)
	case "exec.cgroup.file.inode":
		return ev.setUint64FieldValue("exec.cgroup.file.inode", &ev.Exec.Process.CGroup.CGroupFile.Inode, value)
	case "exec.cgroup.file.mount_id":
		return ev.setUint32FieldValue("exec.cgroup.file.mount_id", &ev.Exec.Process.CGroup.CGroupFile.MountID, value)
	case "exec.cgroup.id":
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "exec.cgroup.id"}
		}
		ev.Exec.Process.CGroup.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "exec.cgroup.manager":
		return ev.setStringFieldValue("exec.cgroup.manager", &ev.Exec.Process.CGroup.CGroupManager, value)
	case "exec.cgroup.version":
		return ev.setIntFieldValue("exec.cgroup.version", &ev.Exec.Process.CGroup.CGroupVersion, value)
	case "exec.comm":
		return ev.setStringFieldValue("exec.comm", &ev.Exec.Process.Comm, value)
	case "exec.container.id":
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "exec.container.id"}
		}
		ev.Exec.Process.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "exec.created_at":
		return ev.setUint64FieldValue("exec.created_at", &ev.Exec.Process.CreatedAt, value)
	case "exec.egid":
		return ev.setUint32FieldValue("exec.egid", &ev.Exec.Process.Credentials.EGID, value)
	case "exec.egroup":
		return ev.setStringFieldValue("exec.egroup", &ev.Exec.Process.Credentials.EGroup, value)
	case "exec.envp":
		return ev.setStringArrayFieldValue("exec.envp", &ev.Exec.Process.Envp, value)
	case "exec.envs":
		return ev.setStringArrayFieldValue("exec.envs", &ev.Exec.Process.Envs, value)
	case "exec.envs_truncated":
		return ev.setBoolFieldValue("exec.envs_truncated", &ev.Exec.Process.EnvsTruncated, value)
	case "exec.euid":
		return ev.setUint32FieldValue("exec.euid", &ev.Exec.Process.Credentials.EUID, value)
	case "exec.euser":
		return ev.setStringFieldValue("exec.euser", &ev.Exec.Process.Credentials.EUser, value)
	case "exec.file.change_time":
		return ev.setUint64FieldValue("exec.file.change_time", &ev.Exec.Process.FileEvent.FileFields.CTime, value)
	case "exec.file.filesystem":
		return ev.setStringFieldValue("exec.file.filesystem", &ev.Exec.Process.FileEvent.Filesystem, value)
	case "exec.file.gid":
		return ev.setUint32FieldValue("exec.file.gid", &ev.Exec.Process.FileEvent.FileFields.GID, value)
	case "exec.file.group":
		return ev.setStringFieldValue("exec.file.group", &ev.Exec.Process.FileEvent.FileFields.Group, value)
	case "exec.file.hashes":
		return ev.setStringArrayFieldValue("exec.file.hashes", &ev.Exec.Process.FileEvent.Hashes, value)
	case "exec.file.in_upper_layer":
		return ev.setBoolFieldValue("exec.file.in_upper_layer", &ev.Exec.Process.FileEvent.FileFields.InUpperLayer, value)
	case "exec.file.inode":
		return ev.setUint64FieldValue("exec.file.inode", &ev.Exec.Process.FileEvent.FileFields.PathKey.Inode, value)
	case "exec.file.metadata.abi":
		return ev.setIntFieldValue("exec.file.metadata.abi", &ev.Exec.FileMetadata.ABI, value)
	case "exec.file.metadata.architecture":
		return ev.setIntFieldValue("exec.file.metadata.architecture", &ev.Exec.FileMetadata.Architecture, value)
	case "exec.file.metadata.compression":
		return ev.setIntFieldValue("exec.file.metadata.compression", &ev.Exec.FileMetadata.Compression, value)
	case "exec.file.metadata.is_executable":
		return ev.setBoolFieldValue("exec.file.metadata.is_executable", &ev.Exec.FileMetadata.IsExecutable, value)
	case "exec.file.metadata.is_garble_obfuscated":
		return ev.setBoolFieldValue("exec.file.metadata.is_garble_obfuscated", &ev.Exec.FileMetadata.IsGarbleObfuscated, value)
	case "exec.file.metadata.is_upx_packed":
		return ev.setBoolFieldValue("exec.file.metadata.is_upx_packed", &ev.Exec.FileMetadata.IsUPXPacked, value)
	case "exec.file.metadata.size":
		return ev.setInt64FieldValue("exec.file.metadata.size", &ev.Exec.FileMetadata.Size, value)
	case "exec.file.metadata.type":
		return ev.setIntFieldValue("exec.file.metadata.type", &ev.Exec.FileMetadata.Type, value)
	case "exec.file.mode":
		return ev.setUint16FieldValue("exec.file.mode", &ev.Exec.Process.FileEvent.FileFields.Mode, value)
	case "exec.file.modification_time":
		return ev.setUint64FieldValue("exec.file.modification_time", &ev.Exec.Process.FileEvent.FileFields.MTime, value)
	case "exec.file.mount_id":
		return ev.setUint32FieldValue("exec.file.mount_id", &ev.Exec.Process.FileEvent.FileFields.PathKey.MountID, value)
	case "exec.file.name":
		return ev.setStringFieldValue("exec.file.name", &ev.Exec.Process.FileEvent.BasenameStr, value)
	case "exec.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "exec.file.name.length"}
	case "exec.file.package.name":
		return ev.setStringFieldValue("exec.file.package.name", &ev.Exec.Process.FileEvent.PkgName, value)
	case "exec.file.package.source_version":
		return ev.setStringFieldValue("exec.file.package.source_version", &ev.Exec.Process.FileEvent.PkgSrcVersion, value)
	case "exec.file.package.version":
		return ev.setStringFieldValue("exec.file.package.version", &ev.Exec.Process.FileEvent.PkgVersion, value)
	case "exec.file.path":
		return ev.setStringFieldValue("exec.file.path", &ev.Exec.Process.FileEvent.PathnameStr, value)
	case "exec.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "exec.file.path.length"}
	case "exec.file.rights":
		return ev.setUint16FieldValue("exec.file.rights", &ev.Exec.Process.FileEvent.FileFields.Mode, value)
	case "exec.file.uid":
		return ev.setUint32FieldValue("exec.file.uid", &ev.Exec.Process.FileEvent.FileFields.UID, value)
	case "exec.file.user":
		return ev.setStringFieldValue("exec.file.user", &ev.Exec.Process.FileEvent.FileFields.User, value)
	case "exec.fsgid":
		return ev.setUint32FieldValue("exec.fsgid", &ev.Exec.Process.Credentials.FSGID, value)
	case "exec.fsgroup":
		return ev.setStringFieldValue("exec.fsgroup", &ev.Exec.Process.Credentials.FSGroup, value)
	case "exec.fsuid":
		return ev.setUint32FieldValue("exec.fsuid", &ev.Exec.Process.Credentials.FSUID, value)
	case "exec.fsuser":
		return ev.setStringFieldValue("exec.fsuser", &ev.Exec.Process.Credentials.FSUser, value)
	case "exec.gid":
		return ev.setUint32FieldValue("exec.gid", &ev.Exec.Process.Credentials.GID, value)
	case "exec.group":
		return ev.setStringFieldValue("exec.group", &ev.Exec.Process.Credentials.Group, value)
	case "exec.interpreter.file.change_time":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.change_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("exec.interpreter.file.change_time", &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.CTime, value)
	case "exec.interpreter.file.filesystem":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.filesystem", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exec.interpreter.file.filesystem", &ev.Exec.Process.LinuxBinprm.FileEvent.Filesystem, value)
	case "exec.interpreter.file.gid":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.gid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("exec.interpreter.file.gid", &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.GID, value)
	case "exec.interpreter.file.group":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.group", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exec.interpreter.file.group", &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.Group, value)
	case "exec.interpreter.file.hashes":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.hashes", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringArrayFieldValue("exec.interpreter.file.hashes", &ev.Exec.Process.LinuxBinprm.FileEvent.Hashes, value)
	case "exec.interpreter.file.in_upper_layer":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.in_upper_layer", value)
		if err != nil || !cont {
			return err
		}
		return ev.setBoolFieldValue("exec.interpreter.file.in_upper_layer", &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.InUpperLayer, value)
	case "exec.interpreter.file.inode":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.inode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("exec.interpreter.file.inode", &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode, value)
	case "exec.interpreter.file.mode":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.mode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("exec.interpreter.file.mode", &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "exec.interpreter.file.modification_time":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.modification_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("exec.interpreter.file.modification_time", &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.MTime, value)
	case "exec.interpreter.file.mount_id":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.mount_id", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("exec.interpreter.file.mount_id", &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID, value)
	case "exec.interpreter.file.name":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exec.interpreter.file.name", &ev.Exec.Process.LinuxBinprm.FileEvent.BasenameStr, value)
	case "exec.interpreter.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "exec.interpreter.file.name.length"}
	case "exec.interpreter.file.package.name":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.package.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exec.interpreter.file.package.name", &ev.Exec.Process.LinuxBinprm.FileEvent.PkgName, value)
	case "exec.interpreter.file.package.source_version":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.package.source_version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exec.interpreter.file.package.source_version", &ev.Exec.Process.LinuxBinprm.FileEvent.PkgSrcVersion, value)
	case "exec.interpreter.file.package.version":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.package.version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exec.interpreter.file.package.version", &ev.Exec.Process.LinuxBinprm.FileEvent.PkgVersion, value)
	case "exec.interpreter.file.path":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.path", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exec.interpreter.file.path", &ev.Exec.Process.LinuxBinprm.FileEvent.PathnameStr, value)
	case "exec.interpreter.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "exec.interpreter.file.path.length"}
	case "exec.interpreter.file.rights":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.rights", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("exec.interpreter.file.rights", &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "exec.interpreter.file.uid":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.uid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("exec.interpreter.file.uid", &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.UID, value)
	case "exec.interpreter.file.user":
		cont, err := SetInterpreterFields(&ev.Exec.Process.LinuxBinprm, "file.user", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exec.interpreter.file.user", &ev.Exec.Process.LinuxBinprm.FileEvent.FileFields.User, value)
	case "exec.is_exec":
		return ev.setBoolFieldValue("exec.is_exec", &ev.Exec.Process.IsExec, value)
	case "exec.is_kworker":
		return ev.setBoolFieldValue("exec.is_kworker", &ev.Exec.Process.PIDContext.IsKworker, value)
	case "exec.is_thread":
		return ev.setBoolFieldValue("exec.is_thread", &ev.Exec.Process.IsThread, value)
	case "exec.pid":
		return ev.setUint32FieldValue("exec.pid", &ev.Exec.Process.PIDContext.Pid, value)
	case "exec.ppid":
		return ev.setUint32FieldValue("exec.ppid", &ev.Exec.Process.PPid, value)
	case "exec.syscall.path":
		return ev.setStringFieldValue("exec.syscall.path", &ev.Exec.SyscallContext.StrArg1, value)
	case "exec.tid":
		return ev.setUint32FieldValue("exec.tid", &ev.Exec.Process.PIDContext.Tid, value)
	case "exec.tty_name":
		return ev.setStringFieldValue("exec.tty_name", &ev.Exec.Process.TTYName, value)
	case "exec.uid":
		return ev.setUint32FieldValue("exec.uid", &ev.Exec.Process.Credentials.UID, value)
	case "exec.user":
		return ev.setStringFieldValue("exec.user", &ev.Exec.Process.Credentials.User, value)
	case "exec.user_session.k8s_groups":
		return ev.setStringArrayFieldValue("exec.user_session.k8s_groups", &ev.Exec.Process.UserSession.K8SGroups, value)
	case "exec.user_session.k8s_uid":
		return ev.setStringFieldValue("exec.user_session.k8s_uid", &ev.Exec.Process.UserSession.K8SUID, value)
	case "exec.user_session.k8s_username":
		return ev.setStringFieldValue("exec.user_session.k8s_username", &ev.Exec.Process.UserSession.K8SUsername, value)
	case "exit.args":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.args", &ev.Exit.Process.Args, value)
	case "exit.args_flags":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringArrayFieldValue("exit.args_flags", &ev.Exit.Process.Argv, value)
	case "exit.args_options":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringArrayFieldValue("exit.args_options", &ev.Exit.Process.Argv, value)
	case "exit.args_truncated":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setBoolFieldValue("exit.args_truncated", &ev.Exit.Process.ArgsTruncated, value)
	case "exit.argv":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringArrayFieldValue("exit.argv", &ev.Exit.Process.Argv, value)
	case "exit.argv0":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.argv0", &ev.Exit.Process.Argv0, value)
	case "exit.auid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint32FieldValue("exit.auid", &ev.Exit.Process.Credentials.AUID, value)
	case "exit.cap_effective":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint64FieldValue("exit.cap_effective", &ev.Exit.Process.Credentials.CapEffective, value)
	case "exit.cap_permitted":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint64FieldValue("exit.cap_permitted", &ev.Exit.Process.Credentials.CapPermitted, value)
	case "exit.cause":
		return ev.setUint32FieldValue("exit.cause", &ev.Exit.Cause, value)
	case "exit.cgroup.file.inode":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint64FieldValue("exit.cgroup.file.inode", &ev.Exit.Process.CGroup.CGroupFile.Inode, value)
	case "exit.cgroup.file.mount_id":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint32FieldValue("exit.cgroup.file.mount_id", &ev.Exit.Process.CGroup.CGroupFile.MountID, value)
	case "exit.cgroup.id":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "exit.cgroup.id"}
		}
		ev.Exit.Process.CGroup.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "exit.cgroup.manager":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.cgroup.manager", &ev.Exit.Process.CGroup.CGroupManager, value)
	case "exit.cgroup.version":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setIntFieldValue("exit.cgroup.version", &ev.Exit.Process.CGroup.CGroupVersion, value)
	case "exit.code":
		return ev.setUint32FieldValue("exit.code", &ev.Exit.Code, value)
	case "exit.comm":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.comm", &ev.Exit.Process.Comm, value)
	case "exit.container.id":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "exit.container.id"}
		}
		ev.Exit.Process.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "exit.created_at":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint64FieldValue("exit.created_at", &ev.Exit.Process.CreatedAt, value)
	case "exit.egid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint32FieldValue("exit.egid", &ev.Exit.Process.Credentials.EGID, value)
	case "exit.egroup":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.egroup", &ev.Exit.Process.Credentials.EGroup, value)
	case "exit.envp":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringArrayFieldValue("exit.envp", &ev.Exit.Process.Envp, value)
	case "exit.envs":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringArrayFieldValue("exit.envs", &ev.Exit.Process.Envs, value)
	case "exit.envs_truncated":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setBoolFieldValue("exit.envs_truncated", &ev.Exit.Process.EnvsTruncated, value)
	case "exit.euid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint32FieldValue("exit.euid", &ev.Exit.Process.Credentials.EUID, value)
	case "exit.euser":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.euser", &ev.Exit.Process.Credentials.EUser, value)
	case "exit.file.change_time":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint64FieldValue("exit.file.change_time", &ev.Exit.Process.FileEvent.FileFields.CTime, value)
	case "exit.file.filesystem":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.file.filesystem", &ev.Exit.Process.FileEvent.Filesystem, value)
	case "exit.file.gid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint32FieldValue("exit.file.gid", &ev.Exit.Process.FileEvent.FileFields.GID, value)
	case "exit.file.group":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.file.group", &ev.Exit.Process.FileEvent.FileFields.Group, value)
	case "exit.file.hashes":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringArrayFieldValue("exit.file.hashes", &ev.Exit.Process.FileEvent.Hashes, value)
	case "exit.file.in_upper_layer":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setBoolFieldValue("exit.file.in_upper_layer", &ev.Exit.Process.FileEvent.FileFields.InUpperLayer, value)
	case "exit.file.inode":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint64FieldValue("exit.file.inode", &ev.Exit.Process.FileEvent.FileFields.PathKey.Inode, value)
	case "exit.file.mode":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint16FieldValue("exit.file.mode", &ev.Exit.Process.FileEvent.FileFields.Mode, value)
	case "exit.file.modification_time":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint64FieldValue("exit.file.modification_time", &ev.Exit.Process.FileEvent.FileFields.MTime, value)
	case "exit.file.mount_id":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint32FieldValue("exit.file.mount_id", &ev.Exit.Process.FileEvent.FileFields.PathKey.MountID, value)
	case "exit.file.name":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.file.name", &ev.Exit.Process.FileEvent.BasenameStr, value)
	case "exit.file.name.length":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "exit.file.name.length"}
	case "exit.file.package.name":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.file.package.name", &ev.Exit.Process.FileEvent.PkgName, value)
	case "exit.file.package.source_version":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.file.package.source_version", &ev.Exit.Process.FileEvent.PkgSrcVersion, value)
	case "exit.file.package.version":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.file.package.version", &ev.Exit.Process.FileEvent.PkgVersion, value)
	case "exit.file.path":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.file.path", &ev.Exit.Process.FileEvent.PathnameStr, value)
	case "exit.file.path.length":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "exit.file.path.length"}
	case "exit.file.rights":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint16FieldValue("exit.file.rights", &ev.Exit.Process.FileEvent.FileFields.Mode, value)
	case "exit.file.uid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint32FieldValue("exit.file.uid", &ev.Exit.Process.FileEvent.FileFields.UID, value)
	case "exit.file.user":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.file.user", &ev.Exit.Process.FileEvent.FileFields.User, value)
	case "exit.fsgid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint32FieldValue("exit.fsgid", &ev.Exit.Process.Credentials.FSGID, value)
	case "exit.fsgroup":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.fsgroup", &ev.Exit.Process.Credentials.FSGroup, value)
	case "exit.fsuid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint32FieldValue("exit.fsuid", &ev.Exit.Process.Credentials.FSUID, value)
	case "exit.fsuser":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.fsuser", &ev.Exit.Process.Credentials.FSUser, value)
	case "exit.gid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint32FieldValue("exit.gid", &ev.Exit.Process.Credentials.GID, value)
	case "exit.group":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.group", &ev.Exit.Process.Credentials.Group, value)
	case "exit.interpreter.file.change_time":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.change_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("exit.interpreter.file.change_time", &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.CTime, value)
	case "exit.interpreter.file.filesystem":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.filesystem", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exit.interpreter.file.filesystem", &ev.Exit.Process.LinuxBinprm.FileEvent.Filesystem, value)
	case "exit.interpreter.file.gid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.gid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("exit.interpreter.file.gid", &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.GID, value)
	case "exit.interpreter.file.group":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.group", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exit.interpreter.file.group", &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.Group, value)
	case "exit.interpreter.file.hashes":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.hashes", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringArrayFieldValue("exit.interpreter.file.hashes", &ev.Exit.Process.LinuxBinprm.FileEvent.Hashes, value)
	case "exit.interpreter.file.in_upper_layer":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.in_upper_layer", value)
		if err != nil || !cont {
			return err
		}
		return ev.setBoolFieldValue("exit.interpreter.file.in_upper_layer", &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.InUpperLayer, value)
	case "exit.interpreter.file.inode":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.inode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("exit.interpreter.file.inode", &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode, value)
	case "exit.interpreter.file.mode":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.mode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("exit.interpreter.file.mode", &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "exit.interpreter.file.modification_time":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.modification_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("exit.interpreter.file.modification_time", &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.MTime, value)
	case "exit.interpreter.file.mount_id":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.mount_id", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("exit.interpreter.file.mount_id", &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID, value)
	case "exit.interpreter.file.name":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exit.interpreter.file.name", &ev.Exit.Process.LinuxBinprm.FileEvent.BasenameStr, value)
	case "exit.interpreter.file.name.length":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "exit.interpreter.file.name.length"}
	case "exit.interpreter.file.package.name":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.package.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exit.interpreter.file.package.name", &ev.Exit.Process.LinuxBinprm.FileEvent.PkgName, value)
	case "exit.interpreter.file.package.source_version":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.package.source_version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exit.interpreter.file.package.source_version", &ev.Exit.Process.LinuxBinprm.FileEvent.PkgSrcVersion, value)
	case "exit.interpreter.file.package.version":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.package.version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exit.interpreter.file.package.version", &ev.Exit.Process.LinuxBinprm.FileEvent.PkgVersion, value)
	case "exit.interpreter.file.path":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.path", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exit.interpreter.file.path", &ev.Exit.Process.LinuxBinprm.FileEvent.PathnameStr, value)
	case "exit.interpreter.file.path.length":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "exit.interpreter.file.path.length"}
	case "exit.interpreter.file.rights":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.rights", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("exit.interpreter.file.rights", &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "exit.interpreter.file.uid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.uid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("exit.interpreter.file.uid", &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.UID, value)
	case "exit.interpreter.file.user":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Exit.Process.LinuxBinprm, "file.user", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("exit.interpreter.file.user", &ev.Exit.Process.LinuxBinprm.FileEvent.FileFields.User, value)
	case "exit.is_exec":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setBoolFieldValue("exit.is_exec", &ev.Exit.Process.IsExec, value)
	case "exit.is_kworker":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setBoolFieldValue("exit.is_kworker", &ev.Exit.Process.PIDContext.IsKworker, value)
	case "exit.is_thread":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setBoolFieldValue("exit.is_thread", &ev.Exit.Process.IsThread, value)
	case "exit.pid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint32FieldValue("exit.pid", &ev.Exit.Process.PIDContext.Pid, value)
	case "exit.ppid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint32FieldValue("exit.ppid", &ev.Exit.Process.PPid, value)
	case "exit.tid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint32FieldValue("exit.tid", &ev.Exit.Process.PIDContext.Tid, value)
	case "exit.tty_name":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.tty_name", &ev.Exit.Process.TTYName, value)
	case "exit.uid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setUint32FieldValue("exit.uid", &ev.Exit.Process.Credentials.UID, value)
	case "exit.user":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.user", &ev.Exit.Process.Credentials.User, value)
	case "exit.user_session.k8s_groups":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringArrayFieldValue("exit.user_session.k8s_groups", &ev.Exit.Process.UserSession.K8SGroups, value)
	case "exit.user_session.k8s_uid":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.user_session.k8s_uid", &ev.Exit.Process.UserSession.K8SUID, value)
	case "exit.user_session.k8s_username":
		if ev.Exit.Process == nil {
			ev.Exit.Process = &Process{}
		}
		return ev.setStringFieldValue("exit.user_session.k8s_username", &ev.Exit.Process.UserSession.K8SUsername, value)
	case "imds.aws.is_imds_v2":
		return ev.setBoolFieldValue("imds.aws.is_imds_v2", &ev.IMDS.AWS.IsIMDSv2, value)
	case "imds.aws.security_credentials.type":
		return ev.setStringFieldValue("imds.aws.security_credentials.type", &ev.IMDS.AWS.SecurityCredentials.Type, value)
	case "imds.cloud_provider":
		return ev.setStringFieldValue("imds.cloud_provider", &ev.IMDS.CloudProvider, value)
	case "imds.host":
		return ev.setStringFieldValue("imds.host", &ev.IMDS.Host, value)
	case "imds.server":
		return ev.setStringFieldValue("imds.server", &ev.IMDS.Server, value)
	case "imds.type":
		return ev.setStringFieldValue("imds.type", &ev.IMDS.Type, value)
	case "imds.url":
		return ev.setStringFieldValue("imds.url", &ev.IMDS.URL, value)
	case "imds.user_agent":
		return ev.setStringFieldValue("imds.user_agent", &ev.IMDS.UserAgent, value)
	case "link.file.change_time":
		return ev.setUint64FieldValue("link.file.change_time", &ev.Link.Source.FileFields.CTime, value)
	case "link.file.destination.change_time":
		return ev.setUint64FieldValue("link.file.destination.change_time", &ev.Link.Target.FileFields.CTime, value)
	case "link.file.destination.filesystem":
		return ev.setStringFieldValue("link.file.destination.filesystem", &ev.Link.Target.Filesystem, value)
	case "link.file.destination.gid":
		return ev.setUint32FieldValue("link.file.destination.gid", &ev.Link.Target.FileFields.GID, value)
	case "link.file.destination.group":
		return ev.setStringFieldValue("link.file.destination.group", &ev.Link.Target.FileFields.Group, value)
	case "link.file.destination.hashes":
		return ev.setStringArrayFieldValue("link.file.destination.hashes", &ev.Link.Target.Hashes, value)
	case "link.file.destination.in_upper_layer":
		return ev.setBoolFieldValue("link.file.destination.in_upper_layer", &ev.Link.Target.FileFields.InUpperLayer, value)
	case "link.file.destination.inode":
		return ev.setUint64FieldValue("link.file.destination.inode", &ev.Link.Target.FileFields.PathKey.Inode, value)
	case "link.file.destination.mode":
		return ev.setUint16FieldValue("link.file.destination.mode", &ev.Link.Target.FileFields.Mode, value)
	case "link.file.destination.modification_time":
		return ev.setUint64FieldValue("link.file.destination.modification_time", &ev.Link.Target.FileFields.MTime, value)
	case "link.file.destination.mount_id":
		return ev.setUint32FieldValue("link.file.destination.mount_id", &ev.Link.Target.FileFields.PathKey.MountID, value)
	case "link.file.destination.name":
		return ev.setStringFieldValue("link.file.destination.name", &ev.Link.Target.BasenameStr, value)
	case "link.file.destination.name.length":
		return &eval.ErrFieldReadOnly{Field: "link.file.destination.name.length"}
	case "link.file.destination.package.name":
		return ev.setStringFieldValue("link.file.destination.package.name", &ev.Link.Target.PkgName, value)
	case "link.file.destination.package.source_version":
		return ev.setStringFieldValue("link.file.destination.package.source_version", &ev.Link.Target.PkgSrcVersion, value)
	case "link.file.destination.package.version":
		return ev.setStringFieldValue("link.file.destination.package.version", &ev.Link.Target.PkgVersion, value)
	case "link.file.destination.path":
		return ev.setStringFieldValue("link.file.destination.path", &ev.Link.Target.PathnameStr, value)
	case "link.file.destination.path.length":
		return &eval.ErrFieldReadOnly{Field: "link.file.destination.path.length"}
	case "link.file.destination.rights":
		return ev.setUint16FieldValue("link.file.destination.rights", &ev.Link.Target.FileFields.Mode, value)
	case "link.file.destination.uid":
		return ev.setUint32FieldValue("link.file.destination.uid", &ev.Link.Target.FileFields.UID, value)
	case "link.file.destination.user":
		return ev.setStringFieldValue("link.file.destination.user", &ev.Link.Target.FileFields.User, value)
	case "link.file.filesystem":
		return ev.setStringFieldValue("link.file.filesystem", &ev.Link.Source.Filesystem, value)
	case "link.file.gid":
		return ev.setUint32FieldValue("link.file.gid", &ev.Link.Source.FileFields.GID, value)
	case "link.file.group":
		return ev.setStringFieldValue("link.file.group", &ev.Link.Source.FileFields.Group, value)
	case "link.file.hashes":
		return ev.setStringArrayFieldValue("link.file.hashes", &ev.Link.Source.Hashes, value)
	case "link.file.in_upper_layer":
		return ev.setBoolFieldValue("link.file.in_upper_layer", &ev.Link.Source.FileFields.InUpperLayer, value)
	case "link.file.inode":
		return ev.setUint64FieldValue("link.file.inode", &ev.Link.Source.FileFields.PathKey.Inode, value)
	case "link.file.mode":
		return ev.setUint16FieldValue("link.file.mode", &ev.Link.Source.FileFields.Mode, value)
	case "link.file.modification_time":
		return ev.setUint64FieldValue("link.file.modification_time", &ev.Link.Source.FileFields.MTime, value)
	case "link.file.mount_id":
		return ev.setUint32FieldValue("link.file.mount_id", &ev.Link.Source.FileFields.PathKey.MountID, value)
	case "link.file.name":
		return ev.setStringFieldValue("link.file.name", &ev.Link.Source.BasenameStr, value)
	case "link.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "link.file.name.length"}
	case "link.file.package.name":
		return ev.setStringFieldValue("link.file.package.name", &ev.Link.Source.PkgName, value)
	case "link.file.package.source_version":
		return ev.setStringFieldValue("link.file.package.source_version", &ev.Link.Source.PkgSrcVersion, value)
	case "link.file.package.version":
		return ev.setStringFieldValue("link.file.package.version", &ev.Link.Source.PkgVersion, value)
	case "link.file.path":
		return ev.setStringFieldValue("link.file.path", &ev.Link.Source.PathnameStr, value)
	case "link.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "link.file.path.length"}
	case "link.file.rights":
		return ev.setUint16FieldValue("link.file.rights", &ev.Link.Source.FileFields.Mode, value)
	case "link.file.uid":
		return ev.setUint32FieldValue("link.file.uid", &ev.Link.Source.FileFields.UID, value)
	case "link.file.user":
		return ev.setStringFieldValue("link.file.user", &ev.Link.Source.FileFields.User, value)
	case "link.retval":
		return ev.setInt64FieldValue("link.retval", &ev.Link.SyscallEvent.Retval, value)
	case "link.syscall.destination.path":
		return ev.setStringFieldValue("link.syscall.destination.path", &ev.Link.SyscallContext.StrArg2, value)
	case "link.syscall.path":
		return ev.setStringFieldValue("link.syscall.path", &ev.Link.SyscallContext.StrArg1, value)
	case "load_module.args":
		return ev.setStringFieldValue("load_module.args", &ev.LoadModule.Args, value)
	case "load_module.args_truncated":
		return ev.setBoolFieldValue("load_module.args_truncated", &ev.LoadModule.ArgsTruncated, value)
	case "load_module.argv":
		return ev.setStringArrayFieldValue("load_module.argv", &ev.LoadModule.Argv, value)
	case "load_module.file.change_time":
		return ev.setUint64FieldValue("load_module.file.change_time", &ev.LoadModule.File.FileFields.CTime, value)
	case "load_module.file.filesystem":
		return ev.setStringFieldValue("load_module.file.filesystem", &ev.LoadModule.File.Filesystem, value)
	case "load_module.file.gid":
		return ev.setUint32FieldValue("load_module.file.gid", &ev.LoadModule.File.FileFields.GID, value)
	case "load_module.file.group":
		return ev.setStringFieldValue("load_module.file.group", &ev.LoadModule.File.FileFields.Group, value)
	case "load_module.file.hashes":
		return ev.setStringArrayFieldValue("load_module.file.hashes", &ev.LoadModule.File.Hashes, value)
	case "load_module.file.in_upper_layer":
		return ev.setBoolFieldValue("load_module.file.in_upper_layer", &ev.LoadModule.File.FileFields.InUpperLayer, value)
	case "load_module.file.inode":
		return ev.setUint64FieldValue("load_module.file.inode", &ev.LoadModule.File.FileFields.PathKey.Inode, value)
	case "load_module.file.mode":
		return ev.setUint16FieldValue("load_module.file.mode", &ev.LoadModule.File.FileFields.Mode, value)
	case "load_module.file.modification_time":
		return ev.setUint64FieldValue("load_module.file.modification_time", &ev.LoadModule.File.FileFields.MTime, value)
	case "load_module.file.mount_id":
		return ev.setUint32FieldValue("load_module.file.mount_id", &ev.LoadModule.File.FileFields.PathKey.MountID, value)
	case "load_module.file.name":
		return ev.setStringFieldValue("load_module.file.name", &ev.LoadModule.File.BasenameStr, value)
	case "load_module.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "load_module.file.name.length"}
	case "load_module.file.package.name":
		return ev.setStringFieldValue("load_module.file.package.name", &ev.LoadModule.File.PkgName, value)
	case "load_module.file.package.source_version":
		return ev.setStringFieldValue("load_module.file.package.source_version", &ev.LoadModule.File.PkgSrcVersion, value)
	case "load_module.file.package.version":
		return ev.setStringFieldValue("load_module.file.package.version", &ev.LoadModule.File.PkgVersion, value)
	case "load_module.file.path":
		return ev.setStringFieldValue("load_module.file.path", &ev.LoadModule.File.PathnameStr, value)
	case "load_module.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "load_module.file.path.length"}
	case "load_module.file.rights":
		return ev.setUint16FieldValue("load_module.file.rights", &ev.LoadModule.File.FileFields.Mode, value)
	case "load_module.file.uid":
		return ev.setUint32FieldValue("load_module.file.uid", &ev.LoadModule.File.FileFields.UID, value)
	case "load_module.file.user":
		return ev.setStringFieldValue("load_module.file.user", &ev.LoadModule.File.FileFields.User, value)
	case "load_module.loaded_from_memory":
		return ev.setBoolFieldValue("load_module.loaded_from_memory", &ev.LoadModule.LoadedFromMemory, value)
	case "load_module.name":
		return ev.setStringFieldValue("load_module.name", &ev.LoadModule.Name, value)
	case "load_module.retval":
		return ev.setInt64FieldValue("load_module.retval", &ev.LoadModule.SyscallEvent.Retval, value)
	case "mkdir.file.change_time":
		return ev.setUint64FieldValue("mkdir.file.change_time", &ev.Mkdir.File.FileFields.CTime, value)
	case "mkdir.file.destination.mode":
		return ev.setUint32FieldValue("mkdir.file.destination.mode", &ev.Mkdir.Mode, value)
	case "mkdir.file.destination.rights":
		return ev.setUint32FieldValue("mkdir.file.destination.rights", &ev.Mkdir.Mode, value)
	case "mkdir.file.filesystem":
		return ev.setStringFieldValue("mkdir.file.filesystem", &ev.Mkdir.File.Filesystem, value)
	case "mkdir.file.gid":
		return ev.setUint32FieldValue("mkdir.file.gid", &ev.Mkdir.File.FileFields.GID, value)
	case "mkdir.file.group":
		return ev.setStringFieldValue("mkdir.file.group", &ev.Mkdir.File.FileFields.Group, value)
	case "mkdir.file.hashes":
		return ev.setStringArrayFieldValue("mkdir.file.hashes", &ev.Mkdir.File.Hashes, value)
	case "mkdir.file.in_upper_layer":
		return ev.setBoolFieldValue("mkdir.file.in_upper_layer", &ev.Mkdir.File.FileFields.InUpperLayer, value)
	case "mkdir.file.inode":
		return ev.setUint64FieldValue("mkdir.file.inode", &ev.Mkdir.File.FileFields.PathKey.Inode, value)
	case "mkdir.file.mode":
		return ev.setUint16FieldValue("mkdir.file.mode", &ev.Mkdir.File.FileFields.Mode, value)
	case "mkdir.file.modification_time":
		return ev.setUint64FieldValue("mkdir.file.modification_time", &ev.Mkdir.File.FileFields.MTime, value)
	case "mkdir.file.mount_id":
		return ev.setUint32FieldValue("mkdir.file.mount_id", &ev.Mkdir.File.FileFields.PathKey.MountID, value)
	case "mkdir.file.name":
		return ev.setStringFieldValue("mkdir.file.name", &ev.Mkdir.File.BasenameStr, value)
	case "mkdir.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "mkdir.file.name.length"}
	case "mkdir.file.package.name":
		return ev.setStringFieldValue("mkdir.file.package.name", &ev.Mkdir.File.PkgName, value)
	case "mkdir.file.package.source_version":
		return ev.setStringFieldValue("mkdir.file.package.source_version", &ev.Mkdir.File.PkgSrcVersion, value)
	case "mkdir.file.package.version":
		return ev.setStringFieldValue("mkdir.file.package.version", &ev.Mkdir.File.PkgVersion, value)
	case "mkdir.file.path":
		return ev.setStringFieldValue("mkdir.file.path", &ev.Mkdir.File.PathnameStr, value)
	case "mkdir.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "mkdir.file.path.length"}
	case "mkdir.file.rights":
		return ev.setUint16FieldValue("mkdir.file.rights", &ev.Mkdir.File.FileFields.Mode, value)
	case "mkdir.file.uid":
		return ev.setUint32FieldValue("mkdir.file.uid", &ev.Mkdir.File.FileFields.UID, value)
	case "mkdir.file.user":
		return ev.setStringFieldValue("mkdir.file.user", &ev.Mkdir.File.FileFields.User, value)
	case "mkdir.retval":
		return ev.setInt64FieldValue("mkdir.retval", &ev.Mkdir.SyscallEvent.Retval, value)
	case "mkdir.syscall.mode":
		return ev.setInt64FieldValue("mkdir.syscall.mode", &ev.Mkdir.SyscallContext.IntArg2, value)
	case "mkdir.syscall.path":
		return ev.setStringFieldValue("mkdir.syscall.path", &ev.Mkdir.SyscallContext.StrArg1, value)
	case "mmap.file.change_time":
		return ev.setUint64FieldValue("mmap.file.change_time", &ev.MMap.File.FileFields.CTime, value)
	case "mmap.file.filesystem":
		return ev.setStringFieldValue("mmap.file.filesystem", &ev.MMap.File.Filesystem, value)
	case "mmap.file.gid":
		return ev.setUint32FieldValue("mmap.file.gid", &ev.MMap.File.FileFields.GID, value)
	case "mmap.file.group":
		return ev.setStringFieldValue("mmap.file.group", &ev.MMap.File.FileFields.Group, value)
	case "mmap.file.hashes":
		return ev.setStringArrayFieldValue("mmap.file.hashes", &ev.MMap.File.Hashes, value)
	case "mmap.file.in_upper_layer":
		return ev.setBoolFieldValue("mmap.file.in_upper_layer", &ev.MMap.File.FileFields.InUpperLayer, value)
	case "mmap.file.inode":
		return ev.setUint64FieldValue("mmap.file.inode", &ev.MMap.File.FileFields.PathKey.Inode, value)
	case "mmap.file.mode":
		return ev.setUint16FieldValue("mmap.file.mode", &ev.MMap.File.FileFields.Mode, value)
	case "mmap.file.modification_time":
		return ev.setUint64FieldValue("mmap.file.modification_time", &ev.MMap.File.FileFields.MTime, value)
	case "mmap.file.mount_id":
		return ev.setUint32FieldValue("mmap.file.mount_id", &ev.MMap.File.FileFields.PathKey.MountID, value)
	case "mmap.file.name":
		return ev.setStringFieldValue("mmap.file.name", &ev.MMap.File.BasenameStr, value)
	case "mmap.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "mmap.file.name.length"}
	case "mmap.file.package.name":
		return ev.setStringFieldValue("mmap.file.package.name", &ev.MMap.File.PkgName, value)
	case "mmap.file.package.source_version":
		return ev.setStringFieldValue("mmap.file.package.source_version", &ev.MMap.File.PkgSrcVersion, value)
	case "mmap.file.package.version":
		return ev.setStringFieldValue("mmap.file.package.version", &ev.MMap.File.PkgVersion, value)
	case "mmap.file.path":
		return ev.setStringFieldValue("mmap.file.path", &ev.MMap.File.PathnameStr, value)
	case "mmap.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "mmap.file.path.length"}
	case "mmap.file.rights":
		return ev.setUint16FieldValue("mmap.file.rights", &ev.MMap.File.FileFields.Mode, value)
	case "mmap.file.uid":
		return ev.setUint32FieldValue("mmap.file.uid", &ev.MMap.File.FileFields.UID, value)
	case "mmap.file.user":
		return ev.setStringFieldValue("mmap.file.user", &ev.MMap.File.FileFields.User, value)
	case "mmap.flags":
		return ev.setUint64FieldValue("mmap.flags", &ev.MMap.Flags, value)
	case "mmap.protection":
		return ev.setUint64FieldValue("mmap.protection", &ev.MMap.Protection, value)
	case "mmap.retval":
		return ev.setInt64FieldValue("mmap.retval", &ev.MMap.SyscallEvent.Retval, value)
	case "mount.fs_type":
		return ev.setStringFieldValue("mount.fs_type", &ev.Mount.Mount.FSType, value)
	case "mount.mountpoint.path":
		return ev.setStringFieldValue("mount.mountpoint.path", &ev.Mount.MountPointPath, value)
	case "mount.retval":
		return ev.setInt64FieldValue("mount.retval", &ev.Mount.SyscallEvent.Retval, value)
	case "mount.root.path":
		return ev.setStringFieldValue("mount.root.path", &ev.Mount.MountRootPath, value)
	case "mount.source.path":
		return ev.setStringFieldValue("mount.source.path", &ev.Mount.MountSourcePath, value)
	case "mount.syscall.fs_type":
		return ev.setStringFieldValue("mount.syscall.fs_type", &ev.Mount.SyscallContext.StrArg3, value)
	case "mount.syscall.mountpoint.path":
		return ev.setStringFieldValue("mount.syscall.mountpoint.path", &ev.Mount.SyscallContext.StrArg2, value)
	case "mount.syscall.source.path":
		return ev.setStringFieldValue("mount.syscall.source.path", &ev.Mount.SyscallContext.StrArg1, value)
	case "mprotect.req_protection":
		return ev.setIntFieldValue("mprotect.req_protection", &ev.MProtect.ReqProtection, value)
	case "mprotect.retval":
		return ev.setInt64FieldValue("mprotect.retval", &ev.MProtect.SyscallEvent.Retval, value)
	case "mprotect.vm_protection":
		return ev.setIntFieldValue("mprotect.vm_protection", &ev.MProtect.VMProtection, value)
	case "network.destination.ip":
		rv, ok := value.(net.IPNet)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "network.destination.ip"}
		}
		ev.NetworkContext.Destination.IPNet = rv
		return nil
	case "network.destination.is_public":
		return ev.setBoolFieldValue("network.destination.is_public", &ev.NetworkContext.Destination.IsPublic, value)
	case "network.destination.port":
		return ev.setUint16FieldValue("network.destination.port", &ev.NetworkContext.Destination.Port, value)
	case "network.device.ifname":
		return ev.setStringFieldValue("network.device.ifname", &ev.NetworkContext.Device.IfName, value)
	case "network.l3_protocol":
		return ev.setUint16FieldValue("network.l3_protocol", &ev.NetworkContext.L3Protocol, value)
	case "network.l4_protocol":
		return ev.setUint16FieldValue("network.l4_protocol", &ev.NetworkContext.L4Protocol, value)
	case "network.network_direction":
		return ev.setUint32FieldValue("network.network_direction", &ev.NetworkContext.NetworkDirection, value)
	case "network.size":
		return ev.setUint32FieldValue("network.size", &ev.NetworkContext.Size, value)
	case "network.source.ip":
		rv, ok := value.(net.IPNet)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "network.source.ip"}
		}
		ev.NetworkContext.Source.IPNet = rv
		return nil
	case "network.source.is_public":
		return ev.setBoolFieldValue("network.source.is_public", &ev.NetworkContext.Source.IsPublic, value)
	case "network.source.port":
		return ev.setUint16FieldValue("network.source.port", &ev.NetworkContext.Source.Port, value)
	case "network_flow_monitor.device.ifname":
		return ev.setStringFieldValue("network_flow_monitor.device.ifname", &ev.NetworkFlowMonitor.Device.IfName, value)
	case "network_flow_monitor.flows.destination.ip":
		if len(ev.NetworkFlowMonitor.Flows) == 0 {
			ev.NetworkFlowMonitor.Flows = append(ev.NetworkFlowMonitor.Flows, Flow{})
		}
		rv, ok := value.(net.IPNet)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "network_flow_monitor.flows.destination.ip"}
		}
		ev.NetworkFlowMonitor.Flows[0].Destination.IPNet = rv
		return nil
	case "network_flow_monitor.flows.destination.is_public":
		if len(ev.NetworkFlowMonitor.Flows) == 0 {
			ev.NetworkFlowMonitor.Flows = append(ev.NetworkFlowMonitor.Flows, Flow{})
		}
		return ev.setBoolFieldValue("network_flow_monitor.flows.destination.is_public", &ev.NetworkFlowMonitor.Flows[0].Destination.IsPublic, value)
	case "network_flow_monitor.flows.destination.port":
		if len(ev.NetworkFlowMonitor.Flows) == 0 {
			ev.NetworkFlowMonitor.Flows = append(ev.NetworkFlowMonitor.Flows, Flow{})
		}
		return ev.setUint16FieldValue("network_flow_monitor.flows.destination.port", &ev.NetworkFlowMonitor.Flows[0].Destination.Port, value)
	case "network_flow_monitor.flows.egress.data_size":
		if len(ev.NetworkFlowMonitor.Flows) == 0 {
			ev.NetworkFlowMonitor.Flows = append(ev.NetworkFlowMonitor.Flows, Flow{})
		}
		return ev.setUint64FieldValue("network_flow_monitor.flows.egress.data_size", &ev.NetworkFlowMonitor.Flows[0].Egress.DataSize, value)
	case "network_flow_monitor.flows.egress.packet_count":
		if len(ev.NetworkFlowMonitor.Flows) == 0 {
			ev.NetworkFlowMonitor.Flows = append(ev.NetworkFlowMonitor.Flows, Flow{})
		}
		return ev.setUint64FieldValue("network_flow_monitor.flows.egress.packet_count", &ev.NetworkFlowMonitor.Flows[0].Egress.PacketCount, value)
	case "network_flow_monitor.flows.ingress.data_size":
		if len(ev.NetworkFlowMonitor.Flows) == 0 {
			ev.NetworkFlowMonitor.Flows = append(ev.NetworkFlowMonitor.Flows, Flow{})
		}
		return ev.setUint64FieldValue("network_flow_monitor.flows.ingress.data_size", &ev.NetworkFlowMonitor.Flows[0].Ingress.DataSize, value)
	case "network_flow_monitor.flows.ingress.packet_count":
		if len(ev.NetworkFlowMonitor.Flows) == 0 {
			ev.NetworkFlowMonitor.Flows = append(ev.NetworkFlowMonitor.Flows, Flow{})
		}
		return ev.setUint64FieldValue("network_flow_monitor.flows.ingress.packet_count", &ev.NetworkFlowMonitor.Flows[0].Ingress.PacketCount, value)
	case "network_flow_monitor.flows.l3_protocol":
		if len(ev.NetworkFlowMonitor.Flows) == 0 {
			ev.NetworkFlowMonitor.Flows = append(ev.NetworkFlowMonitor.Flows, Flow{})
		}
		return ev.setUint16FieldValue("network_flow_monitor.flows.l3_protocol", &ev.NetworkFlowMonitor.Flows[0].L3Protocol, value)
	case "network_flow_monitor.flows.l4_protocol":
		if len(ev.NetworkFlowMonitor.Flows) == 0 {
			ev.NetworkFlowMonitor.Flows = append(ev.NetworkFlowMonitor.Flows, Flow{})
		}
		return ev.setUint16FieldValue("network_flow_monitor.flows.l4_protocol", &ev.NetworkFlowMonitor.Flows[0].L4Protocol, value)
	case "network_flow_monitor.flows.length":
		if len(ev.NetworkFlowMonitor.Flows) == 0 {
			ev.NetworkFlowMonitor.Flows = append(ev.NetworkFlowMonitor.Flows, Flow{})
		}
		return &eval.ErrFieldReadOnly{Field: "network_flow_monitor.flows.length"}
	case "network_flow_monitor.flows.source.ip":
		if len(ev.NetworkFlowMonitor.Flows) == 0 {
			ev.NetworkFlowMonitor.Flows = append(ev.NetworkFlowMonitor.Flows, Flow{})
		}
		rv, ok := value.(net.IPNet)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "network_flow_monitor.flows.source.ip"}
		}
		ev.NetworkFlowMonitor.Flows[0].Source.IPNet = rv
		return nil
	case "network_flow_monitor.flows.source.is_public":
		if len(ev.NetworkFlowMonitor.Flows) == 0 {
			ev.NetworkFlowMonitor.Flows = append(ev.NetworkFlowMonitor.Flows, Flow{})
		}
		return ev.setBoolFieldValue("network_flow_monitor.flows.source.is_public", &ev.NetworkFlowMonitor.Flows[0].Source.IsPublic, value)
	case "network_flow_monitor.flows.source.port":
		if len(ev.NetworkFlowMonitor.Flows) == 0 {
			ev.NetworkFlowMonitor.Flows = append(ev.NetworkFlowMonitor.Flows, Flow{})
		}
		return ev.setUint16FieldValue("network_flow_monitor.flows.source.port", &ev.NetworkFlowMonitor.Flows[0].Source.Port, value)
	case "ondemand.arg1.str":
		return ev.setStringFieldValue("ondemand.arg1.str", &ev.OnDemand.Arg1Str, value)
	case "ondemand.arg1.uint":
		return ev.setUint64FieldValue("ondemand.arg1.uint", &ev.OnDemand.Arg1Uint, value)
	case "ondemand.arg2.str":
		return ev.setStringFieldValue("ondemand.arg2.str", &ev.OnDemand.Arg2Str, value)
	case "ondemand.arg2.uint":
		return ev.setUint64FieldValue("ondemand.arg2.uint", &ev.OnDemand.Arg2Uint, value)
	case "ondemand.arg3.str":
		return ev.setStringFieldValue("ondemand.arg3.str", &ev.OnDemand.Arg3Str, value)
	case "ondemand.arg3.uint":
		return ev.setUint64FieldValue("ondemand.arg3.uint", &ev.OnDemand.Arg3Uint, value)
	case "ondemand.arg4.str":
		return ev.setStringFieldValue("ondemand.arg4.str", &ev.OnDemand.Arg4Str, value)
	case "ondemand.arg4.uint":
		return ev.setUint64FieldValue("ondemand.arg4.uint", &ev.OnDemand.Arg4Uint, value)
	case "ondemand.arg5.str":
		return ev.setStringFieldValue("ondemand.arg5.str", &ev.OnDemand.Arg5Str, value)
	case "ondemand.arg5.uint":
		return ev.setUint64FieldValue("ondemand.arg5.uint", &ev.OnDemand.Arg5Uint, value)
	case "ondemand.arg6.str":
		return ev.setStringFieldValue("ondemand.arg6.str", &ev.OnDemand.Arg6Str, value)
	case "ondemand.arg6.uint":
		return ev.setUint64FieldValue("ondemand.arg6.uint", &ev.OnDemand.Arg6Uint, value)
	case "ondemand.name":
		return ev.setStringFieldValue("ondemand.name", &ev.OnDemand.Name, value)
	case "open.file.change_time":
		return ev.setUint64FieldValue("open.file.change_time", &ev.Open.File.FileFields.CTime, value)
	case "open.file.destination.mode":
		return ev.setUint32FieldValue("open.file.destination.mode", &ev.Open.Mode, value)
	case "open.file.filesystem":
		return ev.setStringFieldValue("open.file.filesystem", &ev.Open.File.Filesystem, value)
	case "open.file.gid":
		return ev.setUint32FieldValue("open.file.gid", &ev.Open.File.FileFields.GID, value)
	case "open.file.group":
		return ev.setStringFieldValue("open.file.group", &ev.Open.File.FileFields.Group, value)
	case "open.file.hashes":
		return ev.setStringArrayFieldValue("open.file.hashes", &ev.Open.File.Hashes, value)
	case "open.file.in_upper_layer":
		return ev.setBoolFieldValue("open.file.in_upper_layer", &ev.Open.File.FileFields.InUpperLayer, value)
	case "open.file.inode":
		return ev.setUint64FieldValue("open.file.inode", &ev.Open.File.FileFields.PathKey.Inode, value)
	case "open.file.mode":
		return ev.setUint16FieldValue("open.file.mode", &ev.Open.File.FileFields.Mode, value)
	case "open.file.modification_time":
		return ev.setUint64FieldValue("open.file.modification_time", &ev.Open.File.FileFields.MTime, value)
	case "open.file.mount_id":
		return ev.setUint32FieldValue("open.file.mount_id", &ev.Open.File.FileFields.PathKey.MountID, value)
	case "open.file.name":
		return ev.setStringFieldValue("open.file.name", &ev.Open.File.BasenameStr, value)
	case "open.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "open.file.name.length"}
	case "open.file.package.name":
		return ev.setStringFieldValue("open.file.package.name", &ev.Open.File.PkgName, value)
	case "open.file.package.source_version":
		return ev.setStringFieldValue("open.file.package.source_version", &ev.Open.File.PkgSrcVersion, value)
	case "open.file.package.version":
		return ev.setStringFieldValue("open.file.package.version", &ev.Open.File.PkgVersion, value)
	case "open.file.path":
		return ev.setStringFieldValue("open.file.path", &ev.Open.File.PathnameStr, value)
	case "open.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "open.file.path.length"}
	case "open.file.rights":
		return ev.setUint16FieldValue("open.file.rights", &ev.Open.File.FileFields.Mode, value)
	case "open.file.uid":
		return ev.setUint32FieldValue("open.file.uid", &ev.Open.File.FileFields.UID, value)
	case "open.file.user":
		return ev.setStringFieldValue("open.file.user", &ev.Open.File.FileFields.User, value)
	case "open.flags":
		return ev.setUint32FieldValue("open.flags", &ev.Open.Flags, value)
	case "open.retval":
		return ev.setInt64FieldValue("open.retval", &ev.Open.SyscallEvent.Retval, value)
	case "open.syscall.flags":
		return ev.setInt64FieldValue("open.syscall.flags", &ev.Open.SyscallContext.IntArg2, value)
	case "open.syscall.mode":
		return ev.setInt64FieldValue("open.syscall.mode", &ev.Open.SyscallContext.IntArg3, value)
	case "open.syscall.path":
		return ev.setStringFieldValue("open.syscall.path", &ev.Open.SyscallContext.StrArg1, value)
	case "packet.destination.ip":
		rv, ok := value.(net.IPNet)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "packet.destination.ip"}
		}
		ev.RawPacket.NetworkContext.Destination.IPNet = rv
		return nil
	case "packet.destination.is_public":
		return ev.setBoolFieldValue("packet.destination.is_public", &ev.RawPacket.NetworkContext.Destination.IsPublic, value)
	case "packet.destination.port":
		return ev.setUint16FieldValue("packet.destination.port", &ev.RawPacket.NetworkContext.Destination.Port, value)
	case "packet.device.ifname":
		return ev.setStringFieldValue("packet.device.ifname", &ev.RawPacket.NetworkContext.Device.IfName, value)
	case "packet.filter":
		return ev.setStringFieldValue("packet.filter", &ev.RawPacket.Filter, value)
	case "packet.l3_protocol":
		return ev.setUint16FieldValue("packet.l3_protocol", &ev.RawPacket.NetworkContext.L3Protocol, value)
	case "packet.l4_protocol":
		return ev.setUint16FieldValue("packet.l4_protocol", &ev.RawPacket.NetworkContext.L4Protocol, value)
	case "packet.network_direction":
		return ev.setUint32FieldValue("packet.network_direction", &ev.RawPacket.NetworkContext.NetworkDirection, value)
	case "packet.size":
		return ev.setUint32FieldValue("packet.size", &ev.RawPacket.NetworkContext.Size, value)
	case "packet.source.ip":
		rv, ok := value.(net.IPNet)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "packet.source.ip"}
		}
		ev.RawPacket.NetworkContext.Source.IPNet = rv
		return nil
	case "packet.source.is_public":
		return ev.setBoolFieldValue("packet.source.is_public", &ev.RawPacket.NetworkContext.Source.IsPublic, value)
	case "packet.source.port":
		return ev.setUint16FieldValue("packet.source.port", &ev.RawPacket.NetworkContext.Source.Port, value)
	case "packet.tls.version":
		return ev.setUint16FieldValue("packet.tls.version", &ev.RawPacket.TLSContext.Version, value)
	case "process.ancestors.args":
		return ev.setStringFieldValue("process.ancestors.args", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Args, value)
	case "process.ancestors.args_flags":
		return ev.setStringArrayFieldValue("process.ancestors.args_flags", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Argv, value)
	case "process.ancestors.args_options":
		return ev.setStringArrayFieldValue("process.ancestors.args_options", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Argv, value)
	case "process.ancestors.args_truncated":
		return ev.setBoolFieldValue("process.ancestors.args_truncated", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.ArgsTruncated, value)
	case "process.ancestors.argv":
		return ev.setStringArrayFieldValue("process.ancestors.argv", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Argv, value)
	case "process.ancestors.argv0":
		return ev.setStringFieldValue("process.ancestors.argv0", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Argv0, value)
	case "process.ancestors.auid":
		return ev.setUint32FieldValue("process.ancestors.auid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.AUID, value)
	case "process.ancestors.cap_effective":
		return ev.setUint64FieldValue("process.ancestors.cap_effective", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.CapEffective, value)
	case "process.ancestors.cap_permitted":
		return ev.setUint64FieldValue("process.ancestors.cap_permitted", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.CapPermitted, value)
	case "process.ancestors.cgroup.file.inode":
		return ev.setUint64FieldValue("process.ancestors.cgroup.file.inode", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.CGroup.CGroupFile.Inode, value)
	case "process.ancestors.cgroup.file.mount_id":
		return ev.setUint32FieldValue("process.ancestors.cgroup.file.mount_id", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.CGroup.CGroupFile.MountID, value)
	case "process.ancestors.cgroup.id":
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "process.ancestors.cgroup.id"}
		}
		ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.CGroup.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "process.ancestors.cgroup.manager":
		return ev.setStringFieldValue("process.ancestors.cgroup.manager", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.CGroup.CGroupManager, value)
	case "process.ancestors.cgroup.version":
		return ev.setIntFieldValue("process.ancestors.cgroup.version", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.CGroup.CGroupVersion, value)
	case "process.ancestors.comm":
		return ev.setStringFieldValue("process.ancestors.comm", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Comm, value)
	case "process.ancestors.container.id":
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "process.ancestors.container.id"}
		}
		ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "process.ancestors.created_at":
		return ev.setUint64FieldValue("process.ancestors.created_at", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.CreatedAt, value)
	case "process.ancestors.egid":
		return ev.setUint32FieldValue("process.ancestors.egid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.EGID, value)
	case "process.ancestors.egroup":
		return ev.setStringFieldValue("process.ancestors.egroup", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.EGroup, value)
	case "process.ancestors.envp":
		return ev.setStringArrayFieldValue("process.ancestors.envp", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Envp, value)
	case "process.ancestors.envs":
		return ev.setStringArrayFieldValue("process.ancestors.envs", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Envs, value)
	case "process.ancestors.envs_truncated":
		return ev.setBoolFieldValue("process.ancestors.envs_truncated", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.EnvsTruncated, value)
	case "process.ancestors.euid":
		return ev.setUint32FieldValue("process.ancestors.euid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.EUID, value)
	case "process.ancestors.euser":
		return ev.setStringFieldValue("process.ancestors.euser", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.EUser, value)
	case "process.ancestors.file.change_time":
		return ev.setUint64FieldValue("process.ancestors.file.change_time", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.FileFields.CTime, value)
	case "process.ancestors.file.filesystem":
		return ev.setStringFieldValue("process.ancestors.file.filesystem", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.Filesystem, value)
	case "process.ancestors.file.gid":
		return ev.setUint32FieldValue("process.ancestors.file.gid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.FileFields.GID, value)
	case "process.ancestors.file.group":
		return ev.setStringFieldValue("process.ancestors.file.group", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.FileFields.Group, value)
	case "process.ancestors.file.hashes":
		return ev.setStringArrayFieldValue("process.ancestors.file.hashes", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.Hashes, value)
	case "process.ancestors.file.in_upper_layer":
		return ev.setBoolFieldValue("process.ancestors.file.in_upper_layer", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.FileFields.InUpperLayer, value)
	case "process.ancestors.file.inode":
		return ev.setUint64FieldValue("process.ancestors.file.inode", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.FileFields.PathKey.Inode, value)
	case "process.ancestors.file.mode":
		return ev.setUint16FieldValue("process.ancestors.file.mode", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.FileFields.Mode, value)
	case "process.ancestors.file.modification_time":
		return ev.setUint64FieldValue("process.ancestors.file.modification_time", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.FileFields.MTime, value)
	case "process.ancestors.file.mount_id":
		return ev.setUint32FieldValue("process.ancestors.file.mount_id", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.FileFields.PathKey.MountID, value)
	case "process.ancestors.file.name":
		return ev.setStringFieldValue("process.ancestors.file.name", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.BasenameStr, value)
	case "process.ancestors.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "process.ancestors.file.name.length"}
	case "process.ancestors.file.package.name":
		return ev.setStringFieldValue("process.ancestors.file.package.name", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.PkgName, value)
	case "process.ancestors.file.package.source_version":
		return ev.setStringFieldValue("process.ancestors.file.package.source_version", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.PkgSrcVersion, value)
	case "process.ancestors.file.package.version":
		return ev.setStringFieldValue("process.ancestors.file.package.version", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.PkgVersion, value)
	case "process.ancestors.file.path":
		return ev.setStringFieldValue("process.ancestors.file.path", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.PathnameStr, value)
	case "process.ancestors.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "process.ancestors.file.path.length"}
	case "process.ancestors.file.rights":
		return ev.setUint16FieldValue("process.ancestors.file.rights", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.FileFields.Mode, value)
	case "process.ancestors.file.uid":
		return ev.setUint32FieldValue("process.ancestors.file.uid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.FileFields.UID, value)
	case "process.ancestors.file.user":
		return ev.setStringFieldValue("process.ancestors.file.user", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.FileEvent.FileFields.User, value)
	case "process.ancestors.fsgid":
		return ev.setUint32FieldValue("process.ancestors.fsgid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.FSGID, value)
	case "process.ancestors.fsgroup":
		return ev.setStringFieldValue("process.ancestors.fsgroup", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.FSGroup, value)
	case "process.ancestors.fsuid":
		return ev.setUint32FieldValue("process.ancestors.fsuid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.FSUID, value)
	case "process.ancestors.fsuser":
		return ev.setStringFieldValue("process.ancestors.fsuser", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.FSUser, value)
	case "process.ancestors.gid":
		return ev.setUint32FieldValue("process.ancestors.gid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.GID, value)
	case "process.ancestors.group":
		return ev.setStringFieldValue("process.ancestors.group", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.Group, value)
	case "process.ancestors.interpreter.file.change_time":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.change_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("process.ancestors.interpreter.file.change_time", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.CTime, value)
	case "process.ancestors.interpreter.file.filesystem":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.filesystem", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.ancestors.interpreter.file.filesystem", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.Filesystem, value)
	case "process.ancestors.interpreter.file.gid":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.gid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("process.ancestors.interpreter.file.gid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.GID, value)
	case "process.ancestors.interpreter.file.group":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.group", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.ancestors.interpreter.file.group", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Group, value)
	case "process.ancestors.interpreter.file.hashes":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.hashes", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringArrayFieldValue("process.ancestors.interpreter.file.hashes", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.Hashes, value)
	case "process.ancestors.interpreter.file.in_upper_layer":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.in_upper_layer", value)
		if err != nil || !cont {
			return err
		}
		return ev.setBoolFieldValue("process.ancestors.interpreter.file.in_upper_layer", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.InUpperLayer, value)
	case "process.ancestors.interpreter.file.inode":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.inode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("process.ancestors.interpreter.file.inode", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode, value)
	case "process.ancestors.interpreter.file.mode":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.mode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("process.ancestors.interpreter.file.mode", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "process.ancestors.interpreter.file.modification_time":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.modification_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("process.ancestors.interpreter.file.modification_time", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.MTime, value)
	case "process.ancestors.interpreter.file.mount_id":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.mount_id", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("process.ancestors.interpreter.file.mount_id", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID, value)
	case "process.ancestors.interpreter.file.name":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.ancestors.interpreter.file.name", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.BasenameStr, value)
	case "process.ancestors.interpreter.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "process.ancestors.interpreter.file.name.length"}
	case "process.ancestors.interpreter.file.package.name":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.package.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.ancestors.interpreter.file.package.name", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PkgName, value)
	case "process.ancestors.interpreter.file.package.source_version":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.package.source_version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.ancestors.interpreter.file.package.source_version", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PkgSrcVersion, value)
	case "process.ancestors.interpreter.file.package.version":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.package.version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.ancestors.interpreter.file.package.version", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PkgVersion, value)
	case "process.ancestors.interpreter.file.path":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.path", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.ancestors.interpreter.file.path", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PathnameStr, value)
	case "process.ancestors.interpreter.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "process.ancestors.interpreter.file.path.length"}
	case "process.ancestors.interpreter.file.rights":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.rights", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("process.ancestors.interpreter.file.rights", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "process.ancestors.interpreter.file.uid":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.uid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("process.ancestors.interpreter.file.uid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.UID, value)
	case "process.ancestors.interpreter.file.user":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm, "file.user", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.ancestors.interpreter.file.user", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.User, value)
	case "process.ancestors.is_exec":
		return ev.setBoolFieldValue("process.ancestors.is_exec", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.IsExec, value)
	case "process.ancestors.is_kworker":
		return ev.setBoolFieldValue("process.ancestors.is_kworker", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.PIDContext.IsKworker, value)
	case "process.ancestors.is_thread":
		return ev.setBoolFieldValue("process.ancestors.is_thread", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.IsThread, value)
	case "process.ancestors.length":
		return &eval.ErrFieldReadOnly{Field: "process.ancestors.length"}
	case "process.ancestors.pid":
		return ev.setUint32FieldValue("process.ancestors.pid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.PIDContext.Pid, value)
	case "process.ancestors.ppid":
		return ev.setUint32FieldValue("process.ancestors.ppid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.PPid, value)
	case "process.ancestors.tid":
		return ev.setUint32FieldValue("process.ancestors.tid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.PIDContext.Tid, value)
	case "process.ancestors.tty_name":
		return ev.setStringFieldValue("process.ancestors.tty_name", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.TTYName, value)
	case "process.ancestors.uid":
		return ev.setUint32FieldValue("process.ancestors.uid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.UID, value)
	case "process.ancestors.user":
		return ev.setStringFieldValue("process.ancestors.user", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.Credentials.User, value)
	case "process.ancestors.user_session.k8s_groups":
		return ev.setStringArrayFieldValue("process.ancestors.user_session.k8s_groups", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.UserSession.K8SGroups, value)
	case "process.ancestors.user_session.k8s_uid":
		return ev.setStringFieldValue("process.ancestors.user_session.k8s_uid", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.UserSession.K8SUID, value)
	case "process.ancestors.user_session.k8s_username":
		return ev.setStringFieldValue("process.ancestors.user_session.k8s_username", &ev.BaseEvent.ProcessContext.Ancestor.ProcessContext.Process.UserSession.K8SUsername, value)
	case "process.args":
		return ev.setStringFieldValue("process.args", &ev.BaseEvent.ProcessContext.Process.Args, value)
	case "process.args_flags":
		return ev.setStringArrayFieldValue("process.args_flags", &ev.BaseEvent.ProcessContext.Process.Argv, value)
	case "process.args_options":
		return ev.setStringArrayFieldValue("process.args_options", &ev.BaseEvent.ProcessContext.Process.Argv, value)
	case "process.args_truncated":
		return ev.setBoolFieldValue("process.args_truncated", &ev.BaseEvent.ProcessContext.Process.ArgsTruncated, value)
	case "process.argv":
		return ev.setStringArrayFieldValue("process.argv", &ev.BaseEvent.ProcessContext.Process.Argv, value)
	case "process.argv0":
		return ev.setStringFieldValue("process.argv0", &ev.BaseEvent.ProcessContext.Process.Argv0, value)
	case "process.auid":
		return ev.setUint32FieldValue("process.auid", &ev.BaseEvent.ProcessContext.Process.Credentials.AUID, value)
	case "process.cap_effective":
		return ev.setUint64FieldValue("process.cap_effective", &ev.BaseEvent.ProcessContext.Process.Credentials.CapEffective, value)
	case "process.cap_permitted":
		return ev.setUint64FieldValue("process.cap_permitted", &ev.BaseEvent.ProcessContext.Process.Credentials.CapPermitted, value)
	case "process.cgroup.file.inode":
		return ev.setUint64FieldValue("process.cgroup.file.inode", &ev.BaseEvent.ProcessContext.Process.CGroup.CGroupFile.Inode, value)
	case "process.cgroup.file.mount_id":
		return ev.setUint32FieldValue("process.cgroup.file.mount_id", &ev.BaseEvent.ProcessContext.Process.CGroup.CGroupFile.MountID, value)
	case "process.cgroup.id":
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "process.cgroup.id"}
		}
		ev.BaseEvent.ProcessContext.Process.CGroup.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "process.cgroup.manager":
		return ev.setStringFieldValue("process.cgroup.manager", &ev.BaseEvent.ProcessContext.Process.CGroup.CGroupManager, value)
	case "process.cgroup.version":
		return ev.setIntFieldValue("process.cgroup.version", &ev.BaseEvent.ProcessContext.Process.CGroup.CGroupVersion, value)
	case "process.comm":
		return ev.setStringFieldValue("process.comm", &ev.BaseEvent.ProcessContext.Process.Comm, value)
	case "process.container.id":
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "process.container.id"}
		}
		ev.BaseEvent.ProcessContext.Process.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "process.created_at":
		return ev.setUint64FieldValue("process.created_at", &ev.BaseEvent.ProcessContext.Process.CreatedAt, value)
	case "process.egid":
		return ev.setUint32FieldValue("process.egid", &ev.BaseEvent.ProcessContext.Process.Credentials.EGID, value)
	case "process.egroup":
		return ev.setStringFieldValue("process.egroup", &ev.BaseEvent.ProcessContext.Process.Credentials.EGroup, value)
	case "process.envp":
		return ev.setStringArrayFieldValue("process.envp", &ev.BaseEvent.ProcessContext.Process.Envp, value)
	case "process.envs":
		return ev.setStringArrayFieldValue("process.envs", &ev.BaseEvent.ProcessContext.Process.Envs, value)
	case "process.envs_truncated":
		return ev.setBoolFieldValue("process.envs_truncated", &ev.BaseEvent.ProcessContext.Process.EnvsTruncated, value)
	case "process.euid":
		return ev.setUint32FieldValue("process.euid", &ev.BaseEvent.ProcessContext.Process.Credentials.EUID, value)
	case "process.euser":
		return ev.setStringFieldValue("process.euser", &ev.BaseEvent.ProcessContext.Process.Credentials.EUser, value)
	case "process.file.change_time":
		return ev.setUint64FieldValue("process.file.change_time", &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.CTime, value)
	case "process.file.filesystem":
		return ev.setStringFieldValue("process.file.filesystem", &ev.BaseEvent.ProcessContext.Process.FileEvent.Filesystem, value)
	case "process.file.gid":
		return ev.setUint32FieldValue("process.file.gid", &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.GID, value)
	case "process.file.group":
		return ev.setStringFieldValue("process.file.group", &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.Group, value)
	case "process.file.hashes":
		return ev.setStringArrayFieldValue("process.file.hashes", &ev.BaseEvent.ProcessContext.Process.FileEvent.Hashes, value)
	case "process.file.in_upper_layer":
		return ev.setBoolFieldValue("process.file.in_upper_layer", &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.InUpperLayer, value)
	case "process.file.inode":
		return ev.setUint64FieldValue("process.file.inode", &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.PathKey.Inode, value)
	case "process.file.mode":
		return ev.setUint16FieldValue("process.file.mode", &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.Mode, value)
	case "process.file.modification_time":
		return ev.setUint64FieldValue("process.file.modification_time", &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.MTime, value)
	case "process.file.mount_id":
		return ev.setUint32FieldValue("process.file.mount_id", &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.PathKey.MountID, value)
	case "process.file.name":
		return ev.setStringFieldValue("process.file.name", &ev.BaseEvent.ProcessContext.Process.FileEvent.BasenameStr, value)
	case "process.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "process.file.name.length"}
	case "process.file.package.name":
		return ev.setStringFieldValue("process.file.package.name", &ev.BaseEvent.ProcessContext.Process.FileEvent.PkgName, value)
	case "process.file.package.source_version":
		return ev.setStringFieldValue("process.file.package.source_version", &ev.BaseEvent.ProcessContext.Process.FileEvent.PkgSrcVersion, value)
	case "process.file.package.version":
		return ev.setStringFieldValue("process.file.package.version", &ev.BaseEvent.ProcessContext.Process.FileEvent.PkgVersion, value)
	case "process.file.path":
		return ev.setStringFieldValue("process.file.path", &ev.BaseEvent.ProcessContext.Process.FileEvent.PathnameStr, value)
	case "process.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "process.file.path.length"}
	case "process.file.rights":
		return ev.setUint16FieldValue("process.file.rights", &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.Mode, value)
	case "process.file.uid":
		return ev.setUint32FieldValue("process.file.uid", &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.UID, value)
	case "process.file.user":
		return ev.setStringFieldValue("process.file.user", &ev.BaseEvent.ProcessContext.Process.FileEvent.FileFields.User, value)
	case "process.fsgid":
		return ev.setUint32FieldValue("process.fsgid", &ev.BaseEvent.ProcessContext.Process.Credentials.FSGID, value)
	case "process.fsgroup":
		return ev.setStringFieldValue("process.fsgroup", &ev.BaseEvent.ProcessContext.Process.Credentials.FSGroup, value)
	case "process.fsuid":
		return ev.setUint32FieldValue("process.fsuid", &ev.BaseEvent.ProcessContext.Process.Credentials.FSUID, value)
	case "process.fsuser":
		return ev.setStringFieldValue("process.fsuser", &ev.BaseEvent.ProcessContext.Process.Credentials.FSUser, value)
	case "process.gid":
		return ev.setUint32FieldValue("process.gid", &ev.BaseEvent.ProcessContext.Process.Credentials.GID, value)
	case "process.group":
		return ev.setStringFieldValue("process.group", &ev.BaseEvent.ProcessContext.Process.Credentials.Group, value)
	case "process.interpreter.file.change_time":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.change_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("process.interpreter.file.change_time", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.CTime, value)
	case "process.interpreter.file.filesystem":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.filesystem", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.interpreter.file.filesystem", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.Filesystem, value)
	case "process.interpreter.file.gid":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.gid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("process.interpreter.file.gid", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.GID, value)
	case "process.interpreter.file.group":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.group", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.interpreter.file.group", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Group, value)
	case "process.interpreter.file.hashes":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.hashes", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringArrayFieldValue("process.interpreter.file.hashes", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.Hashes, value)
	case "process.interpreter.file.in_upper_layer":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.in_upper_layer", value)
		if err != nil || !cont {
			return err
		}
		return ev.setBoolFieldValue("process.interpreter.file.in_upper_layer", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.InUpperLayer, value)
	case "process.interpreter.file.inode":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.inode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("process.interpreter.file.inode", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode, value)
	case "process.interpreter.file.mode":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.mode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("process.interpreter.file.mode", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "process.interpreter.file.modification_time":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.modification_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("process.interpreter.file.modification_time", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.MTime, value)
	case "process.interpreter.file.mount_id":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.mount_id", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("process.interpreter.file.mount_id", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID, value)
	case "process.interpreter.file.name":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.interpreter.file.name", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.BasenameStr, value)
	case "process.interpreter.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "process.interpreter.file.name.length"}
	case "process.interpreter.file.package.name":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.package.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.interpreter.file.package.name", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.PkgName, value)
	case "process.interpreter.file.package.source_version":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.package.source_version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.interpreter.file.package.source_version", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.PkgSrcVersion, value)
	case "process.interpreter.file.package.version":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.package.version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.interpreter.file.package.version", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.PkgVersion, value)
	case "process.interpreter.file.path":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.path", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.interpreter.file.path", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.PathnameStr, value)
	case "process.interpreter.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "process.interpreter.file.path.length"}
	case "process.interpreter.file.rights":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.rights", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("process.interpreter.file.rights", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "process.interpreter.file.uid":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.uid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("process.interpreter.file.uid", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.UID, value)
	case "process.interpreter.file.user":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Process.LinuxBinprm, "file.user", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.interpreter.file.user", &ev.BaseEvent.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.User, value)
	case "process.is_exec":
		return ev.setBoolFieldValue("process.is_exec", &ev.BaseEvent.ProcessContext.Process.IsExec, value)
	case "process.is_kworker":
		return ev.setBoolFieldValue("process.is_kworker", &ev.BaseEvent.ProcessContext.Process.PIDContext.IsKworker, value)
	case "process.is_thread":
		return ev.setBoolFieldValue("process.is_thread", &ev.BaseEvent.ProcessContext.Process.IsThread, value)
	case "process.parent.args":
		return ev.setStringFieldValue("process.parent.args", &ev.BaseEvent.ProcessContext.Parent.Args, value)
	case "process.parent.args_flags":
		return ev.setStringArrayFieldValue("process.parent.args_flags", &ev.BaseEvent.ProcessContext.Parent.Argv, value)
	case "process.parent.args_options":
		return ev.setStringArrayFieldValue("process.parent.args_options", &ev.BaseEvent.ProcessContext.Parent.Argv, value)
	case "process.parent.args_truncated":
		return ev.setBoolFieldValue("process.parent.args_truncated", &ev.BaseEvent.ProcessContext.Parent.ArgsTruncated, value)
	case "process.parent.argv":
		return ev.setStringArrayFieldValue("process.parent.argv", &ev.BaseEvent.ProcessContext.Parent.Argv, value)
	case "process.parent.argv0":
		return ev.setStringFieldValue("process.parent.argv0", &ev.BaseEvent.ProcessContext.Parent.Argv0, value)
	case "process.parent.auid":
		return ev.setUint32FieldValue("process.parent.auid", &ev.BaseEvent.ProcessContext.Parent.Credentials.AUID, value)
	case "process.parent.cap_effective":
		return ev.setUint64FieldValue("process.parent.cap_effective", &ev.BaseEvent.ProcessContext.Parent.Credentials.CapEffective, value)
	case "process.parent.cap_permitted":
		return ev.setUint64FieldValue("process.parent.cap_permitted", &ev.BaseEvent.ProcessContext.Parent.Credentials.CapPermitted, value)
	case "process.parent.cgroup.file.inode":
		return ev.setUint64FieldValue("process.parent.cgroup.file.inode", &ev.BaseEvent.ProcessContext.Parent.CGroup.CGroupFile.Inode, value)
	case "process.parent.cgroup.file.mount_id":
		return ev.setUint32FieldValue("process.parent.cgroup.file.mount_id", &ev.BaseEvent.ProcessContext.Parent.CGroup.CGroupFile.MountID, value)
	case "process.parent.cgroup.id":
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "process.parent.cgroup.id"}
		}
		ev.BaseEvent.ProcessContext.Parent.CGroup.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "process.parent.cgroup.manager":
		return ev.setStringFieldValue("process.parent.cgroup.manager", &ev.BaseEvent.ProcessContext.Parent.CGroup.CGroupManager, value)
	case "process.parent.cgroup.version":
		return ev.setIntFieldValue("process.parent.cgroup.version", &ev.BaseEvent.ProcessContext.Parent.CGroup.CGroupVersion, value)
	case "process.parent.comm":
		return ev.setStringFieldValue("process.parent.comm", &ev.BaseEvent.ProcessContext.Parent.Comm, value)
	case "process.parent.container.id":
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "process.parent.container.id"}
		}
		ev.BaseEvent.ProcessContext.Parent.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "process.parent.created_at":
		return ev.setUint64FieldValue("process.parent.created_at", &ev.BaseEvent.ProcessContext.Parent.CreatedAt, value)
	case "process.parent.egid":
		return ev.setUint32FieldValue("process.parent.egid", &ev.BaseEvent.ProcessContext.Parent.Credentials.EGID, value)
	case "process.parent.egroup":
		return ev.setStringFieldValue("process.parent.egroup", &ev.BaseEvent.ProcessContext.Parent.Credentials.EGroup, value)
	case "process.parent.envp":
		return ev.setStringArrayFieldValue("process.parent.envp", &ev.BaseEvent.ProcessContext.Parent.Envp, value)
	case "process.parent.envs":
		return ev.setStringArrayFieldValue("process.parent.envs", &ev.BaseEvent.ProcessContext.Parent.Envs, value)
	case "process.parent.envs_truncated":
		return ev.setBoolFieldValue("process.parent.envs_truncated", &ev.BaseEvent.ProcessContext.Parent.EnvsTruncated, value)
	case "process.parent.euid":
		return ev.setUint32FieldValue("process.parent.euid", &ev.BaseEvent.ProcessContext.Parent.Credentials.EUID, value)
	case "process.parent.euser":
		return ev.setStringFieldValue("process.parent.euser", &ev.BaseEvent.ProcessContext.Parent.Credentials.EUser, value)
	case "process.parent.file.change_time":
		return ev.setUint64FieldValue("process.parent.file.change_time", &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.CTime, value)
	case "process.parent.file.filesystem":
		return ev.setStringFieldValue("process.parent.file.filesystem", &ev.BaseEvent.ProcessContext.Parent.FileEvent.Filesystem, value)
	case "process.parent.file.gid":
		return ev.setUint32FieldValue("process.parent.file.gid", &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.GID, value)
	case "process.parent.file.group":
		return ev.setStringFieldValue("process.parent.file.group", &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.Group, value)
	case "process.parent.file.hashes":
		return ev.setStringArrayFieldValue("process.parent.file.hashes", &ev.BaseEvent.ProcessContext.Parent.FileEvent.Hashes, value)
	case "process.parent.file.in_upper_layer":
		return ev.setBoolFieldValue("process.parent.file.in_upper_layer", &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.InUpperLayer, value)
	case "process.parent.file.inode":
		return ev.setUint64FieldValue("process.parent.file.inode", &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.PathKey.Inode, value)
	case "process.parent.file.mode":
		return ev.setUint16FieldValue("process.parent.file.mode", &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.Mode, value)
	case "process.parent.file.modification_time":
		return ev.setUint64FieldValue("process.parent.file.modification_time", &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.MTime, value)
	case "process.parent.file.mount_id":
		return ev.setUint32FieldValue("process.parent.file.mount_id", &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.PathKey.MountID, value)
	case "process.parent.file.name":
		return ev.setStringFieldValue("process.parent.file.name", &ev.BaseEvent.ProcessContext.Parent.FileEvent.BasenameStr, value)
	case "process.parent.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "process.parent.file.name.length"}
	case "process.parent.file.package.name":
		return ev.setStringFieldValue("process.parent.file.package.name", &ev.BaseEvent.ProcessContext.Parent.FileEvent.PkgName, value)
	case "process.parent.file.package.source_version":
		return ev.setStringFieldValue("process.parent.file.package.source_version", &ev.BaseEvent.ProcessContext.Parent.FileEvent.PkgSrcVersion, value)
	case "process.parent.file.package.version":
		return ev.setStringFieldValue("process.parent.file.package.version", &ev.BaseEvent.ProcessContext.Parent.FileEvent.PkgVersion, value)
	case "process.parent.file.path":
		return ev.setStringFieldValue("process.parent.file.path", &ev.BaseEvent.ProcessContext.Parent.FileEvent.PathnameStr, value)
	case "process.parent.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "process.parent.file.path.length"}
	case "process.parent.file.rights":
		return ev.setUint16FieldValue("process.parent.file.rights", &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.Mode, value)
	case "process.parent.file.uid":
		return ev.setUint32FieldValue("process.parent.file.uid", &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.UID, value)
	case "process.parent.file.user":
		return ev.setStringFieldValue("process.parent.file.user", &ev.BaseEvent.ProcessContext.Parent.FileEvent.FileFields.User, value)
	case "process.parent.fsgid":
		return ev.setUint32FieldValue("process.parent.fsgid", &ev.BaseEvent.ProcessContext.Parent.Credentials.FSGID, value)
	case "process.parent.fsgroup":
		return ev.setStringFieldValue("process.parent.fsgroup", &ev.BaseEvent.ProcessContext.Parent.Credentials.FSGroup, value)
	case "process.parent.fsuid":
		return ev.setUint32FieldValue("process.parent.fsuid", &ev.BaseEvent.ProcessContext.Parent.Credentials.FSUID, value)
	case "process.parent.fsuser":
		return ev.setStringFieldValue("process.parent.fsuser", &ev.BaseEvent.ProcessContext.Parent.Credentials.FSUser, value)
	case "process.parent.gid":
		return ev.setUint32FieldValue("process.parent.gid", &ev.BaseEvent.ProcessContext.Parent.Credentials.GID, value)
	case "process.parent.group":
		return ev.setStringFieldValue("process.parent.group", &ev.BaseEvent.ProcessContext.Parent.Credentials.Group, value)
	case "process.parent.interpreter.file.change_time":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.change_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("process.parent.interpreter.file.change_time", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.CTime, value)
	case "process.parent.interpreter.file.filesystem":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.filesystem", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.parent.interpreter.file.filesystem", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.Filesystem, value)
	case "process.parent.interpreter.file.gid":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.gid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("process.parent.interpreter.file.gid", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.GID, value)
	case "process.parent.interpreter.file.group":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.group", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.parent.interpreter.file.group", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.Group, value)
	case "process.parent.interpreter.file.hashes":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.hashes", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringArrayFieldValue("process.parent.interpreter.file.hashes", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.Hashes, value)
	case "process.parent.interpreter.file.in_upper_layer":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.in_upper_layer", value)
		if err != nil || !cont {
			return err
		}
		return ev.setBoolFieldValue("process.parent.interpreter.file.in_upper_layer", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.InUpperLayer, value)
	case "process.parent.interpreter.file.inode":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.inode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("process.parent.interpreter.file.inode", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.Inode, value)
	case "process.parent.interpreter.file.mode":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.mode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("process.parent.interpreter.file.mode", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "process.parent.interpreter.file.modification_time":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.modification_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("process.parent.interpreter.file.modification_time", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.MTime, value)
	case "process.parent.interpreter.file.mount_id":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.mount_id", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("process.parent.interpreter.file.mount_id", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.MountID, value)
	case "process.parent.interpreter.file.name":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.parent.interpreter.file.name", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.BasenameStr, value)
	case "process.parent.interpreter.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "process.parent.interpreter.file.name.length"}
	case "process.parent.interpreter.file.package.name":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.package.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.parent.interpreter.file.package.name", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.PkgName, value)
	case "process.parent.interpreter.file.package.source_version":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.package.source_version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.parent.interpreter.file.package.source_version", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.PkgSrcVersion, value)
	case "process.parent.interpreter.file.package.version":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.package.version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.parent.interpreter.file.package.version", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.PkgVersion, value)
	case "process.parent.interpreter.file.path":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.path", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.parent.interpreter.file.path", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.PathnameStr, value)
	case "process.parent.interpreter.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "process.parent.interpreter.file.path.length"}
	case "process.parent.interpreter.file.rights":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.rights", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("process.parent.interpreter.file.rights", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "process.parent.interpreter.file.uid":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.uid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("process.parent.interpreter.file.uid", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.UID, value)
	case "process.parent.interpreter.file.user":
		cont, err := SetInterpreterFields(&ev.BaseEvent.ProcessContext.Parent.LinuxBinprm, "file.user", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("process.parent.interpreter.file.user", &ev.BaseEvent.ProcessContext.Parent.LinuxBinprm.FileEvent.FileFields.User, value)
	case "process.parent.is_exec":
		return ev.setBoolFieldValue("process.parent.is_exec", &ev.BaseEvent.ProcessContext.Parent.IsExec, value)
	case "process.parent.is_kworker":
		return ev.setBoolFieldValue("process.parent.is_kworker", &ev.BaseEvent.ProcessContext.Parent.PIDContext.IsKworker, value)
	case "process.parent.is_thread":
		return ev.setBoolFieldValue("process.parent.is_thread", &ev.BaseEvent.ProcessContext.Parent.IsThread, value)
	case "process.parent.pid":
		return ev.setUint32FieldValue("process.parent.pid", &ev.BaseEvent.ProcessContext.Parent.PIDContext.Pid, value)
	case "process.parent.ppid":
		return ev.setUint32FieldValue("process.parent.ppid", &ev.BaseEvent.ProcessContext.Parent.PPid, value)
	case "process.parent.tid":
		return ev.setUint32FieldValue("process.parent.tid", &ev.BaseEvent.ProcessContext.Parent.PIDContext.Tid, value)
	case "process.parent.tty_name":
		return ev.setStringFieldValue("process.parent.tty_name", &ev.BaseEvent.ProcessContext.Parent.TTYName, value)
	case "process.parent.uid":
		return ev.setUint32FieldValue("process.parent.uid", &ev.BaseEvent.ProcessContext.Parent.Credentials.UID, value)
	case "process.parent.user":
		return ev.setStringFieldValue("process.parent.user", &ev.BaseEvent.ProcessContext.Parent.Credentials.User, value)
	case "process.parent.user_session.k8s_groups":
		return ev.setStringArrayFieldValue("process.parent.user_session.k8s_groups", &ev.BaseEvent.ProcessContext.Parent.UserSession.K8SGroups, value)
	case "process.parent.user_session.k8s_uid":
		return ev.setStringFieldValue("process.parent.user_session.k8s_uid", &ev.BaseEvent.ProcessContext.Parent.UserSession.K8SUID, value)
	case "process.parent.user_session.k8s_username":
		return ev.setStringFieldValue("process.parent.user_session.k8s_username", &ev.BaseEvent.ProcessContext.Parent.UserSession.K8SUsername, value)
	case "process.pid":
		return ev.setUint32FieldValue("process.pid", &ev.BaseEvent.ProcessContext.Process.PIDContext.Pid, value)
	case "process.ppid":
		return ev.setUint32FieldValue("process.ppid", &ev.BaseEvent.ProcessContext.Process.PPid, value)
	case "process.tid":
		return ev.setUint32FieldValue("process.tid", &ev.BaseEvent.ProcessContext.Process.PIDContext.Tid, value)
	case "process.tty_name":
		return ev.setStringFieldValue("process.tty_name", &ev.BaseEvent.ProcessContext.Process.TTYName, value)
	case "process.uid":
		return ev.setUint32FieldValue("process.uid", &ev.BaseEvent.ProcessContext.Process.Credentials.UID, value)
	case "process.user":
		return ev.setStringFieldValue("process.user", &ev.BaseEvent.ProcessContext.Process.Credentials.User, value)
	case "process.user_session.k8s_groups":
		return ev.setStringArrayFieldValue("process.user_session.k8s_groups", &ev.BaseEvent.ProcessContext.Process.UserSession.K8SGroups, value)
	case "process.user_session.k8s_uid":
		return ev.setStringFieldValue("process.user_session.k8s_uid", &ev.BaseEvent.ProcessContext.Process.UserSession.K8SUID, value)
	case "process.user_session.k8s_username":
		return ev.setStringFieldValue("process.user_session.k8s_username", &ev.BaseEvent.ProcessContext.Process.UserSession.K8SUsername, value)
	case "ptrace.request":
		return ev.setUint32FieldValue("ptrace.request", &ev.PTrace.Request, value)
	case "ptrace.retval":
		return ev.setInt64FieldValue("ptrace.retval", &ev.PTrace.SyscallEvent.Retval, value)
	case "ptrace.tracee.ancestors.args":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.args", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Args, value)
	case "ptrace.tracee.ancestors.args_flags":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.ancestors.args_flags", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Argv, value)
	case "ptrace.tracee.ancestors.args_options":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.ancestors.args_options", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Argv, value)
	case "ptrace.tracee.ancestors.args_truncated":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.ancestors.args_truncated", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.ArgsTruncated, value)
	case "ptrace.tracee.ancestors.argv":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.ancestors.argv", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Argv, value)
	case "ptrace.tracee.ancestors.argv0":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.argv0", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Argv0, value)
	case "ptrace.tracee.ancestors.auid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.auid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.AUID, value)
	case "ptrace.tracee.ancestors.cap_effective":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.ancestors.cap_effective", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.CapEffective, value)
	case "ptrace.tracee.ancestors.cap_permitted":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.ancestors.cap_permitted", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.CapPermitted, value)
	case "ptrace.tracee.ancestors.cgroup.file.inode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.ancestors.cgroup.file.inode", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.CGroup.CGroupFile.Inode, value)
	case "ptrace.tracee.ancestors.cgroup.file.mount_id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.cgroup.file.mount_id", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.CGroup.CGroupFile.MountID, value)
	case "ptrace.tracee.ancestors.cgroup.id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "ptrace.tracee.ancestors.cgroup.id"}
		}
		ev.PTrace.Tracee.Ancestor.ProcessContext.Process.CGroup.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "ptrace.tracee.ancestors.cgroup.manager":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.cgroup.manager", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.CGroup.CGroupManager, value)
	case "ptrace.tracee.ancestors.cgroup.version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setIntFieldValue("ptrace.tracee.ancestors.cgroup.version", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.CGroup.CGroupVersion, value)
	case "ptrace.tracee.ancestors.comm":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.comm", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Comm, value)
	case "ptrace.tracee.ancestors.container.id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "ptrace.tracee.ancestors.container.id"}
		}
		ev.PTrace.Tracee.Ancestor.ProcessContext.Process.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "ptrace.tracee.ancestors.created_at":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.ancestors.created_at", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.CreatedAt, value)
	case "ptrace.tracee.ancestors.egid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.egid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.EGID, value)
	case "ptrace.tracee.ancestors.egroup":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.egroup", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.EGroup, value)
	case "ptrace.tracee.ancestors.envp":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.ancestors.envp", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Envp, value)
	case "ptrace.tracee.ancestors.envs":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.ancestors.envs", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Envs, value)
	case "ptrace.tracee.ancestors.envs_truncated":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.ancestors.envs_truncated", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.EnvsTruncated, value)
	case "ptrace.tracee.ancestors.euid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.euid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.EUID, value)
	case "ptrace.tracee.ancestors.euser":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.euser", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.EUser, value)
	case "ptrace.tracee.ancestors.file.change_time":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.ancestors.file.change_time", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.FileFields.CTime, value)
	case "ptrace.tracee.ancestors.file.filesystem":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.file.filesystem", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.Filesystem, value)
	case "ptrace.tracee.ancestors.file.gid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.file.gid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.FileFields.GID, value)
	case "ptrace.tracee.ancestors.file.group":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.file.group", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.FileFields.Group, value)
	case "ptrace.tracee.ancestors.file.hashes":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.ancestors.file.hashes", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.Hashes, value)
	case "ptrace.tracee.ancestors.file.in_upper_layer":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.ancestors.file.in_upper_layer", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.FileFields.InUpperLayer, value)
	case "ptrace.tracee.ancestors.file.inode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.ancestors.file.inode", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.FileFields.PathKey.Inode, value)
	case "ptrace.tracee.ancestors.file.mode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint16FieldValue("ptrace.tracee.ancestors.file.mode", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.FileFields.Mode, value)
	case "ptrace.tracee.ancestors.file.modification_time":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.ancestors.file.modification_time", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.FileFields.MTime, value)
	case "ptrace.tracee.ancestors.file.mount_id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.file.mount_id", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.FileFields.PathKey.MountID, value)
	case "ptrace.tracee.ancestors.file.name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.file.name", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.BasenameStr, value)
	case "ptrace.tracee.ancestors.file.name.length":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "ptrace.tracee.ancestors.file.name.length"}
	case "ptrace.tracee.ancestors.file.package.name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.file.package.name", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.PkgName, value)
	case "ptrace.tracee.ancestors.file.package.source_version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.file.package.source_version", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.PkgSrcVersion, value)
	case "ptrace.tracee.ancestors.file.package.version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.file.package.version", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.PkgVersion, value)
	case "ptrace.tracee.ancestors.file.path":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.file.path", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.PathnameStr, value)
	case "ptrace.tracee.ancestors.file.path.length":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "ptrace.tracee.ancestors.file.path.length"}
	case "ptrace.tracee.ancestors.file.rights":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint16FieldValue("ptrace.tracee.ancestors.file.rights", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.FileFields.Mode, value)
	case "ptrace.tracee.ancestors.file.uid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.file.uid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.FileFields.UID, value)
	case "ptrace.tracee.ancestors.file.user":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.file.user", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.FileEvent.FileFields.User, value)
	case "ptrace.tracee.ancestors.fsgid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.fsgid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.FSGID, value)
	case "ptrace.tracee.ancestors.fsgroup":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.fsgroup", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.FSGroup, value)
	case "ptrace.tracee.ancestors.fsuid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.fsuid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.FSUID, value)
	case "ptrace.tracee.ancestors.fsuser":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.fsuser", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.FSUser, value)
	case "ptrace.tracee.ancestors.gid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.gid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.GID, value)
	case "ptrace.tracee.ancestors.group":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.group", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.Group, value)
	case "ptrace.tracee.ancestors.interpreter.file.change_time":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.change_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("ptrace.tracee.ancestors.interpreter.file.change_time", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.CTime, value)
	case "ptrace.tracee.ancestors.interpreter.file.filesystem":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.filesystem", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.interpreter.file.filesystem", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.Filesystem, value)
	case "ptrace.tracee.ancestors.interpreter.file.gid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.gid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.interpreter.file.gid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.GID, value)
	case "ptrace.tracee.ancestors.interpreter.file.group":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.group", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.interpreter.file.group", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Group, value)
	case "ptrace.tracee.ancestors.interpreter.file.hashes":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.hashes", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.ancestors.interpreter.file.hashes", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.Hashes, value)
	case "ptrace.tracee.ancestors.interpreter.file.in_upper_layer":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.in_upper_layer", value)
		if err != nil || !cont {
			return err
		}
		return ev.setBoolFieldValue("ptrace.tracee.ancestors.interpreter.file.in_upper_layer", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.InUpperLayer, value)
	case "ptrace.tracee.ancestors.interpreter.file.inode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.inode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("ptrace.tracee.ancestors.interpreter.file.inode", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode, value)
	case "ptrace.tracee.ancestors.interpreter.file.mode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.mode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("ptrace.tracee.ancestors.interpreter.file.mode", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "ptrace.tracee.ancestors.interpreter.file.modification_time":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.modification_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("ptrace.tracee.ancestors.interpreter.file.modification_time", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.MTime, value)
	case "ptrace.tracee.ancestors.interpreter.file.mount_id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.mount_id", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.interpreter.file.mount_id", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID, value)
	case "ptrace.tracee.ancestors.interpreter.file.name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.interpreter.file.name", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.BasenameStr, value)
	case "ptrace.tracee.ancestors.interpreter.file.name.length":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "ptrace.tracee.ancestors.interpreter.file.name.length"}
	case "ptrace.tracee.ancestors.interpreter.file.package.name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.package.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.interpreter.file.package.name", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PkgName, value)
	case "ptrace.tracee.ancestors.interpreter.file.package.source_version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.package.source_version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.interpreter.file.package.source_version", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PkgSrcVersion, value)
	case "ptrace.tracee.ancestors.interpreter.file.package.version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.package.version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.interpreter.file.package.version", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PkgVersion, value)
	case "ptrace.tracee.ancestors.interpreter.file.path":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.path", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.interpreter.file.path", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PathnameStr, value)
	case "ptrace.tracee.ancestors.interpreter.file.path.length":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "ptrace.tracee.ancestors.interpreter.file.path.length"}
	case "ptrace.tracee.ancestors.interpreter.file.rights":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.rights", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("ptrace.tracee.ancestors.interpreter.file.rights", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "ptrace.tracee.ancestors.interpreter.file.uid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.uid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.interpreter.file.uid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.UID, value)
	case "ptrace.tracee.ancestors.interpreter.file.user":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm, "file.user", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.interpreter.file.user", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.User, value)
	case "ptrace.tracee.ancestors.is_exec":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.ancestors.is_exec", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.IsExec, value)
	case "ptrace.tracee.ancestors.is_kworker":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.ancestors.is_kworker", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.PIDContext.IsKworker, value)
	case "ptrace.tracee.ancestors.is_thread":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.ancestors.is_thread", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.IsThread, value)
	case "ptrace.tracee.ancestors.length":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "ptrace.tracee.ancestors.length"}
	case "ptrace.tracee.ancestors.pid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.pid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.PIDContext.Pid, value)
	case "ptrace.tracee.ancestors.ppid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.ppid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.PPid, value)
	case "ptrace.tracee.ancestors.tid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.tid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.PIDContext.Tid, value)
	case "ptrace.tracee.ancestors.tty_name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.tty_name", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.TTYName, value)
	case "ptrace.tracee.ancestors.uid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ancestors.uid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.UID, value)
	case "ptrace.tracee.ancestors.user":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.user", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.Credentials.User, value)
	case "ptrace.tracee.ancestors.user_session.k8s_groups":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.ancestors.user_session.k8s_groups", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.UserSession.K8SGroups, value)
	case "ptrace.tracee.ancestors.user_session.k8s_uid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.user_session.k8s_uid", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.UserSession.K8SUID, value)
	case "ptrace.tracee.ancestors.user_session.k8s_username":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Ancestor == nil {
			ev.PTrace.Tracee.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("ptrace.tracee.ancestors.user_session.k8s_username", &ev.PTrace.Tracee.Ancestor.ProcessContext.Process.UserSession.K8SUsername, value)
	case "ptrace.tracee.args":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.args", &ev.PTrace.Tracee.Process.Args, value)
	case "ptrace.tracee.args_flags":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.args_flags", &ev.PTrace.Tracee.Process.Argv, value)
	case "ptrace.tracee.args_options":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.args_options", &ev.PTrace.Tracee.Process.Argv, value)
	case "ptrace.tracee.args_truncated":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.args_truncated", &ev.PTrace.Tracee.Process.ArgsTruncated, value)
	case "ptrace.tracee.argv":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.argv", &ev.PTrace.Tracee.Process.Argv, value)
	case "ptrace.tracee.argv0":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.argv0", &ev.PTrace.Tracee.Process.Argv0, value)
	case "ptrace.tracee.auid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.auid", &ev.PTrace.Tracee.Process.Credentials.AUID, value)
	case "ptrace.tracee.cap_effective":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.cap_effective", &ev.PTrace.Tracee.Process.Credentials.CapEffective, value)
	case "ptrace.tracee.cap_permitted":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.cap_permitted", &ev.PTrace.Tracee.Process.Credentials.CapPermitted, value)
	case "ptrace.tracee.cgroup.file.inode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.cgroup.file.inode", &ev.PTrace.Tracee.Process.CGroup.CGroupFile.Inode, value)
	case "ptrace.tracee.cgroup.file.mount_id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.cgroup.file.mount_id", &ev.PTrace.Tracee.Process.CGroup.CGroupFile.MountID, value)
	case "ptrace.tracee.cgroup.id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "ptrace.tracee.cgroup.id"}
		}
		ev.PTrace.Tracee.Process.CGroup.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "ptrace.tracee.cgroup.manager":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.cgroup.manager", &ev.PTrace.Tracee.Process.CGroup.CGroupManager, value)
	case "ptrace.tracee.cgroup.version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setIntFieldValue("ptrace.tracee.cgroup.version", &ev.PTrace.Tracee.Process.CGroup.CGroupVersion, value)
	case "ptrace.tracee.comm":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.comm", &ev.PTrace.Tracee.Process.Comm, value)
	case "ptrace.tracee.container.id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "ptrace.tracee.container.id"}
		}
		ev.PTrace.Tracee.Process.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "ptrace.tracee.created_at":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.created_at", &ev.PTrace.Tracee.Process.CreatedAt, value)
	case "ptrace.tracee.egid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.egid", &ev.PTrace.Tracee.Process.Credentials.EGID, value)
	case "ptrace.tracee.egroup":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.egroup", &ev.PTrace.Tracee.Process.Credentials.EGroup, value)
	case "ptrace.tracee.envp":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.envp", &ev.PTrace.Tracee.Process.Envp, value)
	case "ptrace.tracee.envs":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.envs", &ev.PTrace.Tracee.Process.Envs, value)
	case "ptrace.tracee.envs_truncated":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.envs_truncated", &ev.PTrace.Tracee.Process.EnvsTruncated, value)
	case "ptrace.tracee.euid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.euid", &ev.PTrace.Tracee.Process.Credentials.EUID, value)
	case "ptrace.tracee.euser":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.euser", &ev.PTrace.Tracee.Process.Credentials.EUser, value)
	case "ptrace.tracee.file.change_time":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.file.change_time", &ev.PTrace.Tracee.Process.FileEvent.FileFields.CTime, value)
	case "ptrace.tracee.file.filesystem":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.file.filesystem", &ev.PTrace.Tracee.Process.FileEvent.Filesystem, value)
	case "ptrace.tracee.file.gid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.file.gid", &ev.PTrace.Tracee.Process.FileEvent.FileFields.GID, value)
	case "ptrace.tracee.file.group":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.file.group", &ev.PTrace.Tracee.Process.FileEvent.FileFields.Group, value)
	case "ptrace.tracee.file.hashes":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.file.hashes", &ev.PTrace.Tracee.Process.FileEvent.Hashes, value)
	case "ptrace.tracee.file.in_upper_layer":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.file.in_upper_layer", &ev.PTrace.Tracee.Process.FileEvent.FileFields.InUpperLayer, value)
	case "ptrace.tracee.file.inode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.file.inode", &ev.PTrace.Tracee.Process.FileEvent.FileFields.PathKey.Inode, value)
	case "ptrace.tracee.file.mode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint16FieldValue("ptrace.tracee.file.mode", &ev.PTrace.Tracee.Process.FileEvent.FileFields.Mode, value)
	case "ptrace.tracee.file.modification_time":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.file.modification_time", &ev.PTrace.Tracee.Process.FileEvent.FileFields.MTime, value)
	case "ptrace.tracee.file.mount_id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.file.mount_id", &ev.PTrace.Tracee.Process.FileEvent.FileFields.PathKey.MountID, value)
	case "ptrace.tracee.file.name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.file.name", &ev.PTrace.Tracee.Process.FileEvent.BasenameStr, value)
	case "ptrace.tracee.file.name.length":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return &eval.ErrFieldReadOnly{Field: "ptrace.tracee.file.name.length"}
	case "ptrace.tracee.file.package.name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.file.package.name", &ev.PTrace.Tracee.Process.FileEvent.PkgName, value)
	case "ptrace.tracee.file.package.source_version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.file.package.source_version", &ev.PTrace.Tracee.Process.FileEvent.PkgSrcVersion, value)
	case "ptrace.tracee.file.package.version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.file.package.version", &ev.PTrace.Tracee.Process.FileEvent.PkgVersion, value)
	case "ptrace.tracee.file.path":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.file.path", &ev.PTrace.Tracee.Process.FileEvent.PathnameStr, value)
	case "ptrace.tracee.file.path.length":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return &eval.ErrFieldReadOnly{Field: "ptrace.tracee.file.path.length"}
	case "ptrace.tracee.file.rights":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint16FieldValue("ptrace.tracee.file.rights", &ev.PTrace.Tracee.Process.FileEvent.FileFields.Mode, value)
	case "ptrace.tracee.file.uid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.file.uid", &ev.PTrace.Tracee.Process.FileEvent.FileFields.UID, value)
	case "ptrace.tracee.file.user":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.file.user", &ev.PTrace.Tracee.Process.FileEvent.FileFields.User, value)
	case "ptrace.tracee.fsgid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.fsgid", &ev.PTrace.Tracee.Process.Credentials.FSGID, value)
	case "ptrace.tracee.fsgroup":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.fsgroup", &ev.PTrace.Tracee.Process.Credentials.FSGroup, value)
	case "ptrace.tracee.fsuid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.fsuid", &ev.PTrace.Tracee.Process.Credentials.FSUID, value)
	case "ptrace.tracee.fsuser":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.fsuser", &ev.PTrace.Tracee.Process.Credentials.FSUser, value)
	case "ptrace.tracee.gid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.gid", &ev.PTrace.Tracee.Process.Credentials.GID, value)
	case "ptrace.tracee.group":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.group", &ev.PTrace.Tracee.Process.Credentials.Group, value)
	case "ptrace.tracee.interpreter.file.change_time":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.change_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("ptrace.tracee.interpreter.file.change_time", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.CTime, value)
	case "ptrace.tracee.interpreter.file.filesystem":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.filesystem", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.interpreter.file.filesystem", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.Filesystem, value)
	case "ptrace.tracee.interpreter.file.gid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.gid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("ptrace.tracee.interpreter.file.gid", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.GID, value)
	case "ptrace.tracee.interpreter.file.group":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.group", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.interpreter.file.group", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.Group, value)
	case "ptrace.tracee.interpreter.file.hashes":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.hashes", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.interpreter.file.hashes", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.Hashes, value)
	case "ptrace.tracee.interpreter.file.in_upper_layer":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.in_upper_layer", value)
		if err != nil || !cont {
			return err
		}
		return ev.setBoolFieldValue("ptrace.tracee.interpreter.file.in_upper_layer", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.InUpperLayer, value)
	case "ptrace.tracee.interpreter.file.inode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.inode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("ptrace.tracee.interpreter.file.inode", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode, value)
	case "ptrace.tracee.interpreter.file.mode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.mode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("ptrace.tracee.interpreter.file.mode", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "ptrace.tracee.interpreter.file.modification_time":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.modification_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("ptrace.tracee.interpreter.file.modification_time", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.MTime, value)
	case "ptrace.tracee.interpreter.file.mount_id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.mount_id", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("ptrace.tracee.interpreter.file.mount_id", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID, value)
	case "ptrace.tracee.interpreter.file.name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.interpreter.file.name", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.BasenameStr, value)
	case "ptrace.tracee.interpreter.file.name.length":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return &eval.ErrFieldReadOnly{Field: "ptrace.tracee.interpreter.file.name.length"}
	case "ptrace.tracee.interpreter.file.package.name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.package.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.interpreter.file.package.name", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.PkgName, value)
	case "ptrace.tracee.interpreter.file.package.source_version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.package.source_version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.interpreter.file.package.source_version", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.PkgSrcVersion, value)
	case "ptrace.tracee.interpreter.file.package.version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.package.version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.interpreter.file.package.version", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.PkgVersion, value)
	case "ptrace.tracee.interpreter.file.path":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.path", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.interpreter.file.path", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.PathnameStr, value)
	case "ptrace.tracee.interpreter.file.path.length":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return &eval.ErrFieldReadOnly{Field: "ptrace.tracee.interpreter.file.path.length"}
	case "ptrace.tracee.interpreter.file.rights":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.rights", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("ptrace.tracee.interpreter.file.rights", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "ptrace.tracee.interpreter.file.uid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.uid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("ptrace.tracee.interpreter.file.uid", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.UID, value)
	case "ptrace.tracee.interpreter.file.user":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Process.LinuxBinprm, "file.user", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.interpreter.file.user", &ev.PTrace.Tracee.Process.LinuxBinprm.FileEvent.FileFields.User, value)
	case "ptrace.tracee.is_exec":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.is_exec", &ev.PTrace.Tracee.Process.IsExec, value)
	case "ptrace.tracee.is_kworker":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.is_kworker", &ev.PTrace.Tracee.Process.PIDContext.IsKworker, value)
	case "ptrace.tracee.is_thread":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.is_thread", &ev.PTrace.Tracee.Process.IsThread, value)
	case "ptrace.tracee.parent.args":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.args", &ev.PTrace.Tracee.Parent.Args, value)
	case "ptrace.tracee.parent.args_flags":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.parent.args_flags", &ev.PTrace.Tracee.Parent.Argv, value)
	case "ptrace.tracee.parent.args_options":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.parent.args_options", &ev.PTrace.Tracee.Parent.Argv, value)
	case "ptrace.tracee.parent.args_truncated":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.parent.args_truncated", &ev.PTrace.Tracee.Parent.ArgsTruncated, value)
	case "ptrace.tracee.parent.argv":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.parent.argv", &ev.PTrace.Tracee.Parent.Argv, value)
	case "ptrace.tracee.parent.argv0":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.argv0", &ev.PTrace.Tracee.Parent.Argv0, value)
	case "ptrace.tracee.parent.auid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.auid", &ev.PTrace.Tracee.Parent.Credentials.AUID, value)
	case "ptrace.tracee.parent.cap_effective":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.parent.cap_effective", &ev.PTrace.Tracee.Parent.Credentials.CapEffective, value)
	case "ptrace.tracee.parent.cap_permitted":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.parent.cap_permitted", &ev.PTrace.Tracee.Parent.Credentials.CapPermitted, value)
	case "ptrace.tracee.parent.cgroup.file.inode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.parent.cgroup.file.inode", &ev.PTrace.Tracee.Parent.CGroup.CGroupFile.Inode, value)
	case "ptrace.tracee.parent.cgroup.file.mount_id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.cgroup.file.mount_id", &ev.PTrace.Tracee.Parent.CGroup.CGroupFile.MountID, value)
	case "ptrace.tracee.parent.cgroup.id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "ptrace.tracee.parent.cgroup.id"}
		}
		ev.PTrace.Tracee.Parent.CGroup.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "ptrace.tracee.parent.cgroup.manager":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.cgroup.manager", &ev.PTrace.Tracee.Parent.CGroup.CGroupManager, value)
	case "ptrace.tracee.parent.cgroup.version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setIntFieldValue("ptrace.tracee.parent.cgroup.version", &ev.PTrace.Tracee.Parent.CGroup.CGroupVersion, value)
	case "ptrace.tracee.parent.comm":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.comm", &ev.PTrace.Tracee.Parent.Comm, value)
	case "ptrace.tracee.parent.container.id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "ptrace.tracee.parent.container.id"}
		}
		ev.PTrace.Tracee.Parent.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "ptrace.tracee.parent.created_at":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.parent.created_at", &ev.PTrace.Tracee.Parent.CreatedAt, value)
	case "ptrace.tracee.parent.egid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.egid", &ev.PTrace.Tracee.Parent.Credentials.EGID, value)
	case "ptrace.tracee.parent.egroup":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.egroup", &ev.PTrace.Tracee.Parent.Credentials.EGroup, value)
	case "ptrace.tracee.parent.envp":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.parent.envp", &ev.PTrace.Tracee.Parent.Envp, value)
	case "ptrace.tracee.parent.envs":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.parent.envs", &ev.PTrace.Tracee.Parent.Envs, value)
	case "ptrace.tracee.parent.envs_truncated":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.parent.envs_truncated", &ev.PTrace.Tracee.Parent.EnvsTruncated, value)
	case "ptrace.tracee.parent.euid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.euid", &ev.PTrace.Tracee.Parent.Credentials.EUID, value)
	case "ptrace.tracee.parent.euser":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.euser", &ev.PTrace.Tracee.Parent.Credentials.EUser, value)
	case "ptrace.tracee.parent.file.change_time":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.parent.file.change_time", &ev.PTrace.Tracee.Parent.FileEvent.FileFields.CTime, value)
	case "ptrace.tracee.parent.file.filesystem":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.file.filesystem", &ev.PTrace.Tracee.Parent.FileEvent.Filesystem, value)
	case "ptrace.tracee.parent.file.gid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.file.gid", &ev.PTrace.Tracee.Parent.FileEvent.FileFields.GID, value)
	case "ptrace.tracee.parent.file.group":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.file.group", &ev.PTrace.Tracee.Parent.FileEvent.FileFields.Group, value)
	case "ptrace.tracee.parent.file.hashes":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.parent.file.hashes", &ev.PTrace.Tracee.Parent.FileEvent.Hashes, value)
	case "ptrace.tracee.parent.file.in_upper_layer":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.parent.file.in_upper_layer", &ev.PTrace.Tracee.Parent.FileEvent.FileFields.InUpperLayer, value)
	case "ptrace.tracee.parent.file.inode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.parent.file.inode", &ev.PTrace.Tracee.Parent.FileEvent.FileFields.PathKey.Inode, value)
	case "ptrace.tracee.parent.file.mode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint16FieldValue("ptrace.tracee.parent.file.mode", &ev.PTrace.Tracee.Parent.FileEvent.FileFields.Mode, value)
	case "ptrace.tracee.parent.file.modification_time":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint64FieldValue("ptrace.tracee.parent.file.modification_time", &ev.PTrace.Tracee.Parent.FileEvent.FileFields.MTime, value)
	case "ptrace.tracee.parent.file.mount_id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.file.mount_id", &ev.PTrace.Tracee.Parent.FileEvent.FileFields.PathKey.MountID, value)
	case "ptrace.tracee.parent.file.name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.file.name", &ev.PTrace.Tracee.Parent.FileEvent.BasenameStr, value)
	case "ptrace.tracee.parent.file.name.length":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "ptrace.tracee.parent.file.name.length"}
	case "ptrace.tracee.parent.file.package.name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.file.package.name", &ev.PTrace.Tracee.Parent.FileEvent.PkgName, value)
	case "ptrace.tracee.parent.file.package.source_version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.file.package.source_version", &ev.PTrace.Tracee.Parent.FileEvent.PkgSrcVersion, value)
	case "ptrace.tracee.parent.file.package.version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.file.package.version", &ev.PTrace.Tracee.Parent.FileEvent.PkgVersion, value)
	case "ptrace.tracee.parent.file.path":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.file.path", &ev.PTrace.Tracee.Parent.FileEvent.PathnameStr, value)
	case "ptrace.tracee.parent.file.path.length":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "ptrace.tracee.parent.file.path.length"}
	case "ptrace.tracee.parent.file.rights":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint16FieldValue("ptrace.tracee.parent.file.rights", &ev.PTrace.Tracee.Parent.FileEvent.FileFields.Mode, value)
	case "ptrace.tracee.parent.file.uid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.file.uid", &ev.PTrace.Tracee.Parent.FileEvent.FileFields.UID, value)
	case "ptrace.tracee.parent.file.user":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.file.user", &ev.PTrace.Tracee.Parent.FileEvent.FileFields.User, value)
	case "ptrace.tracee.parent.fsgid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.fsgid", &ev.PTrace.Tracee.Parent.Credentials.FSGID, value)
	case "ptrace.tracee.parent.fsgroup":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.fsgroup", &ev.PTrace.Tracee.Parent.Credentials.FSGroup, value)
	case "ptrace.tracee.parent.fsuid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.fsuid", &ev.PTrace.Tracee.Parent.Credentials.FSUID, value)
	case "ptrace.tracee.parent.fsuser":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.fsuser", &ev.PTrace.Tracee.Parent.Credentials.FSUser, value)
	case "ptrace.tracee.parent.gid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.gid", &ev.PTrace.Tracee.Parent.Credentials.GID, value)
	case "ptrace.tracee.parent.group":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.group", &ev.PTrace.Tracee.Parent.Credentials.Group, value)
	case "ptrace.tracee.parent.interpreter.file.change_time":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.change_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("ptrace.tracee.parent.interpreter.file.change_time", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.CTime, value)
	case "ptrace.tracee.parent.interpreter.file.filesystem":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.filesystem", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.interpreter.file.filesystem", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.Filesystem, value)
	case "ptrace.tracee.parent.interpreter.file.gid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.gid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.interpreter.file.gid", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.GID, value)
	case "ptrace.tracee.parent.interpreter.file.group":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.group", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.interpreter.file.group", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.Group, value)
	case "ptrace.tracee.parent.interpreter.file.hashes":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.hashes", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.parent.interpreter.file.hashes", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.Hashes, value)
	case "ptrace.tracee.parent.interpreter.file.in_upper_layer":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.in_upper_layer", value)
		if err != nil || !cont {
			return err
		}
		return ev.setBoolFieldValue("ptrace.tracee.parent.interpreter.file.in_upper_layer", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.InUpperLayer, value)
	case "ptrace.tracee.parent.interpreter.file.inode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.inode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("ptrace.tracee.parent.interpreter.file.inode", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.Inode, value)
	case "ptrace.tracee.parent.interpreter.file.mode":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.mode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("ptrace.tracee.parent.interpreter.file.mode", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "ptrace.tracee.parent.interpreter.file.modification_time":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.modification_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("ptrace.tracee.parent.interpreter.file.modification_time", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.MTime, value)
	case "ptrace.tracee.parent.interpreter.file.mount_id":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.mount_id", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.interpreter.file.mount_id", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.MountID, value)
	case "ptrace.tracee.parent.interpreter.file.name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.interpreter.file.name", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.BasenameStr, value)
	case "ptrace.tracee.parent.interpreter.file.name.length":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "ptrace.tracee.parent.interpreter.file.name.length"}
	case "ptrace.tracee.parent.interpreter.file.package.name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.package.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.interpreter.file.package.name", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.PkgName, value)
	case "ptrace.tracee.parent.interpreter.file.package.source_version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.package.source_version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.interpreter.file.package.source_version", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.PkgSrcVersion, value)
	case "ptrace.tracee.parent.interpreter.file.package.version":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.package.version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.interpreter.file.package.version", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.PkgVersion, value)
	case "ptrace.tracee.parent.interpreter.file.path":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.path", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.interpreter.file.path", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.PathnameStr, value)
	case "ptrace.tracee.parent.interpreter.file.path.length":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "ptrace.tracee.parent.interpreter.file.path.length"}
	case "ptrace.tracee.parent.interpreter.file.rights":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.rights", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("ptrace.tracee.parent.interpreter.file.rights", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "ptrace.tracee.parent.interpreter.file.uid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.uid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.interpreter.file.uid", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.UID, value)
	case "ptrace.tracee.parent.interpreter.file.user":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.PTrace.Tracee.Parent.LinuxBinprm, "file.user", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.interpreter.file.user", &ev.PTrace.Tracee.Parent.LinuxBinprm.FileEvent.FileFields.User, value)
	case "ptrace.tracee.parent.is_exec":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.parent.is_exec", &ev.PTrace.Tracee.Parent.IsExec, value)
	case "ptrace.tracee.parent.is_kworker":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.parent.is_kworker", &ev.PTrace.Tracee.Parent.PIDContext.IsKworker, value)
	case "ptrace.tracee.parent.is_thread":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setBoolFieldValue("ptrace.tracee.parent.is_thread", &ev.PTrace.Tracee.Parent.IsThread, value)
	case "ptrace.tracee.parent.pid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.pid", &ev.PTrace.Tracee.Parent.PIDContext.Pid, value)
	case "ptrace.tracee.parent.ppid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.ppid", &ev.PTrace.Tracee.Parent.PPid, value)
	case "ptrace.tracee.parent.tid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.tid", &ev.PTrace.Tracee.Parent.PIDContext.Tid, value)
	case "ptrace.tracee.parent.tty_name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.tty_name", &ev.PTrace.Tracee.Parent.TTYName, value)
	case "ptrace.tracee.parent.uid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.parent.uid", &ev.PTrace.Tracee.Parent.Credentials.UID, value)
	case "ptrace.tracee.parent.user":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.user", &ev.PTrace.Tracee.Parent.Credentials.User, value)
	case "ptrace.tracee.parent.user_session.k8s_groups":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.parent.user_session.k8s_groups", &ev.PTrace.Tracee.Parent.UserSession.K8SGroups, value)
	case "ptrace.tracee.parent.user_session.k8s_uid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.user_session.k8s_uid", &ev.PTrace.Tracee.Parent.UserSession.K8SUID, value)
	case "ptrace.tracee.parent.user_session.k8s_username":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		if ev.PTrace.Tracee.Parent == nil {
			ev.PTrace.Tracee.Parent = &Process{}
		}
		return ev.setStringFieldValue("ptrace.tracee.parent.user_session.k8s_username", &ev.PTrace.Tracee.Parent.UserSession.K8SUsername, value)
	case "ptrace.tracee.pid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.pid", &ev.PTrace.Tracee.Process.PIDContext.Pid, value)
	case "ptrace.tracee.ppid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.ppid", &ev.PTrace.Tracee.Process.PPid, value)
	case "ptrace.tracee.tid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.tid", &ev.PTrace.Tracee.Process.PIDContext.Tid, value)
	case "ptrace.tracee.tty_name":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.tty_name", &ev.PTrace.Tracee.Process.TTYName, value)
	case "ptrace.tracee.uid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setUint32FieldValue("ptrace.tracee.uid", &ev.PTrace.Tracee.Process.Credentials.UID, value)
	case "ptrace.tracee.user":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.user", &ev.PTrace.Tracee.Process.Credentials.User, value)
	case "ptrace.tracee.user_session.k8s_groups":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("ptrace.tracee.user_session.k8s_groups", &ev.PTrace.Tracee.Process.UserSession.K8SGroups, value)
	case "ptrace.tracee.user_session.k8s_uid":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.user_session.k8s_uid", &ev.PTrace.Tracee.Process.UserSession.K8SUID, value)
	case "ptrace.tracee.user_session.k8s_username":
		if ev.PTrace.Tracee == nil {
			ev.PTrace.Tracee = &ProcessContext{}
		}
		return ev.setStringFieldValue("ptrace.tracee.user_session.k8s_username", &ev.PTrace.Tracee.Process.UserSession.K8SUsername, value)
	case "removexattr.file.change_time":
		return ev.setUint64FieldValue("removexattr.file.change_time", &ev.RemoveXAttr.File.FileFields.CTime, value)
	case "removexattr.file.destination.name":
		return ev.setStringFieldValue("removexattr.file.destination.name", &ev.RemoveXAttr.Name, value)
	case "removexattr.file.destination.namespace":
		return ev.setStringFieldValue("removexattr.file.destination.namespace", &ev.RemoveXAttr.Namespace, value)
	case "removexattr.file.filesystem":
		return ev.setStringFieldValue("removexattr.file.filesystem", &ev.RemoveXAttr.File.Filesystem, value)
	case "removexattr.file.gid":
		return ev.setUint32FieldValue("removexattr.file.gid", &ev.RemoveXAttr.File.FileFields.GID, value)
	case "removexattr.file.group":
		return ev.setStringFieldValue("removexattr.file.group", &ev.RemoveXAttr.File.FileFields.Group, value)
	case "removexattr.file.hashes":
		return ev.setStringArrayFieldValue("removexattr.file.hashes", &ev.RemoveXAttr.File.Hashes, value)
	case "removexattr.file.in_upper_layer":
		return ev.setBoolFieldValue("removexattr.file.in_upper_layer", &ev.RemoveXAttr.File.FileFields.InUpperLayer, value)
	case "removexattr.file.inode":
		return ev.setUint64FieldValue("removexattr.file.inode", &ev.RemoveXAttr.File.FileFields.PathKey.Inode, value)
	case "removexattr.file.mode":
		return ev.setUint16FieldValue("removexattr.file.mode", &ev.RemoveXAttr.File.FileFields.Mode, value)
	case "removexattr.file.modification_time":
		return ev.setUint64FieldValue("removexattr.file.modification_time", &ev.RemoveXAttr.File.FileFields.MTime, value)
	case "removexattr.file.mount_id":
		return ev.setUint32FieldValue("removexattr.file.mount_id", &ev.RemoveXAttr.File.FileFields.PathKey.MountID, value)
	case "removexattr.file.name":
		return ev.setStringFieldValue("removexattr.file.name", &ev.RemoveXAttr.File.BasenameStr, value)
	case "removexattr.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "removexattr.file.name.length"}
	case "removexattr.file.package.name":
		return ev.setStringFieldValue("removexattr.file.package.name", &ev.RemoveXAttr.File.PkgName, value)
	case "removexattr.file.package.source_version":
		return ev.setStringFieldValue("removexattr.file.package.source_version", &ev.RemoveXAttr.File.PkgSrcVersion, value)
	case "removexattr.file.package.version":
		return ev.setStringFieldValue("removexattr.file.package.version", &ev.RemoveXAttr.File.PkgVersion, value)
	case "removexattr.file.path":
		return ev.setStringFieldValue("removexattr.file.path", &ev.RemoveXAttr.File.PathnameStr, value)
	case "removexattr.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "removexattr.file.path.length"}
	case "removexattr.file.rights":
		return ev.setUint16FieldValue("removexattr.file.rights", &ev.RemoveXAttr.File.FileFields.Mode, value)
	case "removexattr.file.uid":
		return ev.setUint32FieldValue("removexattr.file.uid", &ev.RemoveXAttr.File.FileFields.UID, value)
	case "removexattr.file.user":
		return ev.setStringFieldValue("removexattr.file.user", &ev.RemoveXAttr.File.FileFields.User, value)
	case "removexattr.retval":
		return ev.setInt64FieldValue("removexattr.retval", &ev.RemoveXAttr.SyscallEvent.Retval, value)
	case "rename.file.change_time":
		return ev.setUint64FieldValue("rename.file.change_time", &ev.Rename.Old.FileFields.CTime, value)
	case "rename.file.destination.change_time":
		return ev.setUint64FieldValue("rename.file.destination.change_time", &ev.Rename.New.FileFields.CTime, value)
	case "rename.file.destination.filesystem":
		return ev.setStringFieldValue("rename.file.destination.filesystem", &ev.Rename.New.Filesystem, value)
	case "rename.file.destination.gid":
		return ev.setUint32FieldValue("rename.file.destination.gid", &ev.Rename.New.FileFields.GID, value)
	case "rename.file.destination.group":
		return ev.setStringFieldValue("rename.file.destination.group", &ev.Rename.New.FileFields.Group, value)
	case "rename.file.destination.hashes":
		return ev.setStringArrayFieldValue("rename.file.destination.hashes", &ev.Rename.New.Hashes, value)
	case "rename.file.destination.in_upper_layer":
		return ev.setBoolFieldValue("rename.file.destination.in_upper_layer", &ev.Rename.New.FileFields.InUpperLayer, value)
	case "rename.file.destination.inode":
		return ev.setUint64FieldValue("rename.file.destination.inode", &ev.Rename.New.FileFields.PathKey.Inode, value)
	case "rename.file.destination.mode":
		return ev.setUint16FieldValue("rename.file.destination.mode", &ev.Rename.New.FileFields.Mode, value)
	case "rename.file.destination.modification_time":
		return ev.setUint64FieldValue("rename.file.destination.modification_time", &ev.Rename.New.FileFields.MTime, value)
	case "rename.file.destination.mount_id":
		return ev.setUint32FieldValue("rename.file.destination.mount_id", &ev.Rename.New.FileFields.PathKey.MountID, value)
	case "rename.file.destination.name":
		return ev.setStringFieldValue("rename.file.destination.name", &ev.Rename.New.BasenameStr, value)
	case "rename.file.destination.name.length":
		return &eval.ErrFieldReadOnly{Field: "rename.file.destination.name.length"}
	case "rename.file.destination.package.name":
		return ev.setStringFieldValue("rename.file.destination.package.name", &ev.Rename.New.PkgName, value)
	case "rename.file.destination.package.source_version":
		return ev.setStringFieldValue("rename.file.destination.package.source_version", &ev.Rename.New.PkgSrcVersion, value)
	case "rename.file.destination.package.version":
		return ev.setStringFieldValue("rename.file.destination.package.version", &ev.Rename.New.PkgVersion, value)
	case "rename.file.destination.path":
		return ev.setStringFieldValue("rename.file.destination.path", &ev.Rename.New.PathnameStr, value)
	case "rename.file.destination.path.length":
		return &eval.ErrFieldReadOnly{Field: "rename.file.destination.path.length"}
	case "rename.file.destination.rights":
		return ev.setUint16FieldValue("rename.file.destination.rights", &ev.Rename.New.FileFields.Mode, value)
	case "rename.file.destination.uid":
		return ev.setUint32FieldValue("rename.file.destination.uid", &ev.Rename.New.FileFields.UID, value)
	case "rename.file.destination.user":
		return ev.setStringFieldValue("rename.file.destination.user", &ev.Rename.New.FileFields.User, value)
	case "rename.file.filesystem":
		return ev.setStringFieldValue("rename.file.filesystem", &ev.Rename.Old.Filesystem, value)
	case "rename.file.gid":
		return ev.setUint32FieldValue("rename.file.gid", &ev.Rename.Old.FileFields.GID, value)
	case "rename.file.group":
		return ev.setStringFieldValue("rename.file.group", &ev.Rename.Old.FileFields.Group, value)
	case "rename.file.hashes":
		return ev.setStringArrayFieldValue("rename.file.hashes", &ev.Rename.Old.Hashes, value)
	case "rename.file.in_upper_layer":
		return ev.setBoolFieldValue("rename.file.in_upper_layer", &ev.Rename.Old.FileFields.InUpperLayer, value)
	case "rename.file.inode":
		return ev.setUint64FieldValue("rename.file.inode", &ev.Rename.Old.FileFields.PathKey.Inode, value)
	case "rename.file.mode":
		return ev.setUint16FieldValue("rename.file.mode", &ev.Rename.Old.FileFields.Mode, value)
	case "rename.file.modification_time":
		return ev.setUint64FieldValue("rename.file.modification_time", &ev.Rename.Old.FileFields.MTime, value)
	case "rename.file.mount_id":
		return ev.setUint32FieldValue("rename.file.mount_id", &ev.Rename.Old.FileFields.PathKey.MountID, value)
	case "rename.file.name":
		return ev.setStringFieldValue("rename.file.name", &ev.Rename.Old.BasenameStr, value)
	case "rename.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "rename.file.name.length"}
	case "rename.file.package.name":
		return ev.setStringFieldValue("rename.file.package.name", &ev.Rename.Old.PkgName, value)
	case "rename.file.package.source_version":
		return ev.setStringFieldValue("rename.file.package.source_version", &ev.Rename.Old.PkgSrcVersion, value)
	case "rename.file.package.version":
		return ev.setStringFieldValue("rename.file.package.version", &ev.Rename.Old.PkgVersion, value)
	case "rename.file.path":
		return ev.setStringFieldValue("rename.file.path", &ev.Rename.Old.PathnameStr, value)
	case "rename.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "rename.file.path.length"}
	case "rename.file.rights":
		return ev.setUint16FieldValue("rename.file.rights", &ev.Rename.Old.FileFields.Mode, value)
	case "rename.file.uid":
		return ev.setUint32FieldValue("rename.file.uid", &ev.Rename.Old.FileFields.UID, value)
	case "rename.file.user":
		return ev.setStringFieldValue("rename.file.user", &ev.Rename.Old.FileFields.User, value)
	case "rename.retval":
		return ev.setInt64FieldValue("rename.retval", &ev.Rename.SyscallEvent.Retval, value)
	case "rename.syscall.destination.path":
		return ev.setStringFieldValue("rename.syscall.destination.path", &ev.Rename.SyscallContext.StrArg2, value)
	case "rename.syscall.path":
		return ev.setStringFieldValue("rename.syscall.path", &ev.Rename.SyscallContext.StrArg1, value)
	case "rmdir.file.change_time":
		return ev.setUint64FieldValue("rmdir.file.change_time", &ev.Rmdir.File.FileFields.CTime, value)
	case "rmdir.file.filesystem":
		return ev.setStringFieldValue("rmdir.file.filesystem", &ev.Rmdir.File.Filesystem, value)
	case "rmdir.file.gid":
		return ev.setUint32FieldValue("rmdir.file.gid", &ev.Rmdir.File.FileFields.GID, value)
	case "rmdir.file.group":
		return ev.setStringFieldValue("rmdir.file.group", &ev.Rmdir.File.FileFields.Group, value)
	case "rmdir.file.hashes":
		return ev.setStringArrayFieldValue("rmdir.file.hashes", &ev.Rmdir.File.Hashes, value)
	case "rmdir.file.in_upper_layer":
		return ev.setBoolFieldValue("rmdir.file.in_upper_layer", &ev.Rmdir.File.FileFields.InUpperLayer, value)
	case "rmdir.file.inode":
		return ev.setUint64FieldValue("rmdir.file.inode", &ev.Rmdir.File.FileFields.PathKey.Inode, value)
	case "rmdir.file.mode":
		return ev.setUint16FieldValue("rmdir.file.mode", &ev.Rmdir.File.FileFields.Mode, value)
	case "rmdir.file.modification_time":
		return ev.setUint64FieldValue("rmdir.file.modification_time", &ev.Rmdir.File.FileFields.MTime, value)
	case "rmdir.file.mount_id":
		return ev.setUint32FieldValue("rmdir.file.mount_id", &ev.Rmdir.File.FileFields.PathKey.MountID, value)
	case "rmdir.file.name":
		return ev.setStringFieldValue("rmdir.file.name", &ev.Rmdir.File.BasenameStr, value)
	case "rmdir.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "rmdir.file.name.length"}
	case "rmdir.file.package.name":
		return ev.setStringFieldValue("rmdir.file.package.name", &ev.Rmdir.File.PkgName, value)
	case "rmdir.file.package.source_version":
		return ev.setStringFieldValue("rmdir.file.package.source_version", &ev.Rmdir.File.PkgSrcVersion, value)
	case "rmdir.file.package.version":
		return ev.setStringFieldValue("rmdir.file.package.version", &ev.Rmdir.File.PkgVersion, value)
	case "rmdir.file.path":
		return ev.setStringFieldValue("rmdir.file.path", &ev.Rmdir.File.PathnameStr, value)
	case "rmdir.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "rmdir.file.path.length"}
	case "rmdir.file.rights":
		return ev.setUint16FieldValue("rmdir.file.rights", &ev.Rmdir.File.FileFields.Mode, value)
	case "rmdir.file.uid":
		return ev.setUint32FieldValue("rmdir.file.uid", &ev.Rmdir.File.FileFields.UID, value)
	case "rmdir.file.user":
		return ev.setStringFieldValue("rmdir.file.user", &ev.Rmdir.File.FileFields.User, value)
	case "rmdir.retval":
		return ev.setInt64FieldValue("rmdir.retval", &ev.Rmdir.SyscallEvent.Retval, value)
	case "rmdir.syscall.path":
		return ev.setStringFieldValue("rmdir.syscall.path", &ev.Rmdir.SyscallContext.StrArg1, value)
	case "selinux.bool.name":
		return ev.setStringFieldValue("selinux.bool.name", &ev.SELinux.BoolName, value)
	case "selinux.bool.state":
		return ev.setStringFieldValue("selinux.bool.state", &ev.SELinux.BoolChangeValue, value)
	case "selinux.bool_commit.state":
		return ev.setBoolFieldValue("selinux.bool_commit.state", &ev.SELinux.BoolCommitValue, value)
	case "selinux.enforce.status":
		return ev.setStringFieldValue("selinux.enforce.status", &ev.SELinux.EnforceStatus, value)
	case "setgid.egid":
		return ev.setUint32FieldValue("setgid.egid", &ev.SetGID.EGID, value)
	case "setgid.egroup":
		return ev.setStringFieldValue("setgid.egroup", &ev.SetGID.EGroup, value)
	case "setgid.fsgid":
		return ev.setUint32FieldValue("setgid.fsgid", &ev.SetGID.FSGID, value)
	case "setgid.fsgroup":
		return ev.setStringFieldValue("setgid.fsgroup", &ev.SetGID.FSGroup, value)
	case "setgid.gid":
		return ev.setUint32FieldValue("setgid.gid", &ev.SetGID.GID, value)
	case "setgid.group":
		return ev.setStringFieldValue("setgid.group", &ev.SetGID.Group, value)
	case "setrlimit.resource":
		return ev.setIntFieldValue("setrlimit.resource", &ev.Setrlimit.Resource, value)
	case "setrlimit.retval":
		return ev.setInt64FieldValue("setrlimit.retval", &ev.Setrlimit.SyscallEvent.Retval, value)
	case "setrlimit.rlim_cur":
		return ev.setUint64FieldValue("setrlimit.rlim_cur", &ev.Setrlimit.RlimCur, value)
	case "setrlimit.rlim_max":
		return ev.setUint64FieldValue("setrlimit.rlim_max", &ev.Setrlimit.RlimMax, value)
	case "setrlimit.target.ancestors.args":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.args", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Args, value)
	case "setrlimit.target.ancestors.args_flags":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.ancestors.args_flags", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Argv, value)
	case "setrlimit.target.ancestors.args_options":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.ancestors.args_options", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Argv, value)
	case "setrlimit.target.ancestors.args_truncated":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("setrlimit.target.ancestors.args_truncated", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.ArgsTruncated, value)
	case "setrlimit.target.ancestors.argv":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.ancestors.argv", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Argv, value)
	case "setrlimit.target.ancestors.argv0":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.argv0", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Argv0, value)
	case "setrlimit.target.ancestors.auid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.auid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.AUID, value)
	case "setrlimit.target.ancestors.cap_effective":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("setrlimit.target.ancestors.cap_effective", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.CapEffective, value)
	case "setrlimit.target.ancestors.cap_permitted":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("setrlimit.target.ancestors.cap_permitted", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.CapPermitted, value)
	case "setrlimit.target.ancestors.cgroup.file.inode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("setrlimit.target.ancestors.cgroup.file.inode", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.CGroup.CGroupFile.Inode, value)
	case "setrlimit.target.ancestors.cgroup.file.mount_id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.cgroup.file.mount_id", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.CGroup.CGroupFile.MountID, value)
	case "setrlimit.target.ancestors.cgroup.id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "setrlimit.target.ancestors.cgroup.id"}
		}
		ev.Setrlimit.Target.Ancestor.ProcessContext.Process.CGroup.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "setrlimit.target.ancestors.cgroup.manager":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.cgroup.manager", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.CGroup.CGroupManager, value)
	case "setrlimit.target.ancestors.cgroup.version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setIntFieldValue("setrlimit.target.ancestors.cgroup.version", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.CGroup.CGroupVersion, value)
	case "setrlimit.target.ancestors.comm":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.comm", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Comm, value)
	case "setrlimit.target.ancestors.container.id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "setrlimit.target.ancestors.container.id"}
		}
		ev.Setrlimit.Target.Ancestor.ProcessContext.Process.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "setrlimit.target.ancestors.created_at":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("setrlimit.target.ancestors.created_at", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.CreatedAt, value)
	case "setrlimit.target.ancestors.egid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.egid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.EGID, value)
	case "setrlimit.target.ancestors.egroup":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.egroup", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.EGroup, value)
	case "setrlimit.target.ancestors.envp":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.ancestors.envp", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Envp, value)
	case "setrlimit.target.ancestors.envs":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.ancestors.envs", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Envs, value)
	case "setrlimit.target.ancestors.envs_truncated":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("setrlimit.target.ancestors.envs_truncated", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.EnvsTruncated, value)
	case "setrlimit.target.ancestors.euid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.euid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.EUID, value)
	case "setrlimit.target.ancestors.euser":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.euser", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.EUser, value)
	case "setrlimit.target.ancestors.file.change_time":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("setrlimit.target.ancestors.file.change_time", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.CTime, value)
	case "setrlimit.target.ancestors.file.filesystem":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.file.filesystem", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.Filesystem, value)
	case "setrlimit.target.ancestors.file.gid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.file.gid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.GID, value)
	case "setrlimit.target.ancestors.file.group":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.file.group", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.Group, value)
	case "setrlimit.target.ancestors.file.hashes":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.ancestors.file.hashes", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.Hashes, value)
	case "setrlimit.target.ancestors.file.in_upper_layer":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("setrlimit.target.ancestors.file.in_upper_layer", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.InUpperLayer, value)
	case "setrlimit.target.ancestors.file.inode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("setrlimit.target.ancestors.file.inode", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.PathKey.Inode, value)
	case "setrlimit.target.ancestors.file.mode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint16FieldValue("setrlimit.target.ancestors.file.mode", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.Mode, value)
	case "setrlimit.target.ancestors.file.modification_time":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("setrlimit.target.ancestors.file.modification_time", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.MTime, value)
	case "setrlimit.target.ancestors.file.mount_id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.file.mount_id", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.PathKey.MountID, value)
	case "setrlimit.target.ancestors.file.name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.file.name", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.BasenameStr, value)
	case "setrlimit.target.ancestors.file.name.length":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "setrlimit.target.ancestors.file.name.length"}
	case "setrlimit.target.ancestors.file.package.name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.file.package.name", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.PkgName, value)
	case "setrlimit.target.ancestors.file.package.source_version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.file.package.source_version", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.PkgSrcVersion, value)
	case "setrlimit.target.ancestors.file.package.version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.file.package.version", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.PkgVersion, value)
	case "setrlimit.target.ancestors.file.path":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.file.path", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.PathnameStr, value)
	case "setrlimit.target.ancestors.file.path.length":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "setrlimit.target.ancestors.file.path.length"}
	case "setrlimit.target.ancestors.file.rights":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint16FieldValue("setrlimit.target.ancestors.file.rights", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.Mode, value)
	case "setrlimit.target.ancestors.file.uid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.file.uid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.UID, value)
	case "setrlimit.target.ancestors.file.user":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.file.user", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.User, value)
	case "setrlimit.target.ancestors.fsgid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.fsgid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.FSGID, value)
	case "setrlimit.target.ancestors.fsgroup":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.fsgroup", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.FSGroup, value)
	case "setrlimit.target.ancestors.fsuid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.fsuid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.FSUID, value)
	case "setrlimit.target.ancestors.fsuser":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.fsuser", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.FSUser, value)
	case "setrlimit.target.ancestors.gid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.gid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.GID, value)
	case "setrlimit.target.ancestors.group":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.group", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.Group, value)
	case "setrlimit.target.ancestors.interpreter.file.change_time":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.change_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("setrlimit.target.ancestors.interpreter.file.change_time", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.CTime, value)
	case "setrlimit.target.ancestors.interpreter.file.filesystem":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.filesystem", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.interpreter.file.filesystem", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.Filesystem, value)
	case "setrlimit.target.ancestors.interpreter.file.gid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.gid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.interpreter.file.gid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.GID, value)
	case "setrlimit.target.ancestors.interpreter.file.group":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.group", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.interpreter.file.group", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Group, value)
	case "setrlimit.target.ancestors.interpreter.file.hashes":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.hashes", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringArrayFieldValue("setrlimit.target.ancestors.interpreter.file.hashes", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.Hashes, value)
	case "setrlimit.target.ancestors.interpreter.file.in_upper_layer":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.in_upper_layer", value)
		if err != nil || !cont {
			return err
		}
		return ev.setBoolFieldValue("setrlimit.target.ancestors.interpreter.file.in_upper_layer", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.InUpperLayer, value)
	case "setrlimit.target.ancestors.interpreter.file.inode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.inode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("setrlimit.target.ancestors.interpreter.file.inode", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode, value)
	case "setrlimit.target.ancestors.interpreter.file.mode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.mode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("setrlimit.target.ancestors.interpreter.file.mode", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "setrlimit.target.ancestors.interpreter.file.modification_time":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.modification_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("setrlimit.target.ancestors.interpreter.file.modification_time", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.MTime, value)
	case "setrlimit.target.ancestors.interpreter.file.mount_id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.mount_id", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.interpreter.file.mount_id", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID, value)
	case "setrlimit.target.ancestors.interpreter.file.name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.interpreter.file.name", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.BasenameStr, value)
	case "setrlimit.target.ancestors.interpreter.file.name.length":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "setrlimit.target.ancestors.interpreter.file.name.length"}
	case "setrlimit.target.ancestors.interpreter.file.package.name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.package.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.interpreter.file.package.name", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PkgName, value)
	case "setrlimit.target.ancestors.interpreter.file.package.source_version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.package.source_version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.interpreter.file.package.source_version", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PkgSrcVersion, value)
	case "setrlimit.target.ancestors.interpreter.file.package.version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.package.version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.interpreter.file.package.version", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PkgVersion, value)
	case "setrlimit.target.ancestors.interpreter.file.path":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.path", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.interpreter.file.path", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PathnameStr, value)
	case "setrlimit.target.ancestors.interpreter.file.path.length":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "setrlimit.target.ancestors.interpreter.file.path.length"}
	case "setrlimit.target.ancestors.interpreter.file.rights":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.rights", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("setrlimit.target.ancestors.interpreter.file.rights", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "setrlimit.target.ancestors.interpreter.file.uid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.uid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.interpreter.file.uid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.UID, value)
	case "setrlimit.target.ancestors.interpreter.file.user":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.user", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.interpreter.file.user", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.User, value)
	case "setrlimit.target.ancestors.is_exec":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("setrlimit.target.ancestors.is_exec", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.IsExec, value)
	case "setrlimit.target.ancestors.is_kworker":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("setrlimit.target.ancestors.is_kworker", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.PIDContext.IsKworker, value)
	case "setrlimit.target.ancestors.is_thread":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("setrlimit.target.ancestors.is_thread", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.IsThread, value)
	case "setrlimit.target.ancestors.length":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "setrlimit.target.ancestors.length"}
	case "setrlimit.target.ancestors.pid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.pid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.PIDContext.Pid, value)
	case "setrlimit.target.ancestors.ppid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.ppid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.PPid, value)
	case "setrlimit.target.ancestors.tid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.tid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.PIDContext.Tid, value)
	case "setrlimit.target.ancestors.tty_name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.tty_name", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.TTYName, value)
	case "setrlimit.target.ancestors.uid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ancestors.uid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.UID, value)
	case "setrlimit.target.ancestors.user":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.user", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.Credentials.User, value)
	case "setrlimit.target.ancestors.user_session.k8s_groups":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.ancestors.user_session.k8s_groups", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.UserSession.K8SGroups, value)
	case "setrlimit.target.ancestors.user_session.k8s_uid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.user_session.k8s_uid", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.UserSession.K8SUID, value)
	case "setrlimit.target.ancestors.user_session.k8s_username":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Ancestor == nil {
			ev.Setrlimit.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("setrlimit.target.ancestors.user_session.k8s_username", &ev.Setrlimit.Target.Ancestor.ProcessContext.Process.UserSession.K8SUsername, value)
	case "setrlimit.target.args":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.args", &ev.Setrlimit.Target.Process.Args, value)
	case "setrlimit.target.args_flags":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.args_flags", &ev.Setrlimit.Target.Process.Argv, value)
	case "setrlimit.target.args_options":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.args_options", &ev.Setrlimit.Target.Process.Argv, value)
	case "setrlimit.target.args_truncated":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setBoolFieldValue("setrlimit.target.args_truncated", &ev.Setrlimit.Target.Process.ArgsTruncated, value)
	case "setrlimit.target.argv":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.argv", &ev.Setrlimit.Target.Process.Argv, value)
	case "setrlimit.target.argv0":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.argv0", &ev.Setrlimit.Target.Process.Argv0, value)
	case "setrlimit.target.auid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("setrlimit.target.auid", &ev.Setrlimit.Target.Process.Credentials.AUID, value)
	case "setrlimit.target.cap_effective":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint64FieldValue("setrlimit.target.cap_effective", &ev.Setrlimit.Target.Process.Credentials.CapEffective, value)
	case "setrlimit.target.cap_permitted":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint64FieldValue("setrlimit.target.cap_permitted", &ev.Setrlimit.Target.Process.Credentials.CapPermitted, value)
	case "setrlimit.target.cgroup.file.inode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint64FieldValue("setrlimit.target.cgroup.file.inode", &ev.Setrlimit.Target.Process.CGroup.CGroupFile.Inode, value)
	case "setrlimit.target.cgroup.file.mount_id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("setrlimit.target.cgroup.file.mount_id", &ev.Setrlimit.Target.Process.CGroup.CGroupFile.MountID, value)
	case "setrlimit.target.cgroup.id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "setrlimit.target.cgroup.id"}
		}
		ev.Setrlimit.Target.Process.CGroup.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "setrlimit.target.cgroup.manager":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.cgroup.manager", &ev.Setrlimit.Target.Process.CGroup.CGroupManager, value)
	case "setrlimit.target.cgroup.version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setIntFieldValue("setrlimit.target.cgroup.version", &ev.Setrlimit.Target.Process.CGroup.CGroupVersion, value)
	case "setrlimit.target.comm":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.comm", &ev.Setrlimit.Target.Process.Comm, value)
	case "setrlimit.target.container.id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "setrlimit.target.container.id"}
		}
		ev.Setrlimit.Target.Process.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "setrlimit.target.created_at":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint64FieldValue("setrlimit.target.created_at", &ev.Setrlimit.Target.Process.CreatedAt, value)
	case "setrlimit.target.egid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("setrlimit.target.egid", &ev.Setrlimit.Target.Process.Credentials.EGID, value)
	case "setrlimit.target.egroup":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.egroup", &ev.Setrlimit.Target.Process.Credentials.EGroup, value)
	case "setrlimit.target.envp":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.envp", &ev.Setrlimit.Target.Process.Envp, value)
	case "setrlimit.target.envs":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.envs", &ev.Setrlimit.Target.Process.Envs, value)
	case "setrlimit.target.envs_truncated":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setBoolFieldValue("setrlimit.target.envs_truncated", &ev.Setrlimit.Target.Process.EnvsTruncated, value)
	case "setrlimit.target.euid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("setrlimit.target.euid", &ev.Setrlimit.Target.Process.Credentials.EUID, value)
	case "setrlimit.target.euser":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.euser", &ev.Setrlimit.Target.Process.Credentials.EUser, value)
	case "setrlimit.target.file.change_time":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint64FieldValue("setrlimit.target.file.change_time", &ev.Setrlimit.Target.Process.FileEvent.FileFields.CTime, value)
	case "setrlimit.target.file.filesystem":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.file.filesystem", &ev.Setrlimit.Target.Process.FileEvent.Filesystem, value)
	case "setrlimit.target.file.gid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("setrlimit.target.file.gid", &ev.Setrlimit.Target.Process.FileEvent.FileFields.GID, value)
	case "setrlimit.target.file.group":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.file.group", &ev.Setrlimit.Target.Process.FileEvent.FileFields.Group, value)
	case "setrlimit.target.file.hashes":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.file.hashes", &ev.Setrlimit.Target.Process.FileEvent.Hashes, value)
	case "setrlimit.target.file.in_upper_layer":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setBoolFieldValue("setrlimit.target.file.in_upper_layer", &ev.Setrlimit.Target.Process.FileEvent.FileFields.InUpperLayer, value)
	case "setrlimit.target.file.inode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint64FieldValue("setrlimit.target.file.inode", &ev.Setrlimit.Target.Process.FileEvent.FileFields.PathKey.Inode, value)
	case "setrlimit.target.file.mode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint16FieldValue("setrlimit.target.file.mode", &ev.Setrlimit.Target.Process.FileEvent.FileFields.Mode, value)
	case "setrlimit.target.file.modification_time":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint64FieldValue("setrlimit.target.file.modification_time", &ev.Setrlimit.Target.Process.FileEvent.FileFields.MTime, value)
	case "setrlimit.target.file.mount_id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("setrlimit.target.file.mount_id", &ev.Setrlimit.Target.Process.FileEvent.FileFields.PathKey.MountID, value)
	case "setrlimit.target.file.name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.file.name", &ev.Setrlimit.Target.Process.FileEvent.BasenameStr, value)
	case "setrlimit.target.file.name.length":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return &eval.ErrFieldReadOnly{Field: "setrlimit.target.file.name.length"}
	case "setrlimit.target.file.package.name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.file.package.name", &ev.Setrlimit.Target.Process.FileEvent.PkgName, value)
	case "setrlimit.target.file.package.source_version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.file.package.source_version", &ev.Setrlimit.Target.Process.FileEvent.PkgSrcVersion, value)
	case "setrlimit.target.file.package.version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.file.package.version", &ev.Setrlimit.Target.Process.FileEvent.PkgVersion, value)
	case "setrlimit.target.file.path":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.file.path", &ev.Setrlimit.Target.Process.FileEvent.PathnameStr, value)
	case "setrlimit.target.file.path.length":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return &eval.ErrFieldReadOnly{Field: "setrlimit.target.file.path.length"}
	case "setrlimit.target.file.rights":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint16FieldValue("setrlimit.target.file.rights", &ev.Setrlimit.Target.Process.FileEvent.FileFields.Mode, value)
	case "setrlimit.target.file.uid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("setrlimit.target.file.uid", &ev.Setrlimit.Target.Process.FileEvent.FileFields.UID, value)
	case "setrlimit.target.file.user":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.file.user", &ev.Setrlimit.Target.Process.FileEvent.FileFields.User, value)
	case "setrlimit.target.fsgid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("setrlimit.target.fsgid", &ev.Setrlimit.Target.Process.Credentials.FSGID, value)
	case "setrlimit.target.fsgroup":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.fsgroup", &ev.Setrlimit.Target.Process.Credentials.FSGroup, value)
	case "setrlimit.target.fsuid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("setrlimit.target.fsuid", &ev.Setrlimit.Target.Process.Credentials.FSUID, value)
	case "setrlimit.target.fsuser":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.fsuser", &ev.Setrlimit.Target.Process.Credentials.FSUser, value)
	case "setrlimit.target.gid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("setrlimit.target.gid", &ev.Setrlimit.Target.Process.Credentials.GID, value)
	case "setrlimit.target.group":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.group", &ev.Setrlimit.Target.Process.Credentials.Group, value)
	case "setrlimit.target.interpreter.file.change_time":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.change_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("setrlimit.target.interpreter.file.change_time", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.CTime, value)
	case "setrlimit.target.interpreter.file.filesystem":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.filesystem", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.interpreter.file.filesystem", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.Filesystem, value)
	case "setrlimit.target.interpreter.file.gid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.gid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("setrlimit.target.interpreter.file.gid", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.GID, value)
	case "setrlimit.target.interpreter.file.group":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.group", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.interpreter.file.group", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.Group, value)
	case "setrlimit.target.interpreter.file.hashes":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.hashes", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringArrayFieldValue("setrlimit.target.interpreter.file.hashes", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.Hashes, value)
	case "setrlimit.target.interpreter.file.in_upper_layer":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.in_upper_layer", value)
		if err != nil || !cont {
			return err
		}
		return ev.setBoolFieldValue("setrlimit.target.interpreter.file.in_upper_layer", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.InUpperLayer, value)
	case "setrlimit.target.interpreter.file.inode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.inode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("setrlimit.target.interpreter.file.inode", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode, value)
	case "setrlimit.target.interpreter.file.mode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.mode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("setrlimit.target.interpreter.file.mode", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "setrlimit.target.interpreter.file.modification_time":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.modification_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("setrlimit.target.interpreter.file.modification_time", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.MTime, value)
	case "setrlimit.target.interpreter.file.mount_id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.mount_id", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("setrlimit.target.interpreter.file.mount_id", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID, value)
	case "setrlimit.target.interpreter.file.name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.interpreter.file.name", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.BasenameStr, value)
	case "setrlimit.target.interpreter.file.name.length":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return &eval.ErrFieldReadOnly{Field: "setrlimit.target.interpreter.file.name.length"}
	case "setrlimit.target.interpreter.file.package.name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.package.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.interpreter.file.package.name", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.PkgName, value)
	case "setrlimit.target.interpreter.file.package.source_version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.package.source_version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.interpreter.file.package.source_version", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.PkgSrcVersion, value)
	case "setrlimit.target.interpreter.file.package.version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.package.version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.interpreter.file.package.version", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.PkgVersion, value)
	case "setrlimit.target.interpreter.file.path":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.path", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.interpreter.file.path", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.PathnameStr, value)
	case "setrlimit.target.interpreter.file.path.length":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return &eval.ErrFieldReadOnly{Field: "setrlimit.target.interpreter.file.path.length"}
	case "setrlimit.target.interpreter.file.rights":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.rights", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("setrlimit.target.interpreter.file.rights", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "setrlimit.target.interpreter.file.uid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.uid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("setrlimit.target.interpreter.file.uid", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.UID, value)
	case "setrlimit.target.interpreter.file.user":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Process.LinuxBinprm, "file.user", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.interpreter.file.user", &ev.Setrlimit.Target.Process.LinuxBinprm.FileEvent.FileFields.User, value)
	case "setrlimit.target.is_exec":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setBoolFieldValue("setrlimit.target.is_exec", &ev.Setrlimit.Target.Process.IsExec, value)
	case "setrlimit.target.is_kworker":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setBoolFieldValue("setrlimit.target.is_kworker", &ev.Setrlimit.Target.Process.PIDContext.IsKworker, value)
	case "setrlimit.target.is_thread":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setBoolFieldValue("setrlimit.target.is_thread", &ev.Setrlimit.Target.Process.IsThread, value)
	case "setrlimit.target.parent.args":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.args", &ev.Setrlimit.Target.Parent.Args, value)
	case "setrlimit.target.parent.args_flags":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.parent.args_flags", &ev.Setrlimit.Target.Parent.Argv, value)
	case "setrlimit.target.parent.args_options":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.parent.args_options", &ev.Setrlimit.Target.Parent.Argv, value)
	case "setrlimit.target.parent.args_truncated":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setBoolFieldValue("setrlimit.target.parent.args_truncated", &ev.Setrlimit.Target.Parent.ArgsTruncated, value)
	case "setrlimit.target.parent.argv":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.parent.argv", &ev.Setrlimit.Target.Parent.Argv, value)
	case "setrlimit.target.parent.argv0":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.argv0", &ev.Setrlimit.Target.Parent.Argv0, value)
	case "setrlimit.target.parent.auid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.auid", &ev.Setrlimit.Target.Parent.Credentials.AUID, value)
	case "setrlimit.target.parent.cap_effective":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint64FieldValue("setrlimit.target.parent.cap_effective", &ev.Setrlimit.Target.Parent.Credentials.CapEffective, value)
	case "setrlimit.target.parent.cap_permitted":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint64FieldValue("setrlimit.target.parent.cap_permitted", &ev.Setrlimit.Target.Parent.Credentials.CapPermitted, value)
	case "setrlimit.target.parent.cgroup.file.inode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint64FieldValue("setrlimit.target.parent.cgroup.file.inode", &ev.Setrlimit.Target.Parent.CGroup.CGroupFile.Inode, value)
	case "setrlimit.target.parent.cgroup.file.mount_id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.cgroup.file.mount_id", &ev.Setrlimit.Target.Parent.CGroup.CGroupFile.MountID, value)
	case "setrlimit.target.parent.cgroup.id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "setrlimit.target.parent.cgroup.id"}
		}
		ev.Setrlimit.Target.Parent.CGroup.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "setrlimit.target.parent.cgroup.manager":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.cgroup.manager", &ev.Setrlimit.Target.Parent.CGroup.CGroupManager, value)
	case "setrlimit.target.parent.cgroup.version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setIntFieldValue("setrlimit.target.parent.cgroup.version", &ev.Setrlimit.Target.Parent.CGroup.CGroupVersion, value)
	case "setrlimit.target.parent.comm":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.comm", &ev.Setrlimit.Target.Parent.Comm, value)
	case "setrlimit.target.parent.container.id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "setrlimit.target.parent.container.id"}
		}
		ev.Setrlimit.Target.Parent.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "setrlimit.target.parent.created_at":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint64FieldValue("setrlimit.target.parent.created_at", &ev.Setrlimit.Target.Parent.CreatedAt, value)
	case "setrlimit.target.parent.egid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.egid", &ev.Setrlimit.Target.Parent.Credentials.EGID, value)
	case "setrlimit.target.parent.egroup":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.egroup", &ev.Setrlimit.Target.Parent.Credentials.EGroup, value)
	case "setrlimit.target.parent.envp":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.parent.envp", &ev.Setrlimit.Target.Parent.Envp, value)
	case "setrlimit.target.parent.envs":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.parent.envs", &ev.Setrlimit.Target.Parent.Envs, value)
	case "setrlimit.target.parent.envs_truncated":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setBoolFieldValue("setrlimit.target.parent.envs_truncated", &ev.Setrlimit.Target.Parent.EnvsTruncated, value)
	case "setrlimit.target.parent.euid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.euid", &ev.Setrlimit.Target.Parent.Credentials.EUID, value)
	case "setrlimit.target.parent.euser":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.euser", &ev.Setrlimit.Target.Parent.Credentials.EUser, value)
	case "setrlimit.target.parent.file.change_time":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint64FieldValue("setrlimit.target.parent.file.change_time", &ev.Setrlimit.Target.Parent.FileEvent.FileFields.CTime, value)
	case "setrlimit.target.parent.file.filesystem":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.file.filesystem", &ev.Setrlimit.Target.Parent.FileEvent.Filesystem, value)
	case "setrlimit.target.parent.file.gid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.file.gid", &ev.Setrlimit.Target.Parent.FileEvent.FileFields.GID, value)
	case "setrlimit.target.parent.file.group":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.file.group", &ev.Setrlimit.Target.Parent.FileEvent.FileFields.Group, value)
	case "setrlimit.target.parent.file.hashes":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.parent.file.hashes", &ev.Setrlimit.Target.Parent.FileEvent.Hashes, value)
	case "setrlimit.target.parent.file.in_upper_layer":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setBoolFieldValue("setrlimit.target.parent.file.in_upper_layer", &ev.Setrlimit.Target.Parent.FileEvent.FileFields.InUpperLayer, value)
	case "setrlimit.target.parent.file.inode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint64FieldValue("setrlimit.target.parent.file.inode", &ev.Setrlimit.Target.Parent.FileEvent.FileFields.PathKey.Inode, value)
	case "setrlimit.target.parent.file.mode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint16FieldValue("setrlimit.target.parent.file.mode", &ev.Setrlimit.Target.Parent.FileEvent.FileFields.Mode, value)
	case "setrlimit.target.parent.file.modification_time":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint64FieldValue("setrlimit.target.parent.file.modification_time", &ev.Setrlimit.Target.Parent.FileEvent.FileFields.MTime, value)
	case "setrlimit.target.parent.file.mount_id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.file.mount_id", &ev.Setrlimit.Target.Parent.FileEvent.FileFields.PathKey.MountID, value)
	case "setrlimit.target.parent.file.name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.file.name", &ev.Setrlimit.Target.Parent.FileEvent.BasenameStr, value)
	case "setrlimit.target.parent.file.name.length":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "setrlimit.target.parent.file.name.length"}
	case "setrlimit.target.parent.file.package.name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.file.package.name", &ev.Setrlimit.Target.Parent.FileEvent.PkgName, value)
	case "setrlimit.target.parent.file.package.source_version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.file.package.source_version", &ev.Setrlimit.Target.Parent.FileEvent.PkgSrcVersion, value)
	case "setrlimit.target.parent.file.package.version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.file.package.version", &ev.Setrlimit.Target.Parent.FileEvent.PkgVersion, value)
	case "setrlimit.target.parent.file.path":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.file.path", &ev.Setrlimit.Target.Parent.FileEvent.PathnameStr, value)
	case "setrlimit.target.parent.file.path.length":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "setrlimit.target.parent.file.path.length"}
	case "setrlimit.target.parent.file.rights":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint16FieldValue("setrlimit.target.parent.file.rights", &ev.Setrlimit.Target.Parent.FileEvent.FileFields.Mode, value)
	case "setrlimit.target.parent.file.uid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.file.uid", &ev.Setrlimit.Target.Parent.FileEvent.FileFields.UID, value)
	case "setrlimit.target.parent.file.user":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.file.user", &ev.Setrlimit.Target.Parent.FileEvent.FileFields.User, value)
	case "setrlimit.target.parent.fsgid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.fsgid", &ev.Setrlimit.Target.Parent.Credentials.FSGID, value)
	case "setrlimit.target.parent.fsgroup":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.fsgroup", &ev.Setrlimit.Target.Parent.Credentials.FSGroup, value)
	case "setrlimit.target.parent.fsuid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.fsuid", &ev.Setrlimit.Target.Parent.Credentials.FSUID, value)
	case "setrlimit.target.parent.fsuser":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.fsuser", &ev.Setrlimit.Target.Parent.Credentials.FSUser, value)
	case "setrlimit.target.parent.gid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.gid", &ev.Setrlimit.Target.Parent.Credentials.GID, value)
	case "setrlimit.target.parent.group":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.group", &ev.Setrlimit.Target.Parent.Credentials.Group, value)
	case "setrlimit.target.parent.interpreter.file.change_time":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.change_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("setrlimit.target.parent.interpreter.file.change_time", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.CTime, value)
	case "setrlimit.target.parent.interpreter.file.filesystem":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.filesystem", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.parent.interpreter.file.filesystem", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.Filesystem, value)
	case "setrlimit.target.parent.interpreter.file.gid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.gid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.interpreter.file.gid", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.GID, value)
	case "setrlimit.target.parent.interpreter.file.group":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.group", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.parent.interpreter.file.group", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.Group, value)
	case "setrlimit.target.parent.interpreter.file.hashes":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.hashes", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringArrayFieldValue("setrlimit.target.parent.interpreter.file.hashes", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.Hashes, value)
	case "setrlimit.target.parent.interpreter.file.in_upper_layer":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.in_upper_layer", value)
		if err != nil || !cont {
			return err
		}
		return ev.setBoolFieldValue("setrlimit.target.parent.interpreter.file.in_upper_layer", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.InUpperLayer, value)
	case "setrlimit.target.parent.interpreter.file.inode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.inode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("setrlimit.target.parent.interpreter.file.inode", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.Inode, value)
	case "setrlimit.target.parent.interpreter.file.mode":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.mode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("setrlimit.target.parent.interpreter.file.mode", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "setrlimit.target.parent.interpreter.file.modification_time":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.modification_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("setrlimit.target.parent.interpreter.file.modification_time", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.MTime, value)
	case "setrlimit.target.parent.interpreter.file.mount_id":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.mount_id", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.interpreter.file.mount_id", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.MountID, value)
	case "setrlimit.target.parent.interpreter.file.name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.parent.interpreter.file.name", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.BasenameStr, value)
	case "setrlimit.target.parent.interpreter.file.name.length":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "setrlimit.target.parent.interpreter.file.name.length"}
	case "setrlimit.target.parent.interpreter.file.package.name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.package.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.parent.interpreter.file.package.name", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.PkgName, value)
	case "setrlimit.target.parent.interpreter.file.package.source_version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.package.source_version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.parent.interpreter.file.package.source_version", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.PkgSrcVersion, value)
	case "setrlimit.target.parent.interpreter.file.package.version":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.package.version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.parent.interpreter.file.package.version", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.PkgVersion, value)
	case "setrlimit.target.parent.interpreter.file.path":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.path", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.parent.interpreter.file.path", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.PathnameStr, value)
	case "setrlimit.target.parent.interpreter.file.path.length":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "setrlimit.target.parent.interpreter.file.path.length"}
	case "setrlimit.target.parent.interpreter.file.rights":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.rights", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("setrlimit.target.parent.interpreter.file.rights", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "setrlimit.target.parent.interpreter.file.uid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.uid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.interpreter.file.uid", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.UID, value)
	case "setrlimit.target.parent.interpreter.file.user":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Setrlimit.Target.Parent.LinuxBinprm, "file.user", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("setrlimit.target.parent.interpreter.file.user", &ev.Setrlimit.Target.Parent.LinuxBinprm.FileEvent.FileFields.User, value)
	case "setrlimit.target.parent.is_exec":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setBoolFieldValue("setrlimit.target.parent.is_exec", &ev.Setrlimit.Target.Parent.IsExec, value)
	case "setrlimit.target.parent.is_kworker":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setBoolFieldValue("setrlimit.target.parent.is_kworker", &ev.Setrlimit.Target.Parent.PIDContext.IsKworker, value)
	case "setrlimit.target.parent.is_thread":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setBoolFieldValue("setrlimit.target.parent.is_thread", &ev.Setrlimit.Target.Parent.IsThread, value)
	case "setrlimit.target.parent.pid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.pid", &ev.Setrlimit.Target.Parent.PIDContext.Pid, value)
	case "setrlimit.target.parent.ppid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.ppid", &ev.Setrlimit.Target.Parent.PPid, value)
	case "setrlimit.target.parent.tid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.tid", &ev.Setrlimit.Target.Parent.PIDContext.Tid, value)
	case "setrlimit.target.parent.tty_name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.tty_name", &ev.Setrlimit.Target.Parent.TTYName, value)
	case "setrlimit.target.parent.uid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("setrlimit.target.parent.uid", &ev.Setrlimit.Target.Parent.Credentials.UID, value)
	case "setrlimit.target.parent.user":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.user", &ev.Setrlimit.Target.Parent.Credentials.User, value)
	case "setrlimit.target.parent.user_session.k8s_groups":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.parent.user_session.k8s_groups", &ev.Setrlimit.Target.Parent.UserSession.K8SGroups, value)
	case "setrlimit.target.parent.user_session.k8s_uid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.user_session.k8s_uid", &ev.Setrlimit.Target.Parent.UserSession.K8SUID, value)
	case "setrlimit.target.parent.user_session.k8s_username":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		if ev.Setrlimit.Target.Parent == nil {
			ev.Setrlimit.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("setrlimit.target.parent.user_session.k8s_username", &ev.Setrlimit.Target.Parent.UserSession.K8SUsername, value)
	case "setrlimit.target.pid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("setrlimit.target.pid", &ev.Setrlimit.Target.Process.PIDContext.Pid, value)
	case "setrlimit.target.ppid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("setrlimit.target.ppid", &ev.Setrlimit.Target.Process.PPid, value)
	case "setrlimit.target.tid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("setrlimit.target.tid", &ev.Setrlimit.Target.Process.PIDContext.Tid, value)
	case "setrlimit.target.tty_name":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.tty_name", &ev.Setrlimit.Target.Process.TTYName, value)
	case "setrlimit.target.uid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("setrlimit.target.uid", &ev.Setrlimit.Target.Process.Credentials.UID, value)
	case "setrlimit.target.user":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.user", &ev.Setrlimit.Target.Process.Credentials.User, value)
	case "setrlimit.target.user_session.k8s_groups":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("setrlimit.target.user_session.k8s_groups", &ev.Setrlimit.Target.Process.UserSession.K8SGroups, value)
	case "setrlimit.target.user_session.k8s_uid":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.user_session.k8s_uid", &ev.Setrlimit.Target.Process.UserSession.K8SUID, value)
	case "setrlimit.target.user_session.k8s_username":
		if ev.Setrlimit.Target == nil {
			ev.Setrlimit.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("setrlimit.target.user_session.k8s_username", &ev.Setrlimit.Target.Process.UserSession.K8SUsername, value)
	case "setsockopt.filter_hash":
		return ev.setStringFieldValue("setsockopt.filter_hash", &ev.SetSockOpt.FilterHash, value)
	case "setsockopt.filter_instructions":
		return ev.setStringFieldValue("setsockopt.filter_instructions", &ev.SetSockOpt.FilterInstructions, value)
	case "setsockopt.filter_len":
		return ev.setUint16FieldValue("setsockopt.filter_len", &ev.SetSockOpt.FilterLen, value)
	case "setsockopt.is_filter_truncated":
		return ev.setBoolFieldValue("setsockopt.is_filter_truncated", &ev.SetSockOpt.IsFilterTruncated, value)
	case "setsockopt.level":
		return ev.setUint32FieldValue("setsockopt.level", &ev.SetSockOpt.Level, value)
	case "setsockopt.optname":
		return ev.setUint32FieldValue("setsockopt.optname", &ev.SetSockOpt.OptName, value)
	case "setsockopt.retval":
		return ev.setInt64FieldValue("setsockopt.retval", &ev.SetSockOpt.SyscallEvent.Retval, value)
	case "setsockopt.socket_family":
		return ev.setUint16FieldValue("setsockopt.socket_family", &ev.SetSockOpt.SocketFamily, value)
	case "setsockopt.socket_protocol":
		return ev.setUint16FieldValue("setsockopt.socket_protocol", &ev.SetSockOpt.SocketProtocol, value)
	case "setsockopt.socket_type":
		return ev.setUint16FieldValue("setsockopt.socket_type", &ev.SetSockOpt.SocketType, value)
	case "setuid.euid":
		return ev.setUint32FieldValue("setuid.euid", &ev.SetUID.EUID, value)
	case "setuid.euser":
		return ev.setStringFieldValue("setuid.euser", &ev.SetUID.EUser, value)
	case "setuid.fsuid":
		return ev.setUint32FieldValue("setuid.fsuid", &ev.SetUID.FSUID, value)
	case "setuid.fsuser":
		return ev.setStringFieldValue("setuid.fsuser", &ev.SetUID.FSUser, value)
	case "setuid.uid":
		return ev.setUint32FieldValue("setuid.uid", &ev.SetUID.UID, value)
	case "setuid.user":
		return ev.setStringFieldValue("setuid.user", &ev.SetUID.User, value)
	case "setxattr.file.change_time":
		return ev.setUint64FieldValue("setxattr.file.change_time", &ev.SetXAttr.File.FileFields.CTime, value)
	case "setxattr.file.destination.name":
		return ev.setStringFieldValue("setxattr.file.destination.name", &ev.SetXAttr.Name, value)
	case "setxattr.file.destination.namespace":
		return ev.setStringFieldValue("setxattr.file.destination.namespace", &ev.SetXAttr.Namespace, value)
	case "setxattr.file.filesystem":
		return ev.setStringFieldValue("setxattr.file.filesystem", &ev.SetXAttr.File.Filesystem, value)
	case "setxattr.file.gid":
		return ev.setUint32FieldValue("setxattr.file.gid", &ev.SetXAttr.File.FileFields.GID, value)
	case "setxattr.file.group":
		return ev.setStringFieldValue("setxattr.file.group", &ev.SetXAttr.File.FileFields.Group, value)
	case "setxattr.file.hashes":
		return ev.setStringArrayFieldValue("setxattr.file.hashes", &ev.SetXAttr.File.Hashes, value)
	case "setxattr.file.in_upper_layer":
		return ev.setBoolFieldValue("setxattr.file.in_upper_layer", &ev.SetXAttr.File.FileFields.InUpperLayer, value)
	case "setxattr.file.inode":
		return ev.setUint64FieldValue("setxattr.file.inode", &ev.SetXAttr.File.FileFields.PathKey.Inode, value)
	case "setxattr.file.mode":
		return ev.setUint16FieldValue("setxattr.file.mode", &ev.SetXAttr.File.FileFields.Mode, value)
	case "setxattr.file.modification_time":
		return ev.setUint64FieldValue("setxattr.file.modification_time", &ev.SetXAttr.File.FileFields.MTime, value)
	case "setxattr.file.mount_id":
		return ev.setUint32FieldValue("setxattr.file.mount_id", &ev.SetXAttr.File.FileFields.PathKey.MountID, value)
	case "setxattr.file.name":
		return ev.setStringFieldValue("setxattr.file.name", &ev.SetXAttr.File.BasenameStr, value)
	case "setxattr.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "setxattr.file.name.length"}
	case "setxattr.file.package.name":
		return ev.setStringFieldValue("setxattr.file.package.name", &ev.SetXAttr.File.PkgName, value)
	case "setxattr.file.package.source_version":
		return ev.setStringFieldValue("setxattr.file.package.source_version", &ev.SetXAttr.File.PkgSrcVersion, value)
	case "setxattr.file.package.version":
		return ev.setStringFieldValue("setxattr.file.package.version", &ev.SetXAttr.File.PkgVersion, value)
	case "setxattr.file.path":
		return ev.setStringFieldValue("setxattr.file.path", &ev.SetXAttr.File.PathnameStr, value)
	case "setxattr.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "setxattr.file.path.length"}
	case "setxattr.file.rights":
		return ev.setUint16FieldValue("setxattr.file.rights", &ev.SetXAttr.File.FileFields.Mode, value)
	case "setxattr.file.uid":
		return ev.setUint32FieldValue("setxattr.file.uid", &ev.SetXAttr.File.FileFields.UID, value)
	case "setxattr.file.user":
		return ev.setStringFieldValue("setxattr.file.user", &ev.SetXAttr.File.FileFields.User, value)
	case "setxattr.retval":
		return ev.setInt64FieldValue("setxattr.retval", &ev.SetXAttr.SyscallEvent.Retval, value)
	case "signal.pid":
		return ev.setUint32FieldValue("signal.pid", &ev.Signal.PID, value)
	case "signal.retval":
		return ev.setInt64FieldValue("signal.retval", &ev.Signal.SyscallEvent.Retval, value)
	case "signal.target.ancestors.args":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.args", &ev.Signal.Target.Ancestor.ProcessContext.Process.Args, value)
	case "signal.target.ancestors.args_flags":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("signal.target.ancestors.args_flags", &ev.Signal.Target.Ancestor.ProcessContext.Process.Argv, value)
	case "signal.target.ancestors.args_options":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("signal.target.ancestors.args_options", &ev.Signal.Target.Ancestor.ProcessContext.Process.Argv, value)
	case "signal.target.ancestors.args_truncated":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("signal.target.ancestors.args_truncated", &ev.Signal.Target.Ancestor.ProcessContext.Process.ArgsTruncated, value)
	case "signal.target.ancestors.argv":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("signal.target.ancestors.argv", &ev.Signal.Target.Ancestor.ProcessContext.Process.Argv, value)
	case "signal.target.ancestors.argv0":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.argv0", &ev.Signal.Target.Ancestor.ProcessContext.Process.Argv0, value)
	case "signal.target.ancestors.auid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("signal.target.ancestors.auid", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.AUID, value)
	case "signal.target.ancestors.cap_effective":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("signal.target.ancestors.cap_effective", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.CapEffective, value)
	case "signal.target.ancestors.cap_permitted":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("signal.target.ancestors.cap_permitted", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.CapPermitted, value)
	case "signal.target.ancestors.cgroup.file.inode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("signal.target.ancestors.cgroup.file.inode", &ev.Signal.Target.Ancestor.ProcessContext.Process.CGroup.CGroupFile.Inode, value)
	case "signal.target.ancestors.cgroup.file.mount_id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("signal.target.ancestors.cgroup.file.mount_id", &ev.Signal.Target.Ancestor.ProcessContext.Process.CGroup.CGroupFile.MountID, value)
	case "signal.target.ancestors.cgroup.id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "signal.target.ancestors.cgroup.id"}
		}
		ev.Signal.Target.Ancestor.ProcessContext.Process.CGroup.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "signal.target.ancestors.cgroup.manager":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.cgroup.manager", &ev.Signal.Target.Ancestor.ProcessContext.Process.CGroup.CGroupManager, value)
	case "signal.target.ancestors.cgroup.version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setIntFieldValue("signal.target.ancestors.cgroup.version", &ev.Signal.Target.Ancestor.ProcessContext.Process.CGroup.CGroupVersion, value)
	case "signal.target.ancestors.comm":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.comm", &ev.Signal.Target.Ancestor.ProcessContext.Process.Comm, value)
	case "signal.target.ancestors.container.id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "signal.target.ancestors.container.id"}
		}
		ev.Signal.Target.Ancestor.ProcessContext.Process.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "signal.target.ancestors.created_at":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("signal.target.ancestors.created_at", &ev.Signal.Target.Ancestor.ProcessContext.Process.CreatedAt, value)
	case "signal.target.ancestors.egid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("signal.target.ancestors.egid", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.EGID, value)
	case "signal.target.ancestors.egroup":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.egroup", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.EGroup, value)
	case "signal.target.ancestors.envp":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("signal.target.ancestors.envp", &ev.Signal.Target.Ancestor.ProcessContext.Process.Envp, value)
	case "signal.target.ancestors.envs":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("signal.target.ancestors.envs", &ev.Signal.Target.Ancestor.ProcessContext.Process.Envs, value)
	case "signal.target.ancestors.envs_truncated":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("signal.target.ancestors.envs_truncated", &ev.Signal.Target.Ancestor.ProcessContext.Process.EnvsTruncated, value)
	case "signal.target.ancestors.euid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("signal.target.ancestors.euid", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.EUID, value)
	case "signal.target.ancestors.euser":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.euser", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.EUser, value)
	case "signal.target.ancestors.file.change_time":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("signal.target.ancestors.file.change_time", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.CTime, value)
	case "signal.target.ancestors.file.filesystem":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.file.filesystem", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.Filesystem, value)
	case "signal.target.ancestors.file.gid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("signal.target.ancestors.file.gid", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.GID, value)
	case "signal.target.ancestors.file.group":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.file.group", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.Group, value)
	case "signal.target.ancestors.file.hashes":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("signal.target.ancestors.file.hashes", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.Hashes, value)
	case "signal.target.ancestors.file.in_upper_layer":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("signal.target.ancestors.file.in_upper_layer", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.InUpperLayer, value)
	case "signal.target.ancestors.file.inode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("signal.target.ancestors.file.inode", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.PathKey.Inode, value)
	case "signal.target.ancestors.file.mode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint16FieldValue("signal.target.ancestors.file.mode", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.Mode, value)
	case "signal.target.ancestors.file.modification_time":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint64FieldValue("signal.target.ancestors.file.modification_time", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.MTime, value)
	case "signal.target.ancestors.file.mount_id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("signal.target.ancestors.file.mount_id", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.PathKey.MountID, value)
	case "signal.target.ancestors.file.name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.file.name", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.BasenameStr, value)
	case "signal.target.ancestors.file.name.length":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "signal.target.ancestors.file.name.length"}
	case "signal.target.ancestors.file.package.name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.file.package.name", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.PkgName, value)
	case "signal.target.ancestors.file.package.source_version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.file.package.source_version", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.PkgSrcVersion, value)
	case "signal.target.ancestors.file.package.version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.file.package.version", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.PkgVersion, value)
	case "signal.target.ancestors.file.path":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.file.path", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.PathnameStr, value)
	case "signal.target.ancestors.file.path.length":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "signal.target.ancestors.file.path.length"}
	case "signal.target.ancestors.file.rights":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint16FieldValue("signal.target.ancestors.file.rights", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.Mode, value)
	case "signal.target.ancestors.file.uid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("signal.target.ancestors.file.uid", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.UID, value)
	case "signal.target.ancestors.file.user":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.file.user", &ev.Signal.Target.Ancestor.ProcessContext.Process.FileEvent.FileFields.User, value)
	case "signal.target.ancestors.fsgid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("signal.target.ancestors.fsgid", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.FSGID, value)
	case "signal.target.ancestors.fsgroup":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.fsgroup", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.FSGroup, value)
	case "signal.target.ancestors.fsuid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("signal.target.ancestors.fsuid", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.FSUID, value)
	case "signal.target.ancestors.fsuser":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.fsuser", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.FSUser, value)
	case "signal.target.ancestors.gid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("signal.target.ancestors.gid", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.GID, value)
	case "signal.target.ancestors.group":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.group", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.Group, value)
	case "signal.target.ancestors.interpreter.file.change_time":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.change_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("signal.target.ancestors.interpreter.file.change_time", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.CTime, value)
	case "signal.target.ancestors.interpreter.file.filesystem":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.filesystem", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.ancestors.interpreter.file.filesystem", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.Filesystem, value)
	case "signal.target.ancestors.interpreter.file.gid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.gid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("signal.target.ancestors.interpreter.file.gid", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.GID, value)
	case "signal.target.ancestors.interpreter.file.group":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.group", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.ancestors.interpreter.file.group", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Group, value)
	case "signal.target.ancestors.interpreter.file.hashes":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.hashes", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringArrayFieldValue("signal.target.ancestors.interpreter.file.hashes", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.Hashes, value)
	case "signal.target.ancestors.interpreter.file.in_upper_layer":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.in_upper_layer", value)
		if err != nil || !cont {
			return err
		}
		return ev.setBoolFieldValue("signal.target.ancestors.interpreter.file.in_upper_layer", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.InUpperLayer, value)
	case "signal.target.ancestors.interpreter.file.inode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.inode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("signal.target.ancestors.interpreter.file.inode", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode, value)
	case "signal.target.ancestors.interpreter.file.mode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.mode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("signal.target.ancestors.interpreter.file.mode", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "signal.target.ancestors.interpreter.file.modification_time":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.modification_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("signal.target.ancestors.interpreter.file.modification_time", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.MTime, value)
	case "signal.target.ancestors.interpreter.file.mount_id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.mount_id", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("signal.target.ancestors.interpreter.file.mount_id", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID, value)
	case "signal.target.ancestors.interpreter.file.name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.ancestors.interpreter.file.name", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.BasenameStr, value)
	case "signal.target.ancestors.interpreter.file.name.length":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "signal.target.ancestors.interpreter.file.name.length"}
	case "signal.target.ancestors.interpreter.file.package.name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.package.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.ancestors.interpreter.file.package.name", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PkgName, value)
	case "signal.target.ancestors.interpreter.file.package.source_version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.package.source_version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.ancestors.interpreter.file.package.source_version", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PkgSrcVersion, value)
	case "signal.target.ancestors.interpreter.file.package.version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.package.version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.ancestors.interpreter.file.package.version", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PkgVersion, value)
	case "signal.target.ancestors.interpreter.file.path":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.path", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.ancestors.interpreter.file.path", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.PathnameStr, value)
	case "signal.target.ancestors.interpreter.file.path.length":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "signal.target.ancestors.interpreter.file.path.length"}
	case "signal.target.ancestors.interpreter.file.rights":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.rights", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("signal.target.ancestors.interpreter.file.rights", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "signal.target.ancestors.interpreter.file.uid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.uid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("signal.target.ancestors.interpreter.file.uid", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.UID, value)
	case "signal.target.ancestors.interpreter.file.user":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm, "file.user", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.ancestors.interpreter.file.user", &ev.Signal.Target.Ancestor.ProcessContext.Process.LinuxBinprm.FileEvent.FileFields.User, value)
	case "signal.target.ancestors.is_exec":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("signal.target.ancestors.is_exec", &ev.Signal.Target.Ancestor.ProcessContext.Process.IsExec, value)
	case "signal.target.ancestors.is_kworker":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("signal.target.ancestors.is_kworker", &ev.Signal.Target.Ancestor.ProcessContext.Process.PIDContext.IsKworker, value)
	case "signal.target.ancestors.is_thread":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setBoolFieldValue("signal.target.ancestors.is_thread", &ev.Signal.Target.Ancestor.ProcessContext.Process.IsThread, value)
	case "signal.target.ancestors.length":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return &eval.ErrFieldReadOnly{Field: "signal.target.ancestors.length"}
	case "signal.target.ancestors.pid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("signal.target.ancestors.pid", &ev.Signal.Target.Ancestor.ProcessContext.Process.PIDContext.Pid, value)
	case "signal.target.ancestors.ppid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("signal.target.ancestors.ppid", &ev.Signal.Target.Ancestor.ProcessContext.Process.PPid, value)
	case "signal.target.ancestors.tid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("signal.target.ancestors.tid", &ev.Signal.Target.Ancestor.ProcessContext.Process.PIDContext.Tid, value)
	case "signal.target.ancestors.tty_name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.tty_name", &ev.Signal.Target.Ancestor.ProcessContext.Process.TTYName, value)
	case "signal.target.ancestors.uid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setUint32FieldValue("signal.target.ancestors.uid", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.UID, value)
	case "signal.target.ancestors.user":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.user", &ev.Signal.Target.Ancestor.ProcessContext.Process.Credentials.User, value)
	case "signal.target.ancestors.user_session.k8s_groups":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringArrayFieldValue("signal.target.ancestors.user_session.k8s_groups", &ev.Signal.Target.Ancestor.ProcessContext.Process.UserSession.K8SGroups, value)
	case "signal.target.ancestors.user_session.k8s_uid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.user_session.k8s_uid", &ev.Signal.Target.Ancestor.ProcessContext.Process.UserSession.K8SUID, value)
	case "signal.target.ancestors.user_session.k8s_username":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Ancestor == nil {
			ev.Signal.Target.Ancestor = &ProcessCacheEntry{}
		}
		return ev.setStringFieldValue("signal.target.ancestors.user_session.k8s_username", &ev.Signal.Target.Ancestor.ProcessContext.Process.UserSession.K8SUsername, value)
	case "signal.target.args":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.args", &ev.Signal.Target.Process.Args, value)
	case "signal.target.args_flags":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("signal.target.args_flags", &ev.Signal.Target.Process.Argv, value)
	case "signal.target.args_options":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("signal.target.args_options", &ev.Signal.Target.Process.Argv, value)
	case "signal.target.args_truncated":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setBoolFieldValue("signal.target.args_truncated", &ev.Signal.Target.Process.ArgsTruncated, value)
	case "signal.target.argv":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("signal.target.argv", &ev.Signal.Target.Process.Argv, value)
	case "signal.target.argv0":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.argv0", &ev.Signal.Target.Process.Argv0, value)
	case "signal.target.auid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("signal.target.auid", &ev.Signal.Target.Process.Credentials.AUID, value)
	case "signal.target.cap_effective":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint64FieldValue("signal.target.cap_effective", &ev.Signal.Target.Process.Credentials.CapEffective, value)
	case "signal.target.cap_permitted":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint64FieldValue("signal.target.cap_permitted", &ev.Signal.Target.Process.Credentials.CapPermitted, value)
	case "signal.target.cgroup.file.inode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint64FieldValue("signal.target.cgroup.file.inode", &ev.Signal.Target.Process.CGroup.CGroupFile.Inode, value)
	case "signal.target.cgroup.file.mount_id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("signal.target.cgroup.file.mount_id", &ev.Signal.Target.Process.CGroup.CGroupFile.MountID, value)
	case "signal.target.cgroup.id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "signal.target.cgroup.id"}
		}
		ev.Signal.Target.Process.CGroup.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "signal.target.cgroup.manager":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.cgroup.manager", &ev.Signal.Target.Process.CGroup.CGroupManager, value)
	case "signal.target.cgroup.version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setIntFieldValue("signal.target.cgroup.version", &ev.Signal.Target.Process.CGroup.CGroupVersion, value)
	case "signal.target.comm":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.comm", &ev.Signal.Target.Process.Comm, value)
	case "signal.target.container.id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "signal.target.container.id"}
		}
		ev.Signal.Target.Process.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "signal.target.created_at":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint64FieldValue("signal.target.created_at", &ev.Signal.Target.Process.CreatedAt, value)
	case "signal.target.egid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("signal.target.egid", &ev.Signal.Target.Process.Credentials.EGID, value)
	case "signal.target.egroup":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.egroup", &ev.Signal.Target.Process.Credentials.EGroup, value)
	case "signal.target.envp":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("signal.target.envp", &ev.Signal.Target.Process.Envp, value)
	case "signal.target.envs":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("signal.target.envs", &ev.Signal.Target.Process.Envs, value)
	case "signal.target.envs_truncated":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setBoolFieldValue("signal.target.envs_truncated", &ev.Signal.Target.Process.EnvsTruncated, value)
	case "signal.target.euid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("signal.target.euid", &ev.Signal.Target.Process.Credentials.EUID, value)
	case "signal.target.euser":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.euser", &ev.Signal.Target.Process.Credentials.EUser, value)
	case "signal.target.file.change_time":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint64FieldValue("signal.target.file.change_time", &ev.Signal.Target.Process.FileEvent.FileFields.CTime, value)
	case "signal.target.file.filesystem":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.file.filesystem", &ev.Signal.Target.Process.FileEvent.Filesystem, value)
	case "signal.target.file.gid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("signal.target.file.gid", &ev.Signal.Target.Process.FileEvent.FileFields.GID, value)
	case "signal.target.file.group":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.file.group", &ev.Signal.Target.Process.FileEvent.FileFields.Group, value)
	case "signal.target.file.hashes":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("signal.target.file.hashes", &ev.Signal.Target.Process.FileEvent.Hashes, value)
	case "signal.target.file.in_upper_layer":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setBoolFieldValue("signal.target.file.in_upper_layer", &ev.Signal.Target.Process.FileEvent.FileFields.InUpperLayer, value)
	case "signal.target.file.inode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint64FieldValue("signal.target.file.inode", &ev.Signal.Target.Process.FileEvent.FileFields.PathKey.Inode, value)
	case "signal.target.file.mode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint16FieldValue("signal.target.file.mode", &ev.Signal.Target.Process.FileEvent.FileFields.Mode, value)
	case "signal.target.file.modification_time":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint64FieldValue("signal.target.file.modification_time", &ev.Signal.Target.Process.FileEvent.FileFields.MTime, value)
	case "signal.target.file.mount_id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("signal.target.file.mount_id", &ev.Signal.Target.Process.FileEvent.FileFields.PathKey.MountID, value)
	case "signal.target.file.name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.file.name", &ev.Signal.Target.Process.FileEvent.BasenameStr, value)
	case "signal.target.file.name.length":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return &eval.ErrFieldReadOnly{Field: "signal.target.file.name.length"}
	case "signal.target.file.package.name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.file.package.name", &ev.Signal.Target.Process.FileEvent.PkgName, value)
	case "signal.target.file.package.source_version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.file.package.source_version", &ev.Signal.Target.Process.FileEvent.PkgSrcVersion, value)
	case "signal.target.file.package.version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.file.package.version", &ev.Signal.Target.Process.FileEvent.PkgVersion, value)
	case "signal.target.file.path":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.file.path", &ev.Signal.Target.Process.FileEvent.PathnameStr, value)
	case "signal.target.file.path.length":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return &eval.ErrFieldReadOnly{Field: "signal.target.file.path.length"}
	case "signal.target.file.rights":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint16FieldValue("signal.target.file.rights", &ev.Signal.Target.Process.FileEvent.FileFields.Mode, value)
	case "signal.target.file.uid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("signal.target.file.uid", &ev.Signal.Target.Process.FileEvent.FileFields.UID, value)
	case "signal.target.file.user":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.file.user", &ev.Signal.Target.Process.FileEvent.FileFields.User, value)
	case "signal.target.fsgid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("signal.target.fsgid", &ev.Signal.Target.Process.Credentials.FSGID, value)
	case "signal.target.fsgroup":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.fsgroup", &ev.Signal.Target.Process.Credentials.FSGroup, value)
	case "signal.target.fsuid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("signal.target.fsuid", &ev.Signal.Target.Process.Credentials.FSUID, value)
	case "signal.target.fsuser":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.fsuser", &ev.Signal.Target.Process.Credentials.FSUser, value)
	case "signal.target.gid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("signal.target.gid", &ev.Signal.Target.Process.Credentials.GID, value)
	case "signal.target.group":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.group", &ev.Signal.Target.Process.Credentials.Group, value)
	case "signal.target.interpreter.file.change_time":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.change_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("signal.target.interpreter.file.change_time", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.CTime, value)
	case "signal.target.interpreter.file.filesystem":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.filesystem", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.interpreter.file.filesystem", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.Filesystem, value)
	case "signal.target.interpreter.file.gid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.gid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("signal.target.interpreter.file.gid", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.GID, value)
	case "signal.target.interpreter.file.group":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.group", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.interpreter.file.group", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.Group, value)
	case "signal.target.interpreter.file.hashes":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.hashes", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringArrayFieldValue("signal.target.interpreter.file.hashes", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.Hashes, value)
	case "signal.target.interpreter.file.in_upper_layer":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.in_upper_layer", value)
		if err != nil || !cont {
			return err
		}
		return ev.setBoolFieldValue("signal.target.interpreter.file.in_upper_layer", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.InUpperLayer, value)
	case "signal.target.interpreter.file.inode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.inode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("signal.target.interpreter.file.inode", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.PathKey.Inode, value)
	case "signal.target.interpreter.file.mode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.mode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("signal.target.interpreter.file.mode", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "signal.target.interpreter.file.modification_time":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.modification_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("signal.target.interpreter.file.modification_time", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.MTime, value)
	case "signal.target.interpreter.file.mount_id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.mount_id", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("signal.target.interpreter.file.mount_id", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.PathKey.MountID, value)
	case "signal.target.interpreter.file.name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.interpreter.file.name", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.BasenameStr, value)
	case "signal.target.interpreter.file.name.length":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return &eval.ErrFieldReadOnly{Field: "signal.target.interpreter.file.name.length"}
	case "signal.target.interpreter.file.package.name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.package.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.interpreter.file.package.name", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.PkgName, value)
	case "signal.target.interpreter.file.package.source_version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.package.source_version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.interpreter.file.package.source_version", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.PkgSrcVersion, value)
	case "signal.target.interpreter.file.package.version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.package.version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.interpreter.file.package.version", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.PkgVersion, value)
	case "signal.target.interpreter.file.path":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.path", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.interpreter.file.path", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.PathnameStr, value)
	case "signal.target.interpreter.file.path.length":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return &eval.ErrFieldReadOnly{Field: "signal.target.interpreter.file.path.length"}
	case "signal.target.interpreter.file.rights":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.rights", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("signal.target.interpreter.file.rights", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "signal.target.interpreter.file.uid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.uid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("signal.target.interpreter.file.uid", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.UID, value)
	case "signal.target.interpreter.file.user":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Process.LinuxBinprm, "file.user", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.interpreter.file.user", &ev.Signal.Target.Process.LinuxBinprm.FileEvent.FileFields.User, value)
	case "signal.target.is_exec":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setBoolFieldValue("signal.target.is_exec", &ev.Signal.Target.Process.IsExec, value)
	case "signal.target.is_kworker":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setBoolFieldValue("signal.target.is_kworker", &ev.Signal.Target.Process.PIDContext.IsKworker, value)
	case "signal.target.is_thread":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setBoolFieldValue("signal.target.is_thread", &ev.Signal.Target.Process.IsThread, value)
	case "signal.target.parent.args":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.args", &ev.Signal.Target.Parent.Args, value)
	case "signal.target.parent.args_flags":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("signal.target.parent.args_flags", &ev.Signal.Target.Parent.Argv, value)
	case "signal.target.parent.args_options":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("signal.target.parent.args_options", &ev.Signal.Target.Parent.Argv, value)
	case "signal.target.parent.args_truncated":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setBoolFieldValue("signal.target.parent.args_truncated", &ev.Signal.Target.Parent.ArgsTruncated, value)
	case "signal.target.parent.argv":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("signal.target.parent.argv", &ev.Signal.Target.Parent.Argv, value)
	case "signal.target.parent.argv0":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.argv0", &ev.Signal.Target.Parent.Argv0, value)
	case "signal.target.parent.auid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("signal.target.parent.auid", &ev.Signal.Target.Parent.Credentials.AUID, value)
	case "signal.target.parent.cap_effective":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint64FieldValue("signal.target.parent.cap_effective", &ev.Signal.Target.Parent.Credentials.CapEffective, value)
	case "signal.target.parent.cap_permitted":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint64FieldValue("signal.target.parent.cap_permitted", &ev.Signal.Target.Parent.Credentials.CapPermitted, value)
	case "signal.target.parent.cgroup.file.inode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint64FieldValue("signal.target.parent.cgroup.file.inode", &ev.Signal.Target.Parent.CGroup.CGroupFile.Inode, value)
	case "signal.target.parent.cgroup.file.mount_id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("signal.target.parent.cgroup.file.mount_id", &ev.Signal.Target.Parent.CGroup.CGroupFile.MountID, value)
	case "signal.target.parent.cgroup.id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "signal.target.parent.cgroup.id"}
		}
		ev.Signal.Target.Parent.CGroup.CGroupID = containerutils.CGroupID(rv)
		return nil
	case "signal.target.parent.cgroup.manager":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.cgroup.manager", &ev.Signal.Target.Parent.CGroup.CGroupManager, value)
	case "signal.target.parent.cgroup.version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setIntFieldValue("signal.target.parent.cgroup.version", &ev.Signal.Target.Parent.CGroup.CGroupVersion, value)
	case "signal.target.parent.comm":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.comm", &ev.Signal.Target.Parent.Comm, value)
	case "signal.target.parent.container.id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		rv, ok := value.(string)
		if !ok {
			return &eval.ErrValueTypeMismatch{Field: "signal.target.parent.container.id"}
		}
		ev.Signal.Target.Parent.ContainerID = containerutils.ContainerID(rv)
		return nil
	case "signal.target.parent.created_at":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint64FieldValue("signal.target.parent.created_at", &ev.Signal.Target.Parent.CreatedAt, value)
	case "signal.target.parent.egid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("signal.target.parent.egid", &ev.Signal.Target.Parent.Credentials.EGID, value)
	case "signal.target.parent.egroup":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.egroup", &ev.Signal.Target.Parent.Credentials.EGroup, value)
	case "signal.target.parent.envp":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("signal.target.parent.envp", &ev.Signal.Target.Parent.Envp, value)
	case "signal.target.parent.envs":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("signal.target.parent.envs", &ev.Signal.Target.Parent.Envs, value)
	case "signal.target.parent.envs_truncated":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setBoolFieldValue("signal.target.parent.envs_truncated", &ev.Signal.Target.Parent.EnvsTruncated, value)
	case "signal.target.parent.euid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("signal.target.parent.euid", &ev.Signal.Target.Parent.Credentials.EUID, value)
	case "signal.target.parent.euser":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.euser", &ev.Signal.Target.Parent.Credentials.EUser, value)
	case "signal.target.parent.file.change_time":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint64FieldValue("signal.target.parent.file.change_time", &ev.Signal.Target.Parent.FileEvent.FileFields.CTime, value)
	case "signal.target.parent.file.filesystem":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.file.filesystem", &ev.Signal.Target.Parent.FileEvent.Filesystem, value)
	case "signal.target.parent.file.gid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("signal.target.parent.file.gid", &ev.Signal.Target.Parent.FileEvent.FileFields.GID, value)
	case "signal.target.parent.file.group":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.file.group", &ev.Signal.Target.Parent.FileEvent.FileFields.Group, value)
	case "signal.target.parent.file.hashes":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("signal.target.parent.file.hashes", &ev.Signal.Target.Parent.FileEvent.Hashes, value)
	case "signal.target.parent.file.in_upper_layer":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setBoolFieldValue("signal.target.parent.file.in_upper_layer", &ev.Signal.Target.Parent.FileEvent.FileFields.InUpperLayer, value)
	case "signal.target.parent.file.inode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint64FieldValue("signal.target.parent.file.inode", &ev.Signal.Target.Parent.FileEvent.FileFields.PathKey.Inode, value)
	case "signal.target.parent.file.mode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint16FieldValue("signal.target.parent.file.mode", &ev.Signal.Target.Parent.FileEvent.FileFields.Mode, value)
	case "signal.target.parent.file.modification_time":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint64FieldValue("signal.target.parent.file.modification_time", &ev.Signal.Target.Parent.FileEvent.FileFields.MTime, value)
	case "signal.target.parent.file.mount_id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("signal.target.parent.file.mount_id", &ev.Signal.Target.Parent.FileEvent.FileFields.PathKey.MountID, value)
	case "signal.target.parent.file.name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.file.name", &ev.Signal.Target.Parent.FileEvent.BasenameStr, value)
	case "signal.target.parent.file.name.length":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "signal.target.parent.file.name.length"}
	case "signal.target.parent.file.package.name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.file.package.name", &ev.Signal.Target.Parent.FileEvent.PkgName, value)
	case "signal.target.parent.file.package.source_version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.file.package.source_version", &ev.Signal.Target.Parent.FileEvent.PkgSrcVersion, value)
	case "signal.target.parent.file.package.version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.file.package.version", &ev.Signal.Target.Parent.FileEvent.PkgVersion, value)
	case "signal.target.parent.file.path":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.file.path", &ev.Signal.Target.Parent.FileEvent.PathnameStr, value)
	case "signal.target.parent.file.path.length":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "signal.target.parent.file.path.length"}
	case "signal.target.parent.file.rights":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint16FieldValue("signal.target.parent.file.rights", &ev.Signal.Target.Parent.FileEvent.FileFields.Mode, value)
	case "signal.target.parent.file.uid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("signal.target.parent.file.uid", &ev.Signal.Target.Parent.FileEvent.FileFields.UID, value)
	case "signal.target.parent.file.user":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.file.user", &ev.Signal.Target.Parent.FileEvent.FileFields.User, value)
	case "signal.target.parent.fsgid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("signal.target.parent.fsgid", &ev.Signal.Target.Parent.Credentials.FSGID, value)
	case "signal.target.parent.fsgroup":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.fsgroup", &ev.Signal.Target.Parent.Credentials.FSGroup, value)
	case "signal.target.parent.fsuid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("signal.target.parent.fsuid", &ev.Signal.Target.Parent.Credentials.FSUID, value)
	case "signal.target.parent.fsuser":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.fsuser", &ev.Signal.Target.Parent.Credentials.FSUser, value)
	case "signal.target.parent.gid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("signal.target.parent.gid", &ev.Signal.Target.Parent.Credentials.GID, value)
	case "signal.target.parent.group":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.group", &ev.Signal.Target.Parent.Credentials.Group, value)
	case "signal.target.parent.interpreter.file.change_time":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.change_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("signal.target.parent.interpreter.file.change_time", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.CTime, value)
	case "signal.target.parent.interpreter.file.filesystem":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.filesystem", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.parent.interpreter.file.filesystem", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.Filesystem, value)
	case "signal.target.parent.interpreter.file.gid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.gid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("signal.target.parent.interpreter.file.gid", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.GID, value)
	case "signal.target.parent.interpreter.file.group":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.group", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.parent.interpreter.file.group", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.Group, value)
	case "signal.target.parent.interpreter.file.hashes":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.hashes", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringArrayFieldValue("signal.target.parent.interpreter.file.hashes", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.Hashes, value)
	case "signal.target.parent.interpreter.file.in_upper_layer":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.in_upper_layer", value)
		if err != nil || !cont {
			return err
		}
		return ev.setBoolFieldValue("signal.target.parent.interpreter.file.in_upper_layer", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.InUpperLayer, value)
	case "signal.target.parent.interpreter.file.inode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.inode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("signal.target.parent.interpreter.file.inode", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.Inode, value)
	case "signal.target.parent.interpreter.file.mode":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.mode", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("signal.target.parent.interpreter.file.mode", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "signal.target.parent.interpreter.file.modification_time":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.modification_time", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint64FieldValue("signal.target.parent.interpreter.file.modification_time", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.MTime, value)
	case "signal.target.parent.interpreter.file.mount_id":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.mount_id", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("signal.target.parent.interpreter.file.mount_id", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.PathKey.MountID, value)
	case "signal.target.parent.interpreter.file.name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.parent.interpreter.file.name", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.BasenameStr, value)
	case "signal.target.parent.interpreter.file.name.length":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "signal.target.parent.interpreter.file.name.length"}
	case "signal.target.parent.interpreter.file.package.name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.package.name", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.parent.interpreter.file.package.name", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.PkgName, value)
	case "signal.target.parent.interpreter.file.package.source_version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.package.source_version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.parent.interpreter.file.package.source_version", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.PkgSrcVersion, value)
	case "signal.target.parent.interpreter.file.package.version":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.package.version", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.parent.interpreter.file.package.version", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.PkgVersion, value)
	case "signal.target.parent.interpreter.file.path":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.path", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.parent.interpreter.file.path", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.PathnameStr, value)
	case "signal.target.parent.interpreter.file.path.length":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return &eval.ErrFieldReadOnly{Field: "signal.target.parent.interpreter.file.path.length"}
	case "signal.target.parent.interpreter.file.rights":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.rights", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint16FieldValue("signal.target.parent.interpreter.file.rights", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.Mode, value)
	case "signal.target.parent.interpreter.file.uid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.uid", value)
		if err != nil || !cont {
			return err
		}
		return ev.setUint32FieldValue("signal.target.parent.interpreter.file.uid", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.UID, value)
	case "signal.target.parent.interpreter.file.user":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		cont, err := SetInterpreterFields(&ev.Signal.Target.Parent.LinuxBinprm, "file.user", value)
		if err != nil || !cont {
			return err
		}
		return ev.setStringFieldValue("signal.target.parent.interpreter.file.user", &ev.Signal.Target.Parent.LinuxBinprm.FileEvent.FileFields.User, value)
	case "signal.target.parent.is_exec":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setBoolFieldValue("signal.target.parent.is_exec", &ev.Signal.Target.Parent.IsExec, value)
	case "signal.target.parent.is_kworker":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setBoolFieldValue("signal.target.parent.is_kworker", &ev.Signal.Target.Parent.PIDContext.IsKworker, value)
	case "signal.target.parent.is_thread":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setBoolFieldValue("signal.target.parent.is_thread", &ev.Signal.Target.Parent.IsThread, value)
	case "signal.target.parent.pid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("signal.target.parent.pid", &ev.Signal.Target.Parent.PIDContext.Pid, value)
	case "signal.target.parent.ppid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("signal.target.parent.ppid", &ev.Signal.Target.Parent.PPid, value)
	case "signal.target.parent.tid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("signal.target.parent.tid", &ev.Signal.Target.Parent.PIDContext.Tid, value)
	case "signal.target.parent.tty_name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.tty_name", &ev.Signal.Target.Parent.TTYName, value)
	case "signal.target.parent.uid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setUint32FieldValue("signal.target.parent.uid", &ev.Signal.Target.Parent.Credentials.UID, value)
	case "signal.target.parent.user":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.user", &ev.Signal.Target.Parent.Credentials.User, value)
	case "signal.target.parent.user_session.k8s_groups":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringArrayFieldValue("signal.target.parent.user_session.k8s_groups", &ev.Signal.Target.Parent.UserSession.K8SGroups, value)
	case "signal.target.parent.user_session.k8s_uid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.user_session.k8s_uid", &ev.Signal.Target.Parent.UserSession.K8SUID, value)
	case "signal.target.parent.user_session.k8s_username":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		if ev.Signal.Target.Parent == nil {
			ev.Signal.Target.Parent = &Process{}
		}
		return ev.setStringFieldValue("signal.target.parent.user_session.k8s_username", &ev.Signal.Target.Parent.UserSession.K8SUsername, value)
	case "signal.target.pid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("signal.target.pid", &ev.Signal.Target.Process.PIDContext.Pid, value)
	case "signal.target.ppid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("signal.target.ppid", &ev.Signal.Target.Process.PPid, value)
	case "signal.target.tid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("signal.target.tid", &ev.Signal.Target.Process.PIDContext.Tid, value)
	case "signal.target.tty_name":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.tty_name", &ev.Signal.Target.Process.TTYName, value)
	case "signal.target.uid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setUint32FieldValue("signal.target.uid", &ev.Signal.Target.Process.Credentials.UID, value)
	case "signal.target.user":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.user", &ev.Signal.Target.Process.Credentials.User, value)
	case "signal.target.user_session.k8s_groups":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringArrayFieldValue("signal.target.user_session.k8s_groups", &ev.Signal.Target.Process.UserSession.K8SGroups, value)
	case "signal.target.user_session.k8s_uid":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.user_session.k8s_uid", &ev.Signal.Target.Process.UserSession.K8SUID, value)
	case "signal.target.user_session.k8s_username":
		if ev.Signal.Target == nil {
			ev.Signal.Target = &ProcessContext{}
		}
		return ev.setStringFieldValue("signal.target.user_session.k8s_username", &ev.Signal.Target.Process.UserSession.K8SUsername, value)
	case "signal.type":
		return ev.setUint32FieldValue("signal.type", &ev.Signal.Type, value)
	case "splice.file.change_time":
		return ev.setUint64FieldValue("splice.file.change_time", &ev.Splice.File.FileFields.CTime, value)
	case "splice.file.filesystem":
		return ev.setStringFieldValue("splice.file.filesystem", &ev.Splice.File.Filesystem, value)
	case "splice.file.gid":
		return ev.setUint32FieldValue("splice.file.gid", &ev.Splice.File.FileFields.GID, value)
	case "splice.file.group":
		return ev.setStringFieldValue("splice.file.group", &ev.Splice.File.FileFields.Group, value)
	case "splice.file.hashes":
		return ev.setStringArrayFieldValue("splice.file.hashes", &ev.Splice.File.Hashes, value)
	case "splice.file.in_upper_layer":
		return ev.setBoolFieldValue("splice.file.in_upper_layer", &ev.Splice.File.FileFields.InUpperLayer, value)
	case "splice.file.inode":
		return ev.setUint64FieldValue("splice.file.inode", &ev.Splice.File.FileFields.PathKey.Inode, value)
	case "splice.file.mode":
		return ev.setUint16FieldValue("splice.file.mode", &ev.Splice.File.FileFields.Mode, value)
	case "splice.file.modification_time":
		return ev.setUint64FieldValue("splice.file.modification_time", &ev.Splice.File.FileFields.MTime, value)
	case "splice.file.mount_id":
		return ev.setUint32FieldValue("splice.file.mount_id", &ev.Splice.File.FileFields.PathKey.MountID, value)
	case "splice.file.name":
		return ev.setStringFieldValue("splice.file.name", &ev.Splice.File.BasenameStr, value)
	case "splice.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "splice.file.name.length"}
	case "splice.file.package.name":
		return ev.setStringFieldValue("splice.file.package.name", &ev.Splice.File.PkgName, value)
	case "splice.file.package.source_version":
		return ev.setStringFieldValue("splice.file.package.source_version", &ev.Splice.File.PkgSrcVersion, value)
	case "splice.file.package.version":
		return ev.setStringFieldValue("splice.file.package.version", &ev.Splice.File.PkgVersion, value)
	case "splice.file.path":
		return ev.setStringFieldValue("splice.file.path", &ev.Splice.File.PathnameStr, value)
	case "splice.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "splice.file.path.length"}
	case "splice.file.rights":
		return ev.setUint16FieldValue("splice.file.rights", &ev.Splice.File.FileFields.Mode, value)
	case "splice.file.uid":
		return ev.setUint32FieldValue("splice.file.uid", &ev.Splice.File.FileFields.UID, value)
	case "splice.file.user":
		return ev.setStringFieldValue("splice.file.user", &ev.Splice.File.FileFields.User, value)
	case "splice.pipe_entry_flag":
		return ev.setUint32FieldValue("splice.pipe_entry_flag", &ev.Splice.PipeEntryFlag, value)
	case "splice.pipe_exit_flag":
		return ev.setUint32FieldValue("splice.pipe_exit_flag", &ev.Splice.PipeExitFlag, value)
	case "splice.retval":
		return ev.setInt64FieldValue("splice.retval", &ev.Splice.SyscallEvent.Retval, value)
	case "sysctl.action":
		return ev.setUint32FieldValue("sysctl.action", &ev.SysCtl.Action, value)
	case "sysctl.file_position":
		return ev.setUint32FieldValue("sysctl.file_position", &ev.SysCtl.FilePosition, value)
	case "sysctl.name":
		return ev.setStringFieldValue("sysctl.name", &ev.SysCtl.Name, value)
	case "sysctl.name_truncated":
		return ev.setBoolFieldValue("sysctl.name_truncated", &ev.SysCtl.NameTruncated, value)
	case "sysctl.old_value":
		return ev.setStringFieldValue("sysctl.old_value", &ev.SysCtl.OldValue, value)
	case "sysctl.old_value_truncated":
		return ev.setBoolFieldValue("sysctl.old_value_truncated", &ev.SysCtl.OldValueTruncated, value)
	case "sysctl.value":
		return ev.setStringFieldValue("sysctl.value", &ev.SysCtl.Value, value)
	case "sysctl.value_truncated":
		return ev.setBoolFieldValue("sysctl.value_truncated", &ev.SysCtl.ValueTruncated, value)
	case "unlink.file.change_time":
		return ev.setUint64FieldValue("unlink.file.change_time", &ev.Unlink.File.FileFields.CTime, value)
	case "unlink.file.filesystem":
		return ev.setStringFieldValue("unlink.file.filesystem", &ev.Unlink.File.Filesystem, value)
	case "unlink.file.gid":
		return ev.setUint32FieldValue("unlink.file.gid", &ev.Unlink.File.FileFields.GID, value)
	case "unlink.file.group":
		return ev.setStringFieldValue("unlink.file.group", &ev.Unlink.File.FileFields.Group, value)
	case "unlink.file.hashes":
		return ev.setStringArrayFieldValue("unlink.file.hashes", &ev.Unlink.File.Hashes, value)
	case "unlink.file.in_upper_layer":
		return ev.setBoolFieldValue("unlink.file.in_upper_layer", &ev.Unlink.File.FileFields.InUpperLayer, value)
	case "unlink.file.inode":
		return ev.setUint64FieldValue("unlink.file.inode", &ev.Unlink.File.FileFields.PathKey.Inode, value)
	case "unlink.file.mode":
		return ev.setUint16FieldValue("unlink.file.mode", &ev.Unlink.File.FileFields.Mode, value)
	case "unlink.file.modification_time":
		return ev.setUint64FieldValue("unlink.file.modification_time", &ev.Unlink.File.FileFields.MTime, value)
	case "unlink.file.mount_id":
		return ev.setUint32FieldValue("unlink.file.mount_id", &ev.Unlink.File.FileFields.PathKey.MountID, value)
	case "unlink.file.name":
		return ev.setStringFieldValue("unlink.file.name", &ev.Unlink.File.BasenameStr, value)
	case "unlink.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "unlink.file.name.length"}
	case "unlink.file.package.name":
		return ev.setStringFieldValue("unlink.file.package.name", &ev.Unlink.File.PkgName, value)
	case "unlink.file.package.source_version":
		return ev.setStringFieldValue("unlink.file.package.source_version", &ev.Unlink.File.PkgSrcVersion, value)
	case "unlink.file.package.version":
		return ev.setStringFieldValue("unlink.file.package.version", &ev.Unlink.File.PkgVersion, value)
	case "unlink.file.path":
		return ev.setStringFieldValue("unlink.file.path", &ev.Unlink.File.PathnameStr, value)
	case "unlink.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "unlink.file.path.length"}
	case "unlink.file.rights":
		return ev.setUint16FieldValue("unlink.file.rights", &ev.Unlink.File.FileFields.Mode, value)
	case "unlink.file.uid":
		return ev.setUint32FieldValue("unlink.file.uid", &ev.Unlink.File.FileFields.UID, value)
	case "unlink.file.user":
		return ev.setStringFieldValue("unlink.file.user", &ev.Unlink.File.FileFields.User, value)
	case "unlink.flags":
		return ev.setUint32FieldValue("unlink.flags", &ev.Unlink.Flags, value)
	case "unlink.retval":
		return ev.setInt64FieldValue("unlink.retval", &ev.Unlink.SyscallEvent.Retval, value)
	case "unlink.syscall.dirfd":
		return ev.setInt64FieldValue("unlink.syscall.dirfd", &ev.Unlink.SyscallContext.IntArg1, value)
	case "unlink.syscall.flags":
		return ev.setInt64FieldValue("unlink.syscall.flags", &ev.Unlink.SyscallContext.IntArg3, value)
	case "unlink.syscall.path":
		return ev.setStringFieldValue("unlink.syscall.path", &ev.Unlink.SyscallContext.StrArg2, value)
	case "unload_module.name":
		return ev.setStringFieldValue("unload_module.name", &ev.UnloadModule.Name, value)
	case "unload_module.retval":
		return ev.setInt64FieldValue("unload_module.retval", &ev.UnloadModule.SyscallEvent.Retval, value)
	case "utimes.file.change_time":
		return ev.setUint64FieldValue("utimes.file.change_time", &ev.Utimes.File.FileFields.CTime, value)
	case "utimes.file.filesystem":
		return ev.setStringFieldValue("utimes.file.filesystem", &ev.Utimes.File.Filesystem, value)
	case "utimes.file.gid":
		return ev.setUint32FieldValue("utimes.file.gid", &ev.Utimes.File.FileFields.GID, value)
	case "utimes.file.group":
		return ev.setStringFieldValue("utimes.file.group", &ev.Utimes.File.FileFields.Group, value)
	case "utimes.file.hashes":
		return ev.setStringArrayFieldValue("utimes.file.hashes", &ev.Utimes.File.Hashes, value)
	case "utimes.file.in_upper_layer":
		return ev.setBoolFieldValue("utimes.file.in_upper_layer", &ev.Utimes.File.FileFields.InUpperLayer, value)
	case "utimes.file.inode":
		return ev.setUint64FieldValue("utimes.file.inode", &ev.Utimes.File.FileFields.PathKey.Inode, value)
	case "utimes.file.mode":
		return ev.setUint16FieldValue("utimes.file.mode", &ev.Utimes.File.FileFields.Mode, value)
	case "utimes.file.modification_time":
		return ev.setUint64FieldValue("utimes.file.modification_time", &ev.Utimes.File.FileFields.MTime, value)
	case "utimes.file.mount_id":
		return ev.setUint32FieldValue("utimes.file.mount_id", &ev.Utimes.File.FileFields.PathKey.MountID, value)
	case "utimes.file.name":
		return ev.setStringFieldValue("utimes.file.name", &ev.Utimes.File.BasenameStr, value)
	case "utimes.file.name.length":
		return &eval.ErrFieldReadOnly{Field: "utimes.file.name.length"}
	case "utimes.file.package.name":
		return ev.setStringFieldValue("utimes.file.package.name", &ev.Utimes.File.PkgName, value)
	case "utimes.file.package.source_version":
		return ev.setStringFieldValue("utimes.file.package.source_version", &ev.Utimes.File.PkgSrcVersion, value)
	case "utimes.file.package.version":
		return ev.setStringFieldValue("utimes.file.package.version", &ev.Utimes.File.PkgVersion, value)
	case "utimes.file.path":
		return ev.setStringFieldValue("utimes.file.path", &ev.Utimes.File.PathnameStr, value)
	case "utimes.file.path.length":
		return &eval.ErrFieldReadOnly{Field: "utimes.file.path.length"}
	case "utimes.file.rights":
		return ev.setUint16FieldValue("utimes.file.rights", &ev.Utimes.File.FileFields.Mode, value)
	case "utimes.file.uid":
		return ev.setUint32FieldValue("utimes.file.uid", &ev.Utimes.File.FileFields.UID, value)
	case "utimes.file.user":
		return ev.setStringFieldValue("utimes.file.user", &ev.Utimes.File.FileFields.User, value)
	case "utimes.retval":
		return ev.setInt64FieldValue("utimes.retval", &ev.Utimes.SyscallEvent.Retval, value)
	case "utimes.syscall.path":
		return ev.setStringFieldValue("utimes.syscall.path", &ev.Utimes.SyscallContext.StrArg1, value)
	}
	return &eval.ErrFieldNotFound{Field: field}
}
