package model

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Credentials) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uid":
			z.UID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "UID")
				return
			}
		case "gid":
			z.GID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "GID")
				return
			}
		case "user":
			z.User, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "group":
			z.Group, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		case "euid":
			z.EUID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "EUID")
				return
			}
		case "egid":
			z.EGID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "EGID")
				return
			}
		case "euser":
			z.EUser, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EUser")
				return
			}
		case "egroup":
			z.EGroup, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EGroup")
				return
			}
		case "fsuid":
			z.FSUID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "FSUID")
				return
			}
		case "fsgid":
			z.FSGID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "FSGID")
				return
			}
		case "fsuser":
			z.FSUser, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "FSUser")
				return
			}
		case "fsgroup":
			z.FSGroup, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "FSGroup")
				return
			}
		case "cap_effective":
			z.CapEffective, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CapEffective")
				return
			}
		case "cap_permitted":
			z.CapPermitted, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CapPermitted")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Credentials) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 14
	// write "uid"
	err = en.Append(0x8e, 0xa3, 0x75, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.UID)
	if err != nil {
		err = msgp.WrapError(err, "UID")
		return
	}
	// write "gid"
	err = en.Append(0xa3, 0x67, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.GID)
	if err != nil {
		err = msgp.WrapError(err, "GID")
		return
	}
	// write "user"
	err = en.Append(0xa4, 0x75, 0x73, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.User)
	if err != nil {
		err = msgp.WrapError(err, "User")
		return
	}
	// write "group"
	err = en.Append(0xa5, 0x67, 0x72, 0x6f, 0x75, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.Group)
	if err != nil {
		err = msgp.WrapError(err, "Group")
		return
	}
	// write "euid"
	err = en.Append(0xa4, 0x65, 0x75, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.EUID)
	if err != nil {
		err = msgp.WrapError(err, "EUID")
		return
	}
	// write "egid"
	err = en.Append(0xa4, 0x65, 0x67, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.EGID)
	if err != nil {
		err = msgp.WrapError(err, "EGID")
		return
	}
	// write "euser"
	err = en.Append(0xa5, 0x65, 0x75, 0x73, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.EUser)
	if err != nil {
		err = msgp.WrapError(err, "EUser")
		return
	}
	// write "egroup"
	err = en.Append(0xa6, 0x65, 0x67, 0x72, 0x6f, 0x75, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.EGroup)
	if err != nil {
		err = msgp.WrapError(err, "EGroup")
		return
	}
	// write "fsuid"
	err = en.Append(0xa5, 0x66, 0x73, 0x75, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.FSUID)
	if err != nil {
		err = msgp.WrapError(err, "FSUID")
		return
	}
	// write "fsgid"
	err = en.Append(0xa5, 0x66, 0x73, 0x67, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.FSGID)
	if err != nil {
		err = msgp.WrapError(err, "FSGID")
		return
	}
	// write "fsuser"
	err = en.Append(0xa6, 0x66, 0x73, 0x75, 0x73, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.FSUser)
	if err != nil {
		err = msgp.WrapError(err, "FSUser")
		return
	}
	// write "fsgroup"
	err = en.Append(0xa7, 0x66, 0x73, 0x67, 0x72, 0x6f, 0x75, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.FSGroup)
	if err != nil {
		err = msgp.WrapError(err, "FSGroup")
		return
	}
	// write "cap_effective"
	err = en.Append(0xad, 0x63, 0x61, 0x70, 0x5f, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CapEffective)
	if err != nil {
		err = msgp.WrapError(err, "CapEffective")
		return
	}
	// write "cap_permitted"
	err = en.Append(0xad, 0x63, 0x61, 0x70, 0x5f, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CapPermitted)
	if err != nil {
		err = msgp.WrapError(err, "CapPermitted")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Credentials) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 14
	// string "uid"
	o = append(o, 0x8e, 0xa3, 0x75, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.UID)
	// string "gid"
	o = append(o, 0xa3, 0x67, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.GID)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	// string "group"
	o = append(o, 0xa5, 0x67, 0x72, 0x6f, 0x75, 0x70)
	o = msgp.AppendString(o, z.Group)
	// string "euid"
	o = append(o, 0xa4, 0x65, 0x75, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.EUID)
	// string "egid"
	o = append(o, 0xa4, 0x65, 0x67, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.EGID)
	// string "euser"
	o = append(o, 0xa5, 0x65, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.EUser)
	// string "egroup"
	o = append(o, 0xa6, 0x65, 0x67, 0x72, 0x6f, 0x75, 0x70)
	o = msgp.AppendString(o, z.EGroup)
	// string "fsuid"
	o = append(o, 0xa5, 0x66, 0x73, 0x75, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.FSUID)
	// string "fsgid"
	o = append(o, 0xa5, 0x66, 0x73, 0x67, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.FSGID)
	// string "fsuser"
	o = append(o, 0xa6, 0x66, 0x73, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.FSUser)
	// string "fsgroup"
	o = append(o, 0xa7, 0x66, 0x73, 0x67, 0x72, 0x6f, 0x75, 0x70)
	o = msgp.AppendString(o, z.FSGroup)
	// string "cap_effective"
	o = append(o, 0xad, 0x63, 0x61, 0x70, 0x5f, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65)
	o = msgp.AppendUint64(o, z.CapEffective)
	// string "cap_permitted"
	o = append(o, 0xad, 0x63, 0x61, 0x70, 0x5f, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.CapPermitted)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Credentials) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uid":
			z.UID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UID")
				return
			}
		case "gid":
			z.GID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GID")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "group":
			z.Group, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		case "euid":
			z.EUID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EUID")
				return
			}
		case "egid":
			z.EGID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EGID")
				return
			}
		case "euser":
			z.EUser, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EUser")
				return
			}
		case "egroup":
			z.EGroup, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EGroup")
				return
			}
		case "fsuid":
			z.FSUID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FSUID")
				return
			}
		case "fsgid":
			z.FSGID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FSGID")
				return
			}
		case "fsuser":
			z.FSUser, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FSUser")
				return
			}
		case "fsgroup":
			z.FSGroup, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FSGroup")
				return
			}
		case "cap_effective":
			z.CapEffective, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CapEffective")
				return
			}
		case "cap_permitted":
			z.CapPermitted, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CapPermitted")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Credentials) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint32Size + 4 + msgp.Uint32Size + 5 + msgp.StringPrefixSize + len(z.User) + 6 + msgp.StringPrefixSize + len(z.Group) + 5 + msgp.Uint32Size + 5 + msgp.Uint32Size + 6 + msgp.StringPrefixSize + len(z.EUser) + 7 + msgp.StringPrefixSize + len(z.EGroup) + 6 + msgp.Uint32Size + 6 + msgp.Uint32Size + 7 + msgp.StringPrefixSize + len(z.FSUser) + 8 + msgp.StringPrefixSize + len(z.FSGroup) + 14 + msgp.Uint64Size + 14 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DNSEvent) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "type":
			z.Type, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "class":
			z.Class, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "Class")
				return
			}
		case "length":
			z.Size, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "count":
			z.Count, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DNSEvent) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "name"
	err = en.Append(0x85, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "type"
	err = en.Append(0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "class"
	err = en.Append(0xa5, 0x63, 0x6c, 0x61, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.Class)
	if err != nil {
		err = msgp.WrapError(err, "Class")
		return
	}
	// write "length"
	err = en.Append(0xa6, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.Size)
	if err != nil {
		err = msgp.WrapError(err, "Size")
		return
	}
	// write "count"
	err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.Count)
	if err != nil {
		err = msgp.WrapError(err, "Count")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DNSEvent) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "name"
	o = append(o, 0x85, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "type"
	o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendUint16(o, z.Type)
	// string "class"
	o = append(o, 0xa5, 0x63, 0x6c, 0x61, 0x73, 0x73)
	o = msgp.AppendUint16(o, z.Class)
	// string "length"
	o = append(o, 0xa6, 0x6c, 0x65, 0x6e, 0x67, 0x74, 0x68)
	o = msgp.AppendUint16(o, z.Size)
	// string "count"
	o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint16(o, z.Count)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DNSEvent) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "type":
			z.Type, bts, err = msgp.ReadUint16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "class":
			z.Class, bts, err = msgp.ReadUint16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Class")
				return
			}
		case "length":
			z.Size, bts, err = msgp.ReadUint16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "count":
			z.Count, bts, err = msgp.ReadUint16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DNSEvent) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 5 + msgp.Uint16Size + 6 + msgp.Uint16Size + 7 + msgp.Uint16Size + 6 + msgp.Uint16Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *FileEvent) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "file_fields":
			err = z.FileFields.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "FileFields")
				return
			}
		case "path":
			z.PathnameStr, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "PathnameStr")
				return
			}
		case "name":
			z.BasenameStr, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BasenameStr")
				return
			}
		case "filesystem":
			z.Filesystem, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Filesystem")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *FileEvent) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "file_fields"
	err = en.Append(0x84, 0xab, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73)
	if err != nil {
		return
	}
	err = z.FileFields.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "FileFields")
		return
	}
	// write "path"
	err = en.Append(0xa4, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.PathnameStr)
	if err != nil {
		err = msgp.WrapError(err, "PathnameStr")
		return
	}
	// write "name"
	err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.BasenameStr)
	if err != nil {
		err = msgp.WrapError(err, "BasenameStr")
		return
	}
	// write "filesystem"
	err = en.Append(0xaa, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.Filesystem)
	if err != nil {
		err = msgp.WrapError(err, "Filesystem")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FileEvent) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "file_fields"
	o = append(o, 0x84, 0xab, 0x66, 0x69, 0x6c, 0x65, 0x5f, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x73)
	o, err = z.FileFields.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "FileFields")
		return
	}
	// string "path"
	o = append(o, 0xa4, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.PathnameStr)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.BasenameStr)
	// string "filesystem"
	o = append(o, 0xaa, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d)
	o = msgp.AppendString(o, z.Filesystem)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FileEvent) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "file_fields":
			bts, err = z.FileFields.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "FileFields")
				return
			}
		case "path":
			z.PathnameStr, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PathnameStr")
				return
			}
		case "name":
			z.BasenameStr, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BasenameStr")
				return
			}
		case "filesystem":
			z.Filesystem, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Filesystem")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FileEvent) Msgsize() (s int) {
	s = 1 + 12 + z.FileFields.Msgsize() + 5 + msgp.StringPrefixSize + len(z.PathnameStr) + 5 + msgp.StringPrefixSize + len(z.BasenameStr) + 11 + msgp.StringPrefixSize + len(z.Filesystem)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *FileFields) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uid":
			z.UID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "UID")
				return
			}
		case "user":
			z.User, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "gid":
			z.GID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "GID")
				return
			}
		case "group":
			z.Group, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		case "mode":
			z.Mode, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "Mode")
				return
			}
		case "ctime":
			z.CTime, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CTime")
				return
			}
		case "mtime":
			z.MTime, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "MTime")
				return
			}
		case "mount_id":
			z.MountID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "MountID")
				return
			}
		case "inode":
			z.Inode, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Inode")
				return
			}
		case "in_upper_layer":
			z.InUpperLayer, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "InUpperLayer")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *FileFields) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(10)
	var zb0001Mask uint16 /* 10 bits */
	if z.User == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Group == "" {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "uid"
	err = en.Append(0xa3, 0x75, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.UID)
	if err != nil {
		err = msgp.WrapError(err, "UID")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "user"
		err = en.Append(0xa4, 0x75, 0x73, 0x65, 0x72)
		if err != nil {
			return
		}
		err = en.WriteString(z.User)
		if err != nil {
			err = msgp.WrapError(err, "User")
			return
		}
	}
	// write "gid"
	err = en.Append(0xa3, 0x67, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.GID)
	if err != nil {
		err = msgp.WrapError(err, "GID")
		return
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// write "group"
		err = en.Append(0xa5, 0x67, 0x72, 0x6f, 0x75, 0x70)
		if err != nil {
			return
		}
		err = en.WriteString(z.Group)
		if err != nil {
			err = msgp.WrapError(err, "Group")
			return
		}
	}
	// write "mode"
	err = en.Append(0xa4, 0x6d, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.Mode)
	if err != nil {
		err = msgp.WrapError(err, "Mode")
		return
	}
	// write "ctime"
	err = en.Append(0xa5, 0x63, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CTime)
	if err != nil {
		err = msgp.WrapError(err, "CTime")
		return
	}
	// write "mtime"
	err = en.Append(0xa5, 0x6d, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.MTime)
	if err != nil {
		err = msgp.WrapError(err, "MTime")
		return
	}
	// write "mount_id"
	err = en.Append(0xa8, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.MountID)
	if err != nil {
		err = msgp.WrapError(err, "MountID")
		return
	}
	// write "inode"
	err = en.Append(0xa5, 0x69, 0x6e, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Inode)
	if err != nil {
		err = msgp.WrapError(err, "Inode")
		return
	}
	// write "in_upper_layer"
	err = en.Append(0xae, 0x69, 0x6e, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBool(z.InUpperLayer)
	if err != nil {
		err = msgp.WrapError(err, "InUpperLayer")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FileFields) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(10)
	var zb0001Mask uint16 /* 10 bits */
	if z.User == "" {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	if z.Group == "" {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "uid"
	o = append(o, 0xa3, 0x75, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.UID)
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "user"
		o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
		o = msgp.AppendString(o, z.User)
	}
	// string "gid"
	o = append(o, 0xa3, 0x67, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.GID)
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// string "group"
		o = append(o, 0xa5, 0x67, 0x72, 0x6f, 0x75, 0x70)
		o = msgp.AppendString(o, z.Group)
	}
	// string "mode"
	o = append(o, 0xa4, 0x6d, 0x6f, 0x64, 0x65)
	o = msgp.AppendUint16(o, z.Mode)
	// string "ctime"
	o = append(o, 0xa5, 0x63, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendUint64(o, z.CTime)
	// string "mtime"
	o = append(o, 0xa5, 0x6d, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendUint64(o, z.MTime)
	// string "mount_id"
	o = append(o, 0xa8, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.MountID)
	// string "inode"
	o = append(o, 0xa5, 0x69, 0x6e, 0x6f, 0x64, 0x65)
	o = msgp.AppendUint64(o, z.Inode)
	// string "in_upper_layer"
	o = append(o, 0xae, 0x69, 0x6e, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72)
	o = msgp.AppendBool(o, z.InUpperLayer)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FileFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uid":
			z.UID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UID")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "gid":
			z.GID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GID")
				return
			}
		case "group":
			z.Group, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		case "mode":
			z.Mode, bts, err = msgp.ReadUint16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mode")
				return
			}
		case "ctime":
			z.CTime, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CTime")
				return
			}
		case "mtime":
			z.MTime, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MTime")
				return
			}
		case "mount_id":
			z.MountID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MountID")
				return
			}
		case "inode":
			z.Inode, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Inode")
				return
			}
		case "in_upper_layer":
			z.InUpperLayer, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InUpperLayer")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FileFields) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint32Size + 5 + msgp.StringPrefixSize + len(z.User) + 4 + msgp.Uint32Size + 6 + msgp.StringPrefixSize + len(z.Group) + 5 + msgp.Uint16Size + 6 + msgp.Uint64Size + 6 + msgp.Uint64Size + 9 + msgp.Uint32Size + 6 + msgp.Uint64Size + 15 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PIDContext) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "pid":
			z.Pid, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Pid")
				return
			}
		case "tid":
			z.Tid, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Tid")
				return
			}
		case "is_kworker":
			z.IsKworker, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsKworker")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z PIDContext) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "pid"
	err = en.Append(0x83, 0xa3, 0x70, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Pid)
	if err != nil {
		err = msgp.WrapError(err, "Pid")
		return
	}
	// write "tid"
	err = en.Append(0xa3, 0x74, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Tid)
	if err != nil {
		err = msgp.WrapError(err, "Tid")
		return
	}
	// write "is_kworker"
	err = en.Append(0xaa, 0x69, 0x73, 0x5f, 0x6b, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsKworker)
	if err != nil {
		err = msgp.WrapError(err, "IsKworker")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PIDContext) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "pid"
	o = append(o, 0x83, 0xa3, 0x70, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.Pid)
	// string "tid"
	o = append(o, 0xa3, 0x74, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.Tid)
	// string "is_kworker"
	o = append(o, 0xaa, 0x69, 0x73, 0x5f, 0x6b, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72)
	o = msgp.AppendBool(o, z.IsKworker)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PIDContext) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "pid":
			z.Pid, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Pid")
				return
			}
		case "tid":
			z.Tid, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tid")
				return
			}
		case "is_kworker":
			z.IsKworker, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsKworker")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PIDContext) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint32Size + 4 + msgp.Uint32Size + 11 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Process) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "pid_context":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "PIDContext")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "PIDContext")
					return
				}
				switch msgp.UnsafeString(field) {
				case "pid":
					z.PIDContext.Pid, err = dc.ReadUint32()
					if err != nil {
						err = msgp.WrapError(err, "PIDContext", "Pid")
						return
					}
				case "tid":
					z.PIDContext.Tid, err = dc.ReadUint32()
					if err != nil {
						err = msgp.WrapError(err, "PIDContext", "Tid")
						return
					}
				case "is_kworker":
					z.PIDContext.IsKworker, err = dc.ReadBool()
					if err != nil {
						err = msgp.WrapError(err, "PIDContext", "IsKworker")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "PIDContext")
						return
					}
				}
			}
		case "file":
			err = z.FileEvent.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "FileEvent")
				return
			}
		case "container_id":
			z.ContainerID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ContainerID")
				return
			}
		case "container_tags":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ContainerTags")
				return
			}
			if cap(z.ContainerTags) >= int(zb0003) {
				z.ContainerTags = (z.ContainerTags)[:zb0003]
			} else {
				z.ContainerTags = make([]string, zb0003)
			}
			for za0001 := range z.ContainerTags {
				z.ContainerTags[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ContainerTags", za0001)
					return
				}
			}
		case "span_id":
			z.SpanID, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "SpanID")
				return
			}
		case "trace_id":
			z.TraceID, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TraceID")
				return
			}
		case "tty":
			z.TTYName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "TTYName")
				return
			}
		case "comm":
			z.Comm, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Comm")
				return
			}
		case "fork_time":
			z.ForkTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "ForkTime")
				return
			}
		case "exit_time":
			z.ExitTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "ExitTime")
				return
			}
		case "exec_time":
			z.ExecTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "ExecTime")
				return
			}
		case "cookie":
			z.Cookie, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Cookie")
				return
			}
		case "ppid":
			z.PPid, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "PPid")
				return
			}
		case "credentials":
			err = z.Credentials.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Credentials")
				return
			}
		case "args_entry":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "ArgsEntry")
					return
				}
				z.ArgsEntry = nil
			} else {
				if z.ArgsEntry == nil {
					z.ArgsEntry = new(ArgsEntry)
				}
				err = z.ArgsEntry.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ArgsEntry")
					return
				}
			}
		case "envs_entry":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "EnvsEntry")
					return
				}
				z.EnvsEntry = nil
			} else {
				if z.EnvsEntry == nil {
					z.EnvsEntry = new(EnvsEntry)
				}
				err = z.EnvsEntry.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "EnvsEntry")
					return
				}
			}
		case "argv0":
			z.Argv0, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Argv0")
				return
			}
		case "envs":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Envs")
				return
			}
			if cap(z.Envs) >= int(zb0004) {
				z.Envs = (z.Envs)[:zb0004]
			} else {
				z.Envs = make([]string, zb0004)
			}
			for za0002 := range z.Envs {
				z.Envs[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Envs", za0002)
					return
				}
			}
		case "envs_truncated":
			z.EnvsTruncated, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "EnvsTruncated")
				return
			}
		case "argv":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ScrubbedArgv")
				return
			}
			if cap(z.ScrubbedArgv) >= int(zb0005) {
				z.ScrubbedArgv = (z.ScrubbedArgv)[:zb0005]
			} else {
				z.ScrubbedArgv = make([]string, zb0005)
			}
			for za0003 := range z.ScrubbedArgv {
				z.ScrubbedArgv[za0003], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ScrubbedArgv", za0003)
					return
				}
			}
		case "argv_truncated":
			z.ScrubbedArgsTruncated, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "ScrubbedArgsTruncated")
				return
			}
		case "is_thread":
			z.IsThread, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsThread")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Process) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(22)
	var zb0001Mask uint32 /* 22 bits */
	if z.ContainerID == "" {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.ContainerTags == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.SpanID == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TraceID == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.TTYName == "" {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Cookie == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.ArgsEntry == nil {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.EnvsEntry == nil {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.Envs == nil {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	if z.EnvsTruncated == false {
		zb0001Len--
		zb0001Mask |= 0x40000
	}
	if z.ScrubbedArgv == nil {
		zb0001Len--
		zb0001Mask |= 0x80000
	}
	if z.ScrubbedArgsTruncated == false {
		zb0001Len--
		zb0001Mask |= 0x100000
	}
	// variable map header, size zb0001Len
	err = en.WriteMapHeader(zb0001Len)
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "pid_context"
	err = en.Append(0xab, 0x70, 0x69, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74)
	if err != nil {
		return
	}
	// map header, size 3
	// write "pid"
	err = en.Append(0x83, 0xa3, 0x70, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.PIDContext.Pid)
	if err != nil {
		err = msgp.WrapError(err, "PIDContext", "Pid")
		return
	}
	// write "tid"
	err = en.Append(0xa3, 0x74, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.PIDContext.Tid)
	if err != nil {
		err = msgp.WrapError(err, "PIDContext", "Tid")
		return
	}
	// write "is_kworker"
	err = en.Append(0xaa, 0x69, 0x73, 0x5f, 0x6b, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBool(z.PIDContext.IsKworker)
	if err != nil {
		err = msgp.WrapError(err, "PIDContext", "IsKworker")
		return
	}
	// write "file"
	err = en.Append(0xa4, 0x66, 0x69, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = z.FileEvent.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "FileEvent")
		return
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// write "container_id"
		err = en.Append(0xac, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x69, 0x64)
		if err != nil {
			return
		}
		err = en.WriteString(z.ContainerID)
		if err != nil {
			err = msgp.WrapError(err, "ContainerID")
			return
		}
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// write "container_tags"
		err = en.Append(0xae, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x74, 0x61, 0x67, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.ContainerTags)))
		if err != nil {
			err = msgp.WrapError(err, "ContainerTags")
			return
		}
		for za0001 := range z.ContainerTags {
			err = en.WriteString(z.ContainerTags[za0001])
			if err != nil {
				err = msgp.WrapError(err, "ContainerTags", za0001)
				return
			}
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// write "span_id"
		err = en.Append(0xa7, 0x73, 0x70, 0x61, 0x6e, 0x5f, 0x69, 0x64)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.SpanID)
		if err != nil {
			err = msgp.WrapError(err, "SpanID")
			return
		}
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// write "trace_id"
		err = en.Append(0xa8, 0x74, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x69, 0x64)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.TraceID)
		if err != nil {
			err = msgp.WrapError(err, "TraceID")
			return
		}
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// write "tty"
		err = en.Append(0xa3, 0x74, 0x74, 0x79)
		if err != nil {
			return
		}
		err = en.WriteString(z.TTYName)
		if err != nil {
			err = msgp.WrapError(err, "TTYName")
			return
		}
	}
	// write "comm"
	err = en.Append(0xa4, 0x63, 0x6f, 0x6d, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.Comm)
	if err != nil {
		err = msgp.WrapError(err, "Comm")
		return
	}
	// write "fork_time"
	err = en.Append(0xa9, 0x66, 0x6f, 0x72, 0x6b, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.ForkTime)
	if err != nil {
		err = msgp.WrapError(err, "ForkTime")
		return
	}
	// write "exit_time"
	err = en.Append(0xa9, 0x65, 0x78, 0x69, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.ExitTime)
	if err != nil {
		err = msgp.WrapError(err, "ExitTime")
		return
	}
	// write "exec_time"
	err = en.Append(0xa9, 0x65, 0x78, 0x65, 0x63, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.ExecTime)
	if err != nil {
		err = msgp.WrapError(err, "ExecTime")
		return
	}
	if (zb0001Mask & 0x800) == 0 { // if not empty
		// write "cookie"
		err = en.Append(0xa6, 0x63, 0x6f, 0x6f, 0x6b, 0x69, 0x65)
		if err != nil {
			return
		}
		err = en.WriteUint32(z.Cookie)
		if err != nil {
			err = msgp.WrapError(err, "Cookie")
			return
		}
	}
	// write "ppid"
	err = en.Append(0xa4, 0x70, 0x70, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.PPid)
	if err != nil {
		err = msgp.WrapError(err, "PPid")
		return
	}
	// write "credentials"
	err = en.Append(0xab, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73)
	if err != nil {
		return
	}
	err = z.Credentials.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Credentials")
		return
	}
	if (zb0001Mask & 0x4000) == 0 { // if not empty
		// write "args_entry"
		err = en.Append(0xaa, 0x61, 0x72, 0x67, 0x73, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79)
		if err != nil {
			return
		}
		if z.ArgsEntry == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.ArgsEntry.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "ArgsEntry")
				return
			}
		}
	}
	if (zb0001Mask & 0x8000) == 0 { // if not empty
		// write "envs_entry"
		err = en.Append(0xaa, 0x65, 0x6e, 0x76, 0x73, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79)
		if err != nil {
			return
		}
		if z.EnvsEntry == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.EnvsEntry.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "EnvsEntry")
				return
			}
		}
	}
	// write "argv0"
	err = en.Append(0xa5, 0x61, 0x72, 0x67, 0x76, 0x30)
	if err != nil {
		return
	}
	err = en.WriteString(z.Argv0)
	if err != nil {
		err = msgp.WrapError(err, "Argv0")
		return
	}
	if (zb0001Mask & 0x20000) == 0 { // if not empty
		// write "envs"
		err = en.Append(0xa4, 0x65, 0x6e, 0x76, 0x73)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.Envs)))
		if err != nil {
			err = msgp.WrapError(err, "Envs")
			return
		}
		for za0002 := range z.Envs {
			err = en.WriteString(z.Envs[za0002])
			if err != nil {
				err = msgp.WrapError(err, "Envs", za0002)
				return
			}
		}
	}
	if (zb0001Mask & 0x40000) == 0 { // if not empty
		// write "envs_truncated"
		err = en.Append(0xae, 0x65, 0x6e, 0x76, 0x73, 0x5f, 0x74, 0x72, 0x75, 0x6e, 0x63, 0x61, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteBool(z.EnvsTruncated)
		if err != nil {
			err = msgp.WrapError(err, "EnvsTruncated")
			return
		}
	}
	if (zb0001Mask & 0x80000) == 0 { // if not empty
		// write "argv"
		err = en.Append(0xa4, 0x61, 0x72, 0x67, 0x76)
		if err != nil {
			return
		}
		err = en.WriteArrayHeader(uint32(len(z.ScrubbedArgv)))
		if err != nil {
			err = msgp.WrapError(err, "ScrubbedArgv")
			return
		}
		for za0003 := range z.ScrubbedArgv {
			err = en.WriteString(z.ScrubbedArgv[za0003])
			if err != nil {
				err = msgp.WrapError(err, "ScrubbedArgv", za0003)
				return
			}
		}
	}
	if (zb0001Mask & 0x100000) == 0 { // if not empty
		// write "argv_truncated"
		err = en.Append(0xae, 0x61, 0x72, 0x67, 0x76, 0x5f, 0x74, 0x72, 0x75, 0x6e, 0x63, 0x61, 0x74, 0x65, 0x64)
		if err != nil {
			return
		}
		err = en.WriteBool(z.ScrubbedArgsTruncated)
		if err != nil {
			err = msgp.WrapError(err, "ScrubbedArgsTruncated")
			return
		}
	}
	// write "is_thread"
	err = en.Append(0xa9, 0x69, 0x73, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsThread)
	if err != nil {
		err = msgp.WrapError(err, "IsThread")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Process) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(22)
	var zb0001Mask uint32 /* 22 bits */
	if z.ContainerID == "" {
		zb0001Len--
		zb0001Mask |= 0x4
	}
	if z.ContainerTags == nil {
		zb0001Len--
		zb0001Mask |= 0x8
	}
	if z.SpanID == 0 {
		zb0001Len--
		zb0001Mask |= 0x10
	}
	if z.TraceID == 0 {
		zb0001Len--
		zb0001Mask |= 0x20
	}
	if z.TTYName == "" {
		zb0001Len--
		zb0001Mask |= 0x40
	}
	if z.Cookie == 0 {
		zb0001Len--
		zb0001Mask |= 0x800
	}
	if z.ArgsEntry == nil {
		zb0001Len--
		zb0001Mask |= 0x4000
	}
	if z.EnvsEntry == nil {
		zb0001Len--
		zb0001Mask |= 0x8000
	}
	if z.Envs == nil {
		zb0001Len--
		zb0001Mask |= 0x20000
	}
	if z.EnvsTruncated == false {
		zb0001Len--
		zb0001Mask |= 0x40000
	}
	if z.ScrubbedArgv == nil {
		zb0001Len--
		zb0001Mask |= 0x80000
	}
	if z.ScrubbedArgsTruncated == false {
		zb0001Len--
		zb0001Mask |= 0x100000
	}
	// variable map header, size zb0001Len
	o = msgp.AppendMapHeader(o, zb0001Len)
	if zb0001Len == 0 {
		return
	}
	// string "pid_context"
	o = append(o, 0xab, 0x70, 0x69, 0x64, 0x5f, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74)
	// map header, size 3
	// string "pid"
	o = append(o, 0x83, 0xa3, 0x70, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.PIDContext.Pid)
	// string "tid"
	o = append(o, 0xa3, 0x74, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.PIDContext.Tid)
	// string "is_kworker"
	o = append(o, 0xaa, 0x69, 0x73, 0x5f, 0x6b, 0x77, 0x6f, 0x72, 0x6b, 0x65, 0x72)
	o = msgp.AppendBool(o, z.PIDContext.IsKworker)
	// string "file"
	o = append(o, 0xa4, 0x66, 0x69, 0x6c, 0x65)
	o, err = z.FileEvent.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "FileEvent")
		return
	}
	if (zb0001Mask & 0x4) == 0 { // if not empty
		// string "container_id"
		o = append(o, 0xac, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x69, 0x64)
		o = msgp.AppendString(o, z.ContainerID)
	}
	if (zb0001Mask & 0x8) == 0 { // if not empty
		// string "container_tags"
		o = append(o, 0xae, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x74, 0x61, 0x67, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.ContainerTags)))
		for za0001 := range z.ContainerTags {
			o = msgp.AppendString(o, z.ContainerTags[za0001])
		}
	}
	if (zb0001Mask & 0x10) == 0 { // if not empty
		// string "span_id"
		o = append(o, 0xa7, 0x73, 0x70, 0x61, 0x6e, 0x5f, 0x69, 0x64)
		o = msgp.AppendUint64(o, z.SpanID)
	}
	if (zb0001Mask & 0x20) == 0 { // if not empty
		// string "trace_id"
		o = append(o, 0xa8, 0x74, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x69, 0x64)
		o = msgp.AppendUint64(o, z.TraceID)
	}
	if (zb0001Mask & 0x40) == 0 { // if not empty
		// string "tty"
		o = append(o, 0xa3, 0x74, 0x74, 0x79)
		o = msgp.AppendString(o, z.TTYName)
	}
	// string "comm"
	o = append(o, 0xa4, 0x63, 0x6f, 0x6d, 0x6d)
	o = msgp.AppendString(o, z.Comm)
	// string "fork_time"
	o = append(o, 0xa9, 0x66, 0x6f, 0x72, 0x6b, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.ForkTime)
	// string "exit_time"
	o = append(o, 0xa9, 0x65, 0x78, 0x69, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.ExitTime)
	// string "exec_time"
	o = append(o, 0xa9, 0x65, 0x78, 0x65, 0x63, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.ExecTime)
	if (zb0001Mask & 0x800) == 0 { // if not empty
		// string "cookie"
		o = append(o, 0xa6, 0x63, 0x6f, 0x6f, 0x6b, 0x69, 0x65)
		o = msgp.AppendUint32(o, z.Cookie)
	}
	// string "ppid"
	o = append(o, 0xa4, 0x70, 0x70, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.PPid)
	// string "credentials"
	o = append(o, 0xab, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73)
	o, err = z.Credentials.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Credentials")
		return
	}
	if (zb0001Mask & 0x4000) == 0 { // if not empty
		// string "args_entry"
		o = append(o, 0xaa, 0x61, 0x72, 0x67, 0x73, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79)
		if z.ArgsEntry == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.ArgsEntry.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "ArgsEntry")
				return
			}
		}
	}
	if (zb0001Mask & 0x8000) == 0 { // if not empty
		// string "envs_entry"
		o = append(o, 0xaa, 0x65, 0x6e, 0x76, 0x73, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79)
		if z.EnvsEntry == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.EnvsEntry.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "EnvsEntry")
				return
			}
		}
	}
	// string "argv0"
	o = append(o, 0xa5, 0x61, 0x72, 0x67, 0x76, 0x30)
	o = msgp.AppendString(o, z.Argv0)
	if (zb0001Mask & 0x20000) == 0 { // if not empty
		// string "envs"
		o = append(o, 0xa4, 0x65, 0x6e, 0x76, 0x73)
		o = msgp.AppendArrayHeader(o, uint32(len(z.Envs)))
		for za0002 := range z.Envs {
			o = msgp.AppendString(o, z.Envs[za0002])
		}
	}
	if (zb0001Mask & 0x40000) == 0 { // if not empty
		// string "envs_truncated"
		o = append(o, 0xae, 0x65, 0x6e, 0x76, 0x73, 0x5f, 0x74, 0x72, 0x75, 0x6e, 0x63, 0x61, 0x74, 0x65, 0x64)
		o = msgp.AppendBool(o, z.EnvsTruncated)
	}
	if (zb0001Mask & 0x80000) == 0 { // if not empty
		// string "argv"
		o = append(o, 0xa4, 0x61, 0x72, 0x67, 0x76)
		o = msgp.AppendArrayHeader(o, uint32(len(z.ScrubbedArgv)))
		for za0003 := range z.ScrubbedArgv {
			o = msgp.AppendString(o, z.ScrubbedArgv[za0003])
		}
	}
	if (zb0001Mask & 0x100000) == 0 { // if not empty
		// string "argv_truncated"
		o = append(o, 0xae, 0x61, 0x72, 0x67, 0x76, 0x5f, 0x74, 0x72, 0x75, 0x6e, 0x63, 0x61, 0x74, 0x65, 0x64)
		o = msgp.AppendBool(o, z.ScrubbedArgsTruncated)
	}
	// string "is_thread"
	o = append(o, 0xa9, 0x69, 0x73, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64)
	o = msgp.AppendBool(o, z.IsThread)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Process) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "pid_context":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PIDContext")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "PIDContext")
					return
				}
				switch msgp.UnsafeString(field) {
				case "pid":
					z.PIDContext.Pid, bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PIDContext", "Pid")
						return
					}
				case "tid":
					z.PIDContext.Tid, bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PIDContext", "Tid")
						return
					}
				case "is_kworker":
					z.PIDContext.IsKworker, bts, err = msgp.ReadBoolBytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PIDContext", "IsKworker")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "PIDContext")
						return
					}
				}
			}
		case "file":
			bts, err = z.FileEvent.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "FileEvent")
				return
			}
		case "container_id":
			z.ContainerID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ContainerID")
				return
			}
		case "container_tags":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ContainerTags")
				return
			}
			if cap(z.ContainerTags) >= int(zb0003) {
				z.ContainerTags = (z.ContainerTags)[:zb0003]
			} else {
				z.ContainerTags = make([]string, zb0003)
			}
			for za0001 := range z.ContainerTags {
				z.ContainerTags[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ContainerTags", za0001)
					return
				}
			}
		case "span_id":
			z.SpanID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SpanID")
				return
			}
		case "trace_id":
			z.TraceID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TraceID")
				return
			}
		case "tty":
			z.TTYName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TTYName")
				return
			}
		case "comm":
			z.Comm, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Comm")
				return
			}
		case "fork_time":
			z.ForkTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ForkTime")
				return
			}
		case "exit_time":
			z.ExitTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExitTime")
				return
			}
		case "exec_time":
			z.ExecTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExecTime")
				return
			}
		case "cookie":
			z.Cookie, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Cookie")
				return
			}
		case "ppid":
			z.PPid, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PPid")
				return
			}
		case "credentials":
			bts, err = z.Credentials.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Credentials")
				return
			}
		case "args_entry":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ArgsEntry = nil
			} else {
				if z.ArgsEntry == nil {
					z.ArgsEntry = new(ArgsEntry)
				}
				bts, err = z.ArgsEntry.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ArgsEntry")
					return
				}
			}
		case "envs_entry":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.EnvsEntry = nil
			} else {
				if z.EnvsEntry == nil {
					z.EnvsEntry = new(EnvsEntry)
				}
				bts, err = z.EnvsEntry.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "EnvsEntry")
					return
				}
			}
		case "argv0":
			z.Argv0, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Argv0")
				return
			}
		case "envs":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Envs")
				return
			}
			if cap(z.Envs) >= int(zb0004) {
				z.Envs = (z.Envs)[:zb0004]
			} else {
				z.Envs = make([]string, zb0004)
			}
			for za0002 := range z.Envs {
				z.Envs[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Envs", za0002)
					return
				}
			}
		case "envs_truncated":
			z.EnvsTruncated, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EnvsTruncated")
				return
			}
		case "argv":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ScrubbedArgv")
				return
			}
			if cap(z.ScrubbedArgv) >= int(zb0005) {
				z.ScrubbedArgv = (z.ScrubbedArgv)[:zb0005]
			} else {
				z.ScrubbedArgv = make([]string, zb0005)
			}
			for za0003 := range z.ScrubbedArgv {
				z.ScrubbedArgv[za0003], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ScrubbedArgv", za0003)
					return
				}
			}
		case "argv_truncated":
			z.ScrubbedArgsTruncated, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ScrubbedArgsTruncated")
				return
			}
		case "is_thread":
			z.IsThread, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsThread")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Process) Msgsize() (s int) {
	s = 3 + 12 + 1 + 4 + msgp.Uint32Size + 4 + msgp.Uint32Size + 11 + msgp.BoolSize + 5 + z.FileEvent.Msgsize() + 13 + msgp.StringPrefixSize + len(z.ContainerID) + 15 + msgp.ArrayHeaderSize
	for za0001 := range z.ContainerTags {
		s += msgp.StringPrefixSize + len(z.ContainerTags[za0001])
	}
	s += 8 + msgp.Uint64Size + 9 + msgp.Uint64Size + 4 + msgp.StringPrefixSize + len(z.TTYName) + 5 + msgp.StringPrefixSize + len(z.Comm) + 10 + msgp.TimeSize + 10 + msgp.TimeSize + 10 + msgp.TimeSize + 7 + msgp.Uint32Size + 5 + msgp.Uint32Size + 12 + z.Credentials.Msgsize() + 11
	if z.ArgsEntry == nil {
		s += msgp.NilSize
	} else {
		s += z.ArgsEntry.Msgsize()
	}
	s += 11
	if z.EnvsEntry == nil {
		s += msgp.NilSize
	} else {
		s += z.EnvsEntry.Msgsize()
	}
	s += 6 + msgp.StringPrefixSize + len(z.Argv0) + 5 + msgp.ArrayHeaderSize
	for za0002 := range z.Envs {
		s += msgp.StringPrefixSize + len(z.Envs[za0002])
	}
	s += 15 + msgp.BoolSize + 5 + msgp.ArrayHeaderSize
	for za0003 := range z.ScrubbedArgv {
		s += msgp.StringPrefixSize + len(z.ScrubbedArgv[za0003])
	}
	s += 15 + msgp.BoolSize + 10 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProcessCacheEntry) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ProcessContext":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ProcessContext")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "ProcessContext")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Process":
					err = z.ProcessContext.Process.DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "ProcessContext", "Process")
						return
					}
				case "ancestor":
					if dc.IsNil() {
						err = dc.ReadNil()
						if err != nil {
							err = msgp.WrapError(err, "ProcessContext", "Ancestor")
							return
						}
						z.ProcessContext.Ancestor = nil
					} else {
						if z.ProcessContext.Ancestor == nil {
							z.ProcessContext.Ancestor = new(ProcessCacheEntry)
						}
						err = z.ProcessContext.Ancestor.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "ProcessContext", "Ancestor")
							return
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "ProcessContext")
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProcessCacheEntry) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "ProcessContext"
	err = en.Append(0x81, 0xae, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74)
	if err != nil {
		return
	}
	// omitempty: check for empty values
	zb0002Len := uint32(2)
	var zb0002Mask uint8 /* 2 bits */
	if z.ProcessContext.Ancestor == nil {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	// variable map header, size zb0002Len
	err = en.Append(0x80 | uint8(zb0002Len))
	if err != nil {
		return
	}
	// write "Process"
	err = en.Append(0xa7, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = z.ProcessContext.Process.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "ProcessContext", "Process")
		return
	}
	if (zb0002Mask & 0x2) == 0 { // if not empty
		// write "ancestor"
		err = en.Append(0xa8, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x74, 0x6f, 0x72)
		if err != nil {
			return
		}
		if z.ProcessContext.Ancestor == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.ProcessContext.Ancestor.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "ProcessContext", "Ancestor")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProcessCacheEntry) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "ProcessContext"
	o = append(o, 0x81, 0xae, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74)
	// omitempty: check for empty values
	zb0002Len := uint32(2)
	var zb0002Mask uint8 /* 2 bits */
	if z.ProcessContext.Ancestor == nil {
		zb0002Len--
		zb0002Mask |= 0x2
	}
	// variable map header, size zb0002Len
	o = append(o, 0x80|uint8(zb0002Len))
	// string "Process"
	o = append(o, 0xa7, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73)
	o, err = z.ProcessContext.Process.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ProcessContext", "Process")
		return
	}
	if (zb0002Mask & 0x2) == 0 { // if not empty
		// string "ancestor"
		o = append(o, 0xa8, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x74, 0x6f, 0x72)
		if z.ProcessContext.Ancestor == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.ProcessContext.Ancestor.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "ProcessContext", "Ancestor")
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProcessCacheEntry) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ProcessContext":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProcessContext")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "ProcessContext")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Process":
					bts, err = z.ProcessContext.Process.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ProcessContext", "Process")
						return
					}
				case "ancestor":
					if msgp.IsNil(bts) {
						bts, err = msgp.ReadNilBytes(bts)
						if err != nil {
							return
						}
						z.ProcessContext.Ancestor = nil
					} else {
						if z.ProcessContext.Ancestor == nil {
							z.ProcessContext.Ancestor = new(ProcessCacheEntry)
						}
						bts, err = z.ProcessContext.Ancestor.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "ProcessContext", "Ancestor")
							return
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "ProcessContext")
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProcessCacheEntry) Msgsize() (s int) {
	s = 1 + 15 + 1 + 8 + z.ProcessContext.Process.Msgsize() + 9
	if z.ProcessContext.Ancestor == nil {
		s += msgp.NilSize
	} else {
		s += z.ProcessContext.Ancestor.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProcessContext) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Process":
			err = z.Process.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Process")
				return
			}
		case "ancestor":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Ancestor")
					return
				}
				z.Ancestor = nil
			} else {
				if z.Ancestor == nil {
					z.Ancestor = new(ProcessCacheEntry)
				}
				err = z.Ancestor.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Ancestor")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProcessContext) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Ancestor == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	// write "Process"
	err = en.Append(0xa7, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = z.Process.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Process")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "ancestor"
		err = en.Append(0xa8, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x74, 0x6f, 0x72)
		if err != nil {
			return
		}
		if z.Ancestor == nil {
			err = en.WriteNil()
			if err != nil {
				return
			}
		} else {
			err = z.Ancestor.EncodeMsg(en)
			if err != nil {
				err = msgp.WrapError(err, "Ancestor")
				return
			}
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProcessContext) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.Ancestor == nil {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	// string "Process"
	o = append(o, 0xa7, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73)
	o, err = z.Process.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Process")
		return
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "ancestor"
		o = append(o, 0xa8, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x74, 0x6f, 0x72)
		if z.Ancestor == nil {
			o = msgp.AppendNil(o)
		} else {
			o, err = z.Ancestor.MarshalMsg(o)
			if err != nil {
				err = msgp.WrapError(err, "Ancestor")
				return
			}
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProcessContext) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Process":
			bts, err = z.Process.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Process")
				return
			}
		case "ancestor":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Ancestor = nil
			} else {
				if z.Ancestor == nil {
					z.Ancestor = new(ProcessCacheEntry)
				}
				bts, err = z.Ancestor.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Ancestor")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProcessContext) Msgsize() (s int) {
	s = 1 + 8 + z.Process.Msgsize() + 9
	if z.Ancestor == nil {
		s += msgp.NilSize
	} else {
		s += z.Ancestor.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SpanContext) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "span_id":
			z.SpanID, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "SpanID")
				return
			}
		case "trace_id":
			z.TraceID, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TraceID")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SpanContext) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.SpanID == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.TraceID == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "span_id"
		err = en.Append(0xa7, 0x73, 0x70, 0x61, 0x6e, 0x5f, 0x69, 0x64)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.SpanID)
		if err != nil {
			err = msgp.WrapError(err, "SpanID")
			return
		}
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// write "trace_id"
		err = en.Append(0xa8, 0x74, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x69, 0x64)
		if err != nil {
			return
		}
		err = en.WriteUint64(z.TraceID)
		if err != nil {
			err = msgp.WrapError(err, "TraceID")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SpanContext) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(2)
	var zb0001Mask uint8 /* 2 bits */
	if z.SpanID == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	if z.TraceID == 0 {
		zb0001Len--
		zb0001Mask |= 0x2
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "span_id"
		o = append(o, 0xa7, 0x73, 0x70, 0x61, 0x6e, 0x5f, 0x69, 0x64)
		o = msgp.AppendUint64(o, z.SpanID)
	}
	if (zb0001Mask & 0x2) == 0 { // if not empty
		// string "trace_id"
		o = append(o, 0xa8, 0x74, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x69, 0x64)
		o = msgp.AppendUint64(o, z.TraceID)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SpanContext) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "span_id":
			z.SpanID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SpanID")
				return
			}
		case "trace_id":
			z.TraceID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TraceID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SpanContext) Msgsize() (s int) {
	s = 1 + 8 + msgp.Uint64Size + 9 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SyscallEvent) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "retval":
			z.Retval, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Retval")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SyscallEvent) EncodeMsg(en *msgp.Writer) (err error) {
	// omitempty: check for empty values
	zb0001Len := uint32(1)
	var zb0001Mask uint8 /* 1 bits */
	if z.Retval == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	// variable map header, size zb0001Len
	err = en.Append(0x80 | uint8(zb0001Len))
	if err != nil {
		return
	}
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// write "retval"
		err = en.Append(0xa6, 0x72, 0x65, 0x74, 0x76, 0x61, 0x6c)
		if err != nil {
			return
		}
		err = en.WriteInt64(z.Retval)
		if err != nil {
			err = msgp.WrapError(err, "Retval")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SyscallEvent) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// omitempty: check for empty values
	zb0001Len := uint32(1)
	var zb0001Mask uint8 /* 1 bits */
	if z.Retval == 0 {
		zb0001Len--
		zb0001Mask |= 0x1
	}
	// variable map header, size zb0001Len
	o = append(o, 0x80|uint8(zb0001Len))
	if zb0001Len == 0 {
		return
	}
	if (zb0001Mask & 0x1) == 0 { // if not empty
		// string "retval"
		o = append(o, 0xa6, 0x72, 0x65, 0x74, 0x76, 0x61, 0x6c)
		o = msgp.AppendInt64(o, z.Retval)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SyscallEvent) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "retval":
			z.Retval, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Retval")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SyscallEvent) Msgsize() (s int) {
	s = 1 + 7 + msgp.Int64Size
	return
}
