package model

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *Credentials) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uid":
			z.UID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "UID")
				return
			}
		case "gid":
			z.GID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "GID")
				return
			}
		case "user":
			z.User, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "group":
			z.Group, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		case "euid":
			z.EUID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "EUID")
				return
			}
		case "egid":
			z.EGID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "EGID")
				return
			}
		case "euser":
			z.EUser, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EUser")
				return
			}
		case "egroup":
			z.EGroup, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EGroup")
				return
			}
		case "fsuid":
			z.FSUID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "FSUID")
				return
			}
		case "fsgid":
			z.FSGID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "FSGID")
				return
			}
		case "fsuser":
			z.FSUser, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "FSUser")
				return
			}
		case "fsgroup":
			z.FSGroup, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "FSGroup")
				return
			}
		case "cap_effective":
			z.CapEffective, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CapEffective")
				return
			}
		case "cap_permitted":
			z.CapPermitted, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CapPermitted")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Credentials) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 14
	// write "uid"
	err = en.Append(0x8e, 0xa3, 0x75, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.UID)
	if err != nil {
		err = msgp.WrapError(err, "UID")
		return
	}
	// write "gid"
	err = en.Append(0xa3, 0x67, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.GID)
	if err != nil {
		err = msgp.WrapError(err, "GID")
		return
	}
	// write "user"
	err = en.Append(0xa4, 0x75, 0x73, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.User)
	if err != nil {
		err = msgp.WrapError(err, "User")
		return
	}
	// write "group"
	err = en.Append(0xa5, 0x67, 0x72, 0x6f, 0x75, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.Group)
	if err != nil {
		err = msgp.WrapError(err, "Group")
		return
	}
	// write "euid"
	err = en.Append(0xa4, 0x65, 0x75, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.EUID)
	if err != nil {
		err = msgp.WrapError(err, "EUID")
		return
	}
	// write "egid"
	err = en.Append(0xa4, 0x65, 0x67, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.EGID)
	if err != nil {
		err = msgp.WrapError(err, "EGID")
		return
	}
	// write "euser"
	err = en.Append(0xa5, 0x65, 0x75, 0x73, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.EUser)
	if err != nil {
		err = msgp.WrapError(err, "EUser")
		return
	}
	// write "egroup"
	err = en.Append(0xa6, 0x65, 0x67, 0x72, 0x6f, 0x75, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.EGroup)
	if err != nil {
		err = msgp.WrapError(err, "EGroup")
		return
	}
	// write "fsuid"
	err = en.Append(0xa5, 0x66, 0x73, 0x75, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.FSUID)
	if err != nil {
		err = msgp.WrapError(err, "FSUID")
		return
	}
	// write "fsgid"
	err = en.Append(0xa5, 0x66, 0x73, 0x67, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.FSGID)
	if err != nil {
		err = msgp.WrapError(err, "FSGID")
		return
	}
	// write "fsuser"
	err = en.Append(0xa6, 0x66, 0x73, 0x75, 0x73, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.FSUser)
	if err != nil {
		err = msgp.WrapError(err, "FSUser")
		return
	}
	// write "fsgroup"
	err = en.Append(0xa7, 0x66, 0x73, 0x67, 0x72, 0x6f, 0x75, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.FSGroup)
	if err != nil {
		err = msgp.WrapError(err, "FSGroup")
		return
	}
	// write "cap_effective"
	err = en.Append(0xad, 0x63, 0x61, 0x70, 0x5f, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CapEffective)
	if err != nil {
		err = msgp.WrapError(err, "CapEffective")
		return
	}
	// write "cap_permitted"
	err = en.Append(0xad, 0x63, 0x61, 0x70, 0x5f, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CapPermitted)
	if err != nil {
		err = msgp.WrapError(err, "CapPermitted")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Credentials) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 14
	// string "uid"
	o = append(o, 0x8e, 0xa3, 0x75, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.UID)
	// string "gid"
	o = append(o, 0xa3, 0x67, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.GID)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	// string "group"
	o = append(o, 0xa5, 0x67, 0x72, 0x6f, 0x75, 0x70)
	o = msgp.AppendString(o, z.Group)
	// string "euid"
	o = append(o, 0xa4, 0x65, 0x75, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.EUID)
	// string "egid"
	o = append(o, 0xa4, 0x65, 0x67, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.EGID)
	// string "euser"
	o = append(o, 0xa5, 0x65, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.EUser)
	// string "egroup"
	o = append(o, 0xa6, 0x65, 0x67, 0x72, 0x6f, 0x75, 0x70)
	o = msgp.AppendString(o, z.EGroup)
	// string "fsuid"
	o = append(o, 0xa5, 0x66, 0x73, 0x75, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.FSUID)
	// string "fsgid"
	o = append(o, 0xa5, 0x66, 0x73, 0x67, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.FSGID)
	// string "fsuser"
	o = append(o, 0xa6, 0x66, 0x73, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.FSUser)
	// string "fsgroup"
	o = append(o, 0xa7, 0x66, 0x73, 0x67, 0x72, 0x6f, 0x75, 0x70)
	o = msgp.AppendString(o, z.FSGroup)
	// string "cap_effective"
	o = append(o, 0xad, 0x63, 0x61, 0x70, 0x5f, 0x65, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65)
	o = msgp.AppendUint64(o, z.CapEffective)
	// string "cap_permitted"
	o = append(o, 0xad, 0x63, 0x61, 0x70, 0x5f, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x74, 0x74, 0x65, 0x64)
	o = msgp.AppendUint64(o, z.CapPermitted)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Credentials) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uid":
			z.UID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UID")
				return
			}
		case "gid":
			z.GID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GID")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "group":
			z.Group, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		case "euid":
			z.EUID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EUID")
				return
			}
		case "egid":
			z.EGID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EGID")
				return
			}
		case "euser":
			z.EUser, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EUser")
				return
			}
		case "egroup":
			z.EGroup, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EGroup")
				return
			}
		case "fsuid":
			z.FSUID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FSUID")
				return
			}
		case "fsgid":
			z.FSGID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FSGID")
				return
			}
		case "fsuser":
			z.FSUser, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FSUser")
				return
			}
		case "fsgroup":
			z.FSGroup, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FSGroup")
				return
			}
		case "cap_effective":
			z.CapEffective, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CapEffective")
				return
			}
		case "cap_permitted":
			z.CapPermitted, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CapPermitted")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Credentials) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint32Size + 4 + msgp.Uint32Size + 5 + msgp.StringPrefixSize + len(z.User) + 6 + msgp.StringPrefixSize + len(z.Group) + 5 + msgp.Uint32Size + 5 + msgp.Uint32Size + 6 + msgp.StringPrefixSize + len(z.EUser) + 7 + msgp.StringPrefixSize + len(z.EGroup) + 6 + msgp.Uint32Size + 6 + msgp.Uint32Size + 7 + msgp.StringPrefixSize + len(z.FSUser) + 8 + msgp.StringPrefixSize + len(z.FSGroup) + 14 + msgp.Uint64Size + 14 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DNSEvent) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "type":
			z.Type, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "class":
			z.Class, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "Class")
				return
			}
		case "size":
			z.Size, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "count":
			z.Count, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DNSEvent) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "name"
	err = en.Append(0x85, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "type"
	err = en.Append(0xa4, 0x74, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "class"
	err = en.Append(0xa5, 0x63, 0x6c, 0x61, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.Class)
	if err != nil {
		err = msgp.WrapError(err, "Class")
		return
	}
	// write "size"
	err = en.Append(0xa4, 0x73, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.Size)
	if err != nil {
		err = msgp.WrapError(err, "Size")
		return
	}
	// write "count"
	err = en.Append(0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.Count)
	if err != nil {
		err = msgp.WrapError(err, "Count")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DNSEvent) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "name"
	o = append(o, 0x85, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "type"
	o = append(o, 0xa4, 0x74, 0x79, 0x70, 0x65)
	o = msgp.AppendUint16(o, z.Type)
	// string "class"
	o = append(o, 0xa5, 0x63, 0x6c, 0x61, 0x73, 0x73)
	o = msgp.AppendUint16(o, z.Class)
	// string "size"
	o = append(o, 0xa4, 0x73, 0x69, 0x7a, 0x65)
	o = msgp.AppendUint16(o, z.Size)
	// string "count"
	o = append(o, 0xa5, 0x63, 0x6f, 0x75, 0x6e, 0x74)
	o = msgp.AppendUint16(o, z.Count)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DNSEvent) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "type":
			z.Type, bts, err = msgp.ReadUint16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "class":
			z.Class, bts, err = msgp.ReadUint16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Class")
				return
			}
		case "size":
			z.Size, bts, err = msgp.ReadUint16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Size")
				return
			}
		case "count":
			z.Count, bts, err = msgp.ReadUint16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Count")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DNSEvent) Msgsize() (s int) {
	s = 1 + 5 + msgp.StringPrefixSize + len(z.Name) + 5 + msgp.Uint16Size + 6 + msgp.Uint16Size + 5 + msgp.Uint16Size + 6 + msgp.Uint16Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *FileEvent) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "FileFields":
			err = z.FileFields.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "FileFields")
				return
			}
		case "path":
			z.PathnameStr, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "PathnameStr")
				return
			}
		case "name":
			z.BasenameStr, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BasenameStr")
				return
			}
		case "filesystem":
			z.Filesystem, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Filesystem")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *FileEvent) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "FileFields"
	err = en.Append(0x84, 0xaa, 0x46, 0x69, 0x6c, 0x65, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73)
	if err != nil {
		return
	}
	err = z.FileFields.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "FileFields")
		return
	}
	// write "path"
	err = en.Append(0xa4, 0x70, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.PathnameStr)
	if err != nil {
		err = msgp.WrapError(err, "PathnameStr")
		return
	}
	// write "name"
	err = en.Append(0xa4, 0x6e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.BasenameStr)
	if err != nil {
		err = msgp.WrapError(err, "BasenameStr")
		return
	}
	// write "filesystem"
	err = en.Append(0xaa, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.Filesystem)
	if err != nil {
		err = msgp.WrapError(err, "Filesystem")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FileEvent) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "FileFields"
	o = append(o, 0x84, 0xaa, 0x46, 0x69, 0x6c, 0x65, 0x46, 0x69, 0x65, 0x6c, 0x64, 0x73)
	o, err = z.FileFields.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "FileFields")
		return
	}
	// string "path"
	o = append(o, 0xa4, 0x70, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.PathnameStr)
	// string "name"
	o = append(o, 0xa4, 0x6e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.BasenameStr)
	// string "filesystem"
	o = append(o, 0xaa, 0x66, 0x69, 0x6c, 0x65, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d)
	o = msgp.AppendString(o, z.Filesystem)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FileEvent) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "FileFields":
			bts, err = z.FileFields.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "FileFields")
				return
			}
		case "path":
			z.PathnameStr, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PathnameStr")
				return
			}
		case "name":
			z.BasenameStr, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BasenameStr")
				return
			}
		case "filesystem":
			z.Filesystem, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Filesystem")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FileEvent) Msgsize() (s int) {
	s = 1 + 11 + z.FileFields.Msgsize() + 5 + msgp.StringPrefixSize + len(z.PathnameStr) + 5 + msgp.StringPrefixSize + len(z.BasenameStr) + 11 + msgp.StringPrefixSize + len(z.Filesystem)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *FileFields) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uid":
			z.UID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "UID")
				return
			}
		case "user":
			z.User, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "gid":
			z.GID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "GID")
				return
			}
		case "group":
			z.Group, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		case "mode":
			z.Mode, err = dc.ReadUint16()
			if err != nil {
				err = msgp.WrapError(err, "Mode")
				return
			}
		case "ctime":
			z.CTime, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CTime")
				return
			}
		case "mtime":
			z.MTime, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "MTime")
				return
			}
		case "mount_id":
			z.MountID, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "MountID")
				return
			}
		case "inode":
			z.Inode, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "Inode")
				return
			}
		case "in_upper_layer":
			z.InUpperLayer, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "InUpperLayer")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *FileFields) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 10
	// write "uid"
	err = en.Append(0x8a, 0xa3, 0x75, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.UID)
	if err != nil {
		err = msgp.WrapError(err, "UID")
		return
	}
	// write "user"
	err = en.Append(0xa4, 0x75, 0x73, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.User)
	if err != nil {
		err = msgp.WrapError(err, "User")
		return
	}
	// write "gid"
	err = en.Append(0xa3, 0x67, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.GID)
	if err != nil {
		err = msgp.WrapError(err, "GID")
		return
	}
	// write "group"
	err = en.Append(0xa5, 0x67, 0x72, 0x6f, 0x75, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.Group)
	if err != nil {
		err = msgp.WrapError(err, "Group")
		return
	}
	// write "mode"
	err = en.Append(0xa4, 0x6d, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint16(z.Mode)
	if err != nil {
		err = msgp.WrapError(err, "Mode")
		return
	}
	// write "ctime"
	err = en.Append(0xa5, 0x63, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CTime)
	if err != nil {
		err = msgp.WrapError(err, "CTime")
		return
	}
	// write "mtime"
	err = en.Append(0xa5, 0x6d, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.MTime)
	if err != nil {
		err = msgp.WrapError(err, "MTime")
		return
	}
	// write "mount_id"
	err = en.Append(0xa8, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.MountID)
	if err != nil {
		err = msgp.WrapError(err, "MountID")
		return
	}
	// write "inode"
	err = en.Append(0xa5, 0x69, 0x6e, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.Inode)
	if err != nil {
		err = msgp.WrapError(err, "Inode")
		return
	}
	// write "in_upper_layer"
	err = en.Append(0xae, 0x69, 0x6e, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBool(z.InUpperLayer)
	if err != nil {
		err = msgp.WrapError(err, "InUpperLayer")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *FileFields) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 10
	// string "uid"
	o = append(o, 0x8a, 0xa3, 0x75, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.UID)
	// string "user"
	o = append(o, 0xa4, 0x75, 0x73, 0x65, 0x72)
	o = msgp.AppendString(o, z.User)
	// string "gid"
	o = append(o, 0xa3, 0x67, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.GID)
	// string "group"
	o = append(o, 0xa5, 0x67, 0x72, 0x6f, 0x75, 0x70)
	o = msgp.AppendString(o, z.Group)
	// string "mode"
	o = append(o, 0xa4, 0x6d, 0x6f, 0x64, 0x65)
	o = msgp.AppendUint16(o, z.Mode)
	// string "ctime"
	o = append(o, 0xa5, 0x63, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendUint64(o, z.CTime)
	// string "mtime"
	o = append(o, 0xa5, 0x6d, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendUint64(o, z.MTime)
	// string "mount_id"
	o = append(o, 0xa8, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x5f, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.MountID)
	// string "inode"
	o = append(o, 0xa5, 0x69, 0x6e, 0x6f, 0x64, 0x65)
	o = msgp.AppendUint64(o, z.Inode)
	// string "in_upper_layer"
	o = append(o, 0xae, 0x69, 0x6e, 0x5f, 0x75, 0x70, 0x70, 0x65, 0x72, 0x5f, 0x6c, 0x61, 0x79, 0x65, 0x72)
	o = msgp.AppendBool(o, z.InUpperLayer)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *FileFields) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "uid":
			z.UID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UID")
				return
			}
		case "user":
			z.User, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "User")
				return
			}
		case "gid":
			z.GID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GID")
				return
			}
		case "group":
			z.Group, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		case "mode":
			z.Mode, bts, err = msgp.ReadUint16Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mode")
				return
			}
		case "ctime":
			z.CTime, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CTime")
				return
			}
		case "mtime":
			z.MTime, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MTime")
				return
			}
		case "mount_id":
			z.MountID, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MountID")
				return
			}
		case "inode":
			z.Inode, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Inode")
				return
			}
		case "in_upper_layer":
			z.InUpperLayer, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InUpperLayer")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *FileFields) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint32Size + 5 + msgp.StringPrefixSize + len(z.User) + 4 + msgp.Uint32Size + 6 + msgp.StringPrefixSize + len(z.Group) + 5 + msgp.Uint16Size + 6 + msgp.Uint64Size + 6 + msgp.Uint64Size + 9 + msgp.Uint32Size + 6 + msgp.Uint64Size + 15 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PIDContext) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "pid":
			z.Pid, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Pid")
				return
			}
		case "tid":
			z.Tid, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Tid")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z PIDContext) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "pid"
	err = en.Append(0x82, 0xa3, 0x70, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Pid)
	if err != nil {
		err = msgp.WrapError(err, "Pid")
		return
	}
	// write "tid"
	err = en.Append(0xa3, 0x74, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Tid)
	if err != nil {
		err = msgp.WrapError(err, "Tid")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PIDContext) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "pid"
	o = append(o, 0x82, 0xa3, 0x70, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.Pid)
	// string "tid"
	o = append(o, 0xa3, 0x74, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.Tid)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PIDContext) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "pid":
			z.Pid, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Pid")
				return
			}
		case "tid":
			z.Tid, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tid")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PIDContext) Msgsize() (s int) {
	s = 1 + 4 + msgp.Uint32Size + 4 + msgp.Uint32Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Process) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "PIDContext":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "PIDContext")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "PIDContext")
					return
				}
				switch msgp.UnsafeString(field) {
				case "pid":
					z.PIDContext.Pid, err = dc.ReadUint32()
					if err != nil {
						err = msgp.WrapError(err, "PIDContext", "Pid")
						return
					}
				case "tid":
					z.PIDContext.Tid, err = dc.ReadUint32()
					if err != nil {
						err = msgp.WrapError(err, "PIDContext", "Tid")
						return
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "PIDContext")
						return
					}
				}
			}
		case "file":
			err = z.FileEvent.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "FileEvent")
				return
			}
		case "container_id":
			z.ContainerID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ContainerID")
				return
			}
		case "container_tags":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ContainerTags")
				return
			}
			if cap(z.ContainerTags) >= int(zb0003) {
				z.ContainerTags = (z.ContainerTags)[:zb0003]
			} else {
				z.ContainerTags = make([]string, zb0003)
			}
			for za0001 := range z.ContainerTags {
				z.ContainerTags[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ContainerTags", za0001)
					return
				}
			}
		case "span_id":
			z.SpanID, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "SpanID")
				return
			}
		case "trace_id":
			z.TraceID, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TraceID")
				return
			}
		case "tty":
			z.TTYName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "TTYName")
				return
			}
		case "comm":
			z.Comm, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Comm")
				return
			}
		case "fork_time":
			z.ForkTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "ForkTime")
				return
			}
		case "exit_time":
			z.ExitTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "ExitTime")
				return
			}
		case "exec_time":
			z.ExecTime, err = dc.ReadTime()
			if err != nil {
				err = msgp.WrapError(err, "ExecTime")
				return
			}
		case "created_at":
			z.CreatedAt, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "CreatedAt")
				return
			}
		case "cookie":
			z.Cookie, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "Cookie")
				return
			}
		case "ppid":
			z.PPid, err = dc.ReadUint32()
			if err != nil {
				err = msgp.WrapError(err, "PPid")
				return
			}
		case "credentials":
			err = z.Credentials.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Credentials")
				return
			}
		case "args":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "ArgsEntry")
					return
				}
				z.ArgsEntry = nil
			} else {
				if z.ArgsEntry == nil {
					z.ArgsEntry = new(ArgsEntry)
				}
				err = z.ArgsEntry.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "ArgsEntry")
					return
				}
			}
		case "envs":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "EnvsEntry")
					return
				}
				z.EnvsEntry = nil
			} else {
				if z.EnvsEntry == nil {
					z.EnvsEntry = new(EnvsEntry)
				}
				err = z.EnvsEntry.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "EnvsEntry")
					return
				}
			}
		case "is_thread":
			z.IsThread, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsThread")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Process) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 18
	// write "PIDContext"
	err = en.Append(0xde, 0x0, 0x12, 0xaa, 0x50, 0x49, 0x44, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74)
	if err != nil {
		return
	}
	// map header, size 2
	// write "pid"
	err = en.Append(0x82, 0xa3, 0x70, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.PIDContext.Pid)
	if err != nil {
		err = msgp.WrapError(err, "PIDContext", "Pid")
		return
	}
	// write "tid"
	err = en.Append(0xa3, 0x74, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.PIDContext.Tid)
	if err != nil {
		err = msgp.WrapError(err, "PIDContext", "Tid")
		return
	}
	// write "file"
	err = en.Append(0xa4, 0x66, 0x69, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = z.FileEvent.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "FileEvent")
		return
	}
	// write "container_id"
	err = en.Append(0xac, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteString(z.ContainerID)
	if err != nil {
		err = msgp.WrapError(err, "ContainerID")
		return
	}
	// write "container_tags"
	err = en.Append(0xae, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x74, 0x61, 0x67, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ContainerTags)))
	if err != nil {
		err = msgp.WrapError(err, "ContainerTags")
		return
	}
	for za0001 := range z.ContainerTags {
		err = en.WriteString(z.ContainerTags[za0001])
		if err != nil {
			err = msgp.WrapError(err, "ContainerTags", za0001)
			return
		}
	}
	// write "span_id"
	err = en.Append(0xa7, 0x73, 0x70, 0x61, 0x6e, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.SpanID)
	if err != nil {
		err = msgp.WrapError(err, "SpanID")
		return
	}
	// write "trace_id"
	err = en.Append(0xa8, 0x74, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TraceID)
	if err != nil {
		err = msgp.WrapError(err, "TraceID")
		return
	}
	// write "tty"
	err = en.Append(0xa3, 0x74, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.TTYName)
	if err != nil {
		err = msgp.WrapError(err, "TTYName")
		return
	}
	// write "comm"
	err = en.Append(0xa4, 0x63, 0x6f, 0x6d, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.Comm)
	if err != nil {
		err = msgp.WrapError(err, "Comm")
		return
	}
	// write "fork_time"
	err = en.Append(0xa9, 0x66, 0x6f, 0x72, 0x6b, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.ForkTime)
	if err != nil {
		err = msgp.WrapError(err, "ForkTime")
		return
	}
	// write "exit_time"
	err = en.Append(0xa9, 0x65, 0x78, 0x69, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.ExitTime)
	if err != nil {
		err = msgp.WrapError(err, "ExitTime")
		return
	}
	// write "exec_time"
	err = en.Append(0xa9, 0x65, 0x78, 0x65, 0x63, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteTime(z.ExecTime)
	if err != nil {
		err = msgp.WrapError(err, "ExecTime")
		return
	}
	// write "created_at"
	err = en.Append(0xaa, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.CreatedAt)
	if err != nil {
		err = msgp.WrapError(err, "CreatedAt")
		return
	}
	// write "cookie"
	err = en.Append(0xa6, 0x63, 0x6f, 0x6f, 0x6b, 0x69, 0x65)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.Cookie)
	if err != nil {
		err = msgp.WrapError(err, "Cookie")
		return
	}
	// write "ppid"
	err = en.Append(0xa4, 0x70, 0x70, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint32(z.PPid)
	if err != nil {
		err = msgp.WrapError(err, "PPid")
		return
	}
	// write "credentials"
	err = en.Append(0xab, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73)
	if err != nil {
		return
	}
	err = z.Credentials.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Credentials")
		return
	}
	// write "args"
	err = en.Append(0xa4, 0x61, 0x72, 0x67, 0x73)
	if err != nil {
		return
	}
	if z.ArgsEntry == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.ArgsEntry.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "ArgsEntry")
			return
		}
	}
	// write "envs"
	err = en.Append(0xa4, 0x65, 0x6e, 0x76, 0x73)
	if err != nil {
		return
	}
	if z.EnvsEntry == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.EnvsEntry.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "EnvsEntry")
			return
		}
	}
	// write "is_thread"
	err = en.Append(0xa9, 0x69, 0x73, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsThread)
	if err != nil {
		err = msgp.WrapError(err, "IsThread")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Process) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 18
	// string "PIDContext"
	o = append(o, 0xde, 0x0, 0x12, 0xaa, 0x50, 0x49, 0x44, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74)
	// map header, size 2
	// string "pid"
	o = append(o, 0x82, 0xa3, 0x70, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.PIDContext.Pid)
	// string "tid"
	o = append(o, 0xa3, 0x74, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.PIDContext.Tid)
	// string "file"
	o = append(o, 0xa4, 0x66, 0x69, 0x6c, 0x65)
	o, err = z.FileEvent.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "FileEvent")
		return
	}
	// string "container_id"
	o = append(o, 0xac, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x69, 0x64)
	o = msgp.AppendString(o, z.ContainerID)
	// string "container_tags"
	o = append(o, 0xae, 0x63, 0x6f, 0x6e, 0x74, 0x61, 0x69, 0x6e, 0x65, 0x72, 0x5f, 0x74, 0x61, 0x67, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ContainerTags)))
	for za0001 := range z.ContainerTags {
		o = msgp.AppendString(o, z.ContainerTags[za0001])
	}
	// string "span_id"
	o = append(o, 0xa7, 0x73, 0x70, 0x61, 0x6e, 0x5f, 0x69, 0x64)
	o = msgp.AppendUint64(o, z.SpanID)
	// string "trace_id"
	o = append(o, 0xa8, 0x74, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x69, 0x64)
	o = msgp.AppendUint64(o, z.TraceID)
	// string "tty"
	o = append(o, 0xa3, 0x74, 0x74, 0x79)
	o = msgp.AppendString(o, z.TTYName)
	// string "comm"
	o = append(o, 0xa4, 0x63, 0x6f, 0x6d, 0x6d)
	o = msgp.AppendString(o, z.Comm)
	// string "fork_time"
	o = append(o, 0xa9, 0x66, 0x6f, 0x72, 0x6b, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.ForkTime)
	// string "exit_time"
	o = append(o, 0xa9, 0x65, 0x78, 0x69, 0x74, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.ExitTime)
	// string "exec_time"
	o = append(o, 0xa9, 0x65, 0x78, 0x65, 0x63, 0x5f, 0x74, 0x69, 0x6d, 0x65)
	o = msgp.AppendTime(o, z.ExecTime)
	// string "created_at"
	o = append(o, 0xaa, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x5f, 0x61, 0x74)
	o = msgp.AppendUint64(o, z.CreatedAt)
	// string "cookie"
	o = append(o, 0xa6, 0x63, 0x6f, 0x6f, 0x6b, 0x69, 0x65)
	o = msgp.AppendUint32(o, z.Cookie)
	// string "ppid"
	o = append(o, 0xa4, 0x70, 0x70, 0x69, 0x64)
	o = msgp.AppendUint32(o, z.PPid)
	// string "credentials"
	o = append(o, 0xab, 0x63, 0x72, 0x65, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x61, 0x6c, 0x73)
	o, err = z.Credentials.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Credentials")
		return
	}
	// string "args"
	o = append(o, 0xa4, 0x61, 0x72, 0x67, 0x73)
	if z.ArgsEntry == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.ArgsEntry.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "ArgsEntry")
			return
		}
	}
	// string "envs"
	o = append(o, 0xa4, 0x65, 0x6e, 0x76, 0x73)
	if z.EnvsEntry == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.EnvsEntry.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "EnvsEntry")
			return
		}
	}
	// string "is_thread"
	o = append(o, 0xa9, 0x69, 0x73, 0x5f, 0x74, 0x68, 0x72, 0x65, 0x61, 0x64)
	o = msgp.AppendBool(o, z.IsThread)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Process) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "PIDContext":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PIDContext")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "PIDContext")
					return
				}
				switch msgp.UnsafeString(field) {
				case "pid":
					z.PIDContext.Pid, bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PIDContext", "Pid")
						return
					}
				case "tid":
					z.PIDContext.Tid, bts, err = msgp.ReadUint32Bytes(bts)
					if err != nil {
						err = msgp.WrapError(err, "PIDContext", "Tid")
						return
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "PIDContext")
						return
					}
				}
			}
		case "file":
			bts, err = z.FileEvent.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "FileEvent")
				return
			}
		case "container_id":
			z.ContainerID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ContainerID")
				return
			}
		case "container_tags":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ContainerTags")
				return
			}
			if cap(z.ContainerTags) >= int(zb0003) {
				z.ContainerTags = (z.ContainerTags)[:zb0003]
			} else {
				z.ContainerTags = make([]string, zb0003)
			}
			for za0001 := range z.ContainerTags {
				z.ContainerTags[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ContainerTags", za0001)
					return
				}
			}
		case "span_id":
			z.SpanID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SpanID")
				return
			}
		case "trace_id":
			z.TraceID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TraceID")
				return
			}
		case "tty":
			z.TTYName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TTYName")
				return
			}
		case "comm":
			z.Comm, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Comm")
				return
			}
		case "fork_time":
			z.ForkTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ForkTime")
				return
			}
		case "exit_time":
			z.ExitTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExitTime")
				return
			}
		case "exec_time":
			z.ExecTime, bts, err = msgp.ReadTimeBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExecTime")
				return
			}
		case "created_at":
			z.CreatedAt, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CreatedAt")
				return
			}
		case "cookie":
			z.Cookie, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Cookie")
				return
			}
		case "ppid":
			z.PPid, bts, err = msgp.ReadUint32Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PPid")
				return
			}
		case "credentials":
			bts, err = z.Credentials.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Credentials")
				return
			}
		case "args":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ArgsEntry = nil
			} else {
				if z.ArgsEntry == nil {
					z.ArgsEntry = new(ArgsEntry)
				}
				bts, err = z.ArgsEntry.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "ArgsEntry")
					return
				}
			}
		case "envs":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.EnvsEntry = nil
			} else {
				if z.EnvsEntry == nil {
					z.EnvsEntry = new(EnvsEntry)
				}
				bts, err = z.EnvsEntry.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "EnvsEntry")
					return
				}
			}
		case "is_thread":
			z.IsThread, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsThread")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Process) Msgsize() (s int) {
	s = 3 + 11 + 1 + 4 + msgp.Uint32Size + 4 + msgp.Uint32Size + 5 + z.FileEvent.Msgsize() + 13 + msgp.StringPrefixSize + len(z.ContainerID) + 15 + msgp.ArrayHeaderSize
	for za0001 := range z.ContainerTags {
		s += msgp.StringPrefixSize + len(z.ContainerTags[za0001])
	}
	s += 8 + msgp.Uint64Size + 9 + msgp.Uint64Size + 4 + msgp.StringPrefixSize + len(z.TTYName) + 5 + msgp.StringPrefixSize + len(z.Comm) + 10 + msgp.TimeSize + 10 + msgp.TimeSize + 10 + msgp.TimeSize + 11 + msgp.Uint64Size + 7 + msgp.Uint32Size + 5 + msgp.Uint32Size + 12 + z.Credentials.Msgsize() + 5
	if z.ArgsEntry == nil {
		s += msgp.NilSize
	} else {
		s += z.ArgsEntry.Msgsize()
	}
	s += 5
	if z.EnvsEntry == nil {
		s += msgp.NilSize
	} else {
		s += z.EnvsEntry.Msgsize()
	}
	s += 10 + msgp.BoolSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProcessCacheEntry) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ProcessContext":
			var zb0002 uint32
			zb0002, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "ProcessContext")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, err = dc.ReadMapKeyPtr()
				if err != nil {
					err = msgp.WrapError(err, "ProcessContext")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Process":
					err = z.ProcessContext.Process.DecodeMsg(dc)
					if err != nil {
						err = msgp.WrapError(err, "ProcessContext", "Process")
						return
					}
				case "ancestor":
					if dc.IsNil() {
						err = dc.ReadNil()
						if err != nil {
							err = msgp.WrapError(err, "ProcessContext", "Ancestor")
							return
						}
						z.ProcessContext.Ancestor = nil
					} else {
						if z.ProcessContext.Ancestor == nil {
							z.ProcessContext.Ancestor = new(ProcessCacheEntry)
						}
						err = z.ProcessContext.Ancestor.DecodeMsg(dc)
						if err != nil {
							err = msgp.WrapError(err, "ProcessContext", "Ancestor")
							return
						}
					}
				default:
					err = dc.Skip()
					if err != nil {
						err = msgp.WrapError(err, "ProcessContext")
						return
					}
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProcessCacheEntry) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "ProcessContext"
	err = en.Append(0x81, 0xae, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74)
	if err != nil {
		return
	}
	// map header, size 2
	// write "Process"
	err = en.Append(0x82, 0xa7, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = z.ProcessContext.Process.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "ProcessContext", "Process")
		return
	}
	// write "ancestor"
	err = en.Append(0xa8, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x74, 0x6f, 0x72)
	if err != nil {
		return
	}
	if z.ProcessContext.Ancestor == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.ProcessContext.Ancestor.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "ProcessContext", "Ancestor")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProcessCacheEntry) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "ProcessContext"
	o = append(o, 0x81, 0xae, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74)
	// map header, size 2
	// string "Process"
	o = append(o, 0x82, 0xa7, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73)
	o, err = z.ProcessContext.Process.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "ProcessContext", "Process")
		return
	}
	// string "ancestor"
	o = append(o, 0xa8, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x74, 0x6f, 0x72)
	if z.ProcessContext.Ancestor == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.ProcessContext.Ancestor.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "ProcessContext", "Ancestor")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProcessCacheEntry) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ProcessContext":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ProcessContext")
				return
			}
			for zb0002 > 0 {
				zb0002--
				field, bts, err = msgp.ReadMapKeyZC(bts)
				if err != nil {
					err = msgp.WrapError(err, "ProcessContext")
					return
				}
				switch msgp.UnsafeString(field) {
				case "Process":
					bts, err = z.ProcessContext.Process.UnmarshalMsg(bts)
					if err != nil {
						err = msgp.WrapError(err, "ProcessContext", "Process")
						return
					}
				case "ancestor":
					if msgp.IsNil(bts) {
						bts, err = msgp.ReadNilBytes(bts)
						if err != nil {
							return
						}
						z.ProcessContext.Ancestor = nil
					} else {
						if z.ProcessContext.Ancestor == nil {
							z.ProcessContext.Ancestor = new(ProcessCacheEntry)
						}
						bts, err = z.ProcessContext.Ancestor.UnmarshalMsg(bts)
						if err != nil {
							err = msgp.WrapError(err, "ProcessContext", "Ancestor")
							return
						}
					}
				default:
					bts, err = msgp.Skip(bts)
					if err != nil {
						err = msgp.WrapError(err, "ProcessContext")
						return
					}
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProcessCacheEntry) Msgsize() (s int) {
	s = 1 + 15 + 1 + 8 + z.ProcessContext.Process.Msgsize() + 9
	if z.ProcessContext.Ancestor == nil {
		s += msgp.NilSize
	} else {
		s += z.ProcessContext.Ancestor.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ProcessContext) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Process":
			err = z.Process.DecodeMsg(dc)
			if err != nil {
				err = msgp.WrapError(err, "Process")
				return
			}
		case "ancestor":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Ancestor")
					return
				}
				z.Ancestor = nil
			} else {
				if z.Ancestor == nil {
					z.Ancestor = new(ProcessCacheEntry)
				}
				err = z.Ancestor.DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Ancestor")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ProcessContext) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "Process"
	err = en.Append(0x82, 0xa7, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = z.Process.EncodeMsg(en)
	if err != nil {
		err = msgp.WrapError(err, "Process")
		return
	}
	// write "ancestor"
	err = en.Append(0xa8, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x74, 0x6f, 0x72)
	if err != nil {
		return
	}
	if z.Ancestor == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = z.Ancestor.EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Ancestor")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ProcessContext) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Process"
	o = append(o, 0x82, 0xa7, 0x50, 0x72, 0x6f, 0x63, 0x65, 0x73, 0x73)
	o, err = z.Process.MarshalMsg(o)
	if err != nil {
		err = msgp.WrapError(err, "Process")
		return
	}
	// string "ancestor"
	o = append(o, 0xa8, 0x61, 0x6e, 0x63, 0x65, 0x73, 0x74, 0x6f, 0x72)
	if z.Ancestor == nil {
		o = msgp.AppendNil(o)
	} else {
		o, err = z.Ancestor.MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Ancestor")
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ProcessContext) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Process":
			bts, err = z.Process.UnmarshalMsg(bts)
			if err != nil {
				err = msgp.WrapError(err, "Process")
				return
			}
		case "ancestor":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Ancestor = nil
			} else {
				if z.Ancestor == nil {
					z.Ancestor = new(ProcessCacheEntry)
				}
				bts, err = z.Ancestor.UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Ancestor")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ProcessContext) Msgsize() (s int) {
	s = 1 + 8 + z.Process.Msgsize() + 9
	if z.Ancestor == nil {
		s += msgp.NilSize
	} else {
		s += z.Ancestor.Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SpanContext) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "span_id":
			z.SpanID, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "SpanID")
				return
			}
		case "trace_id":
			z.TraceID, err = dc.ReadUint64()
			if err != nil {
				err = msgp.WrapError(err, "TraceID")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SpanContext) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "span_id"
	err = en.Append(0x82, 0xa7, 0x73, 0x70, 0x61, 0x6e, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.SpanID)
	if err != nil {
		err = msgp.WrapError(err, "SpanID")
		return
	}
	// write "trace_id"
	err = en.Append(0xa8, 0x74, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x69, 0x64)
	if err != nil {
		return
	}
	err = en.WriteUint64(z.TraceID)
	if err != nil {
		err = msgp.WrapError(err, "TraceID")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SpanContext) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "span_id"
	o = append(o, 0x82, 0xa7, 0x73, 0x70, 0x61, 0x6e, 0x5f, 0x69, 0x64)
	o = msgp.AppendUint64(o, z.SpanID)
	// string "trace_id"
	o = append(o, 0xa8, 0x74, 0x72, 0x61, 0x63, 0x65, 0x5f, 0x69, 0x64)
	o = msgp.AppendUint64(o, z.TraceID)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SpanContext) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "span_id":
			z.SpanID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SpanID")
				return
			}
		case "trace_id":
			z.TraceID, bts, err = msgp.ReadUint64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TraceID")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SpanContext) Msgsize() (s int) {
	s = 1 + 8 + msgp.Uint64Size + 9 + msgp.Uint64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SyscallEvent) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "retval":
			z.Retval, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Retval")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SyscallEvent) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "retval"
	err = en.Append(0x81, 0xa6, 0x72, 0x65, 0x74, 0x76, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Retval)
	if err != nil {
		err = msgp.WrapError(err, "Retval")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SyscallEvent) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "retval"
	o = append(o, 0x81, 0xa6, 0x72, 0x65, 0x74, 0x76, 0x61, 0x6c)
	o = msgp.AppendInt64(o, z.Retval)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SyscallEvent) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "retval":
			z.Retval, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Retval")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SyscallEvent) Msgsize() (s int) {
	s = 1 + 7 + msgp.Int64Size
	return
}
