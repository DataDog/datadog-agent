// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2025-present Datadog, Inc.

use std::io::{BufRead, BufReader};

use crate::{
    procfs::Cmdline,
    service_name::{DetectionContext, ServiceNameMetadata},
};

pub fn extract_name(cmdline: &Cmdline, ctx: &mut DetectionContext) -> Option<ServiceNameMetadata> {
    maybe_extract_from_modname(ctx).or_else(|| maybe_extract_from_puma_cmdline(cmdline))
}

fn maybe_extract_from_puma_cmdline(cmdline: &Cmdline) -> Option<ServiceNameMetadata> {
    if cmdline.is_empty() {
        return None;
    }

    let mut last = cmdline.args().last()?.chars().peekable();
    if last.next()? != '[' || last.next_back()? != ']' || last.peek().is_none() {
        return None;
    }

    let name = last.collect::<String>();
    Some(ServiceNameMetadata::new(
        name,
        super::ServiceNameSource::CommandLine,
    ))
}

/// Checks if the service is a Rails application by looking for a
/// `config/application.rb` file generated by `rails new` when a new rails
/// project is created. This file should contain a `module` declaration with the
/// application name.
fn maybe_extract_from_modname(ctx: &mut DetectionContext) -> Option<ServiceNameMetadata> {
    let application_rb = ctx.resolve_working_dir_relative_path("config/application.rb")?;
    let application_rb = ctx.fs.open(application_rb).ok()?;
    let application_rb = BufReader::new(application_rb.verify(None).ok()?);

    application_rb
        .lines()
        .map_while(Result::ok)
        .find_map(|line| parse_module_line(&line))
        .map(|name| ServiceNameMetadata::new(name, super::ServiceNameSource::Rails))
}

/// Tries to parse a line in the format of "module Name", extracting the name
/// if the line is formated correctly.
fn parse_module_line(line: &str) -> Option<String> {
    // Strip leading whitespaces, and check the line starts with "module". If
    // so, make a characters iterator.
    let mut chars = line.trim_start().strip_prefix("module")?.chars();

    // Check there is at least one whitespace between "module" and its name. If
    // so, skip all the whitespaces. skip_while creates a new iterator, hence
    // the shadowing of chars.
    if !chars.next()?.is_whitespace() {
        return None;
    }
    let mut chars = chars.skip_while(|c| c.is_whitespace());

    let first = chars.next()?;
    if !first.is_ascii_uppercase() {
        return None;
    }

    let name: String = std::iter::once(first)
        .chain(chars.take_while(|&c| c.is_ascii_alphanumeric() || c == '_'))
        .collect();

    Some(to_snake_case(&name))
}

/// Converts a CamelCase or PascalCase string to snake_case.
/// Handles acronyms correctly (e.g., HTTPServer -> http_server).
fn to_snake_case(s: &str) -> String {
    let mut result = String::with_capacity(s.len() + 4); // Pre-allocate with some buffer
    let mut chars = s.chars().peekable();
    let mut prev_is_lower = false;
    let mut prev_is_underscore = false;

    while let Some(c) = chars.next() {
        if c.is_ascii_uppercase() {
            let is_first = result.is_empty();
            let next_is_lower = chars.peek().is_some_and(|&nc| nc.is_ascii_lowercase());

            // Add underscore if not first, not after an underscore, and either:
            // - Previous char was lowercase (camelCase boundary) OR
            // - Next char is lowercase (end of acronym like HTTPServer)
            if !is_first && !prev_is_underscore && (prev_is_lower || next_is_lower) {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
            prev_is_lower = false;
            prev_is_underscore = false;
        } else {
            result.push(c);
            prev_is_lower = c.is_ascii_lowercase();
            prev_is_underscore = c == '_';
        }
    }

    result
}

#[cfg(test)]
#[allow(clippy::unwrap_used, clippy::expect_used)]
mod tests {
    use crate::test_utils::TestDataFs;
    use crate::{cmdline, fs::SubDirFs, service_name::ServiceNameSource};
    use std::{collections::HashMap, path::Path};
    use tempfile::TempDir;

    use super::*;

    fn test_tmp_ctx(path: impl AsRef<Path>) -> (HashMap<String, String>, SubDirFs) {
        let fs = SubDirFs::new(path.as_ref()).expect("Failed to create SubDirFs");
        let mut envs = HashMap::new();
        // Set PWD so that resolve_working_dir_relative_path can find files
        envs.insert("PWD".to_string(), "/".to_string());
        (envs, fs)
    }

    fn test_data_ctx() -> (HashMap<String, String>, TestDataFs) {
        let fs = TestDataFs::new("ruby/rails");
        let mut envs = HashMap::new();
        // Set PWD so that resolve_working_dir_relative_path can find files
        envs.insert("PWD".to_string(), "/".to_string());
        (envs, fs)
    }

    #[test]
    fn name_from_modname() {
        let (envs, fs) = test_data_ctx();
        let mut ctx = DetectionContext::new(0, envs, fs.as_ref());
        let cmdline = cmdline!["/usr/bin/ruby", "foo", "bar"];
        let result = extract_name(&cmdline, &mut ctx);

        assert!(result.is_some());

        let result = result.unwrap();
        assert_eq!(result.name, "my_app");
        assert_eq!(result.source, ServiceNameSource::Rails);
    }

    #[test]
    fn name_from_puma() {
        // Create a temporary directory without Rails config to test Puma detection
        let temp_dir = TempDir::new().expect("Failed to create temp dir");
        let (envs, fs) = test_tmp_ctx(temp_dir.path());
        let mut ctx = DetectionContext::new(0, envs, &fs);

        // Puma server process typically has format: puma <version> (cluster mode) [my_service]
        let cmdline = cmdline!["puma", "5.6.5", "(cluster)", "[api_gateway_service]"];
        let result = extract_name(&cmdline, &mut ctx);

        assert!(result.is_some());
        let result = result.unwrap();
        assert_eq!(result.name, "api_gateway_service");
        assert_eq!(result.source, ServiceNameSource::CommandLine);
    }

    #[test]
    fn name_from_puma_empty_brackets() {
        // Create a temporary directory without Rails config
        let temp_dir = TempDir::new().expect("Failed to create temp dir");
        let (envs, fs) = test_tmp_ctx(temp_dir.path());
        let mut ctx = DetectionContext::new(0, envs, &fs);

        // Edge case: empty brackets should not match
        let cmdline = cmdline!["puma", "[]"];
        let result = extract_name(&cmdline, &mut ctx);

        // Should return None since Rails config doesn't exist and puma pattern doesn't match
        assert!(result.is_none());
    }

    #[test]
    fn name_from_puma_no_brackets() {
        let (envs, fs) = test_data_ctx();
        let mut ctx = DetectionContext::new(0, envs, fs.as_ref());

        // No brackets, should not match puma pattern
        let cmdline = cmdline!["puma", "my_service"];
        let result = extract_name(&cmdline, &mut ctx);

        // Should fall back to Rails detection, which returns my_app
        assert!(result.is_some());
        let result = result.unwrap();
        assert_eq!(result.name, "my_app");
        assert_eq!(result.source, ServiceNameSource::Rails);
    }

    #[test]
    fn test_to_snake_case() {
        // Standard camel case
        assert_eq!(to_snake_case("MyRailsApp"), "my_rails_app");

        // Acronyms followed by camel case
        assert_eq!(to_snake_case("HTTPServer"), "http_server");
        assert_eq!(to_snake_case("HTTPSConnection"), "https_connection");

        // Pure acronym
        assert_eq!(to_snake_case("HTTP"), "http");

        // Single word
        assert_eq!(to_snake_case("App"), "app");

        // Already has underscores
        assert_eq!(to_snake_case("My_App"), "my_app");

        // Mixed patterns
        assert_eq!(to_snake_case("APIClientV2"), "api_client_v2");
        assert_eq!(to_snake_case("XMLHttpRequest"), "xml_http_request");
    }
}
