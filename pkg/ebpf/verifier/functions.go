// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

//go:build ignore

package main

import (
	"fmt"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/cilium/ebpf"
)

var fileTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
//go:build linux_bpf

package verifier

import (
{{ .Imports }}
)

{{ .Structs }}

{{ .InterfaceMap }}
`))

func listOfObjectFiles(directory string) ([]string, error) {
	var objectFiles []string
	if err := filepath.WalkDir(directory, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}

		if strings.Contains(path, "-debug") || !strings.HasSuffix(path, ".o") {
			return nil
		}
		objectFiles = append(objectFiles, path)

		return nil
	}); err != nil {
		return nil, fmt.Errorf("failed to walk directory %s: %v", directory, err)
	}

	return objectFiles, nil
}

func main() {
	args := os.Args[1:]
	if len(args) < 1 {
		panic("please use 'go run integrity.go <object_file_dir>'")
	}

	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("unable to get current working directory: %s", err)
	}

	outputFile := filepath.Join(cwd, "programs.go")
	f, err := os.Create(outputFile)
	if err != nil {
		log.Fatalf("failed to create output file: %v", err)
	}
	defer f.Close()

	objectFiles, err := listOfObjectFiles(args[0])
	if err != nil {
		log.Fatalf("error collecting object files: %v", err)
	}

	var functions strings.Builder
	var interfaceMap strings.Builder
	interfaceMap.WriteString("var interfaceMap = map[string]interface{}{\n")
	for _, file := range objectFiles {
		objectFileName := strings.ReplaceAll(
			strings.Split(filepath.Base(file), ".")[0], "-", "_",
		)
		bc, err := os.Open(file)
		if err != nil {
			log.Fatalf("couldn't open asset: %v", err)
		}
		defer bc.Close()

		collectionSpec, err := ebpf.LoadCollectionSpecFromReader(bc)
		if err != nil {
			log.Fatalf("failed to load collection spec: %v", err)
		}

		functions.WriteString(
			fmt.Sprintf("type EBPFPrograms__%s struct {\n", objectFileName),
		)

		for name, progSpec := range collectionSpec.Programs {
			if progSpec == nil {
				fmt.Printf("ProgramSpec for %s is nil\n", name)
				continue
			}
			functions.WriteString(
				fmt.Sprintf("Func_%s *ebpf.Program `ebpf:\"%s\"`\n", progSpec.Name, progSpec.Name),
			)
		}

		functions.WriteString("}\n")
		functions.WriteString(fmt.Sprintf("var EBPFPrograms__%s_var EBPFPrograms__%s\n", objectFileName, objectFileName))
		interfaceMap.WriteString(
			fmt.Sprintf("\"%s\": &EBPFPrograms__%s_var,\n", objectFileName, objectFileName),
		)
	}
	interfaceMap.WriteString("}")

	if err := fileTemplate.Execute(f, struct {
		Imports      string
		Structs      string
		ObjectFile   string
		InterfaceMap string
	}{"\"github.com/cilium/ebpf\"", functions.String(), "usm_o", interfaceMap.String()}); err != nil {
		log.Fatalf("failed to execute template: %v", err)
	}
}
