// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2016-present Datadog, Inc.

//go:build ignore

package main

import (
	"fmt"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/cilium/ebpf"
)

var fileTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
//go:build linux_bpf

package verifier

import (
{{ .Imports }}
)

{{ .Structs }}

{{ .InterfaceMap }}
`))

func main() {
	args := os.Args[1:]
	if len(args) < 1 {
		panic("please use 'go run functions.go <object_file_dir>'")
	}

	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("unable to get current working directory: %s", err)
	}

	outputFile := filepath.Join(cwd, "programs.go")
	f, err := os.Create(outputFile)
	if err != nil {
		log.Fatalf("failed to create output file: %v", err)
	}
	defer f.Close()

	skipDebugBuilds := func(path string) bool {
		debugBuild := strings.Contains(path, "-debug")
		if os.Getenv("USE_DEBUG_BUILDS") != "" {
			return !debugBuild
		}
		return debugBuild
	}

	objectFiles := make(map[string]string)
	if err := filepath.WalkDir(args[0], func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() {
			return nil
		}

		if skipDebugBuilds(path) || !strings.HasSuffix(path, ".o") {
			return nil
		}
		coreFile := filepath.Join(args[0], "co-re", d.Name())
		if _, err := os.Stat(coreFile); err == nil {
			objectFiles[d.Name()] = coreFile
			return nil
		}

		// if not co-re file present then save normal path
		if _, ok := objectFiles[d.Name()]; !ok {
			objectFiles[d.Name()] = path
		}
		return nil
	}); err != nil {
		log.Fatalf("failed to walk directory %s: %v", args[0], err)
	}

	var functions strings.Builder
	var interfaceMap strings.Builder
	interfaceMap.WriteString("var interfaceMap = map[string]interface{}{\n")
	for _, file := range objectFiles {
		bc, err := os.Open(file)
		if err != nil {
			log.Fatalf("couldn't open asset: %v", err)
		}
		defer bc.Close()

		collectionSpec, err := ebpf.LoadCollectionSpecFromReader(bc)
		if err != nil {
			log.Fatalf("failed to load collection spec: %v", err)
		}

		objectFileName := strings.ReplaceAll(
			strings.Split(filepath.Base(file), ".")[0], "-", "_",
		)
		for name, progSpec := range collectionSpec.Programs {
			if progSpec == nil {
				fmt.Printf("ProgramSpec for %s is nil\n", name)
				continue
			}

			functions.WriteString(
				fmt.Sprintf("type Func__%[1]s_%[2]s struct { Program__%[1]s *ebpf.Program `ebpf:\"%[1]s\"`}\n", progSpec.Name, objectFileName),
			)
			functions.WriteString(
				fmt.Sprintf("var Func__%[1]s_%[2]s_var Func__%[1]s_%[2]s\n", progSpec.Name, objectFileName),
			)
			interfaceMap.WriteString(
				fmt.Sprintf("\"%[1]s_%[2]s\": &Func__%[1]s_%[2]s_var,\n", progSpec.Name, objectFileName),
			)
		}

	}
	interfaceMap.WriteString("}")

	if err := fileTemplate.Execute(f, struct {
		Imports      string
		Structs      string
		ObjectFile   string
		InterfaceMap string
	}{"\"github.com/cilium/ebpf\"", functions.String(), "usm_o", interfaceMap.String()}); err != nil {
		log.Fatalf("failed to execute template: %v", err)
	}
}
