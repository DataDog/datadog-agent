<!DOCTYPE html>
<html lang="en">
<!--
  Fine-Grained Monitor - Exported Scenario Results
  Generated: {{EXPORTED_AT}}
  Scenario: {{SCENARIO_NAME}}
  Run ID: {{RUN_ID}}

  This is a self-contained HTML file with embedded parquet data.
  It can be opened offline in any modern browser.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FGM Export - {{SCENARIO_NAME}} ({{RUN_ID}})</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' rx='10' fill='%23007bff'/><path d='M20 70 L35 40 L50 55 L65 25 L80 50' stroke='white' stroke-width='8' fill='none' stroke-linecap='round' stroke-linejoin='round'/></svg>">
    <!-- uPlot for chart rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uplot@1.6.30/dist/uPlot.min.css">
    <script src="https://cdn.jsdelivr.net/npm/uplot@1.6.30/dist/uPlot.iife.min.js"></script>
    <style>
        /* ============================================================
           THEME SYSTEM - CSS Variables
           ============================================================ */
        :root {
            /* Light theme (default) */
            --bg-primary: #f5f5f5;
            --bg-secondary: #ffffff;
            --bg-tertiary: #fafafa;
            --bg-hover: #f0f0f0;
            --bg-selected: #e8f4ff;
            --bg-accent: #007bff;

            --text-primary: #333333;
            --text-secondary: #666666;
            --text-muted: #888888;
            --text-inverse: #ffffff;

            --border-primary: #dddddd;
            --border-secondary: #eeeeee;
            --border-accent: #007bff;

            --chart-bg: #ffffff;
            --chart-grid: #eeeeee;
            --chart-axis: #666666;

            --loading-overlay: rgba(255, 255, 255, 0.85);
            --range-dim: rgba(0, 0, 0, 0.15);

            --instance-bg: #e8f4ff;
            --instance-border: #007bff;
            --instance-text: #0056b3;
        }

        /* Dark theme */
        [data-theme="dark"] {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #1f2940;
            --bg-hover: #2a3550;
            --bg-selected: #1e3a5f;
            --bg-accent: #4a9eff;

            --text-primary: #e8e8e8;
            --text-secondary: #b0b0b0;
            --text-muted: #808080;
            --text-inverse: #1a1a2e;

            --border-primary: #3a4560;
            --border-secondary: #2a3550;
            --border-accent: #4a9eff;

            --chart-bg: #16213e;
            --chart-grid: #2a3550;
            --chart-axis: #b0b0b0;

            --loading-overlay: rgba(22, 33, 62, 0.9);
            --range-dim: rgba(0, 0, 0, 0.4);

            --instance-bg: #1e3a5f;
            --instance-border: #4a9eff;
            --instance-text: #7ab8ff;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
        }

        /* Grid layout: sidebar + main content */
        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr;
            height: 100vh;
        }

        /* Sidebar styles */
        .sidebar {
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-primary);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-header {
            padding: 16px;
            border-bottom: 1px solid var(--border-secondary);
            flex-shrink: 0;
        }

        .sidebar-header h1 {
            font-size: 16px;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .sidebar-header .scenario-info {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .sidebar-header .export-info {
            margin-top: 8px;
            padding: 8px 10px;
            background: var(--instance-bg);
            border-radius: 4px;
            font-size: 11px;
            border-left: 3px solid var(--instance-border);
        }

        .sidebar-header .export-info .run-id {
            font-family: monospace;
            font-weight: 600;
            color: var(--instance-text);
        }

        .sidebar-header .export-info .export-date {
            color: var(--text-secondary);
            margin-top: 2px;
        }

        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px;
        }

        .sidebar-section {
            margin-bottom: 16px;
        }

        .sidebar-section-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        /* Time range selector */
        .time-range-select {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            font-size: 13px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }

        /* Container list */
        .container-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-secondary);
            border-radius: 4px;
            background: var(--bg-tertiary);
        }

        .container-item {
            display: flex;
            align-items: center;
            padding: 6px 10px;
            cursor: pointer;
            font-size: 12px;
            border-bottom: 1px solid var(--border-secondary);
            gap: 8px;
            color: var(--text-primary);
        }

        .container-item:last-child {
            border-bottom: none;
        }

        .container-item:hover {
            background: var(--bg-hover);
        }

        .container-item.selected {
            background: var(--bg-selected);
            border-left: 3px solid var(--border-accent);
            padding-left: 7px;
        }

        .container-item .container-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .container-item .container-name {
            font-family: monospace;
            font-size: 11px;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Action buttons */
        .action-buttons {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-top: 8px;
        }

        button {
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            white-space: nowrap;
        }

        button:hover {
            opacity: 0.9;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-warning {
            background: #ffc107;
            color: #333;
        }

        /* Main content area */
        .main-content {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--bg-primary);
        }

        /* Panels container */
        .panels-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 12px;
            gap: 12px;
        }

        .panel {
            background: var(--chart-bg);
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            padding: 12px;
            display: flex;
            flex-direction: column;
            min-height: 200px;
        }

        .panel-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-secondary);
        }

        .panel-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            font-family: monospace;
        }

        .panel-chart-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 150px;
        }

        .panel-main-chart {
            flex: 1;
            min-height: 140px;
        }

        /* Legend */
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 8px;
            font-size: 11px;
            flex-shrink: 0;
            color: var(--text-primary);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .legend-color {
            width: 16px;
            height: 3px;
            border-radius: 2px;
        }

        .empty-state {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
            font-size: 14px;
        }

        /* Shared overview */
        #sharedOverview {
            height: 80px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border-top: 2px solid var(--border-accent);
            margin: 0 12px 12px 12px;
            padding: 8px;
            position: relative;
            flex-shrink: 0;
        }

        /* Range selector overlay */
        .range-overlay {
            position: absolute;
            top: 8px;
            left: 0;
            right: 0;
            height: 60px;
            pointer-events: none;
        }

        .range-dim {
            position: absolute;
            top: 0;
            height: 100%;
            background: var(--range-dim);
            pointer-events: auto;
            cursor: crosshair;
        }

        .range-dim.left { left: 0; }
        .range-dim.right { right: 0; }

        .range-selection {
            position: absolute;
            top: 0;
            height: 100%;
            background: transparent;
            border: 2px solid var(--border-accent);
            border-radius: 3px;
            box-sizing: border-box;
            pointer-events: auto;
            cursor: grab;
        }

        .range-handle {
            position: absolute;
            top: 0;
            width: 8px;
            height: 100%;
            background: var(--bg-accent);
            cursor: ew-resize;
            pointer-events: auto;
            border-radius: 2px;
        }

        .range-handle.left { left: -4px; }
        .range-handle.right { right: -4px; }

        /* Loading overlay */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--loading-overlay);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            gap: 12px;
        }

        .loading-spinner {
            width: 32px;
            height: 32px;
            border: 3px solid var(--border-secondary);
            border-top-color: var(--bg-accent);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        .loading-text {
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Theme toggle */
        .theme-toggle {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-secondary);
        }

        .theme-toggle-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .theme-toggle-buttons {
            display: flex;
            gap: 2px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            padding: 2px;
            border: 1px solid var(--border-secondary);
        }

        .theme-toggle-btn {
            padding: 4px 8px;
            border: none;
            background: transparent;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            color: var(--text-muted);
            transition: all 0.15s ease;
        }

        .theme-toggle-btn:hover {
            color: var(--text-primary);
            background: var(--bg-hover);
        }

        .theme-toggle-btn.active {
            background: var(--bg-accent);
            color: var(--text-inverse);
        }

        /* Offline notice */
        .offline-notice {
            background: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 4px;
            padding: 8px 10px;
            margin-top: 12px;
            font-size: 11px;
            color: #856404;
        }

        [data-theme="dark"] .offline-notice {
            background: #3d3200;
            border-color: #ffc107;
            color: #ffc107;
        }
    </style>
</head>

<body>
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading exported data...</div>
    </div>

    <div class="app-container" style="display: none;" id="appContainer">
        <!-- Sidebar -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h1>FGM Export</h1>
                <div class="scenario-info">{{SCENARIO_NAME}}</div>
                <div class="export-info">
                    <div class="run-id">Run: {{RUN_ID}}</div>
                    <div class="export-date">Exported: {{EXPORTED_AT}}</div>
                </div>
                <div class="theme-toggle">
                    <span class="theme-toggle-label">Theme</span>
                    <div class="theme-toggle-buttons">
                        <button class="theme-toggle-btn" data-theme-value="light">Light</button>
                        <button class="theme-toggle-btn active" data-theme-value="dark">Dark</button>
                    </div>
                </div>
            </div>
            <div class="sidebar-content">
                <!-- Time range selector -->
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Time Range</div>
                    <select id="timeRangeSelect" class="time-range-select">
                        <option value="all" selected>All time</option>
                        <option value="1h">Last 1 hour</option>
                        <option value="1d">Last 1 day</option>
                    </select>
                </div>

                <!-- Container list -->
                <div class="sidebar-section">
                    <div class="sidebar-section-title">Containers</div>
                    <div class="container-list" id="containerList"></div>
                    <div class="action-buttons">
                        <button class="btn-secondary" id="btnSelectAll">Select All</button>
                        <button class="btn-secondary" id="btnClearAll">Clear All</button>
                        <button class="btn-warning" id="btnResetZoom">Reset Zoom</button>
                    </div>
                </div>

                <div class="offline-notice">
                    This is an exported snapshot. Data is embedded in this file and works offline.
                </div>
            </div>
        </div>

        <!-- Main content -->
        <div class="main-content">
            <div class="panels-container" id="panelsContainer"></div>
            <div id="sharedOverview"></div>
        </div>
    </div>

    <!-- Embedded data -->
    <script id="parquet-data" type="application/base64">{{PARQUET_DATA}}</script>
    <script id="dashboard-config" type="application/json">{{DASHBOARD_JSON}}</script>

    <!-- Application logic -->
    <script type="module">
        // ============================================================
        // Constants
        // ============================================================
        const COLORS = [
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', '#9467bd',
            '#8c564b', '#e377c2', '#7f7f7f', '#bcbd22', '#17becf'
        ];

        // ============================================================
        // State
        // ============================================================
        let state = {
            containers: [],
            selectedContainerIds: [],
            timeRange: 'all',
            metrics: new Set(),
            timeseries: new Map(), // metric -> Map<containerId, [{time_ms, value}]>
            minTime: Infinity,
            maxTime: -Infinity,
        };

        let plots = new Map(); // panelId -> uPlot instance
        let overviewPlot = null;

        // ============================================================
        // Parquet Loading
        // ============================================================
        async function loadParquetData() {
            const b64Data = document.getElementById('parquet-data').textContent.trim();
            // Check for valid parquet data - must start with "PAR" magic (base64: "UEFS")
            // and not be the unreplaced template placeholder
            if (!b64Data || b64Data.length < 100 || !b64Data.startsWith('UEFS')) {
                throw new Error('No parquet data embedded');
            }

            // Decode base64
            const binaryString = atob(b64Data);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }

            // Load parquet-wasm and arrow from CDN
            const [parquetWasm, arrow] = await Promise.all([
                import('https://cdn.jsdelivr.net/npm/parquet-wasm@0.6.1/esm/parquet_wasm.js'),
                import('https://cdn.jsdelivr.net/npm/apache-arrow@17.0.0/+esm'),
            ]);

            await parquetWasm.default();

            const wasmTable = parquetWasm.readParquet(bytes);
            const ipcStream = wasmTable.intoIPCStream();
            const table = arrow.tableFromIPC(ipcStream);

            console.log('[Export] Loaded table with', table.numRows, 'rows');
            return table;
        }

        function buildIndex(table) {
            const COLUMNS = {
                TIME: 'time',
                METRIC_NAME: 'metric_name',
                VALUE_INT: 'value_int',
                VALUE_FLOAT: 'value_float',
                CONTAINER_ID: 'l_container_id',
                CONTAINER_NAME: 'l_container_name',
                POD_NAME: 'l_pod_name',
                NAMESPACE: 'l_namespace',
                QOS_CLASS: 'l_qos_class',
            };

            const containers = new Map();

            const timeCol = table.getChild(COLUMNS.TIME);
            const metricCol = table.getChild(COLUMNS.METRIC_NAME);
            const valueIntCol = table.getChild(COLUMNS.VALUE_INT);
            const valueFloatCol = table.getChild(COLUMNS.VALUE_FLOAT);
            const containerIdCol = table.getChild(COLUMNS.CONTAINER_ID);
            const containerNameCol = table.getChild(COLUMNS.CONTAINER_NAME);
            const podNameCol = table.getChild(COLUMNS.POD_NAME);
            const namespaceCol = table.getChild(COLUMNS.NAMESPACE);
            const qosClassCol = table.getChild(COLUMNS.QOS_CLASS);

            for (let i = 0; i < table.numRows; i++) {
                const timeValue = timeCol.get(i);
                const ts = typeof timeValue === 'bigint' ? Number(timeValue) : timeValue;
                const metric = metricCol.get(i);
                const containerId = containerIdCol.get(i);

                let value = valueFloatCol.get(i);
                if (value === null || value === undefined) {
                    const intVal = valueIntCol.get(i);
                    value = intVal !== null && intVal !== undefined
                        ? (typeof intVal === 'bigint' ? Number(intVal) : intVal)
                        : null;
                }

                if (value === null || value === undefined) continue;

                state.metrics.add(metric);

                if (ts < state.minTime) state.minTime = ts;
                if (ts > state.maxTime) state.maxTime = ts;

                let containerData = containers.get(containerId);
                if (!containerData) {
                    containerData = {
                        short_id: containerId.slice(0, 12),
                        full_id: containerId,
                        container_name: containerNameCol.get(i) || 'unknown',
                        pod_name: podNameCol.get(i) || 'unknown',
                        namespace: namespaceCol.get(i) || 'default',
                        qos_class: qosClassCol.get(i) || 'BestEffort',
                        firstSeen: ts,
                        lastSeen: ts,
                    };
                    containers.set(containerId, containerData);
                }

                if (ts < containerData.firstSeen) containerData.firstSeen = ts;
                if (ts > containerData.lastSeen) containerData.lastSeen = ts;

                // Store timeseries
                let metricData = state.timeseries.get(metric);
                if (!metricData) {
                    metricData = new Map();
                    state.timeseries.set(metric, metricData);
                }
                let containerTs = metricData.get(containerId);
                if (!containerTs) {
                    containerTs = [];
                    metricData.set(containerId, containerTs);
                }
                containerTs.push({ time_ms: ts, value });
            }

            // Sort timeseries
            for (const metricData of state.timeseries.values()) {
                for (const points of metricData.values()) {
                    points.sort((a, b) => a.time_ms - b.time_ms);
                }
            }

            state.containers = Array.from(containers.values())
                .sort((a, b) => b.lastSeen - a.lastSeen);

            console.log('[Export] Indexed', state.metrics.size, 'metrics,', state.containers.length, 'containers');
        }

        // ============================================================
        // Dashboard Loading
        // ============================================================
        function loadDashboard() {
            try {
                const json = document.getElementById('dashboard-config').textContent.trim();
                if (!json || json === '{{DASHBOARD_JSON}}') return null;
                return JSON.parse(json);
            } catch (e) {
                console.warn('[Export] Failed to parse dashboard config:', e);
                return null;
            }
        }

        // ============================================================
        // UI Rendering
        // ============================================================
        function renderContainerList() {
            const list = document.getElementById('containerList');
            if (!list) return;

            list.innerHTML = state.containers.map((c, i) => {
                const isSelected = state.selectedContainerIds.includes(c.short_id);
                const color = isSelected ? COLORS[state.selectedContainerIds.indexOf(c.short_id) % COLORS.length] : '#ddd';
                const displayName = c.pod_name && c.container_name
                    ? `${c.pod_name}/${c.container_name}`
                    : c.pod_name || c.short_id;

                return `
                    <label class="container-item ${isSelected ? 'selected' : ''}">
                        <input type="checkbox" value="${c.short_id}" ${isSelected ? 'checked' : ''}>
                        <span class="container-color" style="background: ${color}"></span>
                        <span class="container-name" title="${c.full_id}">${displayName}</span>
                    </label>
                `;
            }).join('');
        }

        function getCssVar(name) {
            return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        }

        function formatValue(v) {
            if (v == null) return '';
            if (Math.abs(v) >= 1000000) return `${(v / 1000000).toFixed(1)}M`;
            if (Math.abs(v) >= 1000) return `${(v / 1000).toFixed(1)}K`;
            return v.toFixed(v % 1 === 0 ? 0 : 1);
        }

        function renderPanels(dashboard) {
            const container = document.getElementById('panelsContainer');
            if (!container) return;

            const panels = dashboard?.panels || [];
            if (panels.length === 0) {
                // Default: show first 3 metrics
                const defaultMetrics = Array.from(state.metrics).slice(0, 3);
                defaultMetrics.forEach((metric, i) => panels.push({ metric, title: metric }));
            }

            container.innerHTML = panels.map((panel, i) => `
                <div class="panel" data-panel-id="${i}">
                    <div class="panel-header">
                        <span class="panel-title">${panel.title || panel.metric}</span>
                    </div>
                    <div class="panel-chart-area">
                        <div class="legend" id="legend-${i}"></div>
                        <div class="panel-main-chart" id="chart-${i}"></div>
                    </div>
                </div>
            `).join('');

            // Render each panel
            panels.forEach((panel, i) => renderChart(i, panel.metric));
        }

        function getTimeseries(metric, containerIds) {
            const metricData = state.timeseries.get(metric);
            if (!metricData) return {};

            const result = {};
            for (const id of containerIds) {
                const fullId = state.containers.find(c => c.short_id === id)?.full_id;
                if (fullId && metricData.has(fullId)) {
                    result[id] = metricData.get(fullId);
                }
            }
            return result;
        }

        function renderChart(panelId, metric) {
            const chartDiv = document.getElementById(`chart-${panelId}`);
            const legendDiv = document.getElementById(`legend-${panelId}`);
            if (!chartDiv) return;

            const containerIds = state.selectedContainerIds;
            const timeseries = getTimeseries(metric, containerIds);

            // Build timestamps
            const allTimes = new Set();
            containerIds.forEach(id => {
                const data = timeseries[id] || [];
                data.forEach(p => allTimes.add(p.time_ms));
            });
            const timestamps = Array.from(allTimes).sort((a, b) => a - b);

            if (timestamps.length === 0) {
                chartDiv.innerHTML = '<div class="empty-state">Select containers to display data</div>';
                if (legendDiv) legendDiv.innerHTML = '';
                return;
            }

            // Build value arrays
            const timeToIdx = new Map(timestamps.map((t, i) => [t, i]));
            const series = containerIds.map(id => {
                const values = new Array(timestamps.length).fill(null);
                const data = timeseries[id] || [];
                data.forEach(p => {
                    const idx = timeToIdx.get(p.time_ms);
                    if (idx !== undefined) values[idx] = p.value;
                });
                return values;
            });

            // Check if all null
            let hasData = false;
            series.forEach(s => s.forEach(v => { if (v !== null) hasData = true; }));
            if (!hasData) {
                chartDiv.innerHTML = `<div class="empty-state">No data for ${metric}</div>`;
                if (legendDiv) legendDiv.innerHTML = '';
                return;
            }

            // uPlot data
            const uplotData = [timestamps.map(t => t / 1000), ...series];

            const uplotSeries = [
                { label: 'Time' },
                ...containerIds.map((id, i) => ({
                    label: id,
                    stroke: COLORS[i % COLORS.length],
                    width: 1.5,
                    points: { show: false }
                }))
            ];

            // Legend
            if (legendDiv) {
                legendDiv.innerHTML = containerIds.map((id, i) => {
                    const c = state.containers.find(c => c.short_id === id);
                    const name = c?.pod_name || id;
                    return `
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${COLORS[i % COLORS.length]}"></div>
                            <span title="${id}">${name}</span>
                        </div>
                    `;
                }).join('');
            }

            const opts = {
                width: chartDiv.clientWidth,
                height: chartDiv.clientHeight || 150,
                series: uplotSeries,
                scales: {
                    x: { time: true },
                    y: { range: (u, min, max) => [0, Math.max(max * 1.1, 1)] }
                },
                cursor: {
                    drag: { x: true, y: false, setScale: true }
                },
                axes: [
                    { stroke: getCssVar('--chart-axis'), grid: { stroke: getCssVar('--chart-grid') } },
                    {
                        stroke: getCssVar('--chart-axis'),
                        grid: { stroke: getCssVar('--chart-grid') },
                        size: 60,
                        values: (u, splits) => splits.map(v => formatValue(v))
                    }
                ],
                legend: { show: false }
            };

            // Destroy previous
            if (plots.has(panelId)) {
                plots.get(panelId).destroy();
            }

            chartDiv.innerHTML = '';
            const plot = new uPlot(opts, uplotData, chartDiv);
            plots.set(panelId, plot);
        }

        function renderOverview() {
            const overviewDiv = document.getElementById('sharedOverview');
            if (!overviewDiv) return;

            if (state.selectedContainerIds.length === 0) {
                overviewDiv.innerHTML = '';
                return;
            }

            // Get all timestamps
            const allTimes = new Set();
            for (const [metric, metricData] of state.timeseries) {
                for (const id of state.selectedContainerIds) {
                    const fullId = state.containers.find(c => c.short_id === id)?.full_id;
                    if (fullId && metricData.has(fullId)) {
                        metricData.get(fullId).forEach(p => allTimes.add(p.time_ms));
                    }
                }
            }
            const timestamps = Array.from(allTimes).sort((a, b) => a - b);

            if (timestamps.length === 0) return;

            // Simple flat data for overview
            const series = state.selectedContainerIds.map(() => new Array(timestamps.length).fill(1));
            const uplotData = [timestamps.map(t => t / 1000), ...series];

            const uplotSeries = [
                { label: 'Time' },
                ...state.selectedContainerIds.map((id, i) => ({
                    label: id,
                    stroke: COLORS[i % COLORS.length],
                    width: 1
                }))
            ];

            const opts = {
                width: overviewDiv.clientWidth,
                height: 60,
                series: uplotSeries,
                scales: { x: { time: true }, y: { range: [0, 2] } },
                cursor: { show: false },
                axes: [{ show: false }, { show: false }],
                legend: { show: false }
            };

            if (overviewPlot) overviewPlot.destroy();
            overviewDiv.innerHTML = '';
            overviewPlot = new uPlot(opts, uplotData, overviewDiv);
        }

        // ============================================================
        // Event Handlers
        // ============================================================
        function setupEventListeners(dashboard) {
            // Container selection
            document.getElementById('containerList')?.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                    const id = e.target.value;
                    if (e.target.checked) {
                        state.selectedContainerIds.push(id);
                    } else {
                        state.selectedContainerIds = state.selectedContainerIds.filter(i => i !== id);
                    }
                    renderContainerList();
                    renderPanels(dashboard);
                    renderOverview();
                }
            });

            // Select all
            document.getElementById('btnSelectAll')?.addEventListener('click', () => {
                state.selectedContainerIds = state.containers.map(c => c.short_id);
                renderContainerList();
                renderPanels(dashboard);
                renderOverview();
            });

            // Clear all
            document.getElementById('btnClearAll')?.addEventListener('click', () => {
                state.selectedContainerIds = [];
                renderContainerList();
                renderPanels(dashboard);
                renderOverview();
            });

            // Reset zoom
            document.getElementById('btnResetZoom')?.addEventListener('click', () => {
                for (const plot of plots.values()) {
                    const data = plot.data[0];
                    if (data.length > 0) {
                        plot.setScale('x', { min: data[0], max: data[data.length - 1] });
                    }
                }
            });

            // Theme toggle
            document.querySelectorAll('.theme-toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const theme = btn.dataset.themeValue;
                    document.querySelectorAll('.theme-toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    if (theme === 'dark') {
                        document.documentElement.setAttribute('data-theme', 'dark');
                    } else {
                        document.documentElement.removeAttribute('data-theme');
                    }

                    // Re-render charts with new theme colors
                    renderPanels(dashboard);
                    renderOverview();
                });
            });

            // Window resize
            window.addEventListener('resize', () => {
                for (const [panelId, plot] of plots) {
                    const chartDiv = document.getElementById(`chart-${panelId}`);
                    if (chartDiv) {
                        plot.setSize({ width: chartDiv.clientWidth, height: chartDiv.clientHeight });
                    }
                }
                if (overviewPlot) {
                    const overviewDiv = document.getElementById('sharedOverview');
                    if (overviewDiv) {
                        overviewPlot.setSize({ width: overviewDiv.clientWidth, height: 60 });
                    }
                }
            });
        }

        // ============================================================
        // Initialization
        // ============================================================
        async function init() {
            try {
                console.log('[Export] Initializing...');

                // Load parquet data
                const table = await loadParquetData();
                buildIndex(table);

                // Load dashboard config
                const dashboard = loadDashboard();

                // Auto-select all containers
                state.selectedContainerIds = state.containers.map(c => c.short_id);

                // Show app container first so chart elements have proper dimensions
                document.getElementById('loadingOverlay').style.display = 'none';
                document.getElementById('appContainer').style.display = 'grid';

                // Render UI (after container is visible so clientWidth is correct)
                renderContainerList();
                renderPanels(dashboard);
                renderOverview();

                // Setup events
                setupEventListeners(dashboard);

                console.log('[Export] Initialization complete');
            } catch (err) {
                console.error('[Export] Failed to initialize:', err);
                document.querySelector('.loading-text').textContent = 'Failed to load: ' + err.message;
            }
        }

        // Start after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
