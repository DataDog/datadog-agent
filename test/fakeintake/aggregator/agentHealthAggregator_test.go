// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2025-present Datadog, Inc.

package aggregator

import (
	_ "embed"
	"encoding/json"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/DataDog/datadog-agent/test/fakeintake/api"
)

//go:embed fixtures/agenthealth_bytes
var agentHealthBytes []byte

func TestAgentHealthAggregator(t *testing.T) {
	t.Run("parseAgentHealth empty JSON object should error", func(t *testing.T) {
		payloads, err := ParseAgentHealthPayload(api.Payload{
			Data:     []byte("{}"),
			Encoding: encodingJSON,
		})
		// An empty object is not a valid agent health payload
		assert.NoError(t, err)
		assert.Len(t, payloads, 1)
		// But it should have empty fields
		assert.Empty(t, payloads[0].Host.Hostname)
	})

	t.Run("parseAgentHealth valid body should parse agent health", func(t *testing.T) {
		// Test with JSON encoding
		validPayload := `{
			"schema_version": "1.0",
			"event_type": "agent-health-issues",
			"emitted_at": "2025-12-17T10:00:00Z",
			"host": {
				"hostname": "test-host",
				"agent_version": "7.50.0"
			},
			"issues": {
				"test-check": {
					"ID": "docker-file-tailing-disabled",
					"Category": "docker",
					"Title": "Docker File Tailing Disabled",
					"Description": "Docker logs cannot be tailed",
					"Tags": ["docker", "logs"],
					"Extra": {
						"dockerDir": "/var/lib/docker",
						"os": "linux"
					}
				}
			}
		}`

		agentHealth, err := ParseAgentHealthPayload(api.Payload{
			Data:     []byte(validPayload),
			Encoding: encodingJSON,
		})
		require.NoError(t, err)
		require.Len(t, agentHealth, 1)

		payload := agentHealth[0]
		assert.Equal(t, "1.0", payload.SchemaVersion)
		assert.Equal(t, "agent-health-issues", payload.EventType)
		assert.Equal(t, "test-host", payload.Host.Hostname)
		assert.Equal(t, "7.50.0", payload.Host.AgentVersion)
		assert.Len(t, payload.Issues, 1)

		issue := payload.Issues["test-check"]
		require.NotNil(t, issue)
		assert.Equal(t, "docker-file-tailing-disabled", issue.ID)
		assert.Equal(t, "docker", issue.Category)
		assert.Equal(t, "Docker File Tailing Disabled", issue.Title)
		assert.Contains(t, issue.Tags, "docker")
		assert.Contains(t, issue.Tags, "logs")
		assert.Equal(t, "linux", issue.Extra["os"])
	})

	t.Run("parseAgentHealth with deflate encoding", func(t *testing.T) {
		// This test will use the fixture generated by the client test
		if len(agentHealthBytes) > 0 {
			agentHealth, err := ParseAgentHealthPayload(api.Payload{
				Data:     agentHealthBytes,
				Encoding: encodingDeflate,
			})
			assert.NoError(t, err)
			assert.NotEmpty(t, agentHealth)
		}
	})
}

func TestAgentHealthAggregatorMethods(t *testing.T) {
	t.Run("name() returns hostname", func(t *testing.T) {
		payload := &AgentHealthPayload{
			HealthReport: HealthReport{
				Host: HostInfo{
					Hostname: "test-hostname",
				},
			},
		}
		assert.Equal(t, "test-hostname", payload.name())
	})

	t.Run("GetTags() returns empty slice", func(t *testing.T) {
		payload := &AgentHealthPayload{}
		assert.Empty(t, payload.GetTags())
	})
}

func TestAgentHealthAggregatorIntegration(t *testing.T) {
	t.Run("aggregator should aggregate by hostname", func(t *testing.T) {
		agg := NewAgentHealthAggregator()

		payload1JSON := `{
			"schema_version": "1.0",
			"event_type": "agent-health-issues",
			"emitted_at": "2025-12-17T10:00:00Z",
			"host": {
				"hostname": "host-1",
				"agent_version": "7.50.0"
			},
			"issues": {}
		}`

		payload2JSON := `{
			"schema_version": "1.0",
			"event_type": "agent-health-issues",
			"emitted_at": "2025-12-17T10:00:00Z",
			"host": {
				"hostname": "host-2",
				"agent_version": "7.50.0"
			},
			"issues": {}
		}`

		payloads := []api.Payload{
			{Data: []byte(payload1JSON), Encoding: encodingJSON},
			{Data: []byte(payload2JSON), Encoding: encodingJSON},
		}

		err := agg.UnmarshallPayloads(payloads)
		require.NoError(t, err)

		names := agg.GetNames()
		assert.Len(t, names, 2)
		assert.Contains(t, names, "host-1")
		assert.Contains(t, names, "host-2")

		host1Payloads := agg.GetPayloadsByName("host-1")
		assert.Len(t, host1Payloads, 1)
		assert.Equal(t, "host-1", host1Payloads[0].Host.Hostname)
	})
}

func TestAgentHealthJSONSerialization(t *testing.T) {
	t.Run("JSON round-trip", func(t *testing.T) {
		original := &AgentHealthPayload{
			HealthReport: HealthReport{
				SchemaVersion: "1.0",
				EventType:     "agent-health-issues",
				Host: HostInfo{
					Hostname:     "test-host",
					AgentVersion: "7.50.0",
				},
				Issues: map[string]*Issue{
					"test-check": {
						ID:       "test-issue",
						Category: "test",
						Title:    "Test Issue",
						Tags:     []string{"tag1", "tag2"},
						Extra: map[string]any{
							"key": "value",
						},
					},
				},
			},
		}

		// Marshal to JSON
		jsonData, err := json.Marshal(original)
		require.NoError(t, err)

		// Unmarshal back
		var decoded AgentHealthPayload
		err = json.Unmarshal(jsonData, &decoded)
		require.NoError(t, err)

		// Verify fields
		assert.Equal(t, original.SchemaVersion, decoded.SchemaVersion)
		assert.Equal(t, original.EventType, decoded.EventType)
		assert.Equal(t, original.Host.Hostname, decoded.Host.Hostname)
		assert.Len(t, decoded.Issues, 1)
		assert.Equal(t, "test-issue", decoded.Issues["test-check"].ID)
	})
}
