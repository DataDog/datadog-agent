---
- name: Prepare Connection
  hosts: localhost
  connection: local
  gather_facts: true
  tasks:
    - include_tasks: ../common/prepare/keypair.yml

- name: Prepare Receiver and EKS cluster
  hosts: kubernetes-cluster-agent
  gather_facts: true
  tasks:
    # cleanup before a rerun
    - include_tasks: ../common/prepare/docker-compose-cleanup-receiver.yml

    # - name: Kustomization template
    #   template:
    #     src: /home/ubuntu/overlays-original/kustomization.yaml
    #     dest: /home/ubuntu/deployment/agents/overlays

    - name: Delete namespace '{{namespace}}' and global lock if we took it
      ignore_errors: yes
      shell: kubectl delete ns test-global-lock
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Delete manifests for stackstate node agent and cluster agent
      ignore_errors: yes
      command: kubectl delete -k overlays
      args:
        chdir: /home/ubuntu/deployment/agents
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Delete test namespace '{{namespace}}'
      ignore_errors: yes
      shell: kubectl delete ns {{ namespace }}
      args:
        chdir: /home/ubuntu/deployment
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    # continue

    - name: Run Docker compose
      command: docker-compose up -d
      args:
        chdir: /home/ubuntu/receiver

    - include_tasks: ../common/prepare/wait-for-receiver.yml

    - name: Removing existing config files if exists
      file:
        path: "/home/ubuntu/deployment/aws-eks/tf-cluster/{{ item }}"
        state: absent
      with_items:
        - .terraform
        - kubeconfig

    - name: Run make plan
      make:
        chdir: /home/ubuntu/deployment/aws-eks/tf-cluster
        target: plan
      environment:
        AWS_ACCESS_KEY_ID: '{{lookup("env", "AWS_ACCESS_KEY_ID")}}'
        AWS_SECRET_ACCESS_KEY: '{{lookup("env", "AWS_SECRET_ACCESS_KEY")}}'
        TF_VAR_AWS_SECRET_ACCESS_KEY: '{{lookup("env", "AWS_SECRET_ACCESS_KEY")}}'
        TF_VAR_AWS_ACCESS_KEY_ID: '{{lookup("env", "AWS_ACCESS_KEY_ID")}}'
        TF_VAR_SCALING_DESIRED_CAPACITY: 2
        TF_VAR_AWS_REGION: eu-west-1
        TF_VAR_CLUSTER_NAME: "{{ cluster_name }}"

    - name: Run make apply
      make:
        chdir: /home/ubuntu/deployment/aws-eks/tf-cluster
        target: apply

    - name: Run make kubeconfig
      make:
        chdir: /home/ubuntu/deployment/aws-eks/tf-cluster
        target: kubeconfig

    - name: Run make config-map-aws-auth
      make:
        chdir: /home/ubuntu/deployment/aws-eks/tf-cluster
        target: config-map-aws-auth
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Create secret to allow pulling from private docker registry
      shell: kubectl get secret docker-registry-key || kubectl create secret generic docker-registry-key --from-file=.dockerconfigjson=/home/ubuntu/.docker/config.json --type=kubernetes.io/dockerconfigjson
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Create global lock namespace (only one test can run on the cluster at the same time)
      shell: kubectl create ns test-global-lock
      args:
        chdir: /home/ubuntu/deployment
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Create test namespace '{{namespace}}'
      shell: kubectl create ns {{ namespace }}
      args:
        chdir: /home/ubuntu/deployment
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Apply manifests for test workloads
      command: kubectl -n={{ namespace }} apply -f test_workloads
      args:
        chdir: /home/ubuntu/deployment
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Apply manifests for stackstate node agent and cluster agent
      command: kubectl apply -k overlays
      args:
        chdir: /home/ubuntu/deployment/agents
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Wait for the stackstate cluster agent to start doing it's thing
      command: kubectl -n={{ namespace }} wait --all --for=condition=Ready --timeout=360s -l app=stackstate-cluster-agent pod
      args:
        chdir: /home/ubuntu/deployment/agents
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Wait for the stackstate node agents to start doing their thing (otherwise connections might occur after agent startup)
      command: kubectl -n={{ namespace }} wait --all --for=condition=Ready --timeout=360s -l app=stackstate-agent pod
      args:
        chdir: /home/ubuntu/deployment/agents
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Give the Test Workloads 5 minutes to start performing their actions
      pause:
        minutes: 5

    - name: Apply the pod-to-service-cluster-ip scenario
      command: kubectl -n={{ namespace }} apply -f pod-to-service-cluster-ip.yaml
      args:
        chdir: /home/ubuntu/deployment/test_connections
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Apply the pod-localhost scenario
      command: kubectl -n={{ namespace }} apply -f pod-localhost.yaml
      args:
        chdir: /home/ubuntu/deployment/test_connections
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Apply the pod-to-pod-headless scenario
      command: kubectl -n={{ namespace }} apply -f pod-to-pod-headless.yaml
      args:
        chdir: /home/ubuntu/deployment/test_connections
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Apply the pod-http-metrics scenario
      command: kubectl -n={{ namespace }} apply -f pod-http-metrics.yaml
      args:
        chdir: /home/ubuntu/deployment/test_connections
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Wait for the pod-to-service-cluster-ip scenario to become ready
      command: kubectl -n={{ namespace }} wait --all --for=condition=Ready --timeout=360s -l test=pod-to-service-cluster-ip pod
      args:
        chdir: /home/ubuntu/deployment/agents
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Wait for the pod-localhost scenario to become ready
      command: kubectl -n={{ namespace }} wait --all --for=condition=Ready --timeout=360s -l test=pod-localhost pod
      args:
        chdir: /home/ubuntu/deployment/agents
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Wait for the pod-to-pod-headless scenario to become ready
      command: kubectl -n={{ namespace }} wait --all --for=condition=Ready --timeout=360s -l test=pod-to-pod-headless pod
      args:
        chdir: /home/ubuntu/deployment/agents
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Wait for the pod-http-metrics scenario to become ready
      command: kubectl -n={{ namespace }} wait --all --for=condition=Ready --timeout=360s -l test=pod-http-metrics pod
      args:
        chdir: /home/ubuntu/deployment/agents
      environment:
        KUBECONFIG: /home/ubuntu/deployment/aws-eks/tf-cluster/kubeconfig

    - name: Pause for 2 minutes to perform some http requests
      pause:
        minutes: 2
