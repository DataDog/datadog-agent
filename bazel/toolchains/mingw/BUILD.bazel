load("@rules_cc//cc:defs.bzl", "cc_toolchain")
load("//bazel/toolchains/mingw:toolchain.bzl", "mingw_cc_toolchain_config")

MSYS2_PATH = "C:/tools/msys64"

mingw_cc_toolchain_config(
    name = "mingw-cc-toolchain-config",
    GCC_VERSION = "14.2.0",
    MINGW_PATH = MSYS2_PATH + "/mingw64",
    MSYS2_PATH = MSYS2_PATH,
)

filegroup(
    name = "toolchain_files",
)

# Define our cc_toolchain
# (https://bazel.build/reference/be/c-cpp#cc_toolchain).
# The cc_toolchain rule is pre-defined by the C++ rule owners. It uses these
# parameters to construct a ToolchainInfo provider, as required by Bazel's
# platform/toolchain APIs.
cc_toolchain(
    name = "mingw_cc_toolchain_definition",
    all_files = ":toolchain_files",
    compiler_files = ":toolchain_files",
    dwp_files = ":toolchain_files",
    linker_files = ":toolchain_files",
    objcopy_files = ":toolchain_files",
    strip_files = ":toolchain_files",
    toolchain_config = ":mingw-cc-toolchain-config",
)

# Bazel's platform/toolchain APIs require this wrapper around the actual
# toolchain defined above. It serves two purposes: declare which
# constraint_values it supports (which can be matched to appropriate platforms)
# and tell Bazel what language this toolchain is for.
#
# So when you're building a cc_binary, Bazel has all the info it needs to give
# that cc_binary the right toolchain: it knows cc_binary requires a "C++-type
# toolchain" (this is encoded in the cc_binary rule definition) and needs to
# use a toolchain that matches whatever you set --platforms to at the command
# line.
toolchain(
    name = "mingw_cc_toolchain",
    target_compatible_with = [
        "@platforms//os:windows",
        "@platforms//cpu:x86_64",
    ],
    toolchain = ":mingw_cc_toolchain_definition",
    toolchain_type = "@bazel_tools//tools/cpp:toolchain_type",
)
