diff -ruN -x .git/* patched-godror/BUILD.bazel ./BUILD.bazel
--- patched-godror/BUILD.bazel	2024-05-14 16:25:02
+++ ./BUILD.bazel	2024-05-14 14:55:13
@@ -23,7 +23,12 @@
         "tznames_generated.go",
         "version.go",
         "version_go1.18.go",
-    ],
+    ] + glob([
+        # Header files added manually
+        "odpi/embed/*.h",
+        "odpi/include/*.h",
+        "odpi/src/*.h",
+    ]),
     cgo = True,
     clinkopts = select({
         "@io_bazel_rules_go//go/platform:android": [
diff -ruN -x .git/* patched-godror/drv.go ./drv.go
--- patched-godror/drv.go	2024-05-14 16:25:01
+++ ./drv.go	2024-05-14 14:55:13
@@ -68,7 +68,7 @@
 /*
 #cgo CFLAGS: -I./odpi/include -I./odpi/src -I./odpi/embed
 
-#include "dpi.c"
+#include "dpic.h"
 
 */
 import "C"
diff -ruN -x .git/* patched-godror/odpi/embed/dpi.c ./odpi/embed/dpi.c
--- patched-godror/odpi/embed/dpi.c	2024-05-14 16:25:01
+++ ./odpi/embed/dpi.c	1970-01-01 01:00:00
@@ -1,64 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2018, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpi.c
-//   Include this file in your project in order to embed ODPI-C source without
-// having to compile files individually. Only the definitions in the file
-// include/dpi.h are intended to be used publicly. Each file can also be
-// compiled independently if that is preferable.
-//-----------------------------------------------------------------------------
-
-#include "../src/dpiConn.c"
-#include "../src/dpiContext.c"
-#include "../src/dpiData.c"
-#include "../src/dpiDebug.c"
-#include "../src/dpiDeqOptions.c"
-#include "../src/dpiEnqOptions.c"
-#include "../src/dpiEnv.c"
-#include "../src/dpiError.c"
-#include "../src/dpiGen.c"
-#include "../src/dpiGlobal.c"
-#include "../src/dpiHandleList.c"
-#include "../src/dpiHandlePool.c"
-#include "../src/dpiJson.c"
-#include "../src/dpiLob.c"
-#include "../src/dpiMsgProps.c"
-#include "../src/dpiObjectAttr.c"
-#include "../src/dpiObject.c"
-#include "../src/dpiObjectType.c"
-#include "../src/dpiOci.c"
-#include "../src/dpiOracleType.c"
-#include "../src/dpiPool.c"
-#include "../src/dpiQueue.c"
-#include "../src/dpiRowid.c"
-#include "../src/dpiSodaColl.c"
-#include "../src/dpiSodaCollCursor.c"
-#include "../src/dpiSodaDb.c"
-#include "../src/dpiSodaDoc.c"
-#include "../src/dpiSodaDocCursor.c"
-#include "../src/dpiStmt.c"
-#include "../src/dpiSubscr.c"
-#include "../src/dpiUtils.c"
-#include "../src/dpiVar.c"
diff -ruN -x .git/* patched-godror/odpi/embed/dpic.h ./odpi/embed/dpic.h
--- patched-godror/odpi/embed/dpic.h	1970-01-01 01:00:00
+++ ./odpi/embed/dpic.h	2024-05-14 14:55:13
@@ -0,0 +1,64 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2018, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpi.c
+//   Include this file in your project in order to embed ODPI-C source without
+// having to compile files individually. Only the definitions in the file
+// include/dpi.h are intended to be used publicly. Each file can also be
+// compiled independently if that is preferable.
+//-----------------------------------------------------------------------------
+
+#include "../src/dpiConn.h"
+#include "../src/dpiContext.h"
+#include "../src/dpiData.h"
+#include "../src/dpiDebug.h"
+#include "../src/dpiDeqOptions.h"
+#include "../src/dpiEnqOptions.h"
+#include "../src/dpiEnv.h"
+#include "../src/dpiError.h"
+#include "../src/dpiGen.h"
+#include "../src/dpiGlobal.h"
+#include "../src/dpiHandleList.h"
+#include "../src/dpiHandlePool.h"
+#include "../src/dpiJson.h"
+#include "../src/dpiLob.h"
+#include "../src/dpiMsgProps.h"
+#include "../src/dpiObjectAttr.h"
+#include "../src/dpiObject.h"
+#include "../src/dpiObjectType.h"
+#include "../src/dpiOci.h"
+#include "../src/dpiOracleType.h"
+#include "../src/dpiPool.h"
+#include "../src/dpiQueue.h"
+#include "../src/dpiRowid.h"
+#include "../src/dpiSodaColl.h"
+#include "../src/dpiSodaCollCursor.h"
+#include "../src/dpiSodaDb.h"
+#include "../src/dpiSodaDoc.h"
+#include "../src/dpiSodaDocCursor.h"
+#include "../src/dpiStmt.h"
+#include "../src/dpiSubscr.h"
+#include "../src/dpiUtils.h"
+#include "../src/dpiVar.h"
diff -ruN -x .git/* patched-godror/odpi/src/dpiConn.c ./odpi/src/dpiConn.c
--- patched-godror/odpi/src/dpiConn.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiConn.c	1970-01-01 01:00:00
@@ -1,2788 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiConn.c
-//   Implementation of connection.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-#include <time.h>
-
-// forward declarations of internal functions only used in this file
-static int dpiConn__attachExternal(dpiConn *conn, void *externalHandle,
-        dpiError *error);
-static int dpiConn__createStandalone(dpiConn *conn, const char *userName,
-        uint32_t userNameLength, const char *password, uint32_t passwordLength,
-        const char *connectString, uint32_t connectStringLength,
-        const dpiCommonCreateParams *commonParams,
-        const dpiConnCreateParams *createParams, dpiError *error);
-static int dpiConn__get(dpiConn *conn, const char *userName,
-        uint32_t userNameLength, const char *password, uint32_t passwordLength,
-        const char *connectString, uint32_t connectStringLength,
-        dpiConnCreateParams *createParams, dpiPool *pool, dpiError *error);
-static int dpiConn__getHandles(dpiConn *conn, dpiError *error);
-static int dpiConn__getServerCharset(dpiConn *conn, dpiError *error);
-static int dpiConn__getSession(dpiConn *conn, uint32_t mode,
-        const char *connectString, uint32_t connectStringLength,
-        dpiConnCreateParams *params, void *authInfo, dpiError *error);
-static int dpiConn__setAttributesFromCreateParams(dpiConn *conn, void *handle,
-        uint32_t handleType, const char *userName, uint32_t userNameLength,
-        const char *password, uint32_t passwordLength,
-        const dpiConnCreateParams *params, dpiError *error);
-static int dpiConn__setShardingKey(dpiConn *conn, void **shardingKey,
-        void *handle, uint32_t handleType, uint32_t attribute,
-        const char *action, dpiShardingKeyColumn *columns, uint8_t numColumns,
-        dpiError *error);
-static int dpiConn__setShardingKeyValue(dpiConn *conn, void *shardingKey,
-        dpiShardingKeyColumn *column, dpiError *error);
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__attachExternal() [INTERNAL]
-//   Attach to the server and session of an existing service context handle.
-//-----------------------------------------------------------------------------
-static int dpiConn__attachExternal(dpiConn *conn, void *externalHandle,
-        dpiError *error)
-{
-    // mark connection as using an external handle so that no attempts are
-    // made to close it
-    conn->externalHandle = 1;
-
-    // acquire handles from existing service context handle
-    conn->handle = externalHandle;
-    if (dpiConn__getHandles(conn, error) < 0) {
-        conn->handle = NULL;
-        return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__check() [INTERNAL]
-//   Validate the connection handle and that it is still connected to the
-// database.
-//-----------------------------------------------------------------------------
-static int dpiConn__check(dpiConn *conn, const char *fnName, dpiError *error)
-{
-    if (dpiGen__startPublicFn(conn, DPI_HTYPE_CONN, fnName, error) < 0)
-        return DPI_FAILURE;
-    return dpiConn__checkConnected(conn, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__checkConnected() [INTERNAL]
-//   Check to see if the connection is still open and raise an exception if it
-// is not.
-// Maintainers: keep these checks in sync with dpiConn_getIsHealthy()
-//-----------------------------------------------------------------------------
-int dpiConn__checkConnected(dpiConn *conn, dpiError *error)
-{
-    if (!conn->handle || conn->closing || conn->deadSession ||
-            (conn->pool && !conn->pool->handle))
-        return dpiError__set(error, "check connected", DPI_ERR_NOT_CONNECTED);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__clearTransaction() [INTERNAL]
-//   Clears the service context of any associated transaction.
-//-----------------------------------------------------------------------------
-int dpiConn__clearTransaction(dpiConn *conn, dpiError *error)
-{
-    return dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX, NULL, 0,
-            DPI_OCI_ATTR_TRANS, "clear transaction", error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__close() [INTERNAL]
-//   Internal method used for closing the connection. Any transaction is rolled
-// back and any handles allocated are freed. For connections acquired from a
-// pool and that aren't marked as needed to be dropped, the last time used is
-// updated. This is called from dpiConn_close() where errors are expected to be
-// propagated and from dpiConn__free() where errors are ignored.
-//-----------------------------------------------------------------------------
-static int dpiConn__close(dpiConn *conn, uint32_t mode, const char *tag,
-        uint32_t tagLength, int propagateErrors, dpiError *error)
-{
-    int status, txnInProgress;
-    uint32_t serverStatus, i;
-    time_t *lastTimeUsed;
-    dpiObject *obj;
-    dpiStmt *stmt;
-    dpiLob *lob;
-
-    // rollback any outstanding transaction, if one is in progress; drop the
-    // session if any errors take place
-    txnInProgress = 0;
-    if (!conn->deadSession && !conn->externalHandle && conn->sessionHandle) {
-        txnInProgress = 1;
-        if (conn->env->versionInfo->versionNum >= 12)
-            dpiOci__attrGet(conn->sessionHandle, DPI_OCI_HTYPE_SESSION,
-                    &txnInProgress, NULL, DPI_OCI_ATTR_TRANSACTION_IN_PROGRESS,
-                    NULL, error);
-    }
-    if (txnInProgress &&
-            dpiOci__transRollback(conn, propagateErrors, error) < 0)
-        conn->deadSession = 1;
-
-    // close all objects; note that no references are retained by the
-    // handle list (otherwise all objects would be left until an explicit
-    // close of the connection was made) so a reference needs to be acquired
-    // first, as otherwise the object may be freed while the close is being
-    // performed!
-    if (conn->objects && !conn->externalHandle) {
-        for (i = 0; i < conn->objects->numSlots; i++) {
-            obj = (dpiObject*) conn->objects->handles[i];
-            if (!obj)
-                continue;
-            if (conn->env->threaded) {
-                dpiMutex__acquire(conn->env->mutex);
-                status = dpiGen__checkHandle(obj, DPI_HTYPE_OBJECT, NULL,
-                        NULL);
-                if (status == DPI_SUCCESS)
-                    obj->refCount += 1;
-                dpiMutex__release(conn->env->mutex);
-                if (status < 0)
-                    continue;
-            }
-            status = dpiObject__close(obj, propagateErrors, error);
-            if (conn->env->threaded)
-                dpiGen__setRefCount(obj, error, -1);
-            if (status < 0)
-                return DPI_FAILURE;
-        }
-    }
-
-    // close all open statements; note that no references are retained by the
-    // handle list (otherwise all statements would be left open until an
-    // explicit close was made of either the statement or the connection) so
-    // a reference needs to be acquired first, as otherwise the statement may
-    // be freed while the close is being performed!
-    if (conn->openStmts && !conn->externalHandle) {
-        for (i = 0; i < conn->openStmts->numSlots; i++) {
-            stmt = (dpiStmt*) conn->openStmts->handles[i];
-            if (!stmt)
-                continue;
-            if (conn->env->threaded) {
-                dpiMutex__acquire(conn->env->mutex);
-                status = dpiGen__checkHandle(stmt, DPI_HTYPE_STMT, NULL, NULL);
-                if (status == DPI_SUCCESS)
-                    stmt->refCount += 1;
-                dpiMutex__release(conn->env->mutex);
-                if (status < 0)
-                    continue;
-            }
-            status = dpiStmt__close(stmt, NULL, 0, propagateErrors, error);
-            if (conn->env->threaded)
-                dpiGen__setRefCount(stmt, error, -1);
-            if (status < 0)
-                return DPI_FAILURE;
-        }
-    }
-
-    // close all open LOBs; the same comments apply as for statements
-    // NOTE: Oracle Client 20 automatically closes all open LOBs which makes
-    // this code redundant; as such, it can be removed once the minimum version
-    // supported by ODPI-C is 20
-    if (conn->openLobs && !conn->externalHandle) {
-        for (i = 0; i < conn->openLobs->numSlots; i++) {
-            lob = (dpiLob*) conn->openLobs->handles[i];
-            if (!lob)
-                continue;
-            if (conn->env->threaded) {
-                dpiMutex__acquire(conn->env->mutex);
-                status = dpiGen__checkHandle(lob, DPI_HTYPE_LOB, NULL, NULL);
-                if (status == DPI_SUCCESS)
-                    lob->refCount += 1;
-                dpiMutex__release(conn->env->mutex);
-                if (status < 0)
-                    continue;
-            }
-            status = dpiLob__close(lob, propagateErrors, error);
-            if (conn->env->threaded)
-                dpiGen__setRefCount(lob, error, -1);
-            if (status < 0)
-                return DPI_FAILURE;
-        }
-    }
-
-    // handle connections created with an external handle
-    if (conn->externalHandle) {
-        conn->sessionHandle = NULL;
-
-    // handle standalone connections
-    } else if (conn->standalone) {
-
-        // end session and free session handle
-        if (dpiOci__sessionEnd(conn, propagateErrors, error) < 0)
-            return DPI_FAILURE;
-        dpiOci__handleFree(conn->sessionHandle, DPI_OCI_HTYPE_SESSION);
-        conn->sessionHandle = NULL;
-
-        // detach from server and free server handle
-        if (dpiOci__serverDetach(conn, propagateErrors, error) < 0)
-            return DPI_FAILURE;
-        dpiOci__handleFree(conn->serverHandle, DPI_OCI_HTYPE_SERVER);
-
-        // free service context handle
-        dpiOci__handleFree(conn->handle, DPI_OCI_HTYPE_SVCCTX);
-
-    // handle pooled connections
-    } else {
-
-        // if session is to be dropped, mark it as a dead session
-        if (mode & DPI_OCI_SESSRLS_DROPSESS) {
-            conn->deadSession = 1;
-
-        // otherwise, check server status; if not connected, ensure session is
-        // dropped
-        } else if (conn->serverHandle) {
-            if (dpiOci__attrGet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
-                    &serverStatus, NULL, DPI_OCI_ATTR_SERVER_STATUS,
-                    "get server status", error) < 0 ||
-                    serverStatus != DPI_OCI_SERVER_NORMAL)
-                conn->deadSession = 1;
-        }
-
-        // update last time used (if the session isn't going to be dropped)
-        // clear last time used (if the session is going to be dropped)
-        // do nothing, however, if not using a pool or the pool is being closed
-        if (conn->sessionHandle && conn->pool && conn->pool->handle) {
-
-            // get the pointer from the context associated with the session
-            lastTimeUsed = NULL;
-            if (dpiOci__contextGetValue(conn, DPI_CONTEXT_LAST_TIME_USED,
-                    (uint32_t) (sizeof(DPI_CONTEXT_LAST_TIME_USED) - 1),
-                    (void**) &lastTimeUsed, propagateErrors, error) < 0)
-                return DPI_FAILURE;
-
-            // if pointer available and session is going to be dropped, clear
-            // memory in order to avoid memory leak in OCI
-            if (lastTimeUsed && conn->deadSession) {
-                dpiOci__contextSetValue(conn, DPI_CONTEXT_LAST_TIME_USED,
-                        (uint32_t) (sizeof(DPI_CONTEXT_LAST_TIME_USED) - 1),
-                        NULL, 0, error);
-                dpiOci__memoryFree(conn, lastTimeUsed, error);
-                lastTimeUsed = NULL;
-
-            // otherwise, if the pointer is not available, allocate a new
-            // pointer and set it
-            } else if (!lastTimeUsed && !conn->deadSession) {
-                if (dpiOci__memoryAlloc(conn, (void**) &lastTimeUsed,
-                        sizeof(time_t), propagateErrors, error) < 0)
-                    return DPI_FAILURE;
-                if (dpiOci__contextSetValue(conn, DPI_CONTEXT_LAST_TIME_USED,
-                        (uint32_t) (sizeof(DPI_CONTEXT_LAST_TIME_USED) - 1),
-                        lastTimeUsed, propagateErrors, error) < 0) {
-                    dpiOci__memoryFree(conn, lastTimeUsed, error);
-                    lastTimeUsed = NULL;
-                }
-            }
-
-            // set last time used (used when acquiring a session to determine
-            // if ping is required)
-            if (lastTimeUsed)
-                *lastTimeUsed = time(NULL);
-
-        }
-
-        // release session
-        if (conn->deadSession)
-            mode |= DPI_OCI_SESSRLS_DROPSESS;
-        else if (dpiUtils__checkClientVersion(conn->env->versionInfo, 12, 2,
-                NULL) == DPI_SUCCESS && (mode & DPI_MODE_CONN_CLOSE_RETAG) &&
-                tag && tagLength > 0)
-            mode |= DPI_OCI_SESSRLS_MULTIPROPERTY_TAG;
-        if (dpiOci__sessionRelease(conn, tag, tagLength, mode, propagateErrors,
-                error) < 0)
-            return DPI_FAILURE;
-        conn->sessionHandle = NULL;
-
-    }
-    conn->handle = NULL;
-    conn->serverHandle = NULL;
-
-    // destroy sharding and super sharding key descriptors, if applicable
-    if (conn->shardingKey) {
-        dpiOci__descriptorFree(conn->shardingKey, DPI_OCI_DTYPE_SHARDING_KEY);
-        conn->shardingKey = NULL;
-    }
-    if (conn->superShardingKey) {
-        dpiOci__descriptorFree(conn->superShardingKey,
-                DPI_OCI_DTYPE_SHARDING_KEY);
-        conn->superShardingKey = NULL;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__commit() [PRIVATE]
-//   Internal method used to commit the transaction associated with the
-// connection. Once the commit has taken place, the transaction handle
-// associated with the connection is cleared.
-//-----------------------------------------------------------------------------
-int dpiConn__commit(dpiConn *conn, dpiError *error)
-{
-    if (dpiOci__transCommit(conn, conn->commitMode, error) < 0)
-        return DPI_FAILURE;
-    if (dpiConn__clearTransaction(conn, error) < 0)
-        return DPI_FAILURE;
-    conn->commitMode = DPI_OCI_DEFAULT;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__create() [PRIVATE]
-//   Perform internal initialization of the connection.
-//-----------------------------------------------------------------------------
-int dpiConn__create(dpiConn *conn, const dpiContext *context,
-        const char *userName, uint32_t userNameLength, const char *password,
-        uint32_t passwordLength, const char *connectString,
-        uint32_t connectStringLength, dpiPool *pool,
-        const dpiCommonCreateParams *commonParams,
-        dpiConnCreateParams *createParams, dpiError *error)
-{
-    void *envHandle = NULL;
-    int status;
-
-    // mark connection as being created so that errors that are raised do not
-    // do dead connection detection
-    conn->creating = 1;
-
-    // allocate handle lists for statements, LOBs and objects
-    if (dpiHandleList__create(&conn->openStmts, error) < 0)
-        return DPI_FAILURE;
-    if (dpiHandleList__create(&conn->openLobs, error) < 0)
-        return DPI_FAILURE;
-    if (dpiHandleList__create(&conn->objects, error) < 0)
-        return DPI_FAILURE;
-
-    // if an external service context handle is provided, acquire the
-    // environment handle from it; need a temporary environment handle in order
-    // to do so
-    if (createParams->externalHandle) {
-        error->env = conn->env;
-        if (dpiOci__envNlsCreate(&conn->env->handle, DPI_OCI_DEFAULT, 0, 0,
-                error) < 0)
-            return DPI_FAILURE;
-        if (dpiOci__handleAlloc(conn->env->handle, &error->handle,
-                DPI_OCI_HTYPE_ERROR, "allocate temp OCI error", error) < 0)
-            return DPI_FAILURE;
-        if (dpiOci__attrGet(createParams->externalHandle, DPI_OCI_HTYPE_SVCCTX,
-                &envHandle, NULL, DPI_OCI_ATTR_ENV, "get env handle",
-                error) < 0)
-            return DPI_FAILURE;
-        dpiOci__handleFree(conn->env->handle, DPI_OCI_HTYPE_ENV);
-        error->handle = NULL;
-        conn->env->handle = NULL;
-    }
-
-    // initialize environment (for non-pooled connections)
-    if (!pool && dpiEnv__init(conn->env, context, commonParams, envHandle,
-            commonParams->createMode, error) < 0)
-        return DPI_FAILURE;
-
-    // if a handle is specified, use it
-    if (createParams->externalHandle)
-        return dpiConn__attachExternal(conn, createParams->externalHandle,
-                error);
-
-    // connection class, sharding and the use of session pools require the use
-    // of the OCISessionGet() method; all other cases use the OCISessionBegin()
-    // method which is more capable
-    if (pool || (createParams->connectionClass &&
-            createParams->connectionClassLength > 0) ||
-            createParams->shardingKeyColumns ||
-            createParams->superShardingKeyColumns) {
-        status = dpiConn__get(conn, userName, userNameLength, password,
-                passwordLength, connectString, connectStringLength,
-                createParams, pool, error);
-    } else {
-        status = dpiConn__createStandalone(conn, userName, userNameLength,
-                password, passwordLength, connectString, connectStringLength,
-                commonParams, createParams, error);
-    }
-
-    // mark connection as no longer being created so that subsequent errors
-    // that are raised do perform dead connection detection
-    conn->creating = 0;
-
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__createStandalone() [PRIVATE]
-//   Create a standalone connection to the database using the parameters
-// specified.
-//-----------------------------------------------------------------------------
-static int dpiConn__createStandalone(dpiConn *conn, const char *userName,
-        uint32_t userNameLength, const char *password, uint32_t passwordLength,
-        const char *connectString, uint32_t connectStringLength,
-        const dpiCommonCreateParams *commonParams,
-        const dpiConnCreateParams *createParams, dpiError *error)
-{
-    uint32_t credentialType, authMode;
-
-    // mark the connection as a standalone connection
-    conn->standalone = 1;
-
-    // allocate the server handle
-    if (dpiOci__handleAlloc(conn->env->handle, &conn->serverHandle,
-            DPI_OCI_HTYPE_SERVER, "allocate server handle", error) < 0)
-        return DPI_FAILURE;
-
-    // attach to the server
-    if (dpiOci__serverAttach(conn, connectString, connectStringLength,
-            error) < 0)
-        return DPI_FAILURE;
-
-    // allocate the service context handle
-    if (dpiOci__handleAlloc(conn->env->handle, &conn->handle,
-            DPI_OCI_HTYPE_SVCCTX, "allocate service context handle",
-            error) < 0)
-        return DPI_FAILURE;
-
-    // set attribute for server handle
-    if (dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX, conn->serverHandle,
-            0, DPI_OCI_ATTR_SERVER, "set server handle", error) < 0)
-        return DPI_FAILURE;
-
-    // allocate the session handle
-    if (dpiOci__handleAlloc(conn->env->handle, &conn->sessionHandle,
-            DPI_OCI_HTYPE_SESSION, "allocate session handle", error) < 0)
-        return DPI_FAILURE;
-
-    // driver name and edition are only relevant for standalone connections
-    if (dpiUtils__setAttributesFromCommonCreateParams(conn->sessionHandle,
-            DPI_OCI_HTYPE_SESSION, commonParams, error) < 0)
-        return DPI_FAILURE;
-
-    // set access token for token based authentication
-    if (commonParams->accessToken) {
-        if (dpiUtils__setAccessTokenAttributes(conn->sessionHandle,
-                commonParams->accessToken, conn->env->versionInfo, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // populate attributes on the session handle
-    if (dpiConn__setAttributesFromCreateParams(conn, conn->sessionHandle,
-            DPI_OCI_HTYPE_SESSION, userName, userNameLength, password,
-            passwordLength, createParams, error) < 0)
-        return DPI_FAILURE;
-
-    // set the session handle on the service context handle
-    if (dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
-            conn->sessionHandle, 0, DPI_OCI_ATTR_SESSION, "set session handle",
-            error) < 0)
-        return DPI_FAILURE;
-
-    // if a new password is specified, change it (this also creates the session
-    // so a call to OCISessionBegin() is not needed)
-    if (createParams->newPassword && createParams->newPasswordLength > 0) {
-        authMode = DPI_OCI_AUTH;
-        if (createParams->authMode & DPI_MODE_AUTH_SYSDBA)
-            authMode |= DPI_OCI_CPW_SYSDBA;
-        if (createParams->authMode & DPI_MODE_AUTH_SYSOPER)
-            authMode |= DPI_OCI_CPW_SYSOPER;
-        if (createParams->authMode & DPI_MODE_AUTH_SYSASM)
-            authMode |= DPI_OCI_CPW_SYSASM;
-        if (createParams->authMode & DPI_MODE_AUTH_SYSBKP)
-            authMode |= DPI_OCI_CPW_SYSBKP;
-        if (createParams->authMode & DPI_MODE_AUTH_SYSDGD)
-            authMode |= DPI_OCI_CPW_SYSDGD;
-        if (createParams->authMode & DPI_MODE_AUTH_SYSKMT)
-            authMode |= DPI_OCI_CPW_SYSKMT;
-        return dpiOci__passwordChange(conn, userName, userNameLength, password,
-                passwordLength, createParams->newPassword,
-                createParams->newPasswordLength, authMode, error);
-    }
-
-    // begin the session
-    credentialType = (createParams->externalAuth) ? DPI_OCI_CRED_EXT :
-            DPI_OCI_CRED_RDBMS;
-    authMode = createParams->authMode | DPI_OCI_STMT_CACHE;
-    if (dpiOci__sessionBegin(conn, credentialType, authMode, error) < 0)
-        return DPI_FAILURE;
-    if (dpiConn__getServerCharset(conn, error) < 0)
-        return DPI_FAILURE;
-
-    // set the statement cache size
-    if (dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
-            (void*) &commonParams->stmtCacheSize, 0,
-            DPI_OCI_ATTR_STMTCACHESIZE, "set stmt cache size", error) < 0)
-        return DPI_FAILURE;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__free() [INTERNAL]
-//   Free the memory and any resources associated with the connection.
-//-----------------------------------------------------------------------------
-void dpiConn__free(dpiConn *conn, dpiError *error)
-{
-    if (conn->handle)
-        dpiConn__close(conn, DPI_MODE_CONN_CLOSE_DEFAULT, NULL, 0, 0,
-                error);
-    if (conn->pool) {
-        dpiGen__setRefCount(conn->pool, error, -1);
-        conn->pool = NULL;
-        conn->env = NULL;
-    }
-    if (conn->env) {
-        dpiEnv__free(conn->env, error);
-        conn->env = NULL;
-    }
-    if (conn->releaseString) {
-        dpiUtils__freeMemory((void*) conn->releaseString);
-        conn->releaseString = NULL;
-    }
-    if (conn->openStmts) {
-        dpiHandleList__free(conn->openStmts);
-        conn->openStmts = NULL;
-    }
-    if (conn->openLobs) {
-        dpiHandleList__free(conn->openLobs);
-        conn->openLobs = NULL;
-    }
-    if (conn->objects) {
-        dpiHandleList__free(conn->objects);
-        conn->objects = NULL;
-    }
-    if (conn->transactionHandle) {
-        dpiOci__handleFree(conn->transactionHandle, DPI_OCI_HTYPE_TRANS);
-        conn->transactionHandle = NULL;
-    }
-    dpiUtils__freeMemory(conn);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__get() [INTERNAL]
-//   Create a connection to the database using the parameters specified. This
-// method uses the simplified OCI session creation protocol which is required
-// when using pools and session tagging.
-//-----------------------------------------------------------------------------
-static int dpiConn__get(dpiConn *conn, const char *userName,
-        uint32_t userNameLength, const char *password, uint32_t passwordLength,
-        const char *connectString, uint32_t connectStringLength,
-        dpiConnCreateParams *createParams, dpiPool *pool, dpiError *error)
-{
-    int externalAuth, status;
-    void *authInfo;
-    uint32_t mode;
-
-    // clear pointers if length is 0
-    if (userNameLength == 0)
-        userName = NULL;
-    if (passwordLength == 0)
-        password = NULL;
-
-    // set things up for the call to acquire a session
-    if (pool) {
-        dpiGen__setRefCount(pool, error, 1);
-        conn->pool = pool;
-        mode = DPI_OCI_SESSGET_SPOOL;
-        externalAuth = pool->externalAuth;
-        if (userName && pool->homogeneous)
-            return dpiError__set(error, "check proxy", DPI_ERR_INVALID_PROXY);
-
-        // if the userName is provided but no password is provided and external
-        // authentication is not being used, proxy authentication is taking
-        // place
-        if (userName && !password && !externalAuth)
-            mode |= DPI_OCI_SESSGET_CREDPROXY;
-        if (createParams->matchAnyTag)
-            mode |= DPI_OCI_SESSGET_SPOOL_MATCHANY;
-        if (dpiUtils__checkClientVersion(conn->env->versionInfo, 12, 2,
-                NULL) == DPI_SUCCESS && createParams->tag &&
-                createParams->tagLength > 0)
-            mode |= DPI_OCI_SESSGET_MULTIPROPERTY_TAG;
-    } else {
-        mode = DPI_OCI_SESSGET_STMTCACHE;
-        externalAuth = createParams->externalAuth;
-    }
-    if (createParams->authMode & DPI_MODE_AUTH_SYSDBA)
-        mode |= DPI_OCI_SESSGET_SYSDBA;
-    if (externalAuth)
-        mode |= DPI_OCI_SESSGET_CREDEXT;
-
-    // create authorization handle
-    if (dpiOci__handleAlloc(conn->env->handle, &authInfo,
-            DPI_OCI_HTYPE_AUTHINFO, "allocate authinfo handle", error) < 0)
-        return DPI_FAILURE;
-
-    // set attributes for create parameters
-    if (dpiConn__setAttributesFromCreateParams(conn, authInfo,
-            DPI_OCI_HTYPE_AUTHINFO, userName, userNameLength, password,
-            passwordLength, createParams, error) < 0) {
-        dpiOci__handleFree(authInfo, DPI_OCI_HTYPE_AUTHINFO);
-        return DPI_FAILURE;
-    }
-
-    // get a session from the pool
-    status = dpiConn__getSession(conn, mode, connectString,
-            connectStringLength, createParams, authInfo, error);
-    dpiOci__handleFree(authInfo, DPI_OCI_HTYPE_AUTHINFO);
-    if (status < 0)
-        return status;
-    return dpiConn__getServerCharset(conn, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__getAttributeText() [INTERNAL]
-//   Get the value of the OCI attribute from a text string.
-//-----------------------------------------------------------------------------
-static int dpiConn__getAttributeText(dpiConn *conn, uint32_t attribute,
-        const char **value, uint32_t *valueLength, const char *fnName)
-{
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiConn__check(conn, fnName, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, value)
-    DPI_CHECK_PTR_NOT_NULL(conn, valueLength)
-
-    // determine pointer to pass (OCI uses different sizes)
-    switch (attribute) {
-        case DPI_OCI_ATTR_CURRENT_SCHEMA:
-        case DPI_OCI_ATTR_LTXID:
-        case DPI_OCI_ATTR_EDITION:
-            status = dpiOci__attrGet(conn->sessionHandle,
-                    DPI_OCI_HTYPE_SESSION, (void*) value, valueLength,
-                    attribute, "get session value", &error);
-            break;
-        case DPI_OCI_ATTR_INTERNAL_NAME:
-        case DPI_OCI_ATTR_EXTERNAL_NAME:
-            status = dpiOci__attrGet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
-                    (void*) value, valueLength, attribute, "get server value",
-                    &error);
-            break;
-        default:
-            status = dpiError__set(&error, "get attribute text",
-                    DPI_ERR_NOT_SUPPORTED);
-            break;
-    }
-
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__getHandles() [INTERNAL]
-//   Get the server and session handle from the service context handle.
-//-----------------------------------------------------------------------------
-static int dpiConn__getHandles(dpiConn *conn, dpiError *error)
-{
-    if (dpiOci__attrGet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
-            (void*) &conn->sessionHandle, NULL, DPI_OCI_ATTR_SESSION,
-            "get session handle", error) < 0)
-        return DPI_FAILURE;
-    if (dpiOci__attrGet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
-            (void*) &conn->serverHandle, NULL, DPI_OCI_ATTR_SERVER,
-            "get server handle", error) < 0)
-        return DPI_FAILURE;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__getJsonTDO() [INTERNAL]
-//   Internal method used for ensuring that the JSON TDO has been cached on the
-// connection.
-//-----------------------------------------------------------------------------
-int dpiConn__getJsonTDO(dpiConn *conn, dpiError *error)
-{
-    if (conn->jsonTDO)
-        return DPI_SUCCESS;
-    return dpiOci__typeByName(conn, "SYS", 3, "JSON", 4, &conn->jsonTDO,
-            error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__getRawTDO() [INTERNAL]
-//   Internal method used for ensuring that the RAW TDO has been cached on the
-// connection.
-//-----------------------------------------------------------------------------
-int dpiConn__getRawTDO(dpiConn *conn, dpiError *error)
-{
-    if (conn->rawTDO)
-        return DPI_SUCCESS;
-    return dpiOci__typeByName(conn, "SYS", 3, "RAW", 3, &conn->rawTDO, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__getServerCharset() [INTERNAL]
-//   Internal method used for retrieving the server character set. This is used
-// to determine if any conversion is required when transferring strings between
-// the client and the server.
-//-----------------------------------------------------------------------------
-static int dpiConn__getServerCharset(dpiConn *conn, dpiError *error)
-{
-    return dpiOci__attrGet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
-            &conn->charsetId, NULL, DPI_OCI_ATTR_CHARSET_ID,
-            "get server charset id", error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__getServerVersion() [INTERNAL]
-//   Internal method used for ensuring that the server version has been cached
-// on the connection.
-//-----------------------------------------------------------------------------
-int dpiConn__getServerVersion(dpiConn *conn, int wantReleaseString,
-        dpiError *error)
-{
-    char buffer[512], *releaseString;
-    dpiVersionInfo *tempVersionInfo;
-    uint32_t serverRelease, mode;
-    uint32_t releaseStringLength;
-    int ociCanCache;
-
-    // nothing to do if the server version has been cached earlier
-    if (conn->releaseString ||
-            (conn->versionInfo.versionNum > 0 && !wantReleaseString))
-        return DPI_SUCCESS;
-
-    // the server version is not available in the cache so it must be
-    // determined; as of Oracle Client 20.3, a special mode is available that
-    // causes OCI to cache the server version information, so this mode can be
-    // used if the release string information is not desired and the client
-    // supports it
-    ociCanCache = ((conn->env->versionInfo->versionNum > 20 ||
-            (conn->env->versionInfo->versionNum == 20 &&
-             conn->env->versionInfo->releaseNum >= 3)) && !wantReleaseString);
-
-    // for earlier versions where the OCI cache is not available, pooled
-    // connections can cache the information on the session in order to avoid
-    // the round trip, but again only if the release string is not desired;
-    // nothing further needs to be done if this cache is present
-    if (conn->pool && !ociCanCache && !wantReleaseString) {
-        tempVersionInfo = NULL;
-        if (dpiOci__contextGetValue(conn, DPI_CONTEXT_SERVER_VERSION,
-                (uint32_t) (sizeof(DPI_CONTEXT_SERVER_VERSION) - 1),
-                (void**) &tempVersionInfo, 1, error) < 0)
-            return DPI_FAILURE;
-        if (tempVersionInfo) {
-            memcpy(&conn->versionInfo, tempVersionInfo,
-                    sizeof(conn->versionInfo));
-            return DPI_SUCCESS;
-        }
-    }
-
-    // calculate the server version by making the appropriate call
-    if (ociCanCache) {
-        mode = DPI_OCI_SRVRELEASE2_CACHED;
-        releaseString = NULL;
-        releaseStringLength = 0;
-    } else {
-        mode = DPI_OCI_DEFAULT;
-        releaseString = buffer;
-        releaseStringLength = sizeof(buffer);
-    }
-    if (dpiOci__serverRelease(conn, releaseString, releaseStringLength,
-            &serverRelease, mode, error) < 0)
-        return DPI_FAILURE;
-
-    // store release string, if applicable
-    if (releaseString) {
-        conn->releaseStringLength = (uint32_t) strlen(releaseString);
-        if (dpiUtils__allocateMemory(1, conn->releaseStringLength, 0,
-                "allocate release string", (void**) &conn->releaseString,
-                error) < 0)
-            return DPI_FAILURE;
-        strncpy( (char*) conn->releaseString, releaseString,
-                conn->releaseStringLength);
-    }
-
-    // process version number
-    conn->versionInfo.versionNum = (int)((serverRelease >> 24) & 0xFF);
-    if (conn->versionInfo.versionNum >= 18) {
-        conn->versionInfo.releaseNum = (int)((serverRelease >> 16) & 0xFF);
-        conn->versionInfo.updateNum = (int)((serverRelease >> 12) & 0x0F);
-        conn->versionInfo.portReleaseNum = (int)((serverRelease >> 4) & 0xFF);
-        conn->versionInfo.portUpdateNum = (int)((serverRelease) & 0xF);
-    } else {
-        conn->versionInfo.releaseNum = (int)((serverRelease >> 20) & 0x0F);
-        conn->versionInfo.updateNum = (int)((serverRelease >> 12) & 0xFF);
-        conn->versionInfo.portReleaseNum = (int)((serverRelease >> 8) & 0x0F);
-        conn->versionInfo.portUpdateNum = (int)((serverRelease) & 0xFF);
-    }
-    conn->versionInfo.fullVersionNum = (uint32_t)
-            DPI_ORACLE_VERSION_TO_NUMBER(conn->versionInfo.versionNum,
-                    conn->versionInfo.releaseNum,
-                    conn->versionInfo.updateNum,
-                    conn->versionInfo.portReleaseNum,
-                    conn->versionInfo.portUpdateNum);
-
-    // for earlier versions where the OCI cache is not available, store the
-    // version information on the session in order to avoid the round-trip the
-    // next time the pooled session is acquired from the pool
-    if (conn->pool && !ociCanCache) {
-        if (dpiOci__memoryAlloc(conn, (void**) &tempVersionInfo,
-                sizeof(conn->versionInfo), 1, error) < 0)
-            return DPI_FAILURE;
-        memcpy(tempVersionInfo, &conn->versionInfo, sizeof(conn->versionInfo));
-        if (dpiOci__contextSetValue(conn, DPI_CONTEXT_SERVER_VERSION,
-                (uint32_t) (sizeof(DPI_CONTEXT_SERVER_VERSION) - 1),
-                tempVersionInfo, 1, error) < 0) {
-            dpiOci__memoryFree(conn, tempVersionInfo, error);
-        }
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__getSession() [INTERNAL]
-//   Ping and loop until we get a good session. When a database instance goes
-// down, it can leave several bad connections that need to be flushed out
-// before a good connection can be acquired. If the connection is brand new
-// (ping time context value has not been set) there is no need to do a ping.
-// This also ensures that the loop cannot run forever!
-//-----------------------------------------------------------------------------
-static int dpiConn__getSession(dpiConn *conn, uint32_t mode,
-        const char *connectString, uint32_t connectStringLength,
-        dpiConnCreateParams *params, void *authInfo, dpiError *error)
-{
-    uint8_t savedBreakOnTimeout, breakOnTimeout;
-    uint32_t savedTimeout;
-    time_t *lastTimeUsed;
-
-    while (1) {
-
-        // acquire the new session
-        params->outNewSession = 0;
-        if (dpiOci__sessionGet(conn->env->handle, &conn->handle, authInfo,
-                connectString, connectStringLength, params->tag,
-                params->tagLength, &params->outTag, &params->outTagLength,
-                &params->outTagFound, mode, error) < 0)
-            return DPI_FAILURE;
-
-        // get session and server handles
-        if (dpiConn__getHandles(conn, error) < 0)
-            return DPI_FAILURE;
-
-        // for standalone connections, nothing more needs to be done
-        if (!conn->pool) {
-            params->outNewSession = 1;
-            break;
-        }
-
-        // remainder of the loop is for pooled connections only; get last time
-        // used from session context; if value is not found, a new connection
-        // has been created and there is no need to perform a ping
-        lastTimeUsed = NULL;
-        if (dpiOci__contextGetValue(conn, DPI_CONTEXT_LAST_TIME_USED,
-                (uint32_t) (sizeof(DPI_CONTEXT_LAST_TIME_USED) - 1),
-                (void**) &lastTimeUsed, 1, error) < 0)
-            return DPI_FAILURE;
-        if (!lastTimeUsed) {
-            params->outNewSession = 1;
-
-            // for pooled connections, set the statement cache size; when a
-            // pool is created, the minSessions value is used to create
-            // connections and these use the default statement cache size, not
-            // the statement cache size specified for the pool; setting the
-            // value here eliminates that discrepancy
-            if (dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
-                    &conn->pool->stmtCacheSize, 0, DPI_OCI_ATTR_STMTCACHESIZE,
-                    "set stmt cache size", error) < 0)
-                return DPI_FAILURE;
-
-            break;
-        }
-
-        // if ping interval is negative or the ping interval (in seconds)
-        // has not been exceeded yet, there is also no need to perform a ping
-        if (conn->pool->pingInterval < 0 ||
-                *lastTimeUsed + conn->pool->pingInterval > time(NULL))
-            break;
-
-        // ping needs to be done at this point; set parameters to ensure that
-        // the ping does not take too long to complete; keep original values so
-        // that they can be restored after the ping is completed
-        dpiOci__attrGet(conn->serverHandle,
-                DPI_OCI_HTYPE_SERVER, &savedTimeout, NULL,
-                DPI_OCI_ATTR_RECEIVE_TIMEOUT, NULL, error);
-        dpiOci__attrSet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
-                &conn->pool->pingTimeout, 0, DPI_OCI_ATTR_RECEIVE_TIMEOUT,
-                NULL, error);
-        if (conn->env->versionInfo->versionNum >= 12) {
-            dpiOci__attrGet(conn->serverHandle,
-                    DPI_OCI_HTYPE_SERVER, &savedBreakOnTimeout, NULL,
-                    DPI_OCI_ATTR_BREAK_ON_NET_TIMEOUT, NULL, error);
-            breakOnTimeout = 0;
-            dpiOci__attrSet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
-                    &breakOnTimeout, 0, DPI_OCI_ATTR_BREAK_ON_NET_TIMEOUT,
-                    NULL, error);
-        }
-
-        // if ping is successful, the connection is valid and can be returned;
-        // restore original network parameters
-        if (dpiOci__ping(conn, error) == 0) {
-            dpiOci__attrSet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
-                    &savedTimeout, 0, DPI_OCI_ATTR_RECEIVE_TIMEOUT, NULL,
-                    error);
-            if (conn->env->versionInfo->versionNum >= 12)
-                dpiOci__attrSet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
-                        &savedBreakOnTimeout, 0,
-                        DPI_OCI_ATTR_BREAK_ON_NET_TIMEOUT, NULL, error);
-            break;
-        }
-
-        // session is bad, need to release and drop it
-        dpiOci__sessionRelease(conn, NULL, 0, DPI_OCI_SESSRLS_DROPSESS, 0,
-                error);
-        conn->handle = NULL;
-        conn->serverHandle = NULL;
-        conn->sessionHandle = NULL;
-        conn->deadSession = 0;
-
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__rollback() [PUBLIC]
-//   Internal method for rolling back the transaction associated with the
-// connection. Once the rollback has taken place, the transaction handle
-// associated with the connection is cleared.
-//-----------------------------------------------------------------------------
-int dpiConn__rollback(dpiConn *conn, dpiError *error)
-{
-    if (dpiOci__transRollback(conn, 1, error) < 0)
-        return DPI_FAILURE;
-    if (dpiConn__clearTransaction(conn, error) < 0)
-        return DPI_FAILURE;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__setAppContext() [INTERNAL]
-//   Populate the session handle with the application context.
-//-----------------------------------------------------------------------------
-static int dpiConn__setAppContext(void *handle, uint32_t handleType,
-        const dpiConnCreateParams *params, dpiError *error)
-{
-    void *listHandle, *entryHandle;
-    dpiAppContext *entry;
-    uint32_t i;
-
-    // set the number of application context entries
-    if (dpiOci__attrSet(handle, handleType, (void*) &params->numAppContext,
-            sizeof(params->numAppContext), DPI_OCI_ATTR_APPCTX_SIZE,
-            "set app context size", error) < 0)
-        return DPI_FAILURE;
-
-    // get the application context list handle
-    if (dpiOci__attrGet(handle, handleType, &listHandle, NULL,
-            DPI_OCI_ATTR_APPCTX_LIST, "get context list handle", error) < 0)
-        return DPI_FAILURE;
-
-    // set each application context entry
-    for (i = 0; i < params->numAppContext; i++) {
-        entry = &params->appContext[i];
-
-        // retrieve the context element descriptor
-        if (dpiOci__paramGet(listHandle, DPI_OCI_DTYPE_PARAM,
-                &entryHandle, i + 1, "get context entry handle", error) < 0)
-            return DPI_FAILURE;
-
-        // set the namespace name
-        if (dpiOci__attrSet(entryHandle, DPI_OCI_DTYPE_PARAM,
-                (void*) entry->namespaceName, entry->namespaceNameLength,
-                DPI_OCI_ATTR_APPCTX_NAME, "set namespace name", error) < 0)
-            return DPI_FAILURE;
-
-        // set the name
-        if (dpiOci__attrSet(entryHandle, DPI_OCI_DTYPE_PARAM,
-                (void*) entry->name, entry->nameLength,
-                DPI_OCI_ATTR_APPCTX_ATTR, "set name", error) < 0)
-            return DPI_FAILURE;
-
-        // set the value
-        if (dpiOci__attrSet(entryHandle, DPI_OCI_DTYPE_PARAM,
-                (void*) entry->value, entry->valueLength,
-                DPI_OCI_ATTR_APPCTX_VALUE, "set value", error) < 0)
-            return DPI_FAILURE;
-
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__setAttributesFromCreateParams() [INTERNAL]
-//   Populate the authorization info structure or session handle using the
-// create parameters specified.
-//-----------------------------------------------------------------------------
-static int dpiConn__setAttributesFromCreateParams(dpiConn *conn, void *handle,
-        uint32_t handleType, const char *userName, uint32_t userNameLength,
-        const char *password, uint32_t passwordLength,
-        const dpiConnCreateParams *params, dpiError *error)
-{
-    uint32_t purity;
-
-    // set credentials
-    if (userName && userNameLength > 0 && dpiOci__attrSet(handle,
-            handleType, (void*) userName, userNameLength,
-            DPI_OCI_ATTR_USERNAME, "set user name", error) < 0)
-        return DPI_FAILURE;
-    if (password && passwordLength > 0 && dpiOci__attrSet(handle,
-            handleType, (void*) password, passwordLength,
-            DPI_OCI_ATTR_PASSWORD, "set password", error) < 0)
-        return DPI_FAILURE;
-
-    // set connection class and purity parameters
-    if (params->connectionClass && params->connectionClassLength > 0 &&
-            dpiOci__attrSet(handle, handleType,
-                    (void*) params->connectionClass,
-                    params->connectionClassLength,
-                    DPI_OCI_ATTR_CONNECTION_CLASS, "set connection class",
-                    error) < 0)
-        return DPI_FAILURE;
-    if (params->purity != DPI_OCI_ATTR_PURITY_DEFAULT) {
-        purity = params->purity;
-        if (dpiOci__attrSet(handle, handleType, &purity,
-                sizeof(purity), DPI_OCI_ATTR_PURITY, "set purity", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set sharding key and super sharding key parameters
-    if (params->shardingKeyColumns && params->numShardingKeyColumns > 0) {
-        if (dpiConn__setShardingKey(conn, &conn->shardingKey, handle,
-                handleType, DPI_OCI_ATTR_SHARDING_KEY, "set sharding key",
-                params->shardingKeyColumns, params->numShardingKeyColumns,
-                error) < 0)
-            return DPI_FAILURE;
-    }
-    if (params->superShardingKeyColumns &&
-            params->numSuperShardingKeyColumns > 0) {
-        if (params->numShardingKeyColumns == 0)
-            return dpiError__set(error, "ensure sharding key",
-                    DPI_ERR_MISSING_SHARDING_KEY);
-        if (dpiConn__setShardingKey(conn, &conn->superShardingKey, handle,
-                handleType, DPI_OCI_ATTR_SUPER_SHARDING_KEY,
-                "set super sharding key", params->superShardingKeyColumns,
-                params->numSuperShardingKeyColumns, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set application context, if applicable
-    if (handleType == DPI_OCI_HTYPE_SESSION && params->numAppContext > 0)
-        return dpiConn__setAppContext(handle, handleType, params, error);
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__setAttributeText() [INTERNAL]
-//   Set the value of the OCI attribute from a text string.
-//-----------------------------------------------------------------------------
-static int dpiConn__setAttributeText(dpiConn *conn, uint32_t attribute,
-        const char *value, uint32_t valueLength, const char *fnName)
-{
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiConn__check(conn, fnName, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(conn, value)
-
-    // determine pointer to pass (OCI uses different sizes)
-    switch (attribute) {
-        case DPI_OCI_ATTR_ACTION:
-        case DPI_OCI_ATTR_CLIENT_IDENTIFIER:
-        case DPI_OCI_ATTR_CLIENT_INFO:
-        case DPI_OCI_ATTR_CURRENT_SCHEMA:
-        case DPI_OCI_ATTR_ECONTEXT_ID:
-        case DPI_OCI_ATTR_EDITION:
-        case DPI_OCI_ATTR_MODULE:
-        case DPI_OCI_ATTR_DBOP:
-            status = dpiOci__attrSet(conn->sessionHandle,
-                    DPI_OCI_HTYPE_SESSION, (void*) value, valueLength,
-                    attribute, "set session value", &error);
-            break;
-        case DPI_OCI_ATTR_INTERNAL_NAME:
-        case DPI_OCI_ATTR_EXTERNAL_NAME:
-            status = dpiOci__attrSet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
-                    (void*) value, valueLength, attribute, "set server value",
-                    &error);
-            break;
-        default:
-            status = dpiError__set(&error, "set attribute text",
-                    DPI_ERR_NOT_SUPPORTED);
-            break;
-    }
-
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__setShardingKey() [INTERNAL]
-//   Using the specified columns, create a sharding key and set it on the given
-// handle.
-//-----------------------------------------------------------------------------
-static int dpiConn__setShardingKey(dpiConn *conn, void **shardingKey,
-        void *handle, uint32_t handleType, uint32_t attribute,
-        const char *action, dpiShardingKeyColumn *columns, uint8_t numColumns,
-        dpiError *error)
-{
-    uint8_t i;
-
-    // this is only supported on 12.2 and higher clients
-    if (dpiUtils__checkClientVersion(conn->env->versionInfo, 12, 2,
-            error) < 0)
-        return DPI_FAILURE;
-
-    // create sharding key descriptor, if necessary
-    if (dpiOci__descriptorAlloc(conn->env->handle, shardingKey,
-            DPI_OCI_DTYPE_SHARDING_KEY, "allocate sharding key", error) < 0)
-        return DPI_FAILURE;
-
-    // add each column to the sharding key
-    for (i = 0; i < numColumns; i++) {
-        if (dpiConn__setShardingKeyValue(conn, *shardingKey, &columns[i],
-                error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // add the sharding key to the handle
-    if (dpiOci__attrSet(handle, handleType, *shardingKey, 0, attribute, action,
-            error) < 0)
-        return DPI_FAILURE;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__setShardingKeyValue() [INTERNAL]
-//   Using the specified columns, create a sharding key and set it on the given
-// handle.
-//-----------------------------------------------------------------------------
-static int dpiConn__setShardingKeyValue(dpiConn *conn, void *shardingKey,
-        dpiShardingKeyColumn *column, dpiError *error)
-{
-    dpiShardingOciDate shardingDateValue;
-    uint32_t colLen = 0, descType = 0;
-    const dpiOracleType *oracleType;
-    dpiOciNumber numberValue;
-    int convertOk, status;
-    dpiOciDate dateValue;
-    void *col = NULL;
-    uint16_t colType;
-
-    oracleType = dpiOracleType__getFromNum(column->oracleTypeNum, error);
-    if (!oracleType)
-        return DPI_FAILURE;
-    convertOk = 0;
-    colType = oracleType->oracleType;
-    switch (column->oracleTypeNum) {
-        case DPI_ORACLE_TYPE_VARCHAR:
-        case DPI_ORACLE_TYPE_CHAR:
-        case DPI_ORACLE_TYPE_RAW:
-            if (column->nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
-                col = column->value.asBytes.ptr;
-                colLen = column->value.asBytes.length;
-                convertOk = 1;
-            }
-            break;
-        case DPI_ORACLE_TYPE_NUMBER:
-            col = &numberValue;
-            colLen = sizeof(numberValue);
-            if (column->nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
-                if (dpiDataBuffer__toOracleNumberFromDouble(&column->value,
-                        error, &numberValue) < 0)
-                    return DPI_FAILURE;
-                convertOk = 1;
-            } else if (column->nativeTypeNum == DPI_NATIVE_TYPE_INT64) {
-                if (dpiDataBuffer__toOracleNumberFromInteger(&column->value,
-                        error, &numberValue) < 0)
-                    return DPI_FAILURE;
-                convertOk = 1;
-            } else if (column->nativeTypeNum == DPI_NATIVE_TYPE_UINT64) {
-                if (dpiDataBuffer__toOracleNumberFromUnsignedInteger(
-                        &column->value, error, &numberValue) < 0)
-                    return DPI_FAILURE;
-                convertOk = 1;
-            } else if (column->nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
-                if (dpiDataBuffer__toOracleNumberFromText(&column->value,
-                        conn->env, error, &numberValue) < 0)
-                    return DPI_FAILURE;
-                convertOk = 1;
-            }
-            break;
-        case DPI_ORACLE_TYPE_DATE:
-            if (column->nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP) {
-                if (dpiDataBuffer__toOracleDate(&column->value,
-                        &dateValue) < 0)
-                    return DPI_FAILURE;
-                convertOk = 1;
-            } else if (column->nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
-                if (dpiDataBuffer__toOracleDateFromDouble(&column->value,
-                        conn->env, error, &dateValue) < 0)
-                    return DPI_FAILURE;
-                convertOk = 1;
-            }
-
-            // for sharding only, the type must be SQLT_DAT, which uses a
-            // different format for storing the date values
-            if (convertOk) {
-                col = &shardingDateValue;
-                colLen = sizeof(shardingDateValue);
-                colType = DPI_SQLT_DAT;
-                shardingDateValue.century =
-                        ((uint8_t) (dateValue.year / 100)) + 100;
-                shardingDateValue.year = (dateValue.year % 100) + 100;
-                shardingDateValue.month = dateValue.month;
-                shardingDateValue.day = dateValue.day;
-                shardingDateValue.hour = dateValue.hour + 1;
-                shardingDateValue.minute = dateValue.minute + 1;
-                shardingDateValue.second = dateValue.second + 1;
-            }
-            break;
-        case DPI_ORACLE_TYPE_TIMESTAMP:
-        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
-        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
-            colLen = sizeof(void*);
-            colType = DPI_SQLT_TIMESTAMP;
-            if (column->nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP) {
-                descType = DPI_OCI_DTYPE_TIMESTAMP;
-                if (dpiOci__descriptorAlloc(conn->env->handle, &col, descType,
-                        "alloc timestamp", error) < 0)
-                    return DPI_FAILURE;
-                if (dpiDataBuffer__toOracleTimestamp(&column->value, conn->env,
-                        error, col, 0) < 0) {
-                    dpiOci__descriptorFree(col, descType);
-                    return DPI_FAILURE;
-                }
-                convertOk = 1;
-            } else if (column->nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
-                descType = DPI_OCI_DTYPE_TIMESTAMP_LTZ;
-                if (dpiOci__descriptorAlloc(conn->env->handle, &col, descType,
-                        "alloc LTZ timestamp", error) < 0)
-                    return DPI_FAILURE;
-                if (dpiDataBuffer__toOracleTimestampFromDouble(&column->value,
-                        DPI_ORACLE_TYPE_TIMESTAMP_LTZ, conn->env, error,
-                        col) < 0) {
-                    dpiOci__descriptorFree(col, descType);
-                    return DPI_FAILURE;
-                }
-                convertOk = 1;
-            }
-            break;
-        default:
-            break;
-    }
-    if (!convertOk)
-        return dpiError__set(error, "check type", DPI_ERR_NOT_SUPPORTED);
-
-    status = dpiOci__shardingKeyColumnAdd(shardingKey, col, colLen, colType,
-            error);
-    if (descType)
-        dpiOci__descriptorFree(col, descType);
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__setXid() [INTERNAL]
-//   Internal method for associating an XID with the connection.
-//-----------------------------------------------------------------------------
-static int dpiConn__setXid(dpiConn *conn, dpiXid *xid, dpiError *error)
-{
-    dpiOciXID ociXid;
-
-    // validate XID
-    if (xid->globalTransactionIdLength > 0 && !xid->globalTransactionId)
-        return dpiError__set(error, "check XID transaction id ptr",
-                DPI_ERR_PTR_LENGTH_MISMATCH, "xid->globalTransactionId");
-    if (xid->branchQualifierLength > 0 && !xid->branchQualifier)
-        return dpiError__set(error, "check XID branch id ptr",
-                DPI_ERR_PTR_LENGTH_MISMATCH, "xid->branchQualifier");
-    if (xid->globalTransactionIdLength > DPI_XA_MAXGTRIDSIZE)
-        return dpiError__set(error, "check size of XID transaction id",
-                DPI_ERR_TRANS_ID_TOO_LARGE, xid->globalTransactionIdLength,
-                DPI_XA_MAXGTRIDSIZE);
-    if (xid->branchQualifierLength > DPI_XA_MAXBQUALSIZE)
-        return dpiError__set(error, "check size of XID branch qualifier",
-                DPI_ERR_BRANCH_ID_TOO_LARGE, xid->branchQualifierLength,
-                DPI_XA_MAXBQUALSIZE);
-
-    // if a transaction handle does not exist, create one
-    if (!conn->transactionHandle) {
-        if (dpiOci__handleAlloc(conn->env->handle, &conn->transactionHandle,
-                DPI_OCI_HTYPE_TRANS, "create transaction handle", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // associate the transaction with the connection
-    if (dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
-            conn->transactionHandle, 0, DPI_OCI_ATTR_TRANS,
-            "associate transaction", error) < 0)
-        return DPI_FAILURE;
-
-    // associate the XID with the transaction
-    ociXid.formatID = xid->formatId;
-    ociXid.gtrid_length = xid->globalTransactionIdLength;
-    ociXid.bqual_length = xid->branchQualifierLength;
-    if (xid->globalTransactionIdLength > 0)
-        memcpy(ociXid.data, xid->globalTransactionId,
-                xid->globalTransactionIdLength);
-    if (xid->branchQualifierLength > 0)
-        memcpy(&ociXid.data[xid->globalTransactionIdLength],
-                xid->branchQualifier, xid->branchQualifierLength);
-    if (dpiOci__attrSet(conn->transactionHandle, DPI_OCI_HTYPE_TRANS,
-            &ociXid, sizeof(dpiOciXID), DPI_OCI_ATTR_XID, "set XID",
-            error) < 0)
-        return DPI_FAILURE;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn__startupDatabase() [INTERNAL]
-//   Internal method for starting up a database. This is equivalent to
-// "startup nomount" in SQL*Plus.
-//-----------------------------------------------------------------------------
-static int dpiConn__startupDatabase(dpiConn *conn, const char *pfile,
-        uint32_t pfileLength, dpiStartupMode mode, dpiError *error)
-{
-    void *adminHandle = NULL;
-    int status;
-
-    // if a PFILE has been specified, create an admin handle and populate it
-    if (pfileLength > 0) {
-        if (dpiOci__handleAlloc(conn->env->handle, &adminHandle,
-                DPI_OCI_HTYPE_ADMIN, "create admin handle", error) < 0)
-            return DPI_FAILURE;
-        if (dpiOci__attrSet(adminHandle, DPI_OCI_HTYPE_ADMIN,
-                (void*) pfile, pfileLength, DPI_OCI_ATTR_ADMIN_PFILE,
-                "associate PFILE", error) < 0) {
-            dpiOci__handleFree(adminHandle, DPI_OCI_HTYPE_ADMIN);
-            return DPI_FAILURE;
-        }
-    }
-
-    // perform actual startup call
-    status = dpiOci__dbStartup(conn, adminHandle, mode, error);
-
-    // destroy admin handle, if needed
-    if (pfileLength > 0)
-        dpiOci__handleFree(adminHandle, DPI_OCI_HTYPE_ADMIN);
-
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_addRef() [PUBLIC]
-//   Add a reference to the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_addRef(dpiConn *conn)
-{
-    return dpiGen__addRef(conn, DPI_HTYPE_CONN, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_beginDistribTrans() [PUBLIC]
-//   Begin a distributed transaction. This function is deprecated. Use
-// dpiConn_tpcBegin() instead.
-//-----------------------------------------------------------------------------
-int dpiConn_beginDistribTrans(dpiConn *conn, long formatId,
-        const char *globalTransactionId, uint32_t globalTransactionIdLength,
-        const char *branchQualifier, uint32_t branchQualifierLength)
-{
-    dpiXid xid;
-
-    // a negative format id implies a NULL XID so nothing needs to be done
-    if (formatId < 0)
-        return DPI_SUCCESS;
-
-    // call the new function instead
-    xid.formatId = formatId;
-    xid.globalTransactionId = globalTransactionId;
-    xid.globalTransactionIdLength = globalTransactionIdLength;
-    xid.branchQualifier = branchQualifier;
-    xid.branchQualifierLength = branchQualifierLength;
-    return dpiConn_tpcBegin(conn, &xid, 0, DPI_TPC_BEGIN_NEW);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_breakExecution() [PUBLIC]
-//   Break (interrupt) the currently executing operation.
-//-----------------------------------------------------------------------------
-int dpiConn_breakExecution(dpiConn *conn)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    status = dpiOci__break(conn, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_changePassword() [PUBLIC]
-//   Change the password for the specified user.
-//-----------------------------------------------------------------------------
-int dpiConn_changePassword(dpiConn *conn, const char *userName,
-        uint32_t userNameLength, const char *oldPassword,
-        uint32_t oldPasswordLength, const char *newPassword,
-        uint32_t newPasswordLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(conn, userName)
-    DPI_CHECK_PTR_AND_LENGTH(conn, oldPassword)
-    DPI_CHECK_PTR_AND_LENGTH(conn, newPassword)
-    status = dpiOci__passwordChange(conn, userName, userNameLength,
-            oldPassword, oldPasswordLength, newPassword, newPasswordLength,
-            DPI_OCI_DEFAULT, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_close() [PUBLIC]
-//   Close the connection and ensure it can no longer be used.
-//-----------------------------------------------------------------------------
-int dpiConn_close(dpiConn *conn, dpiConnCloseMode mode, const char *tag,
-        uint32_t tagLength)
-{
-    int propagateErrors = !(mode & DPI_MODE_CONN_CLOSE_DROP);
-    dpiError error;
-    int closing;
-
-    // validate parameters
-    if (dpiGen__startPublicFn(conn, DPI_HTYPE_CONN, __func__, &error) < 0)
-        return DPI_FAILURE;
-    if (!conn->handle || conn->closing ||
-            (conn->pool && !conn->pool->handle)) {
-        dpiError__set(&error, "check connected", DPI_ERR_NOT_CONNECTED);
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-    DPI_CHECK_PTR_AND_LENGTH(conn, tag)
-    if (mode && !conn->pool) {
-        dpiError__set(&error, "check in pool", DPI_ERR_CONN_NOT_IN_POOL);
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-    if (conn->externalHandle) {
-        dpiError__set(&error, "check external", DPI_ERR_CONN_IS_EXTERNAL);
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-
-    // determine whether connection is already being closed and if not, mark
-    // connection as being closed; this MUST be done while holding the lock
-    // (if in threaded mode) to avoid race conditions!
-    if (conn->env->threaded)
-        dpiMutex__acquire(conn->env->mutex);
-    closing = conn->closing;
-    conn->closing = 1;
-    if (conn->env->threaded)
-        dpiMutex__release(conn->env->mutex);
-
-    // if connection is already being closed, raise an exception
-    if (closing) {
-        dpiError__set(&error, "check closing", DPI_ERR_NOT_CONNECTED);
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-
-    // if actual close fails, reset closing flag; again, this must be done
-    // while holding the lock (if in threaded mode) in order to avoid race
-    // conditions!
-    if (dpiConn__close(conn, mode, tag, tagLength, propagateErrors,
-            &error) < 0) {
-        if (conn->env->threaded)
-            dpiMutex__acquire(conn->env->mutex);
-        conn->closing = 0;
-        if (conn->env->threaded)
-            dpiMutex__release(conn->env->mutex);
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-
-    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_commit() [PUBLIC]
-//   Commit the transaction associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_commit(dpiConn *conn)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    status = dpiConn__commit(conn, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_create() [PUBLIC]
-//   Create a standalone connection to the database using the parameters
-// specified.
-//-----------------------------------------------------------------------------
-int dpiConn_create(const dpiContext *context, const char *userName,
-        uint32_t userNameLength, const char *password, uint32_t passwordLength,
-        const char *connectString, uint32_t connectStringLength,
-        const dpiCommonCreateParams *commonParams,
-        dpiConnCreateParams *createParams, dpiConn **conn)
-{
-    dpiCommonCreateParams localCommonParams;
-    dpiConnCreateParams localCreateParams;
-    dpiConn *tempConn;
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(context, conn)
-    DPI_CHECK_PTR_AND_LENGTH(context, userName)
-    DPI_CHECK_PTR_AND_LENGTH(context, password)
-    DPI_CHECK_PTR_AND_LENGTH(context, connectString)
-
-    // use default parameters if none provided
-    if (!commonParams) {
-        dpiContext__initCommonCreateParams(context, &localCommonParams);
-        commonParams = &localCommonParams;
-    }
-    if (!createParams) {
-        dpiContext__initConnCreateParams(&localCreateParams);
-        createParams = &localCreateParams;
-    }
-
-    // password must not be specified if external authentication is desired
-    if (createParams->externalAuth && password && passwordLength > 0) {
-        dpiError__set(&error, "verify no password with external auth",
-                DPI_ERR_EXT_AUTH_WITH_CREDENTIALS);
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    }
-
-    // the username must be enclosed within [] if external authentication
-    // with proxy is desired
-    if (createParams->externalAuth && userName && userNameLength > 0 &&
-            (userName[0] != '[' || userName[userNameLength - 1] != ']')) {
-        dpiError__set(&error, "verify proxy user name with external auth",
-                DPI_ERR_EXT_AUTH_INVALID_PROXY);
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error );
-    }
-
-    if (commonParams->accessToken) {
-
-        // externalAuth must be set to true for token based authentication
-        if (!createParams->externalAuth)
-            return dpiError__set(&error, "check externalAuth value",
-                    DPI_ERR_STANDALONE_TOKEN_BASED_AUTH);
-
-        // cannot set username for token based authentication
-        if (userName && userNameLength > 0)
-            return dpiError__set(&error, "verify user in token based auth",
-                DPI_ERR_EXT_AUTH_WITH_CREDENTIALS);
-    }
-
-    // connectionClass and edition cannot be specified at the same time
-    if (createParams->connectionClass &&
-            createParams->connectionClassLength > 0 &&
-            commonParams->edition && commonParams->editionLength > 0) {
-        dpiError__set(&error, "check edition/conn class",
-                DPI_ERR_NO_EDITION_WITH_CONN_CLASS);
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    }
-
-    // newPassword and edition cannot be specified at the same time
-    if (createParams->newPassword && createParams->newPasswordLength > 0 &&
-            commonParams->edition && commonParams->editionLength > 0) {
-        dpiError__set(&error, "check edition/new password",
-                DPI_ERR_NO_EDITION_WITH_NEW_PASSWORD);
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    }
-
-    // handle case where pool is specified
-    if (createParams->pool) {
-        if (dpiGen__checkHandle(createParams->pool, DPI_HTYPE_POOL,
-                "verify pool", &error) < 0)
-            return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-        if (!createParams->pool->handle) {
-            dpiError__set(&error, "check pool", DPI_ERR_NOT_CONNECTED);
-            return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-        }
-        status = dpiPool__acquireConnection(createParams->pool, userName,
-                userNameLength, password, passwordLength, createParams, conn,
-                &error);
-        return dpiGen__endPublicFn(context, status, &error);
-    }
-
-    // create connection
-    if (dpiGen__allocate(DPI_HTYPE_CONN, NULL, (void**) &tempConn, &error) < 0)
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    if (dpiConn__create(tempConn, context, userName, userNameLength,
-            password, passwordLength, connectString, connectStringLength,
-            NULL, commonParams, createParams, &error) < 0) {
-        dpiConn__free(tempConn, &error);
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    }
-
-    *conn = tempConn;
-    dpiHandlePool__release(tempConn->env->errorHandles, &error.handle);
-    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_getSodaDb() [PUBLIC]
-//   Create a new SODA collection with the given name and metadata.
-//-----------------------------------------------------------------------------
-int dpiConn_getSodaDb(dpiConn *conn, dpiSodaDb **db)
-{
-    dpiError error;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiUtils__checkClientVersion(conn->env->versionInfo, 18, 3,
-            &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiUtils__checkDatabaseVersion(conn, 18, 0, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiGen__allocate(DPI_HTYPE_SODA_DB, conn->env, (void**) db,
-            &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    dpiGen__setRefCount(conn, &error, 1);
-    (*db)->conn = conn;
-    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_deqObject() [PUBLIC]
-//   Dequeue a message from the specified queue.
-//-----------------------------------------------------------------------------
-int dpiConn_deqObject(dpiConn *conn, const char *queueName,
-        uint32_t queueNameLength, dpiDeqOptions *options, dpiMsgProps *props,
-        dpiObject *payload, const char **msgId, uint32_t *msgIdLength)
-{
-    dpiError error;
-
-    // validate parameters
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(options, DPI_HTYPE_DEQ_OPTIONS, "verify options",
-            &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(props, DPI_HTYPE_MSG_PROPS,
-            "verify message properties", &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(payload, DPI_HTYPE_OBJECT, "verify payload",
-            &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(conn, queueName)
-    DPI_CHECK_PTR_NOT_NULL(conn, msgId)
-    DPI_CHECK_PTR_NOT_NULL(conn, msgIdLength)
-
-    // dequeue message
-    if (dpiOci__aqDeq(conn, queueName, options->handle, props->handle,
-            payload->type->tdo, &payload->instance, &payload->indicator,
-            &props->msgIdRaw, &error) < 0) {
-        if (error.buffer->code == 25228) {
-            *msgId = NULL;
-            *msgIdLength = 0;
-            return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
-        }
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-    dpiMsgProps__extractMsgId(props, msgId, msgIdLength);
-    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_enqObject() [PUBLIC]
-//   Enqueue a message to the specified queue.
-//-----------------------------------------------------------------------------
-int dpiConn_enqObject(dpiConn *conn, const char *queueName,
-        uint32_t queueNameLength, dpiEnqOptions *options, dpiMsgProps *props,
-        dpiObject *payload, const char **msgId, uint32_t *msgIdLength)
-{
-    dpiError error;
-
-    // validate parameters
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(options, DPI_HTYPE_ENQ_OPTIONS, "verify options",
-            &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(props, DPI_HTYPE_MSG_PROPS,
-            "verify message properties", &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(payload, DPI_HTYPE_OBJECT, "verify payload",
-            &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(conn, queueName)
-    DPI_CHECK_PTR_NOT_NULL(conn, msgId)
-    DPI_CHECK_PTR_NOT_NULL(conn, msgIdLength)
-
-    // enqueue message
-    if (dpiOci__aqEnq(conn, queueName, options->handle, props->handle,
-            payload->type->tdo, &payload->instance, &payload->indicator,
-            &props->msgIdRaw, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    dpiMsgProps__extractMsgId(props, msgId, msgIdLength);
-    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_getCallTimeout() [PUBLIC]
-//   Return the call timeout (in milliseconds) used for round-trips to the
-// database. This is only valid in Oracle Client 18c and higher.
-//-----------------------------------------------------------------------------
-int dpiConn_getCallTimeout(dpiConn *conn, uint32_t *value)
-{
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, value)
-    if (dpiUtils__checkClientVersion(conn->env->versionInfo, 18, 1,
-            &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-
-    // get call timeout
-    status = dpiOci__attrGet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
-            (void*) value, 0, DPI_OCI_ATTR_CALL_TIMEOUT, "get call timeout",
-            &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_getCurrentSchema() [PUBLIC]
-//   Return the current schema associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_getCurrentSchema(dpiConn *conn, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiConn__getAttributeText(conn, DPI_OCI_ATTR_CURRENT_SCHEMA, value,
-            valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_getEdition() [PUBLIC]
-//   Return the edition associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_getEdition(dpiConn *conn, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiConn__getAttributeText(conn, DPI_OCI_ATTR_EDITION, value,
-            valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_getEncodingInfo() [PUBLIC]
-//   Get the encodings from the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_getEncodingInfo(dpiConn *conn, dpiEncodingInfo *info)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    status = dpiEnv__getEncodingInfo(conn->env, info);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_getExternalName() [PUBLIC]
-//   Return the external name associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_getExternalName(dpiConn *conn, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiConn__getAttributeText(conn, DPI_OCI_ATTR_EXTERNAL_NAME, value,
-            valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_getHandle() [PUBLIC]
-//   Get the OCI service context handle associated with the connection. This is
-// available in order to allow for extensions to the library using OCI
-// directly.
-//-----------------------------------------------------------------------------
-int dpiConn_getHandle(dpiConn *conn, void **handle)
-{
-    dpiError error;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, handle)
-    *handle = conn->handle;
-    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_getInternalName() [PUBLIC]
-//   Return the internal name associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_getInternalName(dpiConn *conn, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiConn__getAttributeText(conn, DPI_OCI_ATTR_INTERNAL_NAME, value,
-            valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_getIsHealthy() [PUBLIC]
-//   Return the health of the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_getIsHealthy(dpiConn *conn, int *isHealthy)
-{
-    dpiError error;
-    int status;
-    uint32_t serverStatus;
-
-    if (dpiGen__startPublicFn(conn, DPI_HTYPE_CONN, __func__, &error) < 0)
-        return DPI_FAILURE;
-    if (!conn->handle || !conn->serverHandle || conn->closing ||
-            conn->deadSession || (conn->pool && !conn->pool->handle)) {
-        *isHealthy = 0;
-        status = DPI_SUCCESS;
-    } else {
-        DPI_CHECK_PTR_NOT_NULL(conn, isHealthy)
-        status = dpiOci__attrGet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
-                &serverStatus, NULL, DPI_OCI_ATTR_SERVER_STATUS,
-                "get server status", &error);
-        *isHealthy = (serverStatus == DPI_OCI_SERVER_NORMAL);
-    }
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_getLTXID() [PUBLIC]
-//   Return the logical transaction id associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_getLTXID(dpiConn *conn, const char **value, uint32_t *valueLength)
-{
-    return dpiConn__getAttributeText(conn, DPI_OCI_ATTR_LTXID, value,
-            valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_getObjectType() [PUBLIC]
-//   Look up an object type given its name and return it.
-//-----------------------------------------------------------------------------
-int dpiConn_getObjectType(dpiConn *conn, const char *name, uint32_t nameLength,
-        dpiObjectType **objType)
-{
-    void *describeHandle, *param, *tdo;
-    int status, useTypeByFullName;
-    dpiError error;
-
-    // validate parameters
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, name)
-    DPI_CHECK_PTR_NOT_NULL(conn, objType)
-
-    // allocate describe handle
-    if (dpiOci__handleAlloc(conn->env->handle, &describeHandle,
-            DPI_OCI_HTYPE_DESCRIBE, "allocate describe handle", &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-
-    // Oracle Client 12.1 is capable of using OCITypeByFullName() but will
-    // fail if accessing an Oracle 11.2 database
-    useTypeByFullName = 1;
-    if (conn->env->versionInfo->versionNum < 12)
-        useTypeByFullName = 0;
-    else if (dpiConn__getServerVersion(conn, 0, &error) < 0)
-        return DPI_FAILURE;
-    else if (conn->versionInfo.versionNum < 12)
-        useTypeByFullName = 0;
-
-    // new API is supported so use it
-    if (useTypeByFullName) {
-        if (dpiOci__typeByFullName(conn, name, nameLength, &tdo, &error) < 0) {
-            dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
-            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-        }
-        if (dpiOci__describeAny(conn, tdo, 0, DPI_OCI_OTYPE_PTR,
-                describeHandle, &error) < 0) {
-            dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
-            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-        }
-
-    // use older API
-    } else {
-        if (dpiOci__describeAny(conn, (void*) name, nameLength,
-                DPI_OCI_OTYPE_NAME, describeHandle, &error) < 0) {
-            dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
-            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-        }
-    }
-
-    // get the parameter handle
-    if (dpiOci__attrGet(describeHandle,
-            DPI_OCI_HTYPE_DESCRIBE, &param, 0, DPI_OCI_ATTR_PARAM,
-            "get param", &error) < 0) {
-        dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-
-    // create object type
-    status = dpiObjectType__allocate(conn, param, DPI_OCI_HTYPE_DESCRIBE,
-            objType, &error);
-    dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_getOciAttr() [PUBLIC]
-//   Get the OCI attribute directly. This is intended for testing of attributes
-// not currently exposed by ODPI-C and should only be used for that purpose.
-//-----------------------------------------------------------------------------
-int dpiConn_getOciAttr(dpiConn *conn, uint32_t handleType,
-        uint32_t attribute, dpiDataBuffer *value, uint32_t *valueLength)
-{
-    const void *handle;
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, value)
-    DPI_CHECK_PTR_NOT_NULL(conn, valueLength)
-    switch (handleType) {
-        case DPI_OCI_HTYPE_SVCCTX:
-            handle = conn->handle;
-            break;
-        case DPI_OCI_HTYPE_SERVER:
-            handle = conn->serverHandle;
-            break;
-        case DPI_OCI_HTYPE_SESSION:
-            handle = conn->sessionHandle;
-            break;
-        default:
-            dpiError__set(&error, "check handle type", DPI_ERR_NOT_SUPPORTED);
-            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-
-    // get attribute value
-    status = dpiOci__attrGet(handle, handleType, &value->asRaw, valueLength,
-            attribute, "generic get OCI attribute", &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_getServerVersion() [PUBLIC]
-//   Get the server version string from the database.
-//-----------------------------------------------------------------------------
-int dpiConn_getServerVersion(dpiConn *conn, const char **releaseString,
-        uint32_t *releaseStringLength, dpiVersionInfo *versionInfo)
-{
-    dpiError error;
-
-    // validate parameters
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, versionInfo)
-
-    // get server version
-    if (dpiConn__getServerVersion(conn, (releaseString != NULL), &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (releaseString)
-        *releaseString = conn->releaseString;
-    if (releaseStringLength)
-        *releaseStringLength = conn->releaseStringLength;
-    memcpy(versionInfo, &conn->versionInfo, sizeof(dpiVersionInfo));
-    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_getStmtCacheSize() [PUBLIC]
-//   Return the current size of the statement cache.
-//-----------------------------------------------------------------------------
-int dpiConn_getStmtCacheSize(dpiConn *conn, uint32_t *cacheSize)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, cacheSize)
-    status = dpiOci__attrGet(conn->handle, DPI_OCI_HTYPE_SVCCTX, cacheSize,
-            NULL, DPI_OCI_ATTR_STMTCACHESIZE, "get stmt cache size", &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_newDeqOptions() [PUBLIC]
-//   Create a new dequeue options object and return it.
-//-----------------------------------------------------------------------------
-int dpiConn_newDeqOptions(dpiConn *conn, dpiDeqOptions **options)
-{
-    dpiDeqOptions *tempOptions;
-    dpiError error;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, options)
-    if (dpiGen__allocate(DPI_HTYPE_DEQ_OPTIONS, conn->env,
-            (void**) &tempOptions, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiDeqOptions__create(tempOptions, conn, &error) < 0) {
-        dpiDeqOptions__free(tempOptions, &error);
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-
-    *options = tempOptions;
-    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_newEnqOptions() [PUBLIC]
-//   Create a new enqueue options object and return it.
-//-----------------------------------------------------------------------------
-int dpiConn_newEnqOptions(dpiConn *conn, dpiEnqOptions **options)
-{
-    dpiEnqOptions *tempOptions;
-    dpiError error;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, options)
-    if (dpiGen__allocate(DPI_HTYPE_ENQ_OPTIONS, conn->env,
-            (void**) &tempOptions, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiEnqOptions__create(tempOptions, conn, &error) < 0) {
-        dpiEnqOptions__free(tempOptions, &error);
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-
-    *options = tempOptions;
-    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_newJson() [PUBLIC]
-//   Create a new JSON object and return it.
-//-----------------------------------------------------------------------------
-int dpiConn_newJson(dpiConn *conn, dpiJson **json)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, json);
-    status = dpiJson__allocate(conn, json, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_newJsonQueue() [PUBLIC]
-//   Create a new AQ queue object with JSON payload and return it.
-//-----------------------------------------------------------------------------
-int dpiConn_newJsonQueue(dpiConn *conn, const char *name, uint32_t nameLength,
-        dpiQueue **queue)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(conn, name)
-    DPI_CHECK_PTR_NOT_NULL(conn, queue)
-    status = dpiQueue__allocate(conn, name, nameLength, NULL, queue, 1,
-            &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_newTempLob() [PUBLIC]
-//   Create a new temporary LOB and return it.
-//-----------------------------------------------------------------------------
-int dpiConn_newTempLob(dpiConn *conn, dpiOracleTypeNum lobType, dpiLob **lob)
-{
-    const dpiOracleType *type;
-    dpiLob *tempLob;
-    dpiError error;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, lob)
-    switch (lobType) {
-        case DPI_ORACLE_TYPE_CLOB:
-        case DPI_ORACLE_TYPE_BLOB:
-        case DPI_ORACLE_TYPE_NCLOB:
-            type = dpiOracleType__getFromNum(lobType, &error);
-            break;
-        default:
-            dpiError__set(&error, "check lob type",
-                    DPI_ERR_INVALID_ORACLE_TYPE, lobType);
-            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-    if (dpiLob__allocate(conn, type, &tempLob, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiOci__lobCreateTemporary(tempLob, &error) < 0) {
-        dpiLob__free(tempLob, &error);
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-
-    *lob = tempLob;
-    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_newMsgProps() [PUBLIC]
-//   Create a new message properties object and return it.
-//-----------------------------------------------------------------------------
-int dpiConn_newMsgProps(dpiConn *conn, dpiMsgProps **props)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, props)
-    status = dpiMsgProps__allocate(conn, props, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_newQueue() [PUBLIC]
-//   Create a new AQ queue object and return it.
-//-----------------------------------------------------------------------------
-int dpiConn_newQueue(dpiConn *conn, const char *name, uint32_t nameLength,
-        dpiObjectType *payloadType, dpiQueue **queue)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(conn, name)
-    DPI_CHECK_PTR_NOT_NULL(conn, queue)
-    status = dpiQueue__allocate(conn, name, nameLength, payloadType, queue,
-            0, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_newVar() [PUBLIC]
-//   Create a new variable and return it.
-//-----------------------------------------------------------------------------
-int dpiConn_newVar(dpiConn *conn, dpiOracleTypeNum oracleTypeNum,
-        dpiNativeTypeNum nativeTypeNum, uint32_t maxArraySize, uint32_t size,
-        int sizeIsBytes, int isArray, dpiObjectType *objType, dpiVar **var,
-        dpiData **data)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, var)
-    DPI_CHECK_PTR_NOT_NULL(conn, data)
-    status = dpiVar__allocate(conn, oracleTypeNum, nativeTypeNum, maxArraySize,
-            size, sizeIsBytes, isArray, objType, var, data, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_ping() [PUBLIC]
-//   Makes a round trip call to the server to confirm that the connection and
-// server are still active.
-//-----------------------------------------------------------------------------
-int dpiConn_ping(dpiConn *conn)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    status = dpiOci__ping(conn, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_prepareDistribTrans() [PUBLIC]
-//   Prepare a distributed transaction for commit. This function is deprecated.
-// Use dpiConn_tpcPrepare() instead.
-//-----------------------------------------------------------------------------
-int dpiConn_prepareDistribTrans(dpiConn *conn, int *commitNeeded)
-{
-    return dpiConn_tpcPrepare(conn, NULL, commitNeeded);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_prepareStmt() [PUBLIC]
-//   Create a new statement and return it after preparing the specified SQL.
-//-----------------------------------------------------------------------------
-int dpiConn_prepareStmt(dpiConn *conn, int scrollable, const char *sql,
-        uint32_t sqlLength, const char *tag, uint32_t tagLength,
-        dpiStmt **stmt)
-{
-    dpiStmt *tempStmt;
-    dpiError error;
-
-    *stmt = NULL;
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(conn, sql)
-    DPI_CHECK_PTR_AND_LENGTH(conn, tag)
-    DPI_CHECK_PTR_NOT_NULL(conn, stmt)
-    if (dpiStmt__allocate(conn, scrollable, &tempStmt, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiStmt__prepare(tempStmt, sql, sqlLength, tag, tagLength,
-            &error) < 0) {
-        dpiStmt__free(tempStmt, &error);
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-    *stmt = tempStmt;
-    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_release() [PUBLIC]
-//   Release a reference to the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_release(dpiConn *conn)
-{
-    return dpiGen__release(conn, DPI_HTYPE_CONN, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_rollback() [PUBLIC]
-//   Rollback the transaction associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_rollback(dpiConn *conn)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    status = dpiConn__rollback(conn, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_setAction() [PUBLIC]
-//   Set the action associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_setAction(dpiConn *conn, const char *value, uint32_t valueLength)
-{
-    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_ACTION, value,
-            valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_setCallTimeout() [PUBLIC]
-//   Set the call timeout (in milliseconds) used for round-trips to the
-// database. This is only valid in Oracle Client 18c and higher.
-//-----------------------------------------------------------------------------
-int dpiConn_setCallTimeout(dpiConn *conn, uint32_t value)
-{
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiUtils__checkClientVersion(conn->env->versionInfo, 18, 1,
-            &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-
-    // set call timeout
-    status = dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX, &value,
-            0, DPI_OCI_ATTR_CALL_TIMEOUT, "set call timeout", &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_setClientIdentifier() [PUBLIC]
-//   Set the client identifier associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_setClientIdentifier(dpiConn *conn, const char *value,
-        uint32_t valueLength)
-{
-    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_CLIENT_IDENTIFIER,
-            value, valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_setClientInfo() [PUBLIC]
-//   Set the client info associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_setClientInfo(dpiConn *conn, const char *value,
-        uint32_t valueLength)
-{
-    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_CLIENT_INFO, value,
-            valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_setCurrentSchema() [PUBLIC]
-//   Set the current schema associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_setCurrentSchema(dpiConn *conn, const char *value,
-        uint32_t valueLength)
-{
-    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_CURRENT_SCHEMA, value,
-            valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_setDbOp() [PUBLIC]
-//   Set the database operation associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_setDbOp(dpiConn *conn, const char *value, uint32_t valueLength)
-{
-    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_DBOP, value,
-            valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_setEcontextId() [PUBLIC]
-//   Set the execute context id associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_setEcontextId(dpiConn *conn, const char *value,
-        uint32_t valueLength)
-{
-    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_ECONTEXT_ID, value,
-            valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_setExternalName() [PUBLIC]
-//   Set the external name associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_setExternalName(dpiConn *conn, const char *value,
-        uint32_t valueLength)
-{
-    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_EXTERNAL_NAME, value,
-            valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_setInternalName() [PUBLIC]
-//   Set the internal name associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_setInternalName(dpiConn *conn, const char *value,
-        uint32_t valueLength)
-{
-    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_INTERNAL_NAME, value,
-            valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_setModule() [PUBLIC]
-//   Set the module associated with the connection.
-//-----------------------------------------------------------------------------
-int dpiConn_setModule(dpiConn *conn, const char *value, uint32_t valueLength)
-{
-    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_MODULE, value,
-            valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_setOciAttr() [PUBLIC]
-//   Set the OCI attribute directly. This is intended for testing of attributes
-// not currently exposed by ODPI-C and should only be used for that purpose.
-//-----------------------------------------------------------------------------
-int dpiConn_setOciAttr(dpiConn *conn, uint32_t handleType,
-        uint32_t attribute, void *value, uint32_t valueLength)
-{
-    dpiError error;
-    void *handle;
-    int status;
-
-    // validate parameters
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, value)
-    switch (handleType) {
-        case DPI_OCI_HTYPE_SVCCTX:
-            handle = conn->handle;
-            break;
-        case DPI_OCI_HTYPE_SERVER:
-            handle = conn->serverHandle;
-            break;
-        case DPI_OCI_HTYPE_SESSION:
-            handle = conn->sessionHandle;
-            break;
-        default:
-            dpiError__set(&error, "check handle type", DPI_ERR_NOT_SUPPORTED);
-            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-
-    // set attribute value
-    status = dpiOci__attrSet(handle, handleType, value, valueLength,
-            attribute, "generic set OCI attribute", &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_setStmtCacheSize() [PUBLIC]
-//   Set the size of the statement cache.
-//-----------------------------------------------------------------------------
-int dpiConn_setStmtCacheSize(dpiConn *conn, uint32_t cacheSize)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    status = dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX, &cacheSize, 0,
-            DPI_OCI_ATTR_STMTCACHESIZE, "set stmt cache size", &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_shutdownDatabase() [PUBLIC]
-//   Shutdown the database. Note that this must be done in two phases except in
-// the situation where the instance is being aborted.
-//-----------------------------------------------------------------------------
-int dpiConn_shutdownDatabase(dpiConn *conn, dpiShutdownMode mode)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    status = dpiOci__dbShutdown(conn, mode, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_startupDatabase() [PUBLIC]
-//   Startup the database. This is equivalent to "startup nomount" in SQL*Plus.
-//-----------------------------------------------------------------------------
-int dpiConn_startupDatabase(dpiConn *conn, dpiStartupMode mode)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    status = dpiConn__startupDatabase(conn, NULL, 0, mode, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_startupDatabaseWithPfile() [PUBLIC]
-//   Startup the database with a parameter file (PFILE). This is equivalent to
-// "startup nomount pfile=<pfile_location>" in SQL*Plus.
-//-----------------------------------------------------------------------------
-int dpiConn_startupDatabaseWithPfile(dpiConn *conn, const char *pfile,
-        uint32_t pfileLength, dpiStartupMode mode)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(conn, pfile)
-    status = dpiConn__startupDatabase(conn, pfile, pfileLength, mode, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_subscribe() [PUBLIC]
-//   Subscribe to events in the database. A subscription is created and
-// returned. This replaces dpiConn_newSubscription().
-//-----------------------------------------------------------------------------
-int dpiConn_subscribe(dpiConn *conn, dpiSubscrCreateParams *params,
-        dpiSubscr **subscr)
-{
-    dpiSubscr *tempSubscr;
-    dpiError error;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, params)
-    DPI_CHECK_PTR_NOT_NULL(conn, subscr)
-    if (!conn->env->events) {
-        dpiError__set(&error, "subscribe", DPI_ERR_EVENTS_MODE_REQUIRED);
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-    if (dpiGen__allocate(DPI_HTYPE_SUBSCR, conn->env, (void**) &tempSubscr,
-            &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiSubscr__create(tempSubscr, conn, params, &error) < 0) {
-        dpiSubscr__free(tempSubscr, &error);
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-
-    *subscr = tempSubscr;
-    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_tpcBegin() [PUBLIC]
-//   Begin a TPC (two-phase commit) transaction.
-//-----------------------------------------------------------------------------
-int dpiConn_tpcBegin(dpiConn *conn, dpiXid *xid, uint32_t transactionTimeout,
-        uint32_t flags)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, xid)
-    if (dpiConn__setXid(conn, xid, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    status = dpiOci__transStart(conn, transactionTimeout, flags, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_tpcCommit() [PUBLIC]
-//   Commit a TPC (two-phase commit) transaction. This method is equivalent to
-// calling dpiConn_commit() if no XID is specified.
-//-----------------------------------------------------------------------------
-int dpiConn_tpcCommit(dpiConn *conn, dpiXid *xid, int onePhase)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (xid) {
-        if (dpiConn__setXid(conn, xid, &error) < 0)
-            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-        conn->commitMode = (onePhase) ? DPI_OCI_DEFAULT :
-                DPI_OCI_TRANS_TWOPHASE;
-    }
-    status = dpiConn__commit(conn, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_tpcEnd() [PUBLIC]
-//   End (detach from) a TPC (two-phase commit) transaction.
-//-----------------------------------------------------------------------------
-int dpiConn_tpcEnd(dpiConn *conn, dpiXid *xid, uint32_t flags)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (xid) {
-        if (dpiConn__setXid(conn, xid, &error) < 0)
-            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-    status = dpiOci__transDetach(conn, flags, &error);
-    if (status == DPI_SUCCESS)
-        status = dpiConn__clearTransaction(conn, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_tpcForget() [PUBLIC]
-//   Forget a TPC (two-phase commit) transaction.
-//-----------------------------------------------------------------------------
-int dpiConn_tpcForget(dpiConn *conn, dpiXid *xid)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, xid)
-    if (dpiConn__setXid(conn, xid, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    status = dpiOci__transForget(conn, &error);
-    if (status == DPI_SUCCESS)
-        status = dpiConn__clearTransaction(conn, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_tpcPrepare() [PUBLIC]
-//   Prepare a TPC (two-phase commit) transaction for commit. A boolean is
-// returned indicating if a commit is actually needed as an attempt to perform
-// a commit when nothing is actually prepared results in ORA-24756 (transaction
-// does not exist). This is determined by the return value from
-// OCITransPrepare() which is OCI_SUCCESS_WITH_INFO if there is no transaction
-// requiring commit.
-//-----------------------------------------------------------------------------
-int dpiConn_tpcPrepare(dpiConn *conn, dpiXid *xid, int *commitNeeded)
-{
-    dpiError error;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(conn, commitNeeded)
-    if (xid) {
-        if (dpiConn__setXid(conn, xid, &error) < 0)
-            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-    if (dpiOci__transPrepare(conn, commitNeeded, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (*commitNeeded)
-        conn->commitMode = DPI_OCI_TRANS_TWOPHASE;
-    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_tpcRollback() [PUBLIC]
-//   Rollback a TPC (two-phase commit) transaction. This method is equivalent
-// to calling dpiConn_rollback() if no XID is specified.
-//-----------------------------------------------------------------------------
-int dpiConn_tpcRollback(dpiConn *conn, dpiXid *xid)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (xid) {
-        if (dpiConn__setXid(conn, xid, &error) < 0)
-            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    }
-    status = dpiConn__rollback(conn, &error);
-    return dpiGen__endPublicFn(conn, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiConn_unsubscribe() [PUBLIC]
-//   Unsubscribe from events in the database. Once this call completes
-// successfully no further notifications will be sent.
-//-----------------------------------------------------------------------------
-int dpiConn_unsubscribe(dpiConn *conn, dpiSubscr *subscr)
-{
-    dpiError error;
-    int status;
-
-    if (dpiConn__check(conn, __func__, &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(subscr, DPI_HTYPE_SUBSCR, "check subscription",
-            &error) < 0)
-        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
-    if (subscr->registered) {
-        dpiMutex__acquire(subscr->mutex);
-        status = dpiOci__subscriptionUnRegister(conn, subscr, &error);
-        if (status == DPI_SUCCESS)
-            subscr->registered = 0;
-        dpiMutex__release(subscr->mutex);
-        if (status < 0)
-            return dpiGen__endPublicFn(subscr, DPI_FAILURE, &error);
-    }
-
-    dpiGen__setRefCount(subscr, &error, -1);
-    return dpiGen__endPublicFn(subscr, DPI_SUCCESS, &error);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiConn.h ./odpi/src/dpiConn.h
--- patched-godror/odpi/src/dpiConn.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiConn.h	2024-05-14 14:55:13
@@ -0,0 +1,2788 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiConn.c
+//   Implementation of connection.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+#include <time.h>
+
+// forward declarations of internal functions only used in this file
+static int dpiConn__attachExternal(dpiConn *conn, void *externalHandle,
+        dpiError *error);
+static int dpiConn__createStandalone(dpiConn *conn, const char *userName,
+        uint32_t userNameLength, const char *password, uint32_t passwordLength,
+        const char *connectString, uint32_t connectStringLength,
+        const dpiCommonCreateParams *commonParams,
+        const dpiConnCreateParams *createParams, dpiError *error);
+static int dpiConn__get(dpiConn *conn, const char *userName,
+        uint32_t userNameLength, const char *password, uint32_t passwordLength,
+        const char *connectString, uint32_t connectStringLength,
+        dpiConnCreateParams *createParams, dpiPool *pool, dpiError *error);
+static int dpiConn__getHandles(dpiConn *conn, dpiError *error);
+static int dpiConn__getServerCharset(dpiConn *conn, dpiError *error);
+static int dpiConn__getSession(dpiConn *conn, uint32_t mode,
+        const char *connectString, uint32_t connectStringLength,
+        dpiConnCreateParams *params, void *authInfo, dpiError *error);
+static int dpiConn__setAttributesFromCreateParams(dpiConn *conn, void *handle,
+        uint32_t handleType, const char *userName, uint32_t userNameLength,
+        const char *password, uint32_t passwordLength,
+        const dpiConnCreateParams *params, dpiError *error);
+static int dpiConn__setShardingKey(dpiConn *conn, void **shardingKey,
+        void *handle, uint32_t handleType, uint32_t attribute,
+        const char *action, dpiShardingKeyColumn *columns, uint8_t numColumns,
+        dpiError *error);
+static int dpiConn__setShardingKeyValue(dpiConn *conn, void *shardingKey,
+        dpiShardingKeyColumn *column, dpiError *error);
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__attachExternal() [INTERNAL]
+//   Attach to the server and session of an existing service context handle.
+//-----------------------------------------------------------------------------
+static int dpiConn__attachExternal(dpiConn *conn, void *externalHandle,
+        dpiError *error)
+{
+    // mark connection as using an external handle so that no attempts are
+    // made to close it
+    conn->externalHandle = 1;
+
+    // acquire handles from existing service context handle
+    conn->handle = externalHandle;
+    if (dpiConn__getHandles(conn, error) < 0) {
+        conn->handle = NULL;
+        return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__check() [INTERNAL]
+//   Validate the connection handle and that it is still connected to the
+// database.
+//-----------------------------------------------------------------------------
+static int dpiConn__check(dpiConn *conn, const char *fnName, dpiError *error)
+{
+    if (dpiGen__startPublicFn(conn, DPI_HTYPE_CONN, fnName, error) < 0)
+        return DPI_FAILURE;
+    return dpiConn__checkConnected(conn, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__checkConnected() [INTERNAL]
+//   Check to see if the connection is still open and raise an exception if it
+// is not.
+// Maintainers: keep these checks in sync with dpiConn_getIsHealthy()
+//-----------------------------------------------------------------------------
+int dpiConn__checkConnected(dpiConn *conn, dpiError *error)
+{
+    if (!conn->handle || conn->closing || conn->deadSession ||
+            (conn->pool && !conn->pool->handle))
+        return dpiError__set(error, "check connected", DPI_ERR_NOT_CONNECTED);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__clearTransaction() [INTERNAL]
+//   Clears the service context of any associated transaction.
+//-----------------------------------------------------------------------------
+int dpiConn__clearTransaction(dpiConn *conn, dpiError *error)
+{
+    return dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX, NULL, 0,
+            DPI_OCI_ATTR_TRANS, "clear transaction", error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__close() [INTERNAL]
+//   Internal method used for closing the connection. Any transaction is rolled
+// back and any handles allocated are freed. For connections acquired from a
+// pool and that aren't marked as needed to be dropped, the last time used is
+// updated. This is called from dpiConn_close() where errors are expected to be
+// propagated and from dpiConn__free() where errors are ignored.
+//-----------------------------------------------------------------------------
+static int dpiConn__close(dpiConn *conn, uint32_t mode, const char *tag,
+        uint32_t tagLength, int propagateErrors, dpiError *error)
+{
+    int status, txnInProgress;
+    uint32_t serverStatus, i;
+    time_t *lastTimeUsed;
+    dpiObject *obj;
+    dpiStmt *stmt;
+    dpiLob *lob;
+
+    // rollback any outstanding transaction, if one is in progress; drop the
+    // session if any errors take place
+    txnInProgress = 0;
+    if (!conn->deadSession && !conn->externalHandle && conn->sessionHandle) {
+        txnInProgress = 1;
+        if (conn->env->versionInfo->versionNum >= 12)
+            dpiOci__attrGet(conn->sessionHandle, DPI_OCI_HTYPE_SESSION,
+                    &txnInProgress, NULL, DPI_OCI_ATTR_TRANSACTION_IN_PROGRESS,
+                    NULL, error);
+    }
+    if (txnInProgress &&
+            dpiOci__transRollback(conn, propagateErrors, error) < 0)
+        conn->deadSession = 1;
+
+    // close all objects; note that no references are retained by the
+    // handle list (otherwise all objects would be left until an explicit
+    // close of the connection was made) so a reference needs to be acquired
+    // first, as otherwise the object may be freed while the close is being
+    // performed!
+    if (conn->objects && !conn->externalHandle) {
+        for (i = 0; i < conn->objects->numSlots; i++) {
+            obj = (dpiObject*) conn->objects->handles[i];
+            if (!obj)
+                continue;
+            if (conn->env->threaded) {
+                dpiMutex__acquire(conn->env->mutex);
+                status = dpiGen__checkHandle(obj, DPI_HTYPE_OBJECT, NULL,
+                        NULL);
+                if (status == DPI_SUCCESS)
+                    obj->refCount += 1;
+                dpiMutex__release(conn->env->mutex);
+                if (status < 0)
+                    continue;
+            }
+            status = dpiObject__close(obj, propagateErrors, error);
+            if (conn->env->threaded)
+                dpiGen__setRefCount(obj, error, -1);
+            if (status < 0)
+                return DPI_FAILURE;
+        }
+    }
+
+    // close all open statements; note that no references are retained by the
+    // handle list (otherwise all statements would be left open until an
+    // explicit close was made of either the statement or the connection) so
+    // a reference needs to be acquired first, as otherwise the statement may
+    // be freed while the close is being performed!
+    if (conn->openStmts && !conn->externalHandle) {
+        for (i = 0; i < conn->openStmts->numSlots; i++) {
+            stmt = (dpiStmt*) conn->openStmts->handles[i];
+            if (!stmt)
+                continue;
+            if (conn->env->threaded) {
+                dpiMutex__acquire(conn->env->mutex);
+                status = dpiGen__checkHandle(stmt, DPI_HTYPE_STMT, NULL, NULL);
+                if (status == DPI_SUCCESS)
+                    stmt->refCount += 1;
+                dpiMutex__release(conn->env->mutex);
+                if (status < 0)
+                    continue;
+            }
+            status = dpiStmt__close(stmt, NULL, 0, propagateErrors, error);
+            if (conn->env->threaded)
+                dpiGen__setRefCount(stmt, error, -1);
+            if (status < 0)
+                return DPI_FAILURE;
+        }
+    }
+
+    // close all open LOBs; the same comments apply as for statements
+    // NOTE: Oracle Client 20 automatically closes all open LOBs which makes
+    // this code redundant; as such, it can be removed once the minimum version
+    // supported by ODPI-C is 20
+    if (conn->openLobs && !conn->externalHandle) {
+        for (i = 0; i < conn->openLobs->numSlots; i++) {
+            lob = (dpiLob*) conn->openLobs->handles[i];
+            if (!lob)
+                continue;
+            if (conn->env->threaded) {
+                dpiMutex__acquire(conn->env->mutex);
+                status = dpiGen__checkHandle(lob, DPI_HTYPE_LOB, NULL, NULL);
+                if (status == DPI_SUCCESS)
+                    lob->refCount += 1;
+                dpiMutex__release(conn->env->mutex);
+                if (status < 0)
+                    continue;
+            }
+            status = dpiLob__close(lob, propagateErrors, error);
+            if (conn->env->threaded)
+                dpiGen__setRefCount(lob, error, -1);
+            if (status < 0)
+                return DPI_FAILURE;
+        }
+    }
+
+    // handle connections created with an external handle
+    if (conn->externalHandle) {
+        conn->sessionHandle = NULL;
+
+    // handle standalone connections
+    } else if (conn->standalone) {
+
+        // end session and free session handle
+        if (dpiOci__sessionEnd(conn, propagateErrors, error) < 0)
+            return DPI_FAILURE;
+        dpiOci__handleFree(conn->sessionHandle, DPI_OCI_HTYPE_SESSION);
+        conn->sessionHandle = NULL;
+
+        // detach from server and free server handle
+        if (dpiOci__serverDetach(conn, propagateErrors, error) < 0)
+            return DPI_FAILURE;
+        dpiOci__handleFree(conn->serverHandle, DPI_OCI_HTYPE_SERVER);
+
+        // free service context handle
+        dpiOci__handleFree(conn->handle, DPI_OCI_HTYPE_SVCCTX);
+
+    // handle pooled connections
+    } else {
+
+        // if session is to be dropped, mark it as a dead session
+        if (mode & DPI_OCI_SESSRLS_DROPSESS) {
+            conn->deadSession = 1;
+
+        // otherwise, check server status; if not connected, ensure session is
+        // dropped
+        } else if (conn->serverHandle) {
+            if (dpiOci__attrGet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
+                    &serverStatus, NULL, DPI_OCI_ATTR_SERVER_STATUS,
+                    "get server status", error) < 0 ||
+                    serverStatus != DPI_OCI_SERVER_NORMAL)
+                conn->deadSession = 1;
+        }
+
+        // update last time used (if the session isn't going to be dropped)
+        // clear last time used (if the session is going to be dropped)
+        // do nothing, however, if not using a pool or the pool is being closed
+        if (conn->sessionHandle && conn->pool && conn->pool->handle) {
+
+            // get the pointer from the context associated with the session
+            lastTimeUsed = NULL;
+            if (dpiOci__contextGetValue(conn, DPI_CONTEXT_LAST_TIME_USED,
+                    (uint32_t) (sizeof(DPI_CONTEXT_LAST_TIME_USED) - 1),
+                    (void**) &lastTimeUsed, propagateErrors, error) < 0)
+                return DPI_FAILURE;
+
+            // if pointer available and session is going to be dropped, clear
+            // memory in order to avoid memory leak in OCI
+            if (lastTimeUsed && conn->deadSession) {
+                dpiOci__contextSetValue(conn, DPI_CONTEXT_LAST_TIME_USED,
+                        (uint32_t) (sizeof(DPI_CONTEXT_LAST_TIME_USED) - 1),
+                        NULL, 0, error);
+                dpiOci__memoryFree(conn, lastTimeUsed, error);
+                lastTimeUsed = NULL;
+
+            // otherwise, if the pointer is not available, allocate a new
+            // pointer and set it
+            } else if (!lastTimeUsed && !conn->deadSession) {
+                if (dpiOci__memoryAlloc(conn, (void**) &lastTimeUsed,
+                        sizeof(time_t), propagateErrors, error) < 0)
+                    return DPI_FAILURE;
+                if (dpiOci__contextSetValue(conn, DPI_CONTEXT_LAST_TIME_USED,
+                        (uint32_t) (sizeof(DPI_CONTEXT_LAST_TIME_USED) - 1),
+                        lastTimeUsed, propagateErrors, error) < 0) {
+                    dpiOci__memoryFree(conn, lastTimeUsed, error);
+                    lastTimeUsed = NULL;
+                }
+            }
+
+            // set last time used (used when acquiring a session to determine
+            // if ping is required)
+            if (lastTimeUsed)
+                *lastTimeUsed = time(NULL);
+
+        }
+
+        // release session
+        if (conn->deadSession)
+            mode |= DPI_OCI_SESSRLS_DROPSESS;
+        else if (dpiUtils__checkClientVersion(conn->env->versionInfo, 12, 2,
+                NULL) == DPI_SUCCESS && (mode & DPI_MODE_CONN_CLOSE_RETAG) &&
+                tag && tagLength > 0)
+            mode |= DPI_OCI_SESSRLS_MULTIPROPERTY_TAG;
+        if (dpiOci__sessionRelease(conn, tag, tagLength, mode, propagateErrors,
+                error) < 0)
+            return DPI_FAILURE;
+        conn->sessionHandle = NULL;
+
+    }
+    conn->handle = NULL;
+    conn->serverHandle = NULL;
+
+    // destroy sharding and super sharding key descriptors, if applicable
+    if (conn->shardingKey) {
+        dpiOci__descriptorFree(conn->shardingKey, DPI_OCI_DTYPE_SHARDING_KEY);
+        conn->shardingKey = NULL;
+    }
+    if (conn->superShardingKey) {
+        dpiOci__descriptorFree(conn->superShardingKey,
+                DPI_OCI_DTYPE_SHARDING_KEY);
+        conn->superShardingKey = NULL;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__commit() [PRIVATE]
+//   Internal method used to commit the transaction associated with the
+// connection. Once the commit has taken place, the transaction handle
+// associated with the connection is cleared.
+//-----------------------------------------------------------------------------
+int dpiConn__commit(dpiConn *conn, dpiError *error)
+{
+    if (dpiOci__transCommit(conn, conn->commitMode, error) < 0)
+        return DPI_FAILURE;
+    if (dpiConn__clearTransaction(conn, error) < 0)
+        return DPI_FAILURE;
+    conn->commitMode = DPI_OCI_DEFAULT;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__create() [PRIVATE]
+//   Perform internal initialization of the connection.
+//-----------------------------------------------------------------------------
+int dpiConn__create(dpiConn *conn, const dpiContext *context,
+        const char *userName, uint32_t userNameLength, const char *password,
+        uint32_t passwordLength, const char *connectString,
+        uint32_t connectStringLength, dpiPool *pool,
+        const dpiCommonCreateParams *commonParams,
+        dpiConnCreateParams *createParams, dpiError *error)
+{
+    void *envHandle = NULL;
+    int status;
+
+    // mark connection as being created so that errors that are raised do not
+    // do dead connection detection
+    conn->creating = 1;
+
+    // allocate handle lists for statements, LOBs and objects
+    if (dpiHandleList__create(&conn->openStmts, error) < 0)
+        return DPI_FAILURE;
+    if (dpiHandleList__create(&conn->openLobs, error) < 0)
+        return DPI_FAILURE;
+    if (dpiHandleList__create(&conn->objects, error) < 0)
+        return DPI_FAILURE;
+
+    // if an external service context handle is provided, acquire the
+    // environment handle from it; need a temporary environment handle in order
+    // to do so
+    if (createParams->externalHandle) {
+        error->env = conn->env;
+        if (dpiOci__envNlsCreate(&conn->env->handle, DPI_OCI_DEFAULT, 0, 0,
+                error) < 0)
+            return DPI_FAILURE;
+        if (dpiOci__handleAlloc(conn->env->handle, &error->handle,
+                DPI_OCI_HTYPE_ERROR, "allocate temp OCI error", error) < 0)
+            return DPI_FAILURE;
+        if (dpiOci__attrGet(createParams->externalHandle, DPI_OCI_HTYPE_SVCCTX,
+                &envHandle, NULL, DPI_OCI_ATTR_ENV, "get env handle",
+                error) < 0)
+            return DPI_FAILURE;
+        dpiOci__handleFree(conn->env->handle, DPI_OCI_HTYPE_ENV);
+        error->handle = NULL;
+        conn->env->handle = NULL;
+    }
+
+    // initialize environment (for non-pooled connections)
+    if (!pool && dpiEnv__init(conn->env, context, commonParams, envHandle,
+            commonParams->createMode, error) < 0)
+        return DPI_FAILURE;
+
+    // if a handle is specified, use it
+    if (createParams->externalHandle)
+        return dpiConn__attachExternal(conn, createParams->externalHandle,
+                error);
+
+    // connection class, sharding and the use of session pools require the use
+    // of the OCISessionGet() method; all other cases use the OCISessionBegin()
+    // method which is more capable
+    if (pool || (createParams->connectionClass &&
+            createParams->connectionClassLength > 0) ||
+            createParams->shardingKeyColumns ||
+            createParams->superShardingKeyColumns) {
+        status = dpiConn__get(conn, userName, userNameLength, password,
+                passwordLength, connectString, connectStringLength,
+                createParams, pool, error);
+    } else {
+        status = dpiConn__createStandalone(conn, userName, userNameLength,
+                password, passwordLength, connectString, connectStringLength,
+                commonParams, createParams, error);
+    }
+
+    // mark connection as no longer being created so that subsequent errors
+    // that are raised do perform dead connection detection
+    conn->creating = 0;
+
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__createStandalone() [PRIVATE]
+//   Create a standalone connection to the database using the parameters
+// specified.
+//-----------------------------------------------------------------------------
+static int dpiConn__createStandalone(dpiConn *conn, const char *userName,
+        uint32_t userNameLength, const char *password, uint32_t passwordLength,
+        const char *connectString, uint32_t connectStringLength,
+        const dpiCommonCreateParams *commonParams,
+        const dpiConnCreateParams *createParams, dpiError *error)
+{
+    uint32_t credentialType, authMode;
+
+    // mark the connection as a standalone connection
+    conn->standalone = 1;
+
+    // allocate the server handle
+    if (dpiOci__handleAlloc(conn->env->handle, &conn->serverHandle,
+            DPI_OCI_HTYPE_SERVER, "allocate server handle", error) < 0)
+        return DPI_FAILURE;
+
+    // attach to the server
+    if (dpiOci__serverAttach(conn, connectString, connectStringLength,
+            error) < 0)
+        return DPI_FAILURE;
+
+    // allocate the service context handle
+    if (dpiOci__handleAlloc(conn->env->handle, &conn->handle,
+            DPI_OCI_HTYPE_SVCCTX, "allocate service context handle",
+            error) < 0)
+        return DPI_FAILURE;
+
+    // set attribute for server handle
+    if (dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX, conn->serverHandle,
+            0, DPI_OCI_ATTR_SERVER, "set server handle", error) < 0)
+        return DPI_FAILURE;
+
+    // allocate the session handle
+    if (dpiOci__handleAlloc(conn->env->handle, &conn->sessionHandle,
+            DPI_OCI_HTYPE_SESSION, "allocate session handle", error) < 0)
+        return DPI_FAILURE;
+
+    // driver name and edition are only relevant for standalone connections
+    if (dpiUtils__setAttributesFromCommonCreateParams(conn->sessionHandle,
+            DPI_OCI_HTYPE_SESSION, commonParams, error) < 0)
+        return DPI_FAILURE;
+
+    // set access token for token based authentication
+    if (commonParams->accessToken) {
+        if (dpiUtils__setAccessTokenAttributes(conn->sessionHandle,
+                commonParams->accessToken, conn->env->versionInfo, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // populate attributes on the session handle
+    if (dpiConn__setAttributesFromCreateParams(conn, conn->sessionHandle,
+            DPI_OCI_HTYPE_SESSION, userName, userNameLength, password,
+            passwordLength, createParams, error) < 0)
+        return DPI_FAILURE;
+
+    // set the session handle on the service context handle
+    if (dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
+            conn->sessionHandle, 0, DPI_OCI_ATTR_SESSION, "set session handle",
+            error) < 0)
+        return DPI_FAILURE;
+
+    // if a new password is specified, change it (this also creates the session
+    // so a call to OCISessionBegin() is not needed)
+    if (createParams->newPassword && createParams->newPasswordLength > 0) {
+        authMode = DPI_OCI_AUTH;
+        if (createParams->authMode & DPI_MODE_AUTH_SYSDBA)
+            authMode |= DPI_OCI_CPW_SYSDBA;
+        if (createParams->authMode & DPI_MODE_AUTH_SYSOPER)
+            authMode |= DPI_OCI_CPW_SYSOPER;
+        if (createParams->authMode & DPI_MODE_AUTH_SYSASM)
+            authMode |= DPI_OCI_CPW_SYSASM;
+        if (createParams->authMode & DPI_MODE_AUTH_SYSBKP)
+            authMode |= DPI_OCI_CPW_SYSBKP;
+        if (createParams->authMode & DPI_MODE_AUTH_SYSDGD)
+            authMode |= DPI_OCI_CPW_SYSDGD;
+        if (createParams->authMode & DPI_MODE_AUTH_SYSKMT)
+            authMode |= DPI_OCI_CPW_SYSKMT;
+        return dpiOci__passwordChange(conn, userName, userNameLength, password,
+                passwordLength, createParams->newPassword,
+                createParams->newPasswordLength, authMode, error);
+    }
+
+    // begin the session
+    credentialType = (createParams->externalAuth) ? DPI_OCI_CRED_EXT :
+            DPI_OCI_CRED_RDBMS;
+    authMode = createParams->authMode | DPI_OCI_STMT_CACHE;
+    if (dpiOci__sessionBegin(conn, credentialType, authMode, error) < 0)
+        return DPI_FAILURE;
+    if (dpiConn__getServerCharset(conn, error) < 0)
+        return DPI_FAILURE;
+
+    // set the statement cache size
+    if (dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
+            (void*) &commonParams->stmtCacheSize, 0,
+            DPI_OCI_ATTR_STMTCACHESIZE, "set stmt cache size", error) < 0)
+        return DPI_FAILURE;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__free() [INTERNAL]
+//   Free the memory and any resources associated with the connection.
+//-----------------------------------------------------------------------------
+void dpiConn__free(dpiConn *conn, dpiError *error)
+{
+    if (conn->handle)
+        dpiConn__close(conn, DPI_MODE_CONN_CLOSE_DEFAULT, NULL, 0, 0,
+                error);
+    if (conn->pool) {
+        dpiGen__setRefCount(conn->pool, error, -1);
+        conn->pool = NULL;
+        conn->env = NULL;
+    }
+    if (conn->env) {
+        dpiEnv__free(conn->env, error);
+        conn->env = NULL;
+    }
+    if (conn->releaseString) {
+        dpiUtils__freeMemory((void*) conn->releaseString);
+        conn->releaseString = NULL;
+    }
+    if (conn->openStmts) {
+        dpiHandleList__free(conn->openStmts);
+        conn->openStmts = NULL;
+    }
+    if (conn->openLobs) {
+        dpiHandleList__free(conn->openLobs);
+        conn->openLobs = NULL;
+    }
+    if (conn->objects) {
+        dpiHandleList__free(conn->objects);
+        conn->objects = NULL;
+    }
+    if (conn->transactionHandle) {
+        dpiOci__handleFree(conn->transactionHandle, DPI_OCI_HTYPE_TRANS);
+        conn->transactionHandle = NULL;
+    }
+    dpiUtils__freeMemory(conn);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__get() [INTERNAL]
+//   Create a connection to the database using the parameters specified. This
+// method uses the simplified OCI session creation protocol which is required
+// when using pools and session tagging.
+//-----------------------------------------------------------------------------
+static int dpiConn__get(dpiConn *conn, const char *userName,
+        uint32_t userNameLength, const char *password, uint32_t passwordLength,
+        const char *connectString, uint32_t connectStringLength,
+        dpiConnCreateParams *createParams, dpiPool *pool, dpiError *error)
+{
+    int externalAuth, status;
+    void *authInfo;
+    uint32_t mode;
+
+    // clear pointers if length is 0
+    if (userNameLength == 0)
+        userName = NULL;
+    if (passwordLength == 0)
+        password = NULL;
+
+    // set things up for the call to acquire a session
+    if (pool) {
+        dpiGen__setRefCount(pool, error, 1);
+        conn->pool = pool;
+        mode = DPI_OCI_SESSGET_SPOOL;
+        externalAuth = pool->externalAuth;
+        if (userName && pool->homogeneous)
+            return dpiError__set(error, "check proxy", DPI_ERR_INVALID_PROXY);
+
+        // if the userName is provided but no password is provided and external
+        // authentication is not being used, proxy authentication is taking
+        // place
+        if (userName && !password && !externalAuth)
+            mode |= DPI_OCI_SESSGET_CREDPROXY;
+        if (createParams->matchAnyTag)
+            mode |= DPI_OCI_SESSGET_SPOOL_MATCHANY;
+        if (dpiUtils__checkClientVersion(conn->env->versionInfo, 12, 2,
+                NULL) == DPI_SUCCESS && createParams->tag &&
+                createParams->tagLength > 0)
+            mode |= DPI_OCI_SESSGET_MULTIPROPERTY_TAG;
+    } else {
+        mode = DPI_OCI_SESSGET_STMTCACHE;
+        externalAuth = createParams->externalAuth;
+    }
+    if (createParams->authMode & DPI_MODE_AUTH_SYSDBA)
+        mode |= DPI_OCI_SESSGET_SYSDBA;
+    if (externalAuth)
+        mode |= DPI_OCI_SESSGET_CREDEXT;
+
+    // create authorization handle
+    if (dpiOci__handleAlloc(conn->env->handle, &authInfo,
+            DPI_OCI_HTYPE_AUTHINFO, "allocate authinfo handle", error) < 0)
+        return DPI_FAILURE;
+
+    // set attributes for create parameters
+    if (dpiConn__setAttributesFromCreateParams(conn, authInfo,
+            DPI_OCI_HTYPE_AUTHINFO, userName, userNameLength, password,
+            passwordLength, createParams, error) < 0) {
+        dpiOci__handleFree(authInfo, DPI_OCI_HTYPE_AUTHINFO);
+        return DPI_FAILURE;
+    }
+
+    // get a session from the pool
+    status = dpiConn__getSession(conn, mode, connectString,
+            connectStringLength, createParams, authInfo, error);
+    dpiOci__handleFree(authInfo, DPI_OCI_HTYPE_AUTHINFO);
+    if (status < 0)
+        return status;
+    return dpiConn__getServerCharset(conn, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__getAttributeText() [INTERNAL]
+//   Get the value of the OCI attribute from a text string.
+//-----------------------------------------------------------------------------
+static int dpiConn__getAttributeText(dpiConn *conn, uint32_t attribute,
+        const char **value, uint32_t *valueLength, const char *fnName)
+{
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiConn__check(conn, fnName, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, value)
+    DPI_CHECK_PTR_NOT_NULL(conn, valueLength)
+
+    // determine pointer to pass (OCI uses different sizes)
+    switch (attribute) {
+        case DPI_OCI_ATTR_CURRENT_SCHEMA:
+        case DPI_OCI_ATTR_LTXID:
+        case DPI_OCI_ATTR_EDITION:
+            status = dpiOci__attrGet(conn->sessionHandle,
+                    DPI_OCI_HTYPE_SESSION, (void*) value, valueLength,
+                    attribute, "get session value", &error);
+            break;
+        case DPI_OCI_ATTR_INTERNAL_NAME:
+        case DPI_OCI_ATTR_EXTERNAL_NAME:
+            status = dpiOci__attrGet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
+                    (void*) value, valueLength, attribute, "get server value",
+                    &error);
+            break;
+        default:
+            status = dpiError__set(&error, "get attribute text",
+                    DPI_ERR_NOT_SUPPORTED);
+            break;
+    }
+
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__getHandles() [INTERNAL]
+//   Get the server and session handle from the service context handle.
+//-----------------------------------------------------------------------------
+static int dpiConn__getHandles(dpiConn *conn, dpiError *error)
+{
+    if (dpiOci__attrGet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
+            (void*) &conn->sessionHandle, NULL, DPI_OCI_ATTR_SESSION,
+            "get session handle", error) < 0)
+        return DPI_FAILURE;
+    if (dpiOci__attrGet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
+            (void*) &conn->serverHandle, NULL, DPI_OCI_ATTR_SERVER,
+            "get server handle", error) < 0)
+        return DPI_FAILURE;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__getJsonTDO() [INTERNAL]
+//   Internal method used for ensuring that the JSON TDO has been cached on the
+// connection.
+//-----------------------------------------------------------------------------
+int dpiConn__getJsonTDO(dpiConn *conn, dpiError *error)
+{
+    if (conn->jsonTDO)
+        return DPI_SUCCESS;
+    return dpiOci__typeByName(conn, "SYS", 3, "JSON", 4, &conn->jsonTDO,
+            error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__getRawTDO() [INTERNAL]
+//   Internal method used for ensuring that the RAW TDO has been cached on the
+// connection.
+//-----------------------------------------------------------------------------
+int dpiConn__getRawTDO(dpiConn *conn, dpiError *error)
+{
+    if (conn->rawTDO)
+        return DPI_SUCCESS;
+    return dpiOci__typeByName(conn, "SYS", 3, "RAW", 3, &conn->rawTDO, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__getServerCharset() [INTERNAL]
+//   Internal method used for retrieving the server character set. This is used
+// to determine if any conversion is required when transferring strings between
+// the client and the server.
+//-----------------------------------------------------------------------------
+static int dpiConn__getServerCharset(dpiConn *conn, dpiError *error)
+{
+    return dpiOci__attrGet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
+            &conn->charsetId, NULL, DPI_OCI_ATTR_CHARSET_ID,
+            "get server charset id", error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__getServerVersion() [INTERNAL]
+//   Internal method used for ensuring that the server version has been cached
+// on the connection.
+//-----------------------------------------------------------------------------
+int dpiConn__getServerVersion(dpiConn *conn, int wantReleaseString,
+        dpiError *error)
+{
+    char buffer[512], *releaseString;
+    dpiVersionInfo *tempVersionInfo;
+    uint32_t serverRelease, mode;
+    uint32_t releaseStringLength;
+    int ociCanCache;
+
+    // nothing to do if the server version has been cached earlier
+    if (conn->releaseString ||
+            (conn->versionInfo.versionNum > 0 && !wantReleaseString))
+        return DPI_SUCCESS;
+
+    // the server version is not available in the cache so it must be
+    // determined; as of Oracle Client 20.3, a special mode is available that
+    // causes OCI to cache the server version information, so this mode can be
+    // used if the release string information is not desired and the client
+    // supports it
+    ociCanCache = ((conn->env->versionInfo->versionNum > 20 ||
+            (conn->env->versionInfo->versionNum == 20 &&
+             conn->env->versionInfo->releaseNum >= 3)) && !wantReleaseString);
+
+    // for earlier versions where the OCI cache is not available, pooled
+    // connections can cache the information on the session in order to avoid
+    // the round trip, but again only if the release string is not desired;
+    // nothing further needs to be done if this cache is present
+    if (conn->pool && !ociCanCache && !wantReleaseString) {
+        tempVersionInfo = NULL;
+        if (dpiOci__contextGetValue(conn, DPI_CONTEXT_SERVER_VERSION,
+                (uint32_t) (sizeof(DPI_CONTEXT_SERVER_VERSION) - 1),
+                (void**) &tempVersionInfo, 1, error) < 0)
+            return DPI_FAILURE;
+        if (tempVersionInfo) {
+            memcpy(&conn->versionInfo, tempVersionInfo,
+                    sizeof(conn->versionInfo));
+            return DPI_SUCCESS;
+        }
+    }
+
+    // calculate the server version by making the appropriate call
+    if (ociCanCache) {
+        mode = DPI_OCI_SRVRELEASE2_CACHED;
+        releaseString = NULL;
+        releaseStringLength = 0;
+    } else {
+        mode = DPI_OCI_DEFAULT;
+        releaseString = buffer;
+        releaseStringLength = sizeof(buffer);
+    }
+    if (dpiOci__serverRelease(conn, releaseString, releaseStringLength,
+            &serverRelease, mode, error) < 0)
+        return DPI_FAILURE;
+
+    // store release string, if applicable
+    if (releaseString) {
+        conn->releaseStringLength = (uint32_t) strlen(releaseString);
+        if (dpiUtils__allocateMemory(1, conn->releaseStringLength, 0,
+                "allocate release string", (void**) &conn->releaseString,
+                error) < 0)
+            return DPI_FAILURE;
+        strncpy( (char*) conn->releaseString, releaseString,
+                conn->releaseStringLength);
+    }
+
+    // process version number
+    conn->versionInfo.versionNum = (int)((serverRelease >> 24) & 0xFF);
+    if (conn->versionInfo.versionNum >= 18) {
+        conn->versionInfo.releaseNum = (int)((serverRelease >> 16) & 0xFF);
+        conn->versionInfo.updateNum = (int)((serverRelease >> 12) & 0x0F);
+        conn->versionInfo.portReleaseNum = (int)((serverRelease >> 4) & 0xFF);
+        conn->versionInfo.portUpdateNum = (int)((serverRelease) & 0xF);
+    } else {
+        conn->versionInfo.releaseNum = (int)((serverRelease >> 20) & 0x0F);
+        conn->versionInfo.updateNum = (int)((serverRelease >> 12) & 0xFF);
+        conn->versionInfo.portReleaseNum = (int)((serverRelease >> 8) & 0x0F);
+        conn->versionInfo.portUpdateNum = (int)((serverRelease) & 0xFF);
+    }
+    conn->versionInfo.fullVersionNum = (uint32_t)
+            DPI_ORACLE_VERSION_TO_NUMBER(conn->versionInfo.versionNum,
+                    conn->versionInfo.releaseNum,
+                    conn->versionInfo.updateNum,
+                    conn->versionInfo.portReleaseNum,
+                    conn->versionInfo.portUpdateNum);
+
+    // for earlier versions where the OCI cache is not available, store the
+    // version information on the session in order to avoid the round-trip the
+    // next time the pooled session is acquired from the pool
+    if (conn->pool && !ociCanCache) {
+        if (dpiOci__memoryAlloc(conn, (void**) &tempVersionInfo,
+                sizeof(conn->versionInfo), 1, error) < 0)
+            return DPI_FAILURE;
+        memcpy(tempVersionInfo, &conn->versionInfo, sizeof(conn->versionInfo));
+        if (dpiOci__contextSetValue(conn, DPI_CONTEXT_SERVER_VERSION,
+                (uint32_t) (sizeof(DPI_CONTEXT_SERVER_VERSION) - 1),
+                tempVersionInfo, 1, error) < 0) {
+            dpiOci__memoryFree(conn, tempVersionInfo, error);
+        }
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__getSession() [INTERNAL]
+//   Ping and loop until we get a good session. When a database instance goes
+// down, it can leave several bad connections that need to be flushed out
+// before a good connection can be acquired. If the connection is brand new
+// (ping time context value has not been set) there is no need to do a ping.
+// This also ensures that the loop cannot run forever!
+//-----------------------------------------------------------------------------
+static int dpiConn__getSession(dpiConn *conn, uint32_t mode,
+        const char *connectString, uint32_t connectStringLength,
+        dpiConnCreateParams *params, void *authInfo, dpiError *error)
+{
+    uint8_t savedBreakOnTimeout, breakOnTimeout;
+    uint32_t savedTimeout;
+    time_t *lastTimeUsed;
+
+    while (1) {
+
+        // acquire the new session
+        params->outNewSession = 0;
+        if (dpiOci__sessionGet(conn->env->handle, &conn->handle, authInfo,
+                connectString, connectStringLength, params->tag,
+                params->tagLength, &params->outTag, &params->outTagLength,
+                &params->outTagFound, mode, error) < 0)
+            return DPI_FAILURE;
+
+        // get session and server handles
+        if (dpiConn__getHandles(conn, error) < 0)
+            return DPI_FAILURE;
+
+        // for standalone connections, nothing more needs to be done
+        if (!conn->pool) {
+            params->outNewSession = 1;
+            break;
+        }
+
+        // remainder of the loop is for pooled connections only; get last time
+        // used from session context; if value is not found, a new connection
+        // has been created and there is no need to perform a ping
+        lastTimeUsed = NULL;
+        if (dpiOci__contextGetValue(conn, DPI_CONTEXT_LAST_TIME_USED,
+                (uint32_t) (sizeof(DPI_CONTEXT_LAST_TIME_USED) - 1),
+                (void**) &lastTimeUsed, 1, error) < 0)
+            return DPI_FAILURE;
+        if (!lastTimeUsed) {
+            params->outNewSession = 1;
+
+            // for pooled connections, set the statement cache size; when a
+            // pool is created, the minSessions value is used to create
+            // connections and these use the default statement cache size, not
+            // the statement cache size specified for the pool; setting the
+            // value here eliminates that discrepancy
+            if (dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
+                    &conn->pool->stmtCacheSize, 0, DPI_OCI_ATTR_STMTCACHESIZE,
+                    "set stmt cache size", error) < 0)
+                return DPI_FAILURE;
+
+            break;
+        }
+
+        // if ping interval is negative or the ping interval (in seconds)
+        // has not been exceeded yet, there is also no need to perform a ping
+        if (conn->pool->pingInterval < 0 ||
+                *lastTimeUsed + conn->pool->pingInterval > time(NULL))
+            break;
+
+        // ping needs to be done at this point; set parameters to ensure that
+        // the ping does not take too long to complete; keep original values so
+        // that they can be restored after the ping is completed
+        dpiOci__attrGet(conn->serverHandle,
+                DPI_OCI_HTYPE_SERVER, &savedTimeout, NULL,
+                DPI_OCI_ATTR_RECEIVE_TIMEOUT, NULL, error);
+        dpiOci__attrSet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
+                &conn->pool->pingTimeout, 0, DPI_OCI_ATTR_RECEIVE_TIMEOUT,
+                NULL, error);
+        if (conn->env->versionInfo->versionNum >= 12) {
+            dpiOci__attrGet(conn->serverHandle,
+                    DPI_OCI_HTYPE_SERVER, &savedBreakOnTimeout, NULL,
+                    DPI_OCI_ATTR_BREAK_ON_NET_TIMEOUT, NULL, error);
+            breakOnTimeout = 0;
+            dpiOci__attrSet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
+                    &breakOnTimeout, 0, DPI_OCI_ATTR_BREAK_ON_NET_TIMEOUT,
+                    NULL, error);
+        }
+
+        // if ping is successful, the connection is valid and can be returned;
+        // restore original network parameters
+        if (dpiOci__ping(conn, error) == 0) {
+            dpiOci__attrSet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
+                    &savedTimeout, 0, DPI_OCI_ATTR_RECEIVE_TIMEOUT, NULL,
+                    error);
+            if (conn->env->versionInfo->versionNum >= 12)
+                dpiOci__attrSet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
+                        &savedBreakOnTimeout, 0,
+                        DPI_OCI_ATTR_BREAK_ON_NET_TIMEOUT, NULL, error);
+            break;
+        }
+
+        // session is bad, need to release and drop it
+        dpiOci__sessionRelease(conn, NULL, 0, DPI_OCI_SESSRLS_DROPSESS, 0,
+                error);
+        conn->handle = NULL;
+        conn->serverHandle = NULL;
+        conn->sessionHandle = NULL;
+        conn->deadSession = 0;
+
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__rollback() [PUBLIC]
+//   Internal method for rolling back the transaction associated with the
+// connection. Once the rollback has taken place, the transaction handle
+// associated with the connection is cleared.
+//-----------------------------------------------------------------------------
+int dpiConn__rollback(dpiConn *conn, dpiError *error)
+{
+    if (dpiOci__transRollback(conn, 1, error) < 0)
+        return DPI_FAILURE;
+    if (dpiConn__clearTransaction(conn, error) < 0)
+        return DPI_FAILURE;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__setAppContext() [INTERNAL]
+//   Populate the session handle with the application context.
+//-----------------------------------------------------------------------------
+static int dpiConn__setAppContext(void *handle, uint32_t handleType,
+        const dpiConnCreateParams *params, dpiError *error)
+{
+    void *listHandle, *entryHandle;
+    dpiAppContext *entry;
+    uint32_t i;
+
+    // set the number of application context entries
+    if (dpiOci__attrSet(handle, handleType, (void*) &params->numAppContext,
+            sizeof(params->numAppContext), DPI_OCI_ATTR_APPCTX_SIZE,
+            "set app context size", error) < 0)
+        return DPI_FAILURE;
+
+    // get the application context list handle
+    if (dpiOci__attrGet(handle, handleType, &listHandle, NULL,
+            DPI_OCI_ATTR_APPCTX_LIST, "get context list handle", error) < 0)
+        return DPI_FAILURE;
+
+    // set each application context entry
+    for (i = 0; i < params->numAppContext; i++) {
+        entry = &params->appContext[i];
+
+        // retrieve the context element descriptor
+        if (dpiOci__paramGet(listHandle, DPI_OCI_DTYPE_PARAM,
+                &entryHandle, i + 1, "get context entry handle", error) < 0)
+            return DPI_FAILURE;
+
+        // set the namespace name
+        if (dpiOci__attrSet(entryHandle, DPI_OCI_DTYPE_PARAM,
+                (void*) entry->namespaceName, entry->namespaceNameLength,
+                DPI_OCI_ATTR_APPCTX_NAME, "set namespace name", error) < 0)
+            return DPI_FAILURE;
+
+        // set the name
+        if (dpiOci__attrSet(entryHandle, DPI_OCI_DTYPE_PARAM,
+                (void*) entry->name, entry->nameLength,
+                DPI_OCI_ATTR_APPCTX_ATTR, "set name", error) < 0)
+            return DPI_FAILURE;
+
+        // set the value
+        if (dpiOci__attrSet(entryHandle, DPI_OCI_DTYPE_PARAM,
+                (void*) entry->value, entry->valueLength,
+                DPI_OCI_ATTR_APPCTX_VALUE, "set value", error) < 0)
+            return DPI_FAILURE;
+
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__setAttributesFromCreateParams() [INTERNAL]
+//   Populate the authorization info structure or session handle using the
+// create parameters specified.
+//-----------------------------------------------------------------------------
+static int dpiConn__setAttributesFromCreateParams(dpiConn *conn, void *handle,
+        uint32_t handleType, const char *userName, uint32_t userNameLength,
+        const char *password, uint32_t passwordLength,
+        const dpiConnCreateParams *params, dpiError *error)
+{
+    uint32_t purity;
+
+    // set credentials
+    if (userName && userNameLength > 0 && dpiOci__attrSet(handle,
+            handleType, (void*) userName, userNameLength,
+            DPI_OCI_ATTR_USERNAME, "set user name", error) < 0)
+        return DPI_FAILURE;
+    if (password && passwordLength > 0 && dpiOci__attrSet(handle,
+            handleType, (void*) password, passwordLength,
+            DPI_OCI_ATTR_PASSWORD, "set password", error) < 0)
+        return DPI_FAILURE;
+
+    // set connection class and purity parameters
+    if (params->connectionClass && params->connectionClassLength > 0 &&
+            dpiOci__attrSet(handle, handleType,
+                    (void*) params->connectionClass,
+                    params->connectionClassLength,
+                    DPI_OCI_ATTR_CONNECTION_CLASS, "set connection class",
+                    error) < 0)
+        return DPI_FAILURE;
+    if (params->purity != DPI_OCI_ATTR_PURITY_DEFAULT) {
+        purity = params->purity;
+        if (dpiOci__attrSet(handle, handleType, &purity,
+                sizeof(purity), DPI_OCI_ATTR_PURITY, "set purity", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set sharding key and super sharding key parameters
+    if (params->shardingKeyColumns && params->numShardingKeyColumns > 0) {
+        if (dpiConn__setShardingKey(conn, &conn->shardingKey, handle,
+                handleType, DPI_OCI_ATTR_SHARDING_KEY, "set sharding key",
+                params->shardingKeyColumns, params->numShardingKeyColumns,
+                error) < 0)
+            return DPI_FAILURE;
+    }
+    if (params->superShardingKeyColumns &&
+            params->numSuperShardingKeyColumns > 0) {
+        if (params->numShardingKeyColumns == 0)
+            return dpiError__set(error, "ensure sharding key",
+                    DPI_ERR_MISSING_SHARDING_KEY);
+        if (dpiConn__setShardingKey(conn, &conn->superShardingKey, handle,
+                handleType, DPI_OCI_ATTR_SUPER_SHARDING_KEY,
+                "set super sharding key", params->superShardingKeyColumns,
+                params->numSuperShardingKeyColumns, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set application context, if applicable
+    if (handleType == DPI_OCI_HTYPE_SESSION && params->numAppContext > 0)
+        return dpiConn__setAppContext(handle, handleType, params, error);
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__setAttributeText() [INTERNAL]
+//   Set the value of the OCI attribute from a text string.
+//-----------------------------------------------------------------------------
+static int dpiConn__setAttributeText(dpiConn *conn, uint32_t attribute,
+        const char *value, uint32_t valueLength, const char *fnName)
+{
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiConn__check(conn, fnName, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(conn, value)
+
+    // determine pointer to pass (OCI uses different sizes)
+    switch (attribute) {
+        case DPI_OCI_ATTR_ACTION:
+        case DPI_OCI_ATTR_CLIENT_IDENTIFIER:
+        case DPI_OCI_ATTR_CLIENT_INFO:
+        case DPI_OCI_ATTR_CURRENT_SCHEMA:
+        case DPI_OCI_ATTR_ECONTEXT_ID:
+        case DPI_OCI_ATTR_EDITION:
+        case DPI_OCI_ATTR_MODULE:
+        case DPI_OCI_ATTR_DBOP:
+            status = dpiOci__attrSet(conn->sessionHandle,
+                    DPI_OCI_HTYPE_SESSION, (void*) value, valueLength,
+                    attribute, "set session value", &error);
+            break;
+        case DPI_OCI_ATTR_INTERNAL_NAME:
+        case DPI_OCI_ATTR_EXTERNAL_NAME:
+            status = dpiOci__attrSet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
+                    (void*) value, valueLength, attribute, "set server value",
+                    &error);
+            break;
+        default:
+            status = dpiError__set(&error, "set attribute text",
+                    DPI_ERR_NOT_SUPPORTED);
+            break;
+    }
+
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__setShardingKey() [INTERNAL]
+//   Using the specified columns, create a sharding key and set it on the given
+// handle.
+//-----------------------------------------------------------------------------
+static int dpiConn__setShardingKey(dpiConn *conn, void **shardingKey,
+        void *handle, uint32_t handleType, uint32_t attribute,
+        const char *action, dpiShardingKeyColumn *columns, uint8_t numColumns,
+        dpiError *error)
+{
+    uint8_t i;
+
+    // this is only supported on 12.2 and higher clients
+    if (dpiUtils__checkClientVersion(conn->env->versionInfo, 12, 2,
+            error) < 0)
+        return DPI_FAILURE;
+
+    // create sharding key descriptor, if necessary
+    if (dpiOci__descriptorAlloc(conn->env->handle, shardingKey,
+            DPI_OCI_DTYPE_SHARDING_KEY, "allocate sharding key", error) < 0)
+        return DPI_FAILURE;
+
+    // add each column to the sharding key
+    for (i = 0; i < numColumns; i++) {
+        if (dpiConn__setShardingKeyValue(conn, *shardingKey, &columns[i],
+                error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // add the sharding key to the handle
+    if (dpiOci__attrSet(handle, handleType, *shardingKey, 0, attribute, action,
+            error) < 0)
+        return DPI_FAILURE;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__setShardingKeyValue() [INTERNAL]
+//   Using the specified columns, create a sharding key and set it on the given
+// handle.
+//-----------------------------------------------------------------------------
+static int dpiConn__setShardingKeyValue(dpiConn *conn, void *shardingKey,
+        dpiShardingKeyColumn *column, dpiError *error)
+{
+    dpiShardingOciDate shardingDateValue;
+    uint32_t colLen = 0, descType = 0;
+    const dpiOracleType *oracleType;
+    dpiOciNumber numberValue;
+    int convertOk, status;
+    dpiOciDate dateValue;
+    void *col = NULL;
+    uint16_t colType;
+
+    oracleType = dpiOracleType__getFromNum(column->oracleTypeNum, error);
+    if (!oracleType)
+        return DPI_FAILURE;
+    convertOk = 0;
+    colType = oracleType->oracleType;
+    switch (column->oracleTypeNum) {
+        case DPI_ORACLE_TYPE_VARCHAR:
+        case DPI_ORACLE_TYPE_CHAR:
+        case DPI_ORACLE_TYPE_RAW:
+            if (column->nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
+                col = column->value.asBytes.ptr;
+                colLen = column->value.asBytes.length;
+                convertOk = 1;
+            }
+            break;
+        case DPI_ORACLE_TYPE_NUMBER:
+            col = &numberValue;
+            colLen = sizeof(numberValue);
+            if (column->nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
+                if (dpiDataBuffer__toOracleNumberFromDouble(&column->value,
+                        error, &numberValue) < 0)
+                    return DPI_FAILURE;
+                convertOk = 1;
+            } else if (column->nativeTypeNum == DPI_NATIVE_TYPE_INT64) {
+                if (dpiDataBuffer__toOracleNumberFromInteger(&column->value,
+                        error, &numberValue) < 0)
+                    return DPI_FAILURE;
+                convertOk = 1;
+            } else if (column->nativeTypeNum == DPI_NATIVE_TYPE_UINT64) {
+                if (dpiDataBuffer__toOracleNumberFromUnsignedInteger(
+                        &column->value, error, &numberValue) < 0)
+                    return DPI_FAILURE;
+                convertOk = 1;
+            } else if (column->nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
+                if (dpiDataBuffer__toOracleNumberFromText(&column->value,
+                        conn->env, error, &numberValue) < 0)
+                    return DPI_FAILURE;
+                convertOk = 1;
+            }
+            break;
+        case DPI_ORACLE_TYPE_DATE:
+            if (column->nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP) {
+                if (dpiDataBuffer__toOracleDate(&column->value,
+                        &dateValue) < 0)
+                    return DPI_FAILURE;
+                convertOk = 1;
+            } else if (column->nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
+                if (dpiDataBuffer__toOracleDateFromDouble(&column->value,
+                        conn->env, error, &dateValue) < 0)
+                    return DPI_FAILURE;
+                convertOk = 1;
+            }
+
+            // for sharding only, the type must be SQLT_DAT, which uses a
+            // different format for storing the date values
+            if (convertOk) {
+                col = &shardingDateValue;
+                colLen = sizeof(shardingDateValue);
+                colType = DPI_SQLT_DAT;
+                shardingDateValue.century =
+                        ((uint8_t) (dateValue.year / 100)) + 100;
+                shardingDateValue.year = (dateValue.year % 100) + 100;
+                shardingDateValue.month = dateValue.month;
+                shardingDateValue.day = dateValue.day;
+                shardingDateValue.hour = dateValue.hour + 1;
+                shardingDateValue.minute = dateValue.minute + 1;
+                shardingDateValue.second = dateValue.second + 1;
+            }
+            break;
+        case DPI_ORACLE_TYPE_TIMESTAMP:
+        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
+        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
+            colLen = sizeof(void*);
+            colType = DPI_SQLT_TIMESTAMP;
+            if (column->nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP) {
+                descType = DPI_OCI_DTYPE_TIMESTAMP;
+                if (dpiOci__descriptorAlloc(conn->env->handle, &col, descType,
+                        "alloc timestamp", error) < 0)
+                    return DPI_FAILURE;
+                if (dpiDataBuffer__toOracleTimestamp(&column->value, conn->env,
+                        error, col, 0) < 0) {
+                    dpiOci__descriptorFree(col, descType);
+                    return DPI_FAILURE;
+                }
+                convertOk = 1;
+            } else if (column->nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
+                descType = DPI_OCI_DTYPE_TIMESTAMP_LTZ;
+                if (dpiOci__descriptorAlloc(conn->env->handle, &col, descType,
+                        "alloc LTZ timestamp", error) < 0)
+                    return DPI_FAILURE;
+                if (dpiDataBuffer__toOracleTimestampFromDouble(&column->value,
+                        DPI_ORACLE_TYPE_TIMESTAMP_LTZ, conn->env, error,
+                        col) < 0) {
+                    dpiOci__descriptorFree(col, descType);
+                    return DPI_FAILURE;
+                }
+                convertOk = 1;
+            }
+            break;
+        default:
+            break;
+    }
+    if (!convertOk)
+        return dpiError__set(error, "check type", DPI_ERR_NOT_SUPPORTED);
+
+    status = dpiOci__shardingKeyColumnAdd(shardingKey, col, colLen, colType,
+            error);
+    if (descType)
+        dpiOci__descriptorFree(col, descType);
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__setXid() [INTERNAL]
+//   Internal method for associating an XID with the connection.
+//-----------------------------------------------------------------------------
+static int dpiConn__setXid(dpiConn *conn, dpiXid *xid, dpiError *error)
+{
+    dpiOciXID ociXid;
+
+    // validate XID
+    if (xid->globalTransactionIdLength > 0 && !xid->globalTransactionId)
+        return dpiError__set(error, "check XID transaction id ptr",
+                DPI_ERR_PTR_LENGTH_MISMATCH, "xid->globalTransactionId");
+    if (xid->branchQualifierLength > 0 && !xid->branchQualifier)
+        return dpiError__set(error, "check XID branch id ptr",
+                DPI_ERR_PTR_LENGTH_MISMATCH, "xid->branchQualifier");
+    if (xid->globalTransactionIdLength > DPI_XA_MAXGTRIDSIZE)
+        return dpiError__set(error, "check size of XID transaction id",
+                DPI_ERR_TRANS_ID_TOO_LARGE, xid->globalTransactionIdLength,
+                DPI_XA_MAXGTRIDSIZE);
+    if (xid->branchQualifierLength > DPI_XA_MAXBQUALSIZE)
+        return dpiError__set(error, "check size of XID branch qualifier",
+                DPI_ERR_BRANCH_ID_TOO_LARGE, xid->branchQualifierLength,
+                DPI_XA_MAXBQUALSIZE);
+
+    // if a transaction handle does not exist, create one
+    if (!conn->transactionHandle) {
+        if (dpiOci__handleAlloc(conn->env->handle, &conn->transactionHandle,
+                DPI_OCI_HTYPE_TRANS, "create transaction handle", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // associate the transaction with the connection
+    if (dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
+            conn->transactionHandle, 0, DPI_OCI_ATTR_TRANS,
+            "associate transaction", error) < 0)
+        return DPI_FAILURE;
+
+    // associate the XID with the transaction
+    ociXid.formatID = xid->formatId;
+    ociXid.gtrid_length = xid->globalTransactionIdLength;
+    ociXid.bqual_length = xid->branchQualifierLength;
+    if (xid->globalTransactionIdLength > 0)
+        memcpy(ociXid.data, xid->globalTransactionId,
+                xid->globalTransactionIdLength);
+    if (xid->branchQualifierLength > 0)
+        memcpy(&ociXid.data[xid->globalTransactionIdLength],
+                xid->branchQualifier, xid->branchQualifierLength);
+    if (dpiOci__attrSet(conn->transactionHandle, DPI_OCI_HTYPE_TRANS,
+            &ociXid, sizeof(dpiOciXID), DPI_OCI_ATTR_XID, "set XID",
+            error) < 0)
+        return DPI_FAILURE;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn__startupDatabase() [INTERNAL]
+//   Internal method for starting up a database. This is equivalent to
+// "startup nomount" in SQL*Plus.
+//-----------------------------------------------------------------------------
+static int dpiConn__startupDatabase(dpiConn *conn, const char *pfile,
+        uint32_t pfileLength, dpiStartupMode mode, dpiError *error)
+{
+    void *adminHandle = NULL;
+    int status;
+
+    // if a PFILE has been specified, create an admin handle and populate it
+    if (pfileLength > 0) {
+        if (dpiOci__handleAlloc(conn->env->handle, &adminHandle,
+                DPI_OCI_HTYPE_ADMIN, "create admin handle", error) < 0)
+            return DPI_FAILURE;
+        if (dpiOci__attrSet(adminHandle, DPI_OCI_HTYPE_ADMIN,
+                (void*) pfile, pfileLength, DPI_OCI_ATTR_ADMIN_PFILE,
+                "associate PFILE", error) < 0) {
+            dpiOci__handleFree(adminHandle, DPI_OCI_HTYPE_ADMIN);
+            return DPI_FAILURE;
+        }
+    }
+
+    // perform actual startup call
+    status = dpiOci__dbStartup(conn, adminHandle, mode, error);
+
+    // destroy admin handle, if needed
+    if (pfileLength > 0)
+        dpiOci__handleFree(adminHandle, DPI_OCI_HTYPE_ADMIN);
+
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_addRef() [PUBLIC]
+//   Add a reference to the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_addRef(dpiConn *conn)
+{
+    return dpiGen__addRef(conn, DPI_HTYPE_CONN, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_beginDistribTrans() [PUBLIC]
+//   Begin a distributed transaction. This function is deprecated. Use
+// dpiConn_tpcBegin() instead.
+//-----------------------------------------------------------------------------
+int dpiConn_beginDistribTrans(dpiConn *conn, long formatId,
+        const char *globalTransactionId, uint32_t globalTransactionIdLength,
+        const char *branchQualifier, uint32_t branchQualifierLength)
+{
+    dpiXid xid;
+
+    // a negative format id implies a NULL XID so nothing needs to be done
+    if (formatId < 0)
+        return DPI_SUCCESS;
+
+    // call the new function instead
+    xid.formatId = formatId;
+    xid.globalTransactionId = globalTransactionId;
+    xid.globalTransactionIdLength = globalTransactionIdLength;
+    xid.branchQualifier = branchQualifier;
+    xid.branchQualifierLength = branchQualifierLength;
+    return dpiConn_tpcBegin(conn, &xid, 0, DPI_TPC_BEGIN_NEW);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_breakExecution() [PUBLIC]
+//   Break (interrupt) the currently executing operation.
+//-----------------------------------------------------------------------------
+int dpiConn_breakExecution(dpiConn *conn)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    status = dpiOci__break(conn, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_changePassword() [PUBLIC]
+//   Change the password for the specified user.
+//-----------------------------------------------------------------------------
+int dpiConn_changePassword(dpiConn *conn, const char *userName,
+        uint32_t userNameLength, const char *oldPassword,
+        uint32_t oldPasswordLength, const char *newPassword,
+        uint32_t newPasswordLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(conn, userName)
+    DPI_CHECK_PTR_AND_LENGTH(conn, oldPassword)
+    DPI_CHECK_PTR_AND_LENGTH(conn, newPassword)
+    status = dpiOci__passwordChange(conn, userName, userNameLength,
+            oldPassword, oldPasswordLength, newPassword, newPasswordLength,
+            DPI_OCI_DEFAULT, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_close() [PUBLIC]
+//   Close the connection and ensure it can no longer be used.
+//-----------------------------------------------------------------------------
+int dpiConn_close(dpiConn *conn, dpiConnCloseMode mode, const char *tag,
+        uint32_t tagLength)
+{
+    int propagateErrors = !(mode & DPI_MODE_CONN_CLOSE_DROP);
+    dpiError error;
+    int closing;
+
+    // validate parameters
+    if (dpiGen__startPublicFn(conn, DPI_HTYPE_CONN, __func__, &error) < 0)
+        return DPI_FAILURE;
+    if (!conn->handle || conn->closing ||
+            (conn->pool && !conn->pool->handle)) {
+        dpiError__set(&error, "check connected", DPI_ERR_NOT_CONNECTED);
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+    DPI_CHECK_PTR_AND_LENGTH(conn, tag)
+    if (mode && !conn->pool) {
+        dpiError__set(&error, "check in pool", DPI_ERR_CONN_NOT_IN_POOL);
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+    if (conn->externalHandle) {
+        dpiError__set(&error, "check external", DPI_ERR_CONN_IS_EXTERNAL);
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+
+    // determine whether connection is already being closed and if not, mark
+    // connection as being closed; this MUST be done while holding the lock
+    // (if in threaded mode) to avoid race conditions!
+    if (conn->env->threaded)
+        dpiMutex__acquire(conn->env->mutex);
+    closing = conn->closing;
+    conn->closing = 1;
+    if (conn->env->threaded)
+        dpiMutex__release(conn->env->mutex);
+
+    // if connection is already being closed, raise an exception
+    if (closing) {
+        dpiError__set(&error, "check closing", DPI_ERR_NOT_CONNECTED);
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+
+    // if actual close fails, reset closing flag; again, this must be done
+    // while holding the lock (if in threaded mode) in order to avoid race
+    // conditions!
+    if (dpiConn__close(conn, mode, tag, tagLength, propagateErrors,
+            &error) < 0) {
+        if (conn->env->threaded)
+            dpiMutex__acquire(conn->env->mutex);
+        conn->closing = 0;
+        if (conn->env->threaded)
+            dpiMutex__release(conn->env->mutex);
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+
+    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_commit() [PUBLIC]
+//   Commit the transaction associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_commit(dpiConn *conn)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    status = dpiConn__commit(conn, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_create() [PUBLIC]
+//   Create a standalone connection to the database using the parameters
+// specified.
+//-----------------------------------------------------------------------------
+int dpiConn_create(const dpiContext *context, const char *userName,
+        uint32_t userNameLength, const char *password, uint32_t passwordLength,
+        const char *connectString, uint32_t connectStringLength,
+        const dpiCommonCreateParams *commonParams,
+        dpiConnCreateParams *createParams, dpiConn **conn)
+{
+    dpiCommonCreateParams localCommonParams;
+    dpiConnCreateParams localCreateParams;
+    dpiConn *tempConn;
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(context, conn)
+    DPI_CHECK_PTR_AND_LENGTH(context, userName)
+    DPI_CHECK_PTR_AND_LENGTH(context, password)
+    DPI_CHECK_PTR_AND_LENGTH(context, connectString)
+
+    // use default parameters if none provided
+    if (!commonParams) {
+        dpiContext__initCommonCreateParams(context, &localCommonParams);
+        commonParams = &localCommonParams;
+    }
+    if (!createParams) {
+        dpiContext__initConnCreateParams(&localCreateParams);
+        createParams = &localCreateParams;
+    }
+
+    // password must not be specified if external authentication is desired
+    if (createParams->externalAuth && password && passwordLength > 0) {
+        dpiError__set(&error, "verify no password with external auth",
+                DPI_ERR_EXT_AUTH_WITH_CREDENTIALS);
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    }
+
+    // the username must be enclosed within [] if external authentication
+    // with proxy is desired
+    if (createParams->externalAuth && userName && userNameLength > 0 &&
+            (userName[0] != '[' || userName[userNameLength - 1] != ']')) {
+        dpiError__set(&error, "verify proxy user name with external auth",
+                DPI_ERR_EXT_AUTH_INVALID_PROXY);
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error );
+    }
+
+    if (commonParams->accessToken) {
+
+        // externalAuth must be set to true for token based authentication
+        if (!createParams->externalAuth)
+            return dpiError__set(&error, "check externalAuth value",
+                    DPI_ERR_STANDALONE_TOKEN_BASED_AUTH);
+
+        // cannot set username for token based authentication
+        if (userName && userNameLength > 0)
+            return dpiError__set(&error, "verify user in token based auth",
+                DPI_ERR_EXT_AUTH_WITH_CREDENTIALS);
+    }
+
+    // connectionClass and edition cannot be specified at the same time
+    if (createParams->connectionClass &&
+            createParams->connectionClassLength > 0 &&
+            commonParams->edition && commonParams->editionLength > 0) {
+        dpiError__set(&error, "check edition/conn class",
+                DPI_ERR_NO_EDITION_WITH_CONN_CLASS);
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    }
+
+    // newPassword and edition cannot be specified at the same time
+    if (createParams->newPassword && createParams->newPasswordLength > 0 &&
+            commonParams->edition && commonParams->editionLength > 0) {
+        dpiError__set(&error, "check edition/new password",
+                DPI_ERR_NO_EDITION_WITH_NEW_PASSWORD);
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    }
+
+    // handle case where pool is specified
+    if (createParams->pool) {
+        if (dpiGen__checkHandle(createParams->pool, DPI_HTYPE_POOL,
+                "verify pool", &error) < 0)
+            return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+        if (!createParams->pool->handle) {
+            dpiError__set(&error, "check pool", DPI_ERR_NOT_CONNECTED);
+            return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+        }
+        status = dpiPool__acquireConnection(createParams->pool, userName,
+                userNameLength, password, passwordLength, createParams, conn,
+                &error);
+        return dpiGen__endPublicFn(context, status, &error);
+    }
+
+    // create connection
+    if (dpiGen__allocate(DPI_HTYPE_CONN, NULL, (void**) &tempConn, &error) < 0)
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    if (dpiConn__create(tempConn, context, userName, userNameLength,
+            password, passwordLength, connectString, connectStringLength,
+            NULL, commonParams, createParams, &error) < 0) {
+        dpiConn__free(tempConn, &error);
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    }
+
+    *conn = tempConn;
+    dpiHandlePool__release(tempConn->env->errorHandles, &error.handle);
+    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_getSodaDb() [PUBLIC]
+//   Create a new SODA collection with the given name and metadata.
+//-----------------------------------------------------------------------------
+int dpiConn_getSodaDb(dpiConn *conn, dpiSodaDb **db)
+{
+    dpiError error;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiUtils__checkClientVersion(conn->env->versionInfo, 18, 3,
+            &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiUtils__checkDatabaseVersion(conn, 18, 0, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiGen__allocate(DPI_HTYPE_SODA_DB, conn->env, (void**) db,
+            &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    dpiGen__setRefCount(conn, &error, 1);
+    (*db)->conn = conn;
+    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_deqObject() [PUBLIC]
+//   Dequeue a message from the specified queue.
+//-----------------------------------------------------------------------------
+int dpiConn_deqObject(dpiConn *conn, const char *queueName,
+        uint32_t queueNameLength, dpiDeqOptions *options, dpiMsgProps *props,
+        dpiObject *payload, const char **msgId, uint32_t *msgIdLength)
+{
+    dpiError error;
+
+    // validate parameters
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(options, DPI_HTYPE_DEQ_OPTIONS, "verify options",
+            &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(props, DPI_HTYPE_MSG_PROPS,
+            "verify message properties", &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(payload, DPI_HTYPE_OBJECT, "verify payload",
+            &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(conn, queueName)
+    DPI_CHECK_PTR_NOT_NULL(conn, msgId)
+    DPI_CHECK_PTR_NOT_NULL(conn, msgIdLength)
+
+    // dequeue message
+    if (dpiOci__aqDeq(conn, queueName, options->handle, props->handle,
+            payload->type->tdo, &payload->instance, &payload->indicator,
+            &props->msgIdRaw, &error) < 0) {
+        if (error.buffer->code == 25228) {
+            *msgId = NULL;
+            *msgIdLength = 0;
+            return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
+        }
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+    dpiMsgProps__extractMsgId(props, msgId, msgIdLength);
+    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_enqObject() [PUBLIC]
+//   Enqueue a message to the specified queue.
+//-----------------------------------------------------------------------------
+int dpiConn_enqObject(dpiConn *conn, const char *queueName,
+        uint32_t queueNameLength, dpiEnqOptions *options, dpiMsgProps *props,
+        dpiObject *payload, const char **msgId, uint32_t *msgIdLength)
+{
+    dpiError error;
+
+    // validate parameters
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(options, DPI_HTYPE_ENQ_OPTIONS, "verify options",
+            &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(props, DPI_HTYPE_MSG_PROPS,
+            "verify message properties", &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(payload, DPI_HTYPE_OBJECT, "verify payload",
+            &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(conn, queueName)
+    DPI_CHECK_PTR_NOT_NULL(conn, msgId)
+    DPI_CHECK_PTR_NOT_NULL(conn, msgIdLength)
+
+    // enqueue message
+    if (dpiOci__aqEnq(conn, queueName, options->handle, props->handle,
+            payload->type->tdo, &payload->instance, &payload->indicator,
+            &props->msgIdRaw, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    dpiMsgProps__extractMsgId(props, msgId, msgIdLength);
+    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_getCallTimeout() [PUBLIC]
+//   Return the call timeout (in milliseconds) used for round-trips to the
+// database. This is only valid in Oracle Client 18c and higher.
+//-----------------------------------------------------------------------------
+int dpiConn_getCallTimeout(dpiConn *conn, uint32_t *value)
+{
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, value)
+    if (dpiUtils__checkClientVersion(conn->env->versionInfo, 18, 1,
+            &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+
+    // get call timeout
+    status = dpiOci__attrGet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
+            (void*) value, 0, DPI_OCI_ATTR_CALL_TIMEOUT, "get call timeout",
+            &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_getCurrentSchema() [PUBLIC]
+//   Return the current schema associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_getCurrentSchema(dpiConn *conn, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiConn__getAttributeText(conn, DPI_OCI_ATTR_CURRENT_SCHEMA, value,
+            valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_getEdition() [PUBLIC]
+//   Return the edition associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_getEdition(dpiConn *conn, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiConn__getAttributeText(conn, DPI_OCI_ATTR_EDITION, value,
+            valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_getEncodingInfo() [PUBLIC]
+//   Get the encodings from the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_getEncodingInfo(dpiConn *conn, dpiEncodingInfo *info)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    status = dpiEnv__getEncodingInfo(conn->env, info);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_getExternalName() [PUBLIC]
+//   Return the external name associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_getExternalName(dpiConn *conn, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiConn__getAttributeText(conn, DPI_OCI_ATTR_EXTERNAL_NAME, value,
+            valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_getHandle() [PUBLIC]
+//   Get the OCI service context handle associated with the connection. This is
+// available in order to allow for extensions to the library using OCI
+// directly.
+//-----------------------------------------------------------------------------
+int dpiConn_getHandle(dpiConn *conn, void **handle)
+{
+    dpiError error;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, handle)
+    *handle = conn->handle;
+    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_getInternalName() [PUBLIC]
+//   Return the internal name associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_getInternalName(dpiConn *conn, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiConn__getAttributeText(conn, DPI_OCI_ATTR_INTERNAL_NAME, value,
+            valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_getIsHealthy() [PUBLIC]
+//   Return the health of the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_getIsHealthy(dpiConn *conn, int *isHealthy)
+{
+    dpiError error;
+    int status;
+    uint32_t serverStatus;
+
+    if (dpiGen__startPublicFn(conn, DPI_HTYPE_CONN, __func__, &error) < 0)
+        return DPI_FAILURE;
+    if (!conn->handle || !conn->serverHandle || conn->closing ||
+            conn->deadSession || (conn->pool && !conn->pool->handle)) {
+        *isHealthy = 0;
+        status = DPI_SUCCESS;
+    } else {
+        DPI_CHECK_PTR_NOT_NULL(conn, isHealthy)
+        status = dpiOci__attrGet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
+                &serverStatus, NULL, DPI_OCI_ATTR_SERVER_STATUS,
+                "get server status", &error);
+        *isHealthy = (serverStatus == DPI_OCI_SERVER_NORMAL);
+    }
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_getLTXID() [PUBLIC]
+//   Return the logical transaction id associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_getLTXID(dpiConn *conn, const char **value, uint32_t *valueLength)
+{
+    return dpiConn__getAttributeText(conn, DPI_OCI_ATTR_LTXID, value,
+            valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_getObjectType() [PUBLIC]
+//   Look up an object type given its name and return it.
+//-----------------------------------------------------------------------------
+int dpiConn_getObjectType(dpiConn *conn, const char *name, uint32_t nameLength,
+        dpiObjectType **objType)
+{
+    void *describeHandle, *param, *tdo;
+    int status, useTypeByFullName;
+    dpiError error;
+
+    // validate parameters
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, name)
+    DPI_CHECK_PTR_NOT_NULL(conn, objType)
+
+    // allocate describe handle
+    if (dpiOci__handleAlloc(conn->env->handle, &describeHandle,
+            DPI_OCI_HTYPE_DESCRIBE, "allocate describe handle", &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+
+    // Oracle Client 12.1 is capable of using OCITypeByFullName() but will
+    // fail if accessing an Oracle 11.2 database
+    useTypeByFullName = 1;
+    if (conn->env->versionInfo->versionNum < 12)
+        useTypeByFullName = 0;
+    else if (dpiConn__getServerVersion(conn, 0, &error) < 0)
+        return DPI_FAILURE;
+    else if (conn->versionInfo.versionNum < 12)
+        useTypeByFullName = 0;
+
+    // new API is supported so use it
+    if (useTypeByFullName) {
+        if (dpiOci__typeByFullName(conn, name, nameLength, &tdo, &error) < 0) {
+            dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
+            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+        }
+        if (dpiOci__describeAny(conn, tdo, 0, DPI_OCI_OTYPE_PTR,
+                describeHandle, &error) < 0) {
+            dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
+            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+        }
+
+    // use older API
+    } else {
+        if (dpiOci__describeAny(conn, (void*) name, nameLength,
+                DPI_OCI_OTYPE_NAME, describeHandle, &error) < 0) {
+            dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
+            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+        }
+    }
+
+    // get the parameter handle
+    if (dpiOci__attrGet(describeHandle,
+            DPI_OCI_HTYPE_DESCRIBE, &param, 0, DPI_OCI_ATTR_PARAM,
+            "get param", &error) < 0) {
+        dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+
+    // create object type
+    status = dpiObjectType__allocate(conn, param, DPI_OCI_HTYPE_DESCRIBE,
+            objType, &error);
+    dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_getOciAttr() [PUBLIC]
+//   Get the OCI attribute directly. This is intended for testing of attributes
+// not currently exposed by ODPI-C and should only be used for that purpose.
+//-----------------------------------------------------------------------------
+int dpiConn_getOciAttr(dpiConn *conn, uint32_t handleType,
+        uint32_t attribute, dpiDataBuffer *value, uint32_t *valueLength)
+{
+    const void *handle;
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, value)
+    DPI_CHECK_PTR_NOT_NULL(conn, valueLength)
+    switch (handleType) {
+        case DPI_OCI_HTYPE_SVCCTX:
+            handle = conn->handle;
+            break;
+        case DPI_OCI_HTYPE_SERVER:
+            handle = conn->serverHandle;
+            break;
+        case DPI_OCI_HTYPE_SESSION:
+            handle = conn->sessionHandle;
+            break;
+        default:
+            dpiError__set(&error, "check handle type", DPI_ERR_NOT_SUPPORTED);
+            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+
+    // get attribute value
+    status = dpiOci__attrGet(handle, handleType, &value->asRaw, valueLength,
+            attribute, "generic get OCI attribute", &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_getServerVersion() [PUBLIC]
+//   Get the server version string from the database.
+//-----------------------------------------------------------------------------
+int dpiConn_getServerVersion(dpiConn *conn, const char **releaseString,
+        uint32_t *releaseStringLength, dpiVersionInfo *versionInfo)
+{
+    dpiError error;
+
+    // validate parameters
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, versionInfo)
+
+    // get server version
+    if (dpiConn__getServerVersion(conn, (releaseString != NULL), &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (releaseString)
+        *releaseString = conn->releaseString;
+    if (releaseStringLength)
+        *releaseStringLength = conn->releaseStringLength;
+    memcpy(versionInfo, &conn->versionInfo, sizeof(dpiVersionInfo));
+    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_getStmtCacheSize() [PUBLIC]
+//   Return the current size of the statement cache.
+//-----------------------------------------------------------------------------
+int dpiConn_getStmtCacheSize(dpiConn *conn, uint32_t *cacheSize)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, cacheSize)
+    status = dpiOci__attrGet(conn->handle, DPI_OCI_HTYPE_SVCCTX, cacheSize,
+            NULL, DPI_OCI_ATTR_STMTCACHESIZE, "get stmt cache size", &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_newDeqOptions() [PUBLIC]
+//   Create a new dequeue options object and return it.
+//-----------------------------------------------------------------------------
+int dpiConn_newDeqOptions(dpiConn *conn, dpiDeqOptions **options)
+{
+    dpiDeqOptions *tempOptions;
+    dpiError error;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, options)
+    if (dpiGen__allocate(DPI_HTYPE_DEQ_OPTIONS, conn->env,
+            (void**) &tempOptions, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiDeqOptions__create(tempOptions, conn, &error) < 0) {
+        dpiDeqOptions__free(tempOptions, &error);
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+
+    *options = tempOptions;
+    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_newEnqOptions() [PUBLIC]
+//   Create a new enqueue options object and return it.
+//-----------------------------------------------------------------------------
+int dpiConn_newEnqOptions(dpiConn *conn, dpiEnqOptions **options)
+{
+    dpiEnqOptions *tempOptions;
+    dpiError error;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, options)
+    if (dpiGen__allocate(DPI_HTYPE_ENQ_OPTIONS, conn->env,
+            (void**) &tempOptions, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiEnqOptions__create(tempOptions, conn, &error) < 0) {
+        dpiEnqOptions__free(tempOptions, &error);
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+
+    *options = tempOptions;
+    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_newJson() [PUBLIC]
+//   Create a new JSON object and return it.
+//-----------------------------------------------------------------------------
+int dpiConn_newJson(dpiConn *conn, dpiJson **json)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, json);
+    status = dpiJson__allocate(conn, json, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_newJsonQueue() [PUBLIC]
+//   Create a new AQ queue object with JSON payload and return it.
+//-----------------------------------------------------------------------------
+int dpiConn_newJsonQueue(dpiConn *conn, const char *name, uint32_t nameLength,
+        dpiQueue **queue)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(conn, name)
+    DPI_CHECK_PTR_NOT_NULL(conn, queue)
+    status = dpiQueue__allocate(conn, name, nameLength, NULL, queue, 1,
+            &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_newTempLob() [PUBLIC]
+//   Create a new temporary LOB and return it.
+//-----------------------------------------------------------------------------
+int dpiConn_newTempLob(dpiConn *conn, dpiOracleTypeNum lobType, dpiLob **lob)
+{
+    const dpiOracleType *type;
+    dpiLob *tempLob;
+    dpiError error;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, lob)
+    switch (lobType) {
+        case DPI_ORACLE_TYPE_CLOB:
+        case DPI_ORACLE_TYPE_BLOB:
+        case DPI_ORACLE_TYPE_NCLOB:
+            type = dpiOracleType__getFromNum(lobType, &error);
+            break;
+        default:
+            dpiError__set(&error, "check lob type",
+                    DPI_ERR_INVALID_ORACLE_TYPE, lobType);
+            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+    if (dpiLob__allocate(conn, type, &tempLob, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiOci__lobCreateTemporary(tempLob, &error) < 0) {
+        dpiLob__free(tempLob, &error);
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+
+    *lob = tempLob;
+    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_newMsgProps() [PUBLIC]
+//   Create a new message properties object and return it.
+//-----------------------------------------------------------------------------
+int dpiConn_newMsgProps(dpiConn *conn, dpiMsgProps **props)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, props)
+    status = dpiMsgProps__allocate(conn, props, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_newQueue() [PUBLIC]
+//   Create a new AQ queue object and return it.
+//-----------------------------------------------------------------------------
+int dpiConn_newQueue(dpiConn *conn, const char *name, uint32_t nameLength,
+        dpiObjectType *payloadType, dpiQueue **queue)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(conn, name)
+    DPI_CHECK_PTR_NOT_NULL(conn, queue)
+    status = dpiQueue__allocate(conn, name, nameLength, payloadType, queue,
+            0, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_newVar() [PUBLIC]
+//   Create a new variable and return it.
+//-----------------------------------------------------------------------------
+int dpiConn_newVar(dpiConn *conn, dpiOracleTypeNum oracleTypeNum,
+        dpiNativeTypeNum nativeTypeNum, uint32_t maxArraySize, uint32_t size,
+        int sizeIsBytes, int isArray, dpiObjectType *objType, dpiVar **var,
+        dpiData **data)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, var)
+    DPI_CHECK_PTR_NOT_NULL(conn, data)
+    status = dpiVar__allocate(conn, oracleTypeNum, nativeTypeNum, maxArraySize,
+            size, sizeIsBytes, isArray, objType, var, data, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_ping() [PUBLIC]
+//   Makes a round trip call to the server to confirm that the connection and
+// server are still active.
+//-----------------------------------------------------------------------------
+int dpiConn_ping(dpiConn *conn)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    status = dpiOci__ping(conn, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_prepareDistribTrans() [PUBLIC]
+//   Prepare a distributed transaction for commit. This function is deprecated.
+// Use dpiConn_tpcPrepare() instead.
+//-----------------------------------------------------------------------------
+int dpiConn_prepareDistribTrans(dpiConn *conn, int *commitNeeded)
+{
+    return dpiConn_tpcPrepare(conn, NULL, commitNeeded);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_prepareStmt() [PUBLIC]
+//   Create a new statement and return it after preparing the specified SQL.
+//-----------------------------------------------------------------------------
+int dpiConn_prepareStmt(dpiConn *conn, int scrollable, const char *sql,
+        uint32_t sqlLength, const char *tag, uint32_t tagLength,
+        dpiStmt **stmt)
+{
+    dpiStmt *tempStmt;
+    dpiError error;
+
+    *stmt = NULL;
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(conn, sql)
+    DPI_CHECK_PTR_AND_LENGTH(conn, tag)
+    DPI_CHECK_PTR_NOT_NULL(conn, stmt)
+    if (dpiStmt__allocate(conn, scrollable, &tempStmt, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiStmt__prepare(tempStmt, sql, sqlLength, tag, tagLength,
+            &error) < 0) {
+        dpiStmt__free(tempStmt, &error);
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+    *stmt = tempStmt;
+    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_release() [PUBLIC]
+//   Release a reference to the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_release(dpiConn *conn)
+{
+    return dpiGen__release(conn, DPI_HTYPE_CONN, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_rollback() [PUBLIC]
+//   Rollback the transaction associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_rollback(dpiConn *conn)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    status = dpiConn__rollback(conn, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_setAction() [PUBLIC]
+//   Set the action associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_setAction(dpiConn *conn, const char *value, uint32_t valueLength)
+{
+    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_ACTION, value,
+            valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_setCallTimeout() [PUBLIC]
+//   Set the call timeout (in milliseconds) used for round-trips to the
+// database. This is only valid in Oracle Client 18c and higher.
+//-----------------------------------------------------------------------------
+int dpiConn_setCallTimeout(dpiConn *conn, uint32_t value)
+{
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiUtils__checkClientVersion(conn->env->versionInfo, 18, 1,
+            &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+
+    // set call timeout
+    status = dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX, &value,
+            0, DPI_OCI_ATTR_CALL_TIMEOUT, "set call timeout", &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_setClientIdentifier() [PUBLIC]
+//   Set the client identifier associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_setClientIdentifier(dpiConn *conn, const char *value,
+        uint32_t valueLength)
+{
+    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_CLIENT_IDENTIFIER,
+            value, valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_setClientInfo() [PUBLIC]
+//   Set the client info associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_setClientInfo(dpiConn *conn, const char *value,
+        uint32_t valueLength)
+{
+    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_CLIENT_INFO, value,
+            valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_setCurrentSchema() [PUBLIC]
+//   Set the current schema associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_setCurrentSchema(dpiConn *conn, const char *value,
+        uint32_t valueLength)
+{
+    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_CURRENT_SCHEMA, value,
+            valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_setDbOp() [PUBLIC]
+//   Set the database operation associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_setDbOp(dpiConn *conn, const char *value, uint32_t valueLength)
+{
+    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_DBOP, value,
+            valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_setEcontextId() [PUBLIC]
+//   Set the execute context id associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_setEcontextId(dpiConn *conn, const char *value,
+        uint32_t valueLength)
+{
+    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_ECONTEXT_ID, value,
+            valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_setExternalName() [PUBLIC]
+//   Set the external name associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_setExternalName(dpiConn *conn, const char *value,
+        uint32_t valueLength)
+{
+    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_EXTERNAL_NAME, value,
+            valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_setInternalName() [PUBLIC]
+//   Set the internal name associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_setInternalName(dpiConn *conn, const char *value,
+        uint32_t valueLength)
+{
+    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_INTERNAL_NAME, value,
+            valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_setModule() [PUBLIC]
+//   Set the module associated with the connection.
+//-----------------------------------------------------------------------------
+int dpiConn_setModule(dpiConn *conn, const char *value, uint32_t valueLength)
+{
+    return dpiConn__setAttributeText(conn, DPI_OCI_ATTR_MODULE, value,
+            valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_setOciAttr() [PUBLIC]
+//   Set the OCI attribute directly. This is intended for testing of attributes
+// not currently exposed by ODPI-C and should only be used for that purpose.
+//-----------------------------------------------------------------------------
+int dpiConn_setOciAttr(dpiConn *conn, uint32_t handleType,
+        uint32_t attribute, void *value, uint32_t valueLength)
+{
+    dpiError error;
+    void *handle;
+    int status;
+
+    // validate parameters
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, value)
+    switch (handleType) {
+        case DPI_OCI_HTYPE_SVCCTX:
+            handle = conn->handle;
+            break;
+        case DPI_OCI_HTYPE_SERVER:
+            handle = conn->serverHandle;
+            break;
+        case DPI_OCI_HTYPE_SESSION:
+            handle = conn->sessionHandle;
+            break;
+        default:
+            dpiError__set(&error, "check handle type", DPI_ERR_NOT_SUPPORTED);
+            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+
+    // set attribute value
+    status = dpiOci__attrSet(handle, handleType, value, valueLength,
+            attribute, "generic set OCI attribute", &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_setStmtCacheSize() [PUBLIC]
+//   Set the size of the statement cache.
+//-----------------------------------------------------------------------------
+int dpiConn_setStmtCacheSize(dpiConn *conn, uint32_t cacheSize)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    status = dpiOci__attrSet(conn->handle, DPI_OCI_HTYPE_SVCCTX, &cacheSize, 0,
+            DPI_OCI_ATTR_STMTCACHESIZE, "set stmt cache size", &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_shutdownDatabase() [PUBLIC]
+//   Shutdown the database. Note that this must be done in two phases except in
+// the situation where the instance is being aborted.
+//-----------------------------------------------------------------------------
+int dpiConn_shutdownDatabase(dpiConn *conn, dpiShutdownMode mode)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    status = dpiOci__dbShutdown(conn, mode, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_startupDatabase() [PUBLIC]
+//   Startup the database. This is equivalent to "startup nomount" in SQL*Plus.
+//-----------------------------------------------------------------------------
+int dpiConn_startupDatabase(dpiConn *conn, dpiStartupMode mode)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    status = dpiConn__startupDatabase(conn, NULL, 0, mode, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_startupDatabaseWithPfile() [PUBLIC]
+//   Startup the database with a parameter file (PFILE). This is equivalent to
+// "startup nomount pfile=<pfile_location>" in SQL*Plus.
+//-----------------------------------------------------------------------------
+int dpiConn_startupDatabaseWithPfile(dpiConn *conn, const char *pfile,
+        uint32_t pfileLength, dpiStartupMode mode)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(conn, pfile)
+    status = dpiConn__startupDatabase(conn, pfile, pfileLength, mode, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_subscribe() [PUBLIC]
+//   Subscribe to events in the database. A subscription is created and
+// returned. This replaces dpiConn_newSubscription().
+//-----------------------------------------------------------------------------
+int dpiConn_subscribe(dpiConn *conn, dpiSubscrCreateParams *params,
+        dpiSubscr **subscr)
+{
+    dpiSubscr *tempSubscr;
+    dpiError error;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, params)
+    DPI_CHECK_PTR_NOT_NULL(conn, subscr)
+    if (!conn->env->events) {
+        dpiError__set(&error, "subscribe", DPI_ERR_EVENTS_MODE_REQUIRED);
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+    if (dpiGen__allocate(DPI_HTYPE_SUBSCR, conn->env, (void**) &tempSubscr,
+            &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiSubscr__create(tempSubscr, conn, params, &error) < 0) {
+        dpiSubscr__free(tempSubscr, &error);
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+
+    *subscr = tempSubscr;
+    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_tpcBegin() [PUBLIC]
+//   Begin a TPC (two-phase commit) transaction.
+//-----------------------------------------------------------------------------
+int dpiConn_tpcBegin(dpiConn *conn, dpiXid *xid, uint32_t transactionTimeout,
+        uint32_t flags)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, xid)
+    if (dpiConn__setXid(conn, xid, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    status = dpiOci__transStart(conn, transactionTimeout, flags, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_tpcCommit() [PUBLIC]
+//   Commit a TPC (two-phase commit) transaction. This method is equivalent to
+// calling dpiConn_commit() if no XID is specified.
+//-----------------------------------------------------------------------------
+int dpiConn_tpcCommit(dpiConn *conn, dpiXid *xid, int onePhase)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (xid) {
+        if (dpiConn__setXid(conn, xid, &error) < 0)
+            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+        conn->commitMode = (onePhase) ? DPI_OCI_DEFAULT :
+                DPI_OCI_TRANS_TWOPHASE;
+    }
+    status = dpiConn__commit(conn, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_tpcEnd() [PUBLIC]
+//   End (detach from) a TPC (two-phase commit) transaction.
+//-----------------------------------------------------------------------------
+int dpiConn_tpcEnd(dpiConn *conn, dpiXid *xid, uint32_t flags)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (xid) {
+        if (dpiConn__setXid(conn, xid, &error) < 0)
+            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+    status = dpiOci__transDetach(conn, flags, &error);
+    if (status == DPI_SUCCESS)
+        status = dpiConn__clearTransaction(conn, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_tpcForget() [PUBLIC]
+//   Forget a TPC (two-phase commit) transaction.
+//-----------------------------------------------------------------------------
+int dpiConn_tpcForget(dpiConn *conn, dpiXid *xid)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, xid)
+    if (dpiConn__setXid(conn, xid, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    status = dpiOci__transForget(conn, &error);
+    if (status == DPI_SUCCESS)
+        status = dpiConn__clearTransaction(conn, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_tpcPrepare() [PUBLIC]
+//   Prepare a TPC (two-phase commit) transaction for commit. A boolean is
+// returned indicating if a commit is actually needed as an attempt to perform
+// a commit when nothing is actually prepared results in ORA-24756 (transaction
+// does not exist). This is determined by the return value from
+// OCITransPrepare() which is OCI_SUCCESS_WITH_INFO if there is no transaction
+// requiring commit.
+//-----------------------------------------------------------------------------
+int dpiConn_tpcPrepare(dpiConn *conn, dpiXid *xid, int *commitNeeded)
+{
+    dpiError error;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(conn, commitNeeded)
+    if (xid) {
+        if (dpiConn__setXid(conn, xid, &error) < 0)
+            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+    if (dpiOci__transPrepare(conn, commitNeeded, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (*commitNeeded)
+        conn->commitMode = DPI_OCI_TRANS_TWOPHASE;
+    return dpiGen__endPublicFn(conn, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_tpcRollback() [PUBLIC]
+//   Rollback a TPC (two-phase commit) transaction. This method is equivalent
+// to calling dpiConn_rollback() if no XID is specified.
+//-----------------------------------------------------------------------------
+int dpiConn_tpcRollback(dpiConn *conn, dpiXid *xid)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (xid) {
+        if (dpiConn__setXid(conn, xid, &error) < 0)
+            return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    }
+    status = dpiConn__rollback(conn, &error);
+    return dpiGen__endPublicFn(conn, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiConn_unsubscribe() [PUBLIC]
+//   Unsubscribe from events in the database. Once this call completes
+// successfully no further notifications will be sent.
+//-----------------------------------------------------------------------------
+int dpiConn_unsubscribe(dpiConn *conn, dpiSubscr *subscr)
+{
+    dpiError error;
+    int status;
+
+    if (dpiConn__check(conn, __func__, &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(subscr, DPI_HTYPE_SUBSCR, "check subscription",
+            &error) < 0)
+        return dpiGen__endPublicFn(conn, DPI_FAILURE, &error);
+    if (subscr->registered) {
+        dpiMutex__acquire(subscr->mutex);
+        status = dpiOci__subscriptionUnRegister(conn, subscr, &error);
+        if (status == DPI_SUCCESS)
+            subscr->registered = 0;
+        dpiMutex__release(subscr->mutex);
+        if (status < 0)
+            return dpiGen__endPublicFn(subscr, DPI_FAILURE, &error);
+    }
+
+    dpiGen__setRefCount(subscr, &error, -1);
+    return dpiGen__endPublicFn(subscr, DPI_SUCCESS, &error);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiContext.c ./odpi/src/dpiContext.c
--- patched-godror/odpi/src/dpiContext.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiContext.c	1970-01-01 01:00:00
@@ -1,414 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiContext.c
-//   Implementation of context. Each context uses a specific version of the
-// ODPI-C library, which is checked for compatibility before allowing its use.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-// forward declarations of internal functions only used in this file
-static void dpiContext__free(dpiContext *context);
-
-
-//-----------------------------------------------------------------------------
-// dpiContext__create() [INTERNAL]
-//   Helper function for dpiContext__create().
-//-----------------------------------------------------------------------------
-static int dpiContext__create(const char *fnName, unsigned int majorVersion,
-        unsigned int minorVersion, dpiContextCreateParams *params,
-        dpiContext **context, dpiError *error)
-{
-    dpiVersionInfo *versionInfo;
-    dpiContext *tempContext;
-
-    // ensure global infrastructure is initialized
-    if (dpiGlobal__ensureInitialized(fnName, params, &versionInfo, error) < 0)
-        return DPI_FAILURE;
-
-    // validate context handle
-    if (!context)
-        return dpiError__set(error, "check context handle",
-                DPI_ERR_NULL_POINTER_PARAMETER, "context");
-
-    // verify that the supplied version is supported by the library
-    if (majorVersion != DPI_MAJOR_VERSION || minorVersion > DPI_MINOR_VERSION)
-        return dpiError__set(error, "check version",
-                DPI_ERR_VERSION_NOT_SUPPORTED, majorVersion, majorVersion,
-                minorVersion, DPI_MAJOR_VERSION, DPI_MINOR_VERSION);
-
-    // allocate context and initialize it
-    if (dpiGen__allocate(DPI_HTYPE_CONTEXT, NULL, (void**) &tempContext,
-            error) < 0)
-        return DPI_FAILURE;
-    tempContext->dpiMinorVersion = (uint8_t) minorVersion;
-    tempContext->versionInfo = versionInfo;
-
-    // store default encoding, if applicable
-    if (params->defaultEncoding) {
-        if (dpiUtils__allocateMemory(1, strlen(params->defaultEncoding) + 1, 0,
-                "allocate default encoding",
-                (void**) &tempContext->defaultEncoding, error) < 0) {
-            dpiContext__free(tempContext);
-            return DPI_FAILURE;
-        }
-        strcpy(tempContext->defaultEncoding, params->defaultEncoding);
-    }
-
-    // store default driver name, if applicable
-    if (params->defaultDriverName) {
-        if (dpiUtils__allocateMemory(1, strlen(params->defaultDriverName) + 1,
-                0, "allocate default driver name",
-                (void**) &tempContext->defaultDriverName, error) < 0) {
-            dpiContext__free(tempContext);
-            return DPI_FAILURE;
-        }
-        strcpy(tempContext->defaultDriverName, params->defaultDriverName);
-    }
-
-    *context = tempContext;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext__free() [INTERNAL]
-//   Free the memory and any resources associated with the context.
-//-----------------------------------------------------------------------------
-static void dpiContext__free(dpiContext *context)
-{
-    if (context->defaultDriverName) {
-        dpiUtils__freeMemory((void*) context->defaultDriverName);
-        context->defaultDriverName = NULL;
-    }
-    if (context->defaultEncoding) {
-        dpiUtils__freeMemory((void*) context->defaultEncoding);
-        context->defaultEncoding = NULL;
-    }
-    dpiUtils__freeMemory(context);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext__initCommonCreateParams() [INTERNAL]
-//   Initialize the common connection/pool creation parameters to default
-// values.
-//-----------------------------------------------------------------------------
-void dpiContext__initCommonCreateParams(const dpiContext *context,
-        dpiCommonCreateParams *params)
-{
-    memset(params, 0, sizeof(dpiCommonCreateParams));
-    if (context->defaultEncoding) {
-        params->encoding = context->defaultEncoding;
-        params->nencoding = context->defaultEncoding;
-    } else {
-        params->encoding = DPI_CHARSET_NAME_UTF8;
-        params->nencoding = DPI_CHARSET_NAME_UTF8;
-    }
-    if (context->defaultDriverName) {
-        params->driverName = context->defaultDriverName;
-        params->driverNameLength =
-                (uint32_t) strlen(context->defaultDriverName);
-    } else {
-        params->driverName = DPI_DEFAULT_DRIVER_NAME;
-        params->driverNameLength = (uint32_t) strlen(params->driverName);
-    }
-    params->stmtCacheSize = DPI_DEFAULT_STMT_CACHE_SIZE;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext__initConnCreateParams() [INTERNAL]
-//   Initialize the connection creation parameters to default values. Return
-// the structure size as a convenience for calling functions which may have to
-// differentiate between different ODPI-C application versions.
-//-----------------------------------------------------------------------------
-void dpiContext__initConnCreateParams(dpiConnCreateParams *params)
-{
-    memset(params, 0, sizeof(dpiConnCreateParams));
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext__initPoolCreateParams() [INTERNAL]
-//   Initialize the pool creation parameters to default values.
-//-----------------------------------------------------------------------------
-void dpiContext__initPoolCreateParams(dpiPoolCreateParams *params)
-{
-    memset(params, 0, sizeof(dpiPoolCreateParams));
-    params->minSessions = 1;
-    params->maxSessions = 1;
-    params->sessionIncrement = 0;
-    params->homogeneous = 1;
-    params->getMode = DPI_MODE_POOL_GET_NOWAIT;
-    params->pingInterval = DPI_DEFAULT_PING_INTERVAL;
-    params->pingTimeout = DPI_DEFAULT_PING_TIMEOUT;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext__initSodaOperOptions() [INTERNAL]
-//   Initialize the SODA operation options to default values.
-//-----------------------------------------------------------------------------
-void dpiContext__initSodaOperOptions(dpiSodaOperOptions *options)
-{
-    memset(options, 0, sizeof(dpiSodaOperOptions));
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext__initSubscrCreateParams() [INTERNAL]
-//   Initialize the subscription creation parameters to default values.
-//-----------------------------------------------------------------------------
-void dpiContext__initSubscrCreateParams(dpiSubscrCreateParams *params)
-{
-    memset(params, 0, sizeof(dpiSubscrCreateParams));
-    params->subscrNamespace = DPI_SUBSCR_NAMESPACE_DBCHANGE;
-    params->groupingType = DPI_SUBSCR_GROUPING_TYPE_SUMMARY;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext_createWithParams() [PUBLIC]
-//   Create a new context for interaction with the library. The major versions
-// must match and the minor version of the caller must be less than or equal to
-// the minor version compiled into the library. The supplied parameters can be
-// used to modify how the Oracle client library is loaded.
-//-----------------------------------------------------------------------------
-int dpiContext_createWithParams(unsigned int majorVersion,
-        unsigned int minorVersion, dpiContextCreateParams *params,
-        dpiContext **context, dpiErrorInfo *errorInfo)
-{
-    dpiContextCreateParams localParams;
-    dpiErrorInfo localErrorInfo;
-    dpiError error;
-    int status;
-
-    // make a copy of the parameters so that the addition of defaults doesn't
-    // modify the original parameters that were passed; then add defaults, if
-    // needed
-    if (params) {
-        memcpy(&localParams, params, sizeof(localParams));
-    } else {
-        memset(&localParams, 0, sizeof(localParams));
-    }
-    if (!localParams.loadErrorUrl)
-        localParams.loadErrorUrl = DPI_DEFAULT_LOAD_ERROR_URL;
-
-    status = dpiContext__create(__func__, majorVersion, minorVersion,
-            &localParams, context, &error);
-    if (status < 0) {
-        dpiError__getInfo(&error, &localErrorInfo);
-        memcpy(errorInfo, &localErrorInfo, sizeof(dpiErrorInfo__v33));
-    }
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_FNS)
-        dpiDebug__print("fn end %s -> %d\n", __func__, status);
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext_destroy() [PUBLIC]
-//   Destroy an existing context. The structure will be checked for validity
-// first.
-//-----------------------------------------------------------------------------
-int dpiContext_destroy(dpiContext *context)
-{
-    char message[80];
-    dpiError error;
-
-    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    dpiUtils__clearMemory(&context->checkInt, sizeof(context->checkInt));
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_REFS)
-        dpiDebug__print("ref %p (%s) -> 0\n", context, context->typeDef->name);
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_FNS)
-        (void) sprintf(message, "fn end %s(%p) -> %d", __func__, context,
-                DPI_SUCCESS);
-    dpiContext__free(context);
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_FNS)
-        dpiDebug__print("%s\n", message);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext_getClientVersion() [PUBLIC]
-//   Return the version of the Oracle client that is in use.
-//-----------------------------------------------------------------------------
-int dpiContext_getClientVersion(const dpiContext *context,
-        dpiVersionInfo *versionInfo)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(context, versionInfo)
-    memcpy(versionInfo, context->versionInfo, sizeof(dpiVersionInfo));
-    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext_getError() [PUBLIC]
-//   Return information about the error that was last populated.
-//-----------------------------------------------------------------------------
-void dpiContext_getError(const dpiContext *context, dpiErrorInfo *info)
-{
-    dpiError error;
-
-    dpiGlobal__initError(NULL, &error);
-    dpiGen__checkHandle(context, DPI_HTYPE_CONTEXT, "check handle", &error);
-    dpiError__getInfo(&error, info);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext_initCommonCreateParams() [PUBLIC]
-//   Initialize the common connection/pool creation parameters to default
-// values.
-//-----------------------------------------------------------------------------
-int dpiContext_initCommonCreateParams(const dpiContext *context,
-        dpiCommonCreateParams *params)
-{
-    dpiCommonCreateParams localParams;
-    dpiError error;
-
-    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(context, params)
-
-    // size changed in version 4.2 and 4.4; local structure and checks can
-    // be dropped once version 5 released
-    if (context->dpiMinorVersion > 3) {
-        dpiContext__initCommonCreateParams(context, params);
-    } else if (context->dpiMinorVersion > 1) {
-        dpiContext__initCommonCreateParams(context, &localParams);
-        memcpy(params, &localParams, sizeof(dpiCommonCreateParams__v43));
-    } else {
-        dpiContext__initCommonCreateParams(context, &localParams);
-        memcpy(params, &localParams, sizeof(dpiCommonCreateParams__v41));
-    }
-
-    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext_initConnCreateParams() [PUBLIC]
-//   Initialize the connection creation parameters to default values.
-//-----------------------------------------------------------------------------
-int dpiContext_initConnCreateParams(const dpiContext *context,
-        dpiConnCreateParams *params)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(context, params)
-
-    dpiContext__initConnCreateParams(params);
-    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext_initPoolCreateParams() [PUBLIC]
-//   Initialize the pool creation parameters to default values.
-//-----------------------------------------------------------------------------
-int dpiContext_initPoolCreateParams(const dpiContext *context,
-        dpiPoolCreateParams *params)
-{
-    dpiPoolCreateParams localParams;
-    dpiError error;
-
-    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(context, params)
-
-    // size changed in version 4.4; local structure and checks
-    // can be dropped once version 5 released
-    if (context->dpiMinorVersion > 3) {
-        dpiContext__initPoolCreateParams(params);
-    } else {
-        dpiContext__initPoolCreateParams(&localParams);
-        memcpy(params, &localParams, sizeof(dpiPoolCreateParams__v43));
-    }
-
-    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext_initSodaOperOptions() [PUBLIC]
-//   Initialize the SODA operation options to default values.
-//-----------------------------------------------------------------------------
-int dpiContext_initSodaOperOptions(const dpiContext *context,
-        dpiSodaOperOptions *options)
-{
-    dpiSodaOperOptions localOptions;
-    dpiError error;
-
-    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(context, options)
-
-    // size changed in version 4.2; local structure and check can be dropped
-    // once version 5 released
-    if (context->dpiMinorVersion > 1) {
-        dpiContext__initSodaOperOptions(options);
-    } else {
-        dpiContext__initSodaOperOptions(&localOptions);
-        memcpy(options, &localOptions, sizeof(dpiSodaOperOptions__v41));
-    }
-
-    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiContext_initSubscrCreateParams() [PUBLIC]
-//   Initialize the subscription creation parameters to default values.
-//-----------------------------------------------------------------------------
-int dpiContext_initSubscrCreateParams(const dpiContext *context,
-        dpiSubscrCreateParams *params)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(context, params)
-
-    dpiContext__initSubscrCreateParams(params);
-    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiContext.h ./odpi/src/dpiContext.h
--- patched-godror/odpi/src/dpiContext.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiContext.h	2024-05-14 14:55:13
@@ -0,0 +1,414 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiContext.c
+//   Implementation of context. Each context uses a specific version of the
+// ODPI-C library, which is checked for compatibility before allowing its use.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+// forward declarations of internal functions only used in this file
+static void dpiContext__free(dpiContext *context);
+
+
+//-----------------------------------------------------------------------------
+// dpiContext__create() [INTERNAL]
+//   Helper function for dpiContext__create().
+//-----------------------------------------------------------------------------
+static int dpiContext__create(const char *fnName, unsigned int majorVersion,
+        unsigned int minorVersion, dpiContextCreateParams *params,
+        dpiContext **context, dpiError *error)
+{
+    dpiVersionInfo *versionInfo;
+    dpiContext *tempContext;
+
+    // ensure global infrastructure is initialized
+    if (dpiGlobal__ensureInitialized(fnName, params, &versionInfo, error) < 0)
+        return DPI_FAILURE;
+
+    // validate context handle
+    if (!context)
+        return dpiError__set(error, "check context handle",
+                DPI_ERR_NULL_POINTER_PARAMETER, "context");
+
+    // verify that the supplied version is supported by the library
+    if (majorVersion != DPI_MAJOR_VERSION || minorVersion > DPI_MINOR_VERSION)
+        return dpiError__set(error, "check version",
+                DPI_ERR_VERSION_NOT_SUPPORTED, majorVersion, majorVersion,
+                minorVersion, DPI_MAJOR_VERSION, DPI_MINOR_VERSION);
+
+    // allocate context and initialize it
+    if (dpiGen__allocate(DPI_HTYPE_CONTEXT, NULL, (void**) &tempContext,
+            error) < 0)
+        return DPI_FAILURE;
+    tempContext->dpiMinorVersion = (uint8_t) minorVersion;
+    tempContext->versionInfo = versionInfo;
+
+    // store default encoding, if applicable
+    if (params->defaultEncoding) {
+        if (dpiUtils__allocateMemory(1, strlen(params->defaultEncoding) + 1, 0,
+                "allocate default encoding",
+                (void**) &tempContext->defaultEncoding, error) < 0) {
+            dpiContext__free(tempContext);
+            return DPI_FAILURE;
+        }
+        strcpy(tempContext->defaultEncoding, params->defaultEncoding);
+    }
+
+    // store default driver name, if applicable
+    if (params->defaultDriverName) {
+        if (dpiUtils__allocateMemory(1, strlen(params->defaultDriverName) + 1,
+                0, "allocate default driver name",
+                (void**) &tempContext->defaultDriverName, error) < 0) {
+            dpiContext__free(tempContext);
+            return DPI_FAILURE;
+        }
+        strcpy(tempContext->defaultDriverName, params->defaultDriverName);
+    }
+
+    *context = tempContext;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext__free() [INTERNAL]
+//   Free the memory and any resources associated with the context.
+//-----------------------------------------------------------------------------
+static void dpiContext__free(dpiContext *context)
+{
+    if (context->defaultDriverName) {
+        dpiUtils__freeMemory((void*) context->defaultDriverName);
+        context->defaultDriverName = NULL;
+    }
+    if (context->defaultEncoding) {
+        dpiUtils__freeMemory((void*) context->defaultEncoding);
+        context->defaultEncoding = NULL;
+    }
+    dpiUtils__freeMemory(context);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext__initCommonCreateParams() [INTERNAL]
+//   Initialize the common connection/pool creation parameters to default
+// values.
+//-----------------------------------------------------------------------------
+void dpiContext__initCommonCreateParams(const dpiContext *context,
+        dpiCommonCreateParams *params)
+{
+    memset(params, 0, sizeof(dpiCommonCreateParams));
+    if (context->defaultEncoding) {
+        params->encoding = context->defaultEncoding;
+        params->nencoding = context->defaultEncoding;
+    } else {
+        params->encoding = DPI_CHARSET_NAME_UTF8;
+        params->nencoding = DPI_CHARSET_NAME_UTF8;
+    }
+    if (context->defaultDriverName) {
+        params->driverName = context->defaultDriverName;
+        params->driverNameLength =
+                (uint32_t) strlen(context->defaultDriverName);
+    } else {
+        params->driverName = DPI_DEFAULT_DRIVER_NAME;
+        params->driverNameLength = (uint32_t) strlen(params->driverName);
+    }
+    params->stmtCacheSize = DPI_DEFAULT_STMT_CACHE_SIZE;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext__initConnCreateParams() [INTERNAL]
+//   Initialize the connection creation parameters to default values. Return
+// the structure size as a convenience for calling functions which may have to
+// differentiate between different ODPI-C application versions.
+//-----------------------------------------------------------------------------
+void dpiContext__initConnCreateParams(dpiConnCreateParams *params)
+{
+    memset(params, 0, sizeof(dpiConnCreateParams));
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext__initPoolCreateParams() [INTERNAL]
+//   Initialize the pool creation parameters to default values.
+//-----------------------------------------------------------------------------
+void dpiContext__initPoolCreateParams(dpiPoolCreateParams *params)
+{
+    memset(params, 0, sizeof(dpiPoolCreateParams));
+    params->minSessions = 1;
+    params->maxSessions = 1;
+    params->sessionIncrement = 0;
+    params->homogeneous = 1;
+    params->getMode = DPI_MODE_POOL_GET_NOWAIT;
+    params->pingInterval = DPI_DEFAULT_PING_INTERVAL;
+    params->pingTimeout = DPI_DEFAULT_PING_TIMEOUT;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext__initSodaOperOptions() [INTERNAL]
+//   Initialize the SODA operation options to default values.
+//-----------------------------------------------------------------------------
+void dpiContext__initSodaOperOptions(dpiSodaOperOptions *options)
+{
+    memset(options, 0, sizeof(dpiSodaOperOptions));
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext__initSubscrCreateParams() [INTERNAL]
+//   Initialize the subscription creation parameters to default values.
+//-----------------------------------------------------------------------------
+void dpiContext__initSubscrCreateParams(dpiSubscrCreateParams *params)
+{
+    memset(params, 0, sizeof(dpiSubscrCreateParams));
+    params->subscrNamespace = DPI_SUBSCR_NAMESPACE_DBCHANGE;
+    params->groupingType = DPI_SUBSCR_GROUPING_TYPE_SUMMARY;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext_createWithParams() [PUBLIC]
+//   Create a new context for interaction with the library. The major versions
+// must match and the minor version of the caller must be less than or equal to
+// the minor version compiled into the library. The supplied parameters can be
+// used to modify how the Oracle client library is loaded.
+//-----------------------------------------------------------------------------
+int dpiContext_createWithParams(unsigned int majorVersion,
+        unsigned int minorVersion, dpiContextCreateParams *params,
+        dpiContext **context, dpiErrorInfo *errorInfo)
+{
+    dpiContextCreateParams localParams;
+    dpiErrorInfo localErrorInfo;
+    dpiError error;
+    int status;
+
+    // make a copy of the parameters so that the addition of defaults doesn't
+    // modify the original parameters that were passed; then add defaults, if
+    // needed
+    if (params) {
+        memcpy(&localParams, params, sizeof(localParams));
+    } else {
+        memset(&localParams, 0, sizeof(localParams));
+    }
+    if (!localParams.loadErrorUrl)
+        localParams.loadErrorUrl = DPI_DEFAULT_LOAD_ERROR_URL;
+
+    status = dpiContext__create(__func__, majorVersion, minorVersion,
+            &localParams, context, &error);
+    if (status < 0) {
+        dpiError__getInfo(&error, &localErrorInfo);
+        memcpy(errorInfo, &localErrorInfo, sizeof(dpiErrorInfo__v33));
+    }
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_FNS)
+        dpiDebug__print("fn end %s -> %d\n", __func__, status);
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext_destroy() [PUBLIC]
+//   Destroy an existing context. The structure will be checked for validity
+// first.
+//-----------------------------------------------------------------------------
+int dpiContext_destroy(dpiContext *context)
+{
+    char message[80];
+    dpiError error;
+
+    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    dpiUtils__clearMemory(&context->checkInt, sizeof(context->checkInt));
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_REFS)
+        dpiDebug__print("ref %p (%s) -> 0\n", context, context->typeDef->name);
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_FNS)
+        (void) sprintf(message, "fn end %s(%p) -> %d", __func__, context,
+                DPI_SUCCESS);
+    dpiContext__free(context);
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_FNS)
+        dpiDebug__print("%s\n", message);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext_getClientVersion() [PUBLIC]
+//   Return the version of the Oracle client that is in use.
+//-----------------------------------------------------------------------------
+int dpiContext_getClientVersion(const dpiContext *context,
+        dpiVersionInfo *versionInfo)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(context, versionInfo)
+    memcpy(versionInfo, context->versionInfo, sizeof(dpiVersionInfo));
+    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext_getError() [PUBLIC]
+//   Return information about the error that was last populated.
+//-----------------------------------------------------------------------------
+void dpiContext_getError(const dpiContext *context, dpiErrorInfo *info)
+{
+    dpiError error;
+
+    dpiGlobal__initError(NULL, &error);
+    dpiGen__checkHandle(context, DPI_HTYPE_CONTEXT, "check handle", &error);
+    dpiError__getInfo(&error, info);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext_initCommonCreateParams() [PUBLIC]
+//   Initialize the common connection/pool creation parameters to default
+// values.
+//-----------------------------------------------------------------------------
+int dpiContext_initCommonCreateParams(const dpiContext *context,
+        dpiCommonCreateParams *params)
+{
+    dpiCommonCreateParams localParams;
+    dpiError error;
+
+    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(context, params)
+
+    // size changed in version 4.2 and 4.4; local structure and checks can
+    // be dropped once version 5 released
+    if (context->dpiMinorVersion > 3) {
+        dpiContext__initCommonCreateParams(context, params);
+    } else if (context->dpiMinorVersion > 1) {
+        dpiContext__initCommonCreateParams(context, &localParams);
+        memcpy(params, &localParams, sizeof(dpiCommonCreateParams__v43));
+    } else {
+        dpiContext__initCommonCreateParams(context, &localParams);
+        memcpy(params, &localParams, sizeof(dpiCommonCreateParams__v41));
+    }
+
+    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext_initConnCreateParams() [PUBLIC]
+//   Initialize the connection creation parameters to default values.
+//-----------------------------------------------------------------------------
+int dpiContext_initConnCreateParams(const dpiContext *context,
+        dpiConnCreateParams *params)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(context, params)
+
+    dpiContext__initConnCreateParams(params);
+    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext_initPoolCreateParams() [PUBLIC]
+//   Initialize the pool creation parameters to default values.
+//-----------------------------------------------------------------------------
+int dpiContext_initPoolCreateParams(const dpiContext *context,
+        dpiPoolCreateParams *params)
+{
+    dpiPoolCreateParams localParams;
+    dpiError error;
+
+    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(context, params)
+
+    // size changed in version 4.4; local structure and checks
+    // can be dropped once version 5 released
+    if (context->dpiMinorVersion > 3) {
+        dpiContext__initPoolCreateParams(params);
+    } else {
+        dpiContext__initPoolCreateParams(&localParams);
+        memcpy(params, &localParams, sizeof(dpiPoolCreateParams__v43));
+    }
+
+    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext_initSodaOperOptions() [PUBLIC]
+//   Initialize the SODA operation options to default values.
+//-----------------------------------------------------------------------------
+int dpiContext_initSodaOperOptions(const dpiContext *context,
+        dpiSodaOperOptions *options)
+{
+    dpiSodaOperOptions localOptions;
+    dpiError error;
+
+    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(context, options)
+
+    // size changed in version 4.2; local structure and check can be dropped
+    // once version 5 released
+    if (context->dpiMinorVersion > 1) {
+        dpiContext__initSodaOperOptions(options);
+    } else {
+        dpiContext__initSodaOperOptions(&localOptions);
+        memcpy(options, &localOptions, sizeof(dpiSodaOperOptions__v41));
+    }
+
+    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiContext_initSubscrCreateParams() [PUBLIC]
+//   Initialize the subscription creation parameters to default values.
+//-----------------------------------------------------------------------------
+int dpiContext_initSubscrCreateParams(const dpiContext *context,
+        dpiSubscrCreateParams *params)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(context, params)
+
+    dpiContext__initSubscrCreateParams(params);
+    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiData.c ./odpi/src/dpiData.c
--- patched-godror/odpi/src/dpiData.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiData.c	1970-01-01 01:00:00
@@ -1,936 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiData.c
-//   Implementation of transformation routines.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-// constants used for converting timestamps to/from an interval
-#define DPI_MS_DAY        86400000  // 24 * 60 * 60 * 1000
-#define DPI_MS_HOUR       3600000   // 60 * 60 * 1000
-#define DPI_MS_MINUTE     60000     // 60 * 1000
-#define DPI_MS_SECOND     1000      // ms per sec
-#define DPI_MS_FSECOND    1000000   // 1000 * 1000
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__fromOracleDate() [INTERNAL]
-//   Populate the data from an dpiOciDate structure.
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__fromOracleDate(dpiDataBuffer *data,
-        dpiOciDate *oracleValue)
-{
-    dpiTimestamp *timestamp = &data->asTimestamp;
-
-    timestamp->year = oracleValue->year;
-    timestamp->month = oracleValue->month;
-    timestamp->day = oracleValue->day;
-    timestamp->hour = oracleValue->hour;
-    timestamp->minute = oracleValue->minute;
-    timestamp->second = oracleValue->second;
-    timestamp->fsecond = 0;
-    timestamp->tzHourOffset = 0;
-    timestamp->tzMinuteOffset = 0;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__fromOracleDateAsDouble() [INTERNAL]
-//   Populate the data from an dpiOciDate structure as a double value (number
-// of milliseconds since January 1, 1970).
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__fromOracleDateAsDouble(dpiDataBuffer *data,
-        dpiEnv *env, dpiError *error, dpiOciDate *oracleValue)
-{
-    void *timestamp;
-    int status;
-
-    // allocate and populate a timestamp with the value of the date
-    if (dpiOci__descriptorAlloc(env->handle, &timestamp,
-            DPI_OCI_DTYPE_TIMESTAMP, "alloc timestamp", error) < 0)
-        return DPI_FAILURE;
-    if (dpiOci__dateTimeConstruct(env->handle, timestamp, oracleValue->year,
-            oracleValue->month, oracleValue->day, oracleValue->hour,
-            oracleValue->minute, oracleValue->second, 0, NULL, 0, error) < 0) {
-        dpiOci__descriptorFree(timestamp, DPI_OCI_DTYPE_TIMESTAMP);
-        return DPI_FAILURE;
-    }
-
-    // now calculate the number of milliseconds since January 1, 1970
-    status = dpiDataBuffer__fromOracleTimestampAsDouble(data,
-            DPI_ORACLE_TYPE_TIMESTAMP, env, error, timestamp);
-    dpiOci__descriptorFree(timestamp, DPI_OCI_DTYPE_TIMESTAMP);
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__fromOracleIntervalDS() [INTERNAL]
-//   Populate the data from an OCIInterval structure (days/seconds).
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__fromOracleIntervalDS(dpiDataBuffer *data, dpiEnv *env,
-        dpiError *error, void *oracleValue)
-{
-    dpiIntervalDS *interval = &data->asIntervalDS;
-
-    return dpiOci__intervalGetDaySecond(env->handle, &interval->days,
-            &interval->hours, &interval->minutes, &interval->seconds,
-            &interval->fseconds, oracleValue, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__fromOracleIntervalYM() [INTERNAL]
-//   Populate the data from an OCIInterval structure (years/months).
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__fromOracleIntervalYM(dpiDataBuffer *data, dpiEnv *env,
-        dpiError *error, void *oracleValue)
-{
-    dpiIntervalYM *interval = &data->asIntervalYM;
-
-    return dpiOci__intervalGetYearMonth(env->handle, &interval->years,
-            &interval->months, oracleValue, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__fromOracleNumberAsDouble() [INTERNAL]
-//   Populate the data from an OCINumber structure as a double.
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__fromOracleNumberAsDouble(dpiDataBuffer *data,
-        dpiError *error, void *oracleValue)
-{
-    return dpiOci__numberToReal(&data->asDouble, oracleValue, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__fromOracleNumberAsInteger() [INTERNAL]
-//   Populate the data from an OCINumber structure as an integer.
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__fromOracleNumberAsInteger(dpiDataBuffer *data,
-        dpiError *error, void *oracleValue)
-{
-    return dpiOci__numberToInt(oracleValue, &data->asInt64, sizeof(int64_t),
-            DPI_OCI_NUMBER_SIGNED, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__fromOracleNumberAsUnsignedInteger() [INTERNAL]
-//   Populate the data from an OCINumber structure as an unsigned integer.
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__fromOracleNumberAsUnsignedInteger(dpiDataBuffer *data,
-        dpiError *error, void *oracleValue)
-{
-    return dpiOci__numberToInt(oracleValue, &data->asUint64, sizeof(uint64_t),
-            DPI_OCI_NUMBER_UNSIGNED, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__fromOracleNumberAsText() [INTERNAL]
-//   Populate the data from an OCINumber structure as text.
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__fromOracleNumberAsText(dpiDataBuffer *data, dpiEnv *env,
-        dpiError *error, void *oracleValue)
-{
-    uint8_t *target, numDigits, digits[DPI_NUMBER_MAX_DIGITS];
-    int16_t decimalPointIndex, i;
-    uint16_t *targetUtf16;
-    uint32_t numBytes;
-    dpiBytes *bytes;
-    int isNegative;
-
-    // parse the OCINumber structure
-    if (dpiUtils__parseOracleNumber(oracleValue, &isNegative,
-            &decimalPointIndex, &numDigits, digits, error) < 0)
-        return DPI_FAILURE;
-
-    // calculate the number of bytes that will be required for the string
-    numBytes = numDigits;
-    if (isNegative)
-        numBytes++;
-    if (decimalPointIndex <= 0)
-        numBytes += -decimalPointIndex + 2;
-    else if (decimalPointIndex < numDigits)
-        numBytes++;
-    else if (decimalPointIndex > numDigits)
-        numBytes += decimalPointIndex - numDigits;
-    if (env->charsetId == DPI_CHARSET_ID_UTF16)
-        numBytes *= 2;
-
-    // verify that the provided buffer is large enough
-    bytes = &data->asBytes;
-    if (numBytes > bytes->length)
-        return dpiError__set(error, "check number to text size",
-                DPI_ERR_BUFFER_SIZE_TOO_SMALL, bytes->length);
-    bytes->length = numBytes;
-
-    // UTF-16 must be handled differently; the platform endianness is used in
-    // order to be compatible with OCI which has this restriction
-    if (env->charsetId == DPI_CHARSET_ID_UTF16) {
-        targetUtf16 = (uint16_t*) bytes->ptr;
-
-        // if negative, include the sign
-        if (isNegative)
-            *targetUtf16++ = '-';
-
-        // if the decimal point index is 0 or less, add the decimal point and
-        // any leading zeroes that are needed
-        if (decimalPointIndex <= 0) {
-            *targetUtf16++ = '0';
-            *targetUtf16++ = '.';
-            for (; decimalPointIndex < 0; decimalPointIndex++)
-                *targetUtf16++ = '0';
-        }
-
-        // add each of the digits
-        for (i = 0; i < numDigits; i++) {
-            if (i > 0 && i == decimalPointIndex)
-                *targetUtf16++ = '.';
-            *targetUtf16++ = '0' + digits[i];
-        }
-
-        // if the decimal point index exceeds the number of digits, add any
-        // trailing zeroes that are needed
-        if (decimalPointIndex > numDigits) {
-            for (i = numDigits; i < decimalPointIndex; i++)
-                *targetUtf16++ = '0';
-        }
-
-    // the following should be the same logic as the section above for UTF-16,
-    // simply with single byte encodings instead
-    } else {
-        target = (uint8_t*) bytes->ptr;
-
-        // if negative, include the sign
-        if (isNegative)
-            *target++ = '-';
-
-        // if the decimal point index is 0 or less, add the decimal point and
-        // any leading zeroes that are needed
-        if (decimalPointIndex <= 0) {
-            *target++ = '0';
-            *target++ = '.';
-            for (; decimalPointIndex < 0; decimalPointIndex++)
-                *target++ = '0';
-        }
-
-        // add each of the digits
-        for (i = 0; i < numDigits; i++) {
-            if (i > 0 && i == decimalPointIndex)
-                *target++ = '.';
-            *target++ = '0' + digits[i];
-        }
-
-        // if the decimal point index exceeds the number of digits, add any
-        // trailing zeroes that are needed
-        if (decimalPointIndex > numDigits) {
-            for (i = numDigits; i < decimalPointIndex; i++)
-                *target++ = '0';
-        }
-
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__fromOracleTimestamp() [INTERNAL]
-//   Populate the data from an OCIDateTime structure.
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__fromOracleTimestamp(dpiDataBuffer *data, dpiEnv *env,
-        dpiError *error, void *oracleValue, int withTZ)
-{
-    dpiTimestamp *timestamp = &data->asTimestamp;
-
-    if (dpiOci__dateTimeGetDate(env->handle, oracleValue, &timestamp->year,
-            &timestamp->month, &timestamp->day, error) < 0)
-        return DPI_FAILURE;
-    if (dpiOci__dateTimeGetTime(env->handle, oracleValue, &timestamp->hour,
-            &timestamp->minute, &timestamp->second, &timestamp->fsecond,
-            error) < 0)
-        return DPI_FAILURE;
-    if (withTZ) {
-        if (dpiOci__dateTimeGetTimeZoneOffset(env->handle, oracleValue,
-                &timestamp->tzHourOffset, &timestamp->tzMinuteOffset,
-                error) < 0)
-            return DPI_FAILURE;
-    } else {
-        timestamp->tzHourOffset = 0;
-        timestamp->tzMinuteOffset = 0;
-    }
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__fromOracleTimestampAsDouble() [INTERNAL]
-//   Populate the data from an OCIDateTime structure as a double value (number
-// of milliseconds since January 1, 1970).
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__fromOracleTimestampAsDouble(dpiDataBuffer *data,
-        uint32_t dataType, dpiEnv *env, dpiError *error, void *oracleValue)
-{
-    int32_t day, hour, minute, second, fsecond;
-    void *interval, *baseDate;
-    int status;
-
-    // determine the base date to use for the given data type
-    if (dpiEnv__getBaseDate(env, dataType, &baseDate, error) < 0)
-        return DPI_FAILURE;
-
-    // allocate interval to use in calculation
-    if (dpiOci__descriptorAlloc(env->handle, &interval,
-            DPI_OCI_DTYPE_INTERVAL_DS, "alloc interval", error) < 0)
-        return DPI_FAILURE;
-
-    // subtract dates to determine interval between date and base date
-    if (dpiOci__dateTimeSubtract(env->handle, oracleValue, baseDate, interval,
-            error) < 0) {
-        dpiOci__descriptorFree(interval, DPI_OCI_DTYPE_INTERVAL_DS);
-        return DPI_FAILURE;
-    }
-
-    // get the days, hours, minutes and seconds from the interval
-    status = dpiOci__intervalGetDaySecond(env->handle, &day, &hour, &minute,
-            &second, &fsecond, interval, error);
-    dpiOci__descriptorFree(interval, DPI_OCI_DTYPE_INTERVAL_DS);
-    if (status < 0)
-        return DPI_FAILURE;
-
-    // calculate milliseconds since January 1, 1970
-    data->asDouble = ((double) day) * DPI_MS_DAY + hour * DPI_MS_HOUR +
-            minute * DPI_MS_MINUTE + second * DPI_MS_SECOND +
-            fsecond / DPI_MS_FSECOND;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__toOracleDate() [INTERNAL]
-//   Populate the data in an dpiOciDate structure.
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__toOracleDate(dpiDataBuffer *data, dpiOciDate *oracleValue)
-{
-    dpiTimestamp *timestamp = &data->asTimestamp;
-
-    oracleValue->year = timestamp->year;
-    oracleValue->month = timestamp->month;
-    oracleValue->day = timestamp->day;
-    oracleValue->hour = timestamp->hour;
-    oracleValue->minute = timestamp->minute;
-    oracleValue->second = timestamp->second;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__toOracleDateFromDouble() [INTERNAL]
-//   Populate the data in an dpiOciDate structure given a double (number of
-// milliseconds since January 1, 1970).
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__toOracleDateFromDouble(dpiDataBuffer *data, dpiEnv *env,
-        dpiError *error, dpiOciDate *oracleValue)
-{
-    uint32_t fsecond;
-    void *timestamp;
-
-    // allocate a descriptor to acquire a timestamp
-    if (dpiOci__descriptorAlloc(env->handle, &timestamp,
-            DPI_OCI_DTYPE_TIMESTAMP, "alloc timestamp", error) < 0)
-        return DPI_FAILURE;
-    if (dpiDataBuffer__toOracleTimestampFromDouble(data,
-            DPI_ORACLE_TYPE_TIMESTAMP, env, error, timestamp) < 0) {
-        dpiOci__descriptorFree(timestamp, DPI_OCI_DTYPE_TIMESTAMP);
-        return DPI_FAILURE;
-    }
-
-    // populate date structure
-    if (dpiOci__dateTimeGetDate(env->handle, timestamp, &oracleValue->year,
-            &oracleValue->month, &oracleValue->day, error) < 0) {
-        dpiOci__descriptorFree(timestamp, DPI_OCI_DTYPE_TIMESTAMP);
-        return DPI_FAILURE;
-    }
-    if (dpiOci__dateTimeGetTime(env->handle, timestamp, &oracleValue->hour,
-            &oracleValue->minute, &oracleValue->second, &fsecond, error) < 0) {
-        dpiOci__descriptorFree(timestamp, DPI_OCI_DTYPE_TIMESTAMP);
-        return DPI_FAILURE;
-    }
-
-    dpiOci__descriptorFree(timestamp, DPI_OCI_DTYPE_TIMESTAMP);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__toOracleIntervalDS() [INTERNAL]
-//   Populate the data in an OCIInterval structure (days/seconds).
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__toOracleIntervalDS(dpiDataBuffer *data, dpiEnv *env,
-        dpiError *error, void *oracleValue)
-{
-    dpiIntervalDS *interval = &data->asIntervalDS;
-
-    return dpiOci__intervalSetDaySecond(env->handle, interval->days,
-            interval->hours, interval->minutes, interval->seconds,
-            interval->fseconds, oracleValue, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__toOracleIntervalYM() [INTERNAL]
-//   Populate the data in an OCIInterval structure (years/months).
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__toOracleIntervalYM(dpiDataBuffer *data, dpiEnv *env,
-        dpiError *error, void *oracleValue)
-{
-    dpiIntervalYM *interval = &data->asIntervalYM;
-
-    return dpiOci__intervalSetYearMonth(env->handle, interval->years,
-            interval->months, oracleValue, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__toOracleNumberFromDouble() [INTERNAL]
-//   Populate the data in an OCINumber structure from a double.
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__toOracleNumberFromDouble(dpiDataBuffer *data,
-        dpiError *error, void *oracleValue)
-{
-    if (isnan(data->asDouble))
-        return dpiError__set(error, "convert double to Oracle number",
-                DPI_ERR_NAN);
-    return dpiOci__numberFromReal(data->asDouble, oracleValue, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__toOracleNumberFromInteger() [INTERNAL]
-//   Populate the data in an OCINumber structure from an integer.
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__toOracleNumberFromInteger(dpiDataBuffer *data,
-        dpiError *error, void *oracleValue)
-{
-    return dpiOci__numberFromInt(&data->asInt64, sizeof(int64_t),
-            DPI_OCI_NUMBER_SIGNED, oracleValue, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__toOracleNumberFromText() [INTERNAL]
-//   Populate the data in an OCINumber structure from text.
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__toOracleNumberFromText(dpiDataBuffer *data, dpiEnv *env,
-        dpiError *error, void *oracleValue)
-{
-    uint8_t numDigits, digits[DPI_NUMBER_AS_TEXT_CHARS], *source, *target, i;
-    int isNegative, prependZero, appendSentinel;
-    dpiBytes *value = &data->asBytes;
-    int16_t decimalPointIndex;
-    uint8_t byte, numPairs;
-    int8_t ociExponent;
-
-    // parse the string into its constituent components
-    if (dpiUtils__parseNumberString(value->ptr, value->length, env->charsetId,
-            &isNegative, &decimalPointIndex, &numDigits, digits, error) < 0)
-        return DPI_FAILURE;
-
-    // if the exponent is odd, prepend a zero
-    prependZero = (decimalPointIndex > 0 && decimalPointIndex % 2 == 1) ||
-            (decimalPointIndex < 0 && decimalPointIndex % 2 == -1);
-    if (prependZero && numDigits != 0) {
-        digits[numDigits++] = 0;
-        decimalPointIndex++;
-    }
-
-    // determine the number of digit pairs; if the number of digits is odd,
-    // append a zero to make the number of digits even
-    if (numDigits % 2 == 1)
-        digits[numDigits++] = 0;
-    numPairs = numDigits / 2;
-
-    // append a sentinel 102 byte for negative numbers if there is room
-    appendSentinel = (isNegative && numDigits > 0 &&
-            numDigits < DPI_NUMBER_MAX_DIGITS);
-
-    // initialize the OCINumber value
-    // the length is the number of pairs, plus one for the exponent
-    // include an extra byte for the sentinel if applicable
-    target = (uint8_t*) oracleValue;
-    *target++ = (uint8_t) (numPairs + 1 + appendSentinel);
-
-    // if the number of digits is zero, the value is itself zero since all
-    // leading and trailing zeroes are removed from the digits string; the OCI
-    // value for zero is a special case
-    if (numDigits == 0) {
-        *target = 128;
-        return DPI_SUCCESS;
-    }
-
-    // calculate the exponent
-    ociExponent = (int8_t) ((decimalPointIndex - 2) / 2 + 193);
-    if (isNegative)
-        ociExponent = ~ociExponent;
-    *target++ = (uint8_t) ociExponent;
-
-    // calculate the mantissa bytes
-    source = digits;
-    for (i = 0; i < numPairs; i++) {
-        if (i == 0 && prependZero)
-            byte = *source++;
-        else {
-            byte = *source++ * 10;
-            byte += *source++;
-        }
-        if (isNegative)
-            byte = 101 - byte;
-        else byte++;
-        *target++ = byte;
-    }
-
-    // append 102 byte for negative numbers if the number of digits is less
-    // than the maximum allowable
-    if (appendSentinel)
-        *target = 102;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__toOracleNumberFromUnsignedInteger() [INTERNAL]
-//   Populate the data in an OCINumber structure from an integer.
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__toOracleNumberFromUnsignedInteger(dpiDataBuffer *data,
-        dpiError *error, void *oracleValue)
-{
-    return dpiOci__numberFromInt(&data->asUint64, sizeof(uint64_t),
-            DPI_OCI_NUMBER_UNSIGNED, oracleValue, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__toOracleTimestamp() [INTERNAL]
-//   Populate the data in an OCIDateTime structure.
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__toOracleTimestamp(dpiDataBuffer *data, dpiEnv *env,
-        dpiError *error, void *oracleValue, int withTZ)
-{
-    dpiTimestamp *timestamp = &data->asTimestamp;
-    char tzOffsetBuffer[10], *tzOffset = NULL;
-    size_t tzOffsetLength = 0;
-    char sign;
-
-    if (withTZ) {
-        sign = (timestamp->tzHourOffset < 0 || timestamp->tzMinuteOffset < 0) ?
-                '-' : '+';
-        tzOffsetLength = (size_t) sprintf(tzOffsetBuffer, "%c%.2d:%.2d", sign,
-                abs(timestamp->tzHourOffset), abs(timestamp->tzMinuteOffset));
-        tzOffset = tzOffsetBuffer;
-    }
-    return dpiOci__dateTimeConstruct(env->handle, oracleValue, timestamp->year,
-            timestamp->month, timestamp->day, timestamp->hour,
-            timestamp->minute, timestamp->second, timestamp->fsecond, tzOffset,
-            tzOffsetLength, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDataBuffer__toOracleTimestampFromDouble() [INTERNAL]
-//   Populate the data in an OCIDateTime structure, given the number of
-// milliseconds since January 1, 1970.
-//-----------------------------------------------------------------------------
-int dpiDataBuffer__toOracleTimestampFromDouble(dpiDataBuffer *data,
-        uint32_t dataType, dpiEnv *env, dpiError *error, void *oracleValue)
-{
-    int32_t day, hour, minute, second, fsecond;
-    void *interval, *baseDate;
-    int status;
-    double ms;
-
-    // determine the base date to use for the given data type
-    if (dpiEnv__getBaseDate(env, dataType, &baseDate, error) < 0)
-        return DPI_FAILURE;
-
-    // allocate interval to use in calculation
-    if (dpiOci__descriptorAlloc(env->handle, &interval,
-            DPI_OCI_DTYPE_INTERVAL_DS, "alloc interval", error) < 0)
-        return DPI_FAILURE;
-
-    // determine the interval
-    ms = data->asDouble;
-    day = (int32_t) (ms / DPI_MS_DAY);
-    ms = ms - ((double) day) * DPI_MS_DAY;
-    hour = (int32_t) (ms / DPI_MS_HOUR);
-    ms = ms - (hour * DPI_MS_HOUR);
-    minute = (int32_t) (ms / DPI_MS_MINUTE);
-    ms = ms - (minute * DPI_MS_MINUTE);
-    second = (int32_t) (ms / DPI_MS_SECOND);
-    ms = ms - (second * DPI_MS_SECOND);
-    fsecond = (int32_t)(ms * DPI_MS_FSECOND);
-    if (dpiOci__intervalSetDaySecond(env->handle, day, hour, minute, second,
-            fsecond, interval, error) < 0) {
-        dpiOci__descriptorFree(interval, DPI_OCI_DTYPE_INTERVAL_DS);
-        return DPI_FAILURE;
-    }
-
-    // add the interval to the base date
-    status = dpiOci__dateTimeIntervalAdd(env->handle, baseDate, interval,
-            oracleValue, error);
-    dpiOci__descriptorFree(interval, DPI_OCI_DTYPE_INTERVAL_DS);
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getBool() [PUBLIC]
-//   Return the boolean portion of the data.
-//-----------------------------------------------------------------------------
-int dpiData_getBool(dpiData *data)
-{
-    return data->value.asBoolean;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getBytes() [PUBLIC]
-//   Return the bytes portion of the data.
-//-----------------------------------------------------------------------------
-dpiBytes *dpiData_getBytes(dpiData *data)
-{
-    return &data->value.asBytes;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getDouble() [PUBLIC]
-//   Return the double portion of the data.
-//-----------------------------------------------------------------------------
-double dpiData_getDouble(dpiData *data)
-{
-    return data->value.asDouble;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getFloat() [PUBLIC]
-//   Return the float portion of the data.
-//-----------------------------------------------------------------------------
-float dpiData_getFloat(dpiData *data)
-{
-    return data->value.asFloat;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getInt64() [PUBLIC]
-//   Return the integer portion of the data.
-//-----------------------------------------------------------------------------
-int64_t dpiData_getInt64(dpiData *data)
-{
-    return data->value.asInt64;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getIntervalDS() [PUBLIC]
-//   Return the interval (days/seconds) portion of the data.
-//-----------------------------------------------------------------------------
-dpiIntervalDS *dpiData_getIntervalDS(dpiData *data)
-{
-    return &data->value.asIntervalDS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getIntervalYM() [PUBLIC]
-//   Return the interval (years/months) portion of the data.
-//-----------------------------------------------------------------------------
-dpiIntervalYM *dpiData_getIntervalYM(dpiData *data)
-{
-    return &data->value.asIntervalYM;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getIsNull() [PUBLIC]
-//   Return a boolean indicating if the value is null or not.
-//-----------------------------------------------------------------------------
-int dpiData_getIsNull(dpiData *data)
-{
-    return data->isNull;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getLOB() [PUBLIC]
-//   Return the LOB portion of the data.
-//-----------------------------------------------------------------------------
-dpiLob *dpiData_getLOB(dpiData *data)
-{
-    return data->value.asLOB;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getJson() [PUBLIC]
-//   Return the JSON portion of the data.
-//-----------------------------------------------------------------------------
-dpiJson *dpiData_getJson(dpiData *data)
-{
-    return data->value.asJson;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getJsonArray() [PUBLIC]
-//   Return the JSON Array portion of the data.
-//-----------------------------------------------------------------------------
-dpiJsonArray *dpiData_getJsonArray(dpiData *data)
-{
-    return &data->value.asJsonArray;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getJsonObject() [PUBLIC]
-//   Return the JSON Object portion of the data.
-//-----------------------------------------------------------------------------
-dpiJsonObject *dpiData_getJsonObject(dpiData *data)
-{
-    return &data->value.asJsonObject;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getObject() [PUBLIC]
-//   Return the object portion of the data.
-//-----------------------------------------------------------------------------
-dpiObject *dpiData_getObject(dpiData *data)
-{
-    return data->value.asObject;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getStmt() [PUBLIC]
-//   Return the statement portion of the data.
-//-----------------------------------------------------------------------------
-dpiStmt *dpiData_getStmt(dpiData *data)
-{
-    return data->value.asStmt;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getTimestamp() [PUBLIC]
-//   Return the timestamp portion of the data.
-//-----------------------------------------------------------------------------
-dpiTimestamp *dpiData_getTimestamp(dpiData *data)
-{
-    return &data->value.asTimestamp;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_getUint64() [PUBLIC]
-//   Return the unsigned integer portion of the data.
-//-----------------------------------------------------------------------------
-uint64_t dpiData_getUint64(dpiData *data)
-{
-    return data->value.asUint64;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_setBool() [PUBLIC]
-//   Set the boolean portion of the data.
-//-----------------------------------------------------------------------------
-void dpiData_setBool(dpiData *data, int value)
-{
-    data->isNull = 0;
-    data->value.asBoolean = value;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_setBytes() [PUBLIC]
-//   Set the bytes portion of the data.
-//-----------------------------------------------------------------------------
-void dpiData_setBytes(dpiData *data, char *ptr, uint32_t length)
-{
-    data->isNull = 0;
-    data->value.asBytes.ptr = ptr;
-    data->value.asBytes.length = length;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_setDouble() [PUBLIC]
-//   Set the double portion of the data.
-//-----------------------------------------------------------------------------
-void dpiData_setDouble(dpiData *data, double value)
-{
-    data->isNull = 0;
-    data->value.asDouble = value;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_setFloat() [PUBLIC]
-//   Set the float portion of the data.
-//-----------------------------------------------------------------------------
-void dpiData_setFloat(dpiData *data, float value)
-{
-    data->isNull = 0;
-    data->value.asFloat = value;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_setInt64() [PUBLIC]
-//   Set the integer portion of the data.
-//-----------------------------------------------------------------------------
-void dpiData_setInt64(dpiData *data, int64_t value)
-{
-    data->isNull = 0;
-    data->value.asInt64 = value;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_setIntervalDS() [PUBLIC]
-//   Set the interval (days/seconds) portion of the data.
-//-----------------------------------------------------------------------------
-void dpiData_setIntervalDS(dpiData *data, int32_t days, int32_t hours,
-        int32_t minutes, int32_t seconds, int32_t fseconds)
-{
-    dpiIntervalDS *interval = &data->value.asIntervalDS;
-
-    data->isNull = 0;
-    interval->days = days;
-    interval->hours = hours;
-    interval->minutes = minutes;
-    interval->seconds = seconds;
-    interval->fseconds = fseconds;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_setIntervalYM() [PUBLIC]
-//   Set the interval (years/months) portion of the data.
-//-----------------------------------------------------------------------------
-void dpiData_setIntervalYM(dpiData *data, int32_t years, int32_t months)
-{
-    dpiIntervalYM *interval = &data->value.asIntervalYM;
-
-    data->isNull = 0;
-    interval->years = years;
-    interval->months = months;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_setLOB() [PUBLIC]
-//   Set the LOB portion of the data.
-//-----------------------------------------------------------------------------
-void dpiData_setLOB(dpiData *data, dpiLob *lob)
-{
-    data->isNull = 0;
-    data->value.asLOB = lob;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_setNull() [PUBLIC]
-//   Set the data to be treated as a null value.
-//-----------------------------------------------------------------------------
-void dpiData_setNull(dpiData *data)
-{
-    data->isNull = 1;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_setObject() [PUBLIC]
-//   Set the object portion of the data.
-//-----------------------------------------------------------------------------
-void dpiData_setObject(dpiData *data, dpiObject *obj)
-{
-    data->isNull = 0;
-    data->value.asObject = obj;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_setStmt() [PUBLIC]
-//   Set the statement portion of the data.
-//-----------------------------------------------------------------------------
-void dpiData_setStmt(dpiData *data, dpiStmt *obj)
-{
-    data->isNull = 0;
-    data->value.asStmt = obj;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_setTimestamp() [PUBLIC]
-//   Set the timestamp portion of the data.
-//-----------------------------------------------------------------------------
-void dpiData_setTimestamp(dpiData *data, int16_t year, uint8_t month,
-        uint8_t day, uint8_t hour, uint8_t minute, uint8_t second,
-        uint32_t fsecond, int8_t tzHourOffset, int8_t tzMinuteOffset)
-{
-    dpiTimestamp *timestamp = &data->value.asTimestamp;
-
-    data->isNull = 0;
-    timestamp->year = year;
-    timestamp->month = month;
-    timestamp->day = day;
-    timestamp->hour = hour;
-    timestamp->minute = minute;
-    timestamp->second = second;
-    timestamp->fsecond = fsecond;
-    timestamp->tzHourOffset = tzHourOffset;
-    timestamp->tzMinuteOffset = tzMinuteOffset;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiData_setUint64() [PUBLIC]
-//   Set the unsigned integer portion of the data.
-//-----------------------------------------------------------------------------
-void dpiData_setUint64(dpiData *data, uint64_t value)
-{
-    data->isNull = 0;
-    data->value.asUint64 = value;
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiData.h ./odpi/src/dpiData.h
--- patched-godror/odpi/src/dpiData.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiData.h	2024-05-14 14:55:13
@@ -0,0 +1,936 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiData.c
+//   Implementation of transformation routines.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+// constants used for converting timestamps to/from an interval
+#define DPI_MS_DAY        86400000  // 24 * 60 * 60 * 1000
+#define DPI_MS_HOUR       3600000   // 60 * 60 * 1000
+#define DPI_MS_MINUTE     60000     // 60 * 1000
+#define DPI_MS_SECOND     1000      // ms per sec
+#define DPI_MS_FSECOND    1000000   // 1000 * 1000
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__fromOracleDate() [INTERNAL]
+//   Populate the data from an dpiOciDate structure.
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__fromOracleDate(dpiDataBuffer *data,
+        dpiOciDate *oracleValue)
+{
+    dpiTimestamp *timestamp = &data->asTimestamp;
+
+    timestamp->year = oracleValue->year;
+    timestamp->month = oracleValue->month;
+    timestamp->day = oracleValue->day;
+    timestamp->hour = oracleValue->hour;
+    timestamp->minute = oracleValue->minute;
+    timestamp->second = oracleValue->second;
+    timestamp->fsecond = 0;
+    timestamp->tzHourOffset = 0;
+    timestamp->tzMinuteOffset = 0;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__fromOracleDateAsDouble() [INTERNAL]
+//   Populate the data from an dpiOciDate structure as a double value (number
+// of milliseconds since January 1, 1970).
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__fromOracleDateAsDouble(dpiDataBuffer *data,
+        dpiEnv *env, dpiError *error, dpiOciDate *oracleValue)
+{
+    void *timestamp;
+    int status;
+
+    // allocate and populate a timestamp with the value of the date
+    if (dpiOci__descriptorAlloc(env->handle, &timestamp,
+            DPI_OCI_DTYPE_TIMESTAMP, "alloc timestamp", error) < 0)
+        return DPI_FAILURE;
+    if (dpiOci__dateTimeConstruct(env->handle, timestamp, oracleValue->year,
+            oracleValue->month, oracleValue->day, oracleValue->hour,
+            oracleValue->minute, oracleValue->second, 0, NULL, 0, error) < 0) {
+        dpiOci__descriptorFree(timestamp, DPI_OCI_DTYPE_TIMESTAMP);
+        return DPI_FAILURE;
+    }
+
+    // now calculate the number of milliseconds since January 1, 1970
+    status = dpiDataBuffer__fromOracleTimestampAsDouble(data,
+            DPI_ORACLE_TYPE_TIMESTAMP, env, error, timestamp);
+    dpiOci__descriptorFree(timestamp, DPI_OCI_DTYPE_TIMESTAMP);
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__fromOracleIntervalDS() [INTERNAL]
+//   Populate the data from an OCIInterval structure (days/seconds).
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__fromOracleIntervalDS(dpiDataBuffer *data, dpiEnv *env,
+        dpiError *error, void *oracleValue)
+{
+    dpiIntervalDS *interval = &data->asIntervalDS;
+
+    return dpiOci__intervalGetDaySecond(env->handle, &interval->days,
+            &interval->hours, &interval->minutes, &interval->seconds,
+            &interval->fseconds, oracleValue, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__fromOracleIntervalYM() [INTERNAL]
+//   Populate the data from an OCIInterval structure (years/months).
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__fromOracleIntervalYM(dpiDataBuffer *data, dpiEnv *env,
+        dpiError *error, void *oracleValue)
+{
+    dpiIntervalYM *interval = &data->asIntervalYM;
+
+    return dpiOci__intervalGetYearMonth(env->handle, &interval->years,
+            &interval->months, oracleValue, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__fromOracleNumberAsDouble() [INTERNAL]
+//   Populate the data from an OCINumber structure as a double.
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__fromOracleNumberAsDouble(dpiDataBuffer *data,
+        dpiError *error, void *oracleValue)
+{
+    return dpiOci__numberToReal(&data->asDouble, oracleValue, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__fromOracleNumberAsInteger() [INTERNAL]
+//   Populate the data from an OCINumber structure as an integer.
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__fromOracleNumberAsInteger(dpiDataBuffer *data,
+        dpiError *error, void *oracleValue)
+{
+    return dpiOci__numberToInt(oracleValue, &data->asInt64, sizeof(int64_t),
+            DPI_OCI_NUMBER_SIGNED, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__fromOracleNumberAsUnsignedInteger() [INTERNAL]
+//   Populate the data from an OCINumber structure as an unsigned integer.
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__fromOracleNumberAsUnsignedInteger(dpiDataBuffer *data,
+        dpiError *error, void *oracleValue)
+{
+    return dpiOci__numberToInt(oracleValue, &data->asUint64, sizeof(uint64_t),
+            DPI_OCI_NUMBER_UNSIGNED, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__fromOracleNumberAsText() [INTERNAL]
+//   Populate the data from an OCINumber structure as text.
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__fromOracleNumberAsText(dpiDataBuffer *data, dpiEnv *env,
+        dpiError *error, void *oracleValue)
+{
+    uint8_t *target, numDigits, digits[DPI_NUMBER_MAX_DIGITS];
+    int16_t decimalPointIndex, i;
+    uint16_t *targetUtf16;
+    uint32_t numBytes;
+    dpiBytes *bytes;
+    int isNegative;
+
+    // parse the OCINumber structure
+    if (dpiUtils__parseOracleNumber(oracleValue, &isNegative,
+            &decimalPointIndex, &numDigits, digits, error) < 0)
+        return DPI_FAILURE;
+
+    // calculate the number of bytes that will be required for the string
+    numBytes = numDigits;
+    if (isNegative)
+        numBytes++;
+    if (decimalPointIndex <= 0)
+        numBytes += -decimalPointIndex + 2;
+    else if (decimalPointIndex < numDigits)
+        numBytes++;
+    else if (decimalPointIndex > numDigits)
+        numBytes += decimalPointIndex - numDigits;
+    if (env->charsetId == DPI_CHARSET_ID_UTF16)
+        numBytes *= 2;
+
+    // verify that the provided buffer is large enough
+    bytes = &data->asBytes;
+    if (numBytes > bytes->length)
+        return dpiError__set(error, "check number to text size",
+                DPI_ERR_BUFFER_SIZE_TOO_SMALL, bytes->length);
+    bytes->length = numBytes;
+
+    // UTF-16 must be handled differently; the platform endianness is used in
+    // order to be compatible with OCI which has this restriction
+    if (env->charsetId == DPI_CHARSET_ID_UTF16) {
+        targetUtf16 = (uint16_t*) bytes->ptr;
+
+        // if negative, include the sign
+        if (isNegative)
+            *targetUtf16++ = '-';
+
+        // if the decimal point index is 0 or less, add the decimal point and
+        // any leading zeroes that are needed
+        if (decimalPointIndex <= 0) {
+            *targetUtf16++ = '0';
+            *targetUtf16++ = '.';
+            for (; decimalPointIndex < 0; decimalPointIndex++)
+                *targetUtf16++ = '0';
+        }
+
+        // add each of the digits
+        for (i = 0; i < numDigits; i++) {
+            if (i > 0 && i == decimalPointIndex)
+                *targetUtf16++ = '.';
+            *targetUtf16++ = '0' + digits[i];
+        }
+
+        // if the decimal point index exceeds the number of digits, add any
+        // trailing zeroes that are needed
+        if (decimalPointIndex > numDigits) {
+            for (i = numDigits; i < decimalPointIndex; i++)
+                *targetUtf16++ = '0';
+        }
+
+    // the following should be the same logic as the section above for UTF-16,
+    // simply with single byte encodings instead
+    } else {
+        target = (uint8_t*) bytes->ptr;
+
+        // if negative, include the sign
+        if (isNegative)
+            *target++ = '-';
+
+        // if the decimal point index is 0 or less, add the decimal point and
+        // any leading zeroes that are needed
+        if (decimalPointIndex <= 0) {
+            *target++ = '0';
+            *target++ = '.';
+            for (; decimalPointIndex < 0; decimalPointIndex++)
+                *target++ = '0';
+        }
+
+        // add each of the digits
+        for (i = 0; i < numDigits; i++) {
+            if (i > 0 && i == decimalPointIndex)
+                *target++ = '.';
+            *target++ = '0' + digits[i];
+        }
+
+        // if the decimal point index exceeds the number of digits, add any
+        // trailing zeroes that are needed
+        if (decimalPointIndex > numDigits) {
+            for (i = numDigits; i < decimalPointIndex; i++)
+                *target++ = '0';
+        }
+
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__fromOracleTimestamp() [INTERNAL]
+//   Populate the data from an OCIDateTime structure.
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__fromOracleTimestamp(dpiDataBuffer *data, dpiEnv *env,
+        dpiError *error, void *oracleValue, int withTZ)
+{
+    dpiTimestamp *timestamp = &data->asTimestamp;
+
+    if (dpiOci__dateTimeGetDate(env->handle, oracleValue, &timestamp->year,
+            &timestamp->month, &timestamp->day, error) < 0)
+        return DPI_FAILURE;
+    if (dpiOci__dateTimeGetTime(env->handle, oracleValue, &timestamp->hour,
+            &timestamp->minute, &timestamp->second, &timestamp->fsecond,
+            error) < 0)
+        return DPI_FAILURE;
+    if (withTZ) {
+        if (dpiOci__dateTimeGetTimeZoneOffset(env->handle, oracleValue,
+                &timestamp->tzHourOffset, &timestamp->tzMinuteOffset,
+                error) < 0)
+            return DPI_FAILURE;
+    } else {
+        timestamp->tzHourOffset = 0;
+        timestamp->tzMinuteOffset = 0;
+    }
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__fromOracleTimestampAsDouble() [INTERNAL]
+//   Populate the data from an OCIDateTime structure as a double value (number
+// of milliseconds since January 1, 1970).
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__fromOracleTimestampAsDouble(dpiDataBuffer *data,
+        uint32_t dataType, dpiEnv *env, dpiError *error, void *oracleValue)
+{
+    int32_t day, hour, minute, second, fsecond;
+    void *interval, *baseDate;
+    int status;
+
+    // determine the base date to use for the given data type
+    if (dpiEnv__getBaseDate(env, dataType, &baseDate, error) < 0)
+        return DPI_FAILURE;
+
+    // allocate interval to use in calculation
+    if (dpiOci__descriptorAlloc(env->handle, &interval,
+            DPI_OCI_DTYPE_INTERVAL_DS, "alloc interval", error) < 0)
+        return DPI_FAILURE;
+
+    // subtract dates to determine interval between date and base date
+    if (dpiOci__dateTimeSubtract(env->handle, oracleValue, baseDate, interval,
+            error) < 0) {
+        dpiOci__descriptorFree(interval, DPI_OCI_DTYPE_INTERVAL_DS);
+        return DPI_FAILURE;
+    }
+
+    // get the days, hours, minutes and seconds from the interval
+    status = dpiOci__intervalGetDaySecond(env->handle, &day, &hour, &minute,
+            &second, &fsecond, interval, error);
+    dpiOci__descriptorFree(interval, DPI_OCI_DTYPE_INTERVAL_DS);
+    if (status < 0)
+        return DPI_FAILURE;
+
+    // calculate milliseconds since January 1, 1970
+    data->asDouble = ((double) day) * DPI_MS_DAY + hour * DPI_MS_HOUR +
+            minute * DPI_MS_MINUTE + second * DPI_MS_SECOND +
+            fsecond / DPI_MS_FSECOND;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__toOracleDate() [INTERNAL]
+//   Populate the data in an dpiOciDate structure.
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__toOracleDate(dpiDataBuffer *data, dpiOciDate *oracleValue)
+{
+    dpiTimestamp *timestamp = &data->asTimestamp;
+
+    oracleValue->year = timestamp->year;
+    oracleValue->month = timestamp->month;
+    oracleValue->day = timestamp->day;
+    oracleValue->hour = timestamp->hour;
+    oracleValue->minute = timestamp->minute;
+    oracleValue->second = timestamp->second;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__toOracleDateFromDouble() [INTERNAL]
+//   Populate the data in an dpiOciDate structure given a double (number of
+// milliseconds since January 1, 1970).
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__toOracleDateFromDouble(dpiDataBuffer *data, dpiEnv *env,
+        dpiError *error, dpiOciDate *oracleValue)
+{
+    uint32_t fsecond;
+    void *timestamp;
+
+    // allocate a descriptor to acquire a timestamp
+    if (dpiOci__descriptorAlloc(env->handle, &timestamp,
+            DPI_OCI_DTYPE_TIMESTAMP, "alloc timestamp", error) < 0)
+        return DPI_FAILURE;
+    if (dpiDataBuffer__toOracleTimestampFromDouble(data,
+            DPI_ORACLE_TYPE_TIMESTAMP, env, error, timestamp) < 0) {
+        dpiOci__descriptorFree(timestamp, DPI_OCI_DTYPE_TIMESTAMP);
+        return DPI_FAILURE;
+    }
+
+    // populate date structure
+    if (dpiOci__dateTimeGetDate(env->handle, timestamp, &oracleValue->year,
+            &oracleValue->month, &oracleValue->day, error) < 0) {
+        dpiOci__descriptorFree(timestamp, DPI_OCI_DTYPE_TIMESTAMP);
+        return DPI_FAILURE;
+    }
+    if (dpiOci__dateTimeGetTime(env->handle, timestamp, &oracleValue->hour,
+            &oracleValue->minute, &oracleValue->second, &fsecond, error) < 0) {
+        dpiOci__descriptorFree(timestamp, DPI_OCI_DTYPE_TIMESTAMP);
+        return DPI_FAILURE;
+    }
+
+    dpiOci__descriptorFree(timestamp, DPI_OCI_DTYPE_TIMESTAMP);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__toOracleIntervalDS() [INTERNAL]
+//   Populate the data in an OCIInterval structure (days/seconds).
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__toOracleIntervalDS(dpiDataBuffer *data, dpiEnv *env,
+        dpiError *error, void *oracleValue)
+{
+    dpiIntervalDS *interval = &data->asIntervalDS;
+
+    return dpiOci__intervalSetDaySecond(env->handle, interval->days,
+            interval->hours, interval->minutes, interval->seconds,
+            interval->fseconds, oracleValue, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__toOracleIntervalYM() [INTERNAL]
+//   Populate the data in an OCIInterval structure (years/months).
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__toOracleIntervalYM(dpiDataBuffer *data, dpiEnv *env,
+        dpiError *error, void *oracleValue)
+{
+    dpiIntervalYM *interval = &data->asIntervalYM;
+
+    return dpiOci__intervalSetYearMonth(env->handle, interval->years,
+            interval->months, oracleValue, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__toOracleNumberFromDouble() [INTERNAL]
+//   Populate the data in an OCINumber structure from a double.
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__toOracleNumberFromDouble(dpiDataBuffer *data,
+        dpiError *error, void *oracleValue)
+{
+    if (isnan(data->asDouble))
+        return dpiError__set(error, "convert double to Oracle number",
+                DPI_ERR_NAN);
+    return dpiOci__numberFromReal(data->asDouble, oracleValue, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__toOracleNumberFromInteger() [INTERNAL]
+//   Populate the data in an OCINumber structure from an integer.
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__toOracleNumberFromInteger(dpiDataBuffer *data,
+        dpiError *error, void *oracleValue)
+{
+    return dpiOci__numberFromInt(&data->asInt64, sizeof(int64_t),
+            DPI_OCI_NUMBER_SIGNED, oracleValue, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__toOracleNumberFromText() [INTERNAL]
+//   Populate the data in an OCINumber structure from text.
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__toOracleNumberFromText(dpiDataBuffer *data, dpiEnv *env,
+        dpiError *error, void *oracleValue)
+{
+    uint8_t numDigits, digits[DPI_NUMBER_AS_TEXT_CHARS], *source, *target, i;
+    int isNegative, prependZero, appendSentinel;
+    dpiBytes *value = &data->asBytes;
+    int16_t decimalPointIndex;
+    uint8_t byte, numPairs;
+    int8_t ociExponent;
+
+    // parse the string into its constituent components
+    if (dpiUtils__parseNumberString(value->ptr, value->length, env->charsetId,
+            &isNegative, &decimalPointIndex, &numDigits, digits, error) < 0)
+        return DPI_FAILURE;
+
+    // if the exponent is odd, prepend a zero
+    prependZero = (decimalPointIndex > 0 && decimalPointIndex % 2 == 1) ||
+            (decimalPointIndex < 0 && decimalPointIndex % 2 == -1);
+    if (prependZero && numDigits != 0) {
+        digits[numDigits++] = 0;
+        decimalPointIndex++;
+    }
+
+    // determine the number of digit pairs; if the number of digits is odd,
+    // append a zero to make the number of digits even
+    if (numDigits % 2 == 1)
+        digits[numDigits++] = 0;
+    numPairs = numDigits / 2;
+
+    // append a sentinel 102 byte for negative numbers if there is room
+    appendSentinel = (isNegative && numDigits > 0 &&
+            numDigits < DPI_NUMBER_MAX_DIGITS);
+
+    // initialize the OCINumber value
+    // the length is the number of pairs, plus one for the exponent
+    // include an extra byte for the sentinel if applicable
+    target = (uint8_t*) oracleValue;
+    *target++ = (uint8_t) (numPairs + 1 + appendSentinel);
+
+    // if the number of digits is zero, the value is itself zero since all
+    // leading and trailing zeroes are removed from the digits string; the OCI
+    // value for zero is a special case
+    if (numDigits == 0) {
+        *target = 128;
+        return DPI_SUCCESS;
+    }
+
+    // calculate the exponent
+    ociExponent = (int8_t) ((decimalPointIndex - 2) / 2 + 193);
+    if (isNegative)
+        ociExponent = ~ociExponent;
+    *target++ = (uint8_t) ociExponent;
+
+    // calculate the mantissa bytes
+    source = digits;
+    for (i = 0; i < numPairs; i++) {
+        if (i == 0 && prependZero)
+            byte = *source++;
+        else {
+            byte = *source++ * 10;
+            byte += *source++;
+        }
+        if (isNegative)
+            byte = 101 - byte;
+        else byte++;
+        *target++ = byte;
+    }
+
+    // append 102 byte for negative numbers if the number of digits is less
+    // than the maximum allowable
+    if (appendSentinel)
+        *target = 102;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__toOracleNumberFromUnsignedInteger() [INTERNAL]
+//   Populate the data in an OCINumber structure from an integer.
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__toOracleNumberFromUnsignedInteger(dpiDataBuffer *data,
+        dpiError *error, void *oracleValue)
+{
+    return dpiOci__numberFromInt(&data->asUint64, sizeof(uint64_t),
+            DPI_OCI_NUMBER_UNSIGNED, oracleValue, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__toOracleTimestamp() [INTERNAL]
+//   Populate the data in an OCIDateTime structure.
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__toOracleTimestamp(dpiDataBuffer *data, dpiEnv *env,
+        dpiError *error, void *oracleValue, int withTZ)
+{
+    dpiTimestamp *timestamp = &data->asTimestamp;
+    char tzOffsetBuffer[10], *tzOffset = NULL;
+    size_t tzOffsetLength = 0;
+    char sign;
+
+    if (withTZ) {
+        sign = (timestamp->tzHourOffset < 0 || timestamp->tzMinuteOffset < 0) ?
+                '-' : '+';
+        tzOffsetLength = (size_t) sprintf(tzOffsetBuffer, "%c%.2d:%.2d", sign,
+                abs(timestamp->tzHourOffset), abs(timestamp->tzMinuteOffset));
+        tzOffset = tzOffsetBuffer;
+    }
+    return dpiOci__dateTimeConstruct(env->handle, oracleValue, timestamp->year,
+            timestamp->month, timestamp->day, timestamp->hour,
+            timestamp->minute, timestamp->second, timestamp->fsecond, tzOffset,
+            tzOffsetLength, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDataBuffer__toOracleTimestampFromDouble() [INTERNAL]
+//   Populate the data in an OCIDateTime structure, given the number of
+// milliseconds since January 1, 1970.
+//-----------------------------------------------------------------------------
+int dpiDataBuffer__toOracleTimestampFromDouble(dpiDataBuffer *data,
+        uint32_t dataType, dpiEnv *env, dpiError *error, void *oracleValue)
+{
+    int32_t day, hour, minute, second, fsecond;
+    void *interval, *baseDate;
+    int status;
+    double ms;
+
+    // determine the base date to use for the given data type
+    if (dpiEnv__getBaseDate(env, dataType, &baseDate, error) < 0)
+        return DPI_FAILURE;
+
+    // allocate interval to use in calculation
+    if (dpiOci__descriptorAlloc(env->handle, &interval,
+            DPI_OCI_DTYPE_INTERVAL_DS, "alloc interval", error) < 0)
+        return DPI_FAILURE;
+
+    // determine the interval
+    ms = data->asDouble;
+    day = (int32_t) (ms / DPI_MS_DAY);
+    ms = ms - ((double) day) * DPI_MS_DAY;
+    hour = (int32_t) (ms / DPI_MS_HOUR);
+    ms = ms - (hour * DPI_MS_HOUR);
+    minute = (int32_t) (ms / DPI_MS_MINUTE);
+    ms = ms - (minute * DPI_MS_MINUTE);
+    second = (int32_t) (ms / DPI_MS_SECOND);
+    ms = ms - (second * DPI_MS_SECOND);
+    fsecond = (int32_t)(ms * DPI_MS_FSECOND);
+    if (dpiOci__intervalSetDaySecond(env->handle, day, hour, minute, second,
+            fsecond, interval, error) < 0) {
+        dpiOci__descriptorFree(interval, DPI_OCI_DTYPE_INTERVAL_DS);
+        return DPI_FAILURE;
+    }
+
+    // add the interval to the base date
+    status = dpiOci__dateTimeIntervalAdd(env->handle, baseDate, interval,
+            oracleValue, error);
+    dpiOci__descriptorFree(interval, DPI_OCI_DTYPE_INTERVAL_DS);
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getBool() [PUBLIC]
+//   Return the boolean portion of the data.
+//-----------------------------------------------------------------------------
+int dpiData_getBool(dpiData *data)
+{
+    return data->value.asBoolean;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getBytes() [PUBLIC]
+//   Return the bytes portion of the data.
+//-----------------------------------------------------------------------------
+dpiBytes *dpiData_getBytes(dpiData *data)
+{
+    return &data->value.asBytes;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getDouble() [PUBLIC]
+//   Return the double portion of the data.
+//-----------------------------------------------------------------------------
+double dpiData_getDouble(dpiData *data)
+{
+    return data->value.asDouble;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getFloat() [PUBLIC]
+//   Return the float portion of the data.
+//-----------------------------------------------------------------------------
+float dpiData_getFloat(dpiData *data)
+{
+    return data->value.asFloat;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getInt64() [PUBLIC]
+//   Return the integer portion of the data.
+//-----------------------------------------------------------------------------
+int64_t dpiData_getInt64(dpiData *data)
+{
+    return data->value.asInt64;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getIntervalDS() [PUBLIC]
+//   Return the interval (days/seconds) portion of the data.
+//-----------------------------------------------------------------------------
+dpiIntervalDS *dpiData_getIntervalDS(dpiData *data)
+{
+    return &data->value.asIntervalDS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getIntervalYM() [PUBLIC]
+//   Return the interval (years/months) portion of the data.
+//-----------------------------------------------------------------------------
+dpiIntervalYM *dpiData_getIntervalYM(dpiData *data)
+{
+    return &data->value.asIntervalYM;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getIsNull() [PUBLIC]
+//   Return a boolean indicating if the value is null or not.
+//-----------------------------------------------------------------------------
+int dpiData_getIsNull(dpiData *data)
+{
+    return data->isNull;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getLOB() [PUBLIC]
+//   Return the LOB portion of the data.
+//-----------------------------------------------------------------------------
+dpiLob *dpiData_getLOB(dpiData *data)
+{
+    return data->value.asLOB;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getJson() [PUBLIC]
+//   Return the JSON portion of the data.
+//-----------------------------------------------------------------------------
+dpiJson *dpiData_getJson(dpiData *data)
+{
+    return data->value.asJson;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getJsonArray() [PUBLIC]
+//   Return the JSON Array portion of the data.
+//-----------------------------------------------------------------------------
+dpiJsonArray *dpiData_getJsonArray(dpiData *data)
+{
+    return &data->value.asJsonArray;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getJsonObject() [PUBLIC]
+//   Return the JSON Object portion of the data.
+//-----------------------------------------------------------------------------
+dpiJsonObject *dpiData_getJsonObject(dpiData *data)
+{
+    return &data->value.asJsonObject;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getObject() [PUBLIC]
+//   Return the object portion of the data.
+//-----------------------------------------------------------------------------
+dpiObject *dpiData_getObject(dpiData *data)
+{
+    return data->value.asObject;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getStmt() [PUBLIC]
+//   Return the statement portion of the data.
+//-----------------------------------------------------------------------------
+dpiStmt *dpiData_getStmt(dpiData *data)
+{
+    return data->value.asStmt;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getTimestamp() [PUBLIC]
+//   Return the timestamp portion of the data.
+//-----------------------------------------------------------------------------
+dpiTimestamp *dpiData_getTimestamp(dpiData *data)
+{
+    return &data->value.asTimestamp;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_getUint64() [PUBLIC]
+//   Return the unsigned integer portion of the data.
+//-----------------------------------------------------------------------------
+uint64_t dpiData_getUint64(dpiData *data)
+{
+    return data->value.asUint64;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_setBool() [PUBLIC]
+//   Set the boolean portion of the data.
+//-----------------------------------------------------------------------------
+void dpiData_setBool(dpiData *data, int value)
+{
+    data->isNull = 0;
+    data->value.asBoolean = value;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_setBytes() [PUBLIC]
+//   Set the bytes portion of the data.
+//-----------------------------------------------------------------------------
+void dpiData_setBytes(dpiData *data, char *ptr, uint32_t length)
+{
+    data->isNull = 0;
+    data->value.asBytes.ptr = ptr;
+    data->value.asBytes.length = length;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_setDouble() [PUBLIC]
+//   Set the double portion of the data.
+//-----------------------------------------------------------------------------
+void dpiData_setDouble(dpiData *data, double value)
+{
+    data->isNull = 0;
+    data->value.asDouble = value;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_setFloat() [PUBLIC]
+//   Set the float portion of the data.
+//-----------------------------------------------------------------------------
+void dpiData_setFloat(dpiData *data, float value)
+{
+    data->isNull = 0;
+    data->value.asFloat = value;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_setInt64() [PUBLIC]
+//   Set the integer portion of the data.
+//-----------------------------------------------------------------------------
+void dpiData_setInt64(dpiData *data, int64_t value)
+{
+    data->isNull = 0;
+    data->value.asInt64 = value;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_setIntervalDS() [PUBLIC]
+//   Set the interval (days/seconds) portion of the data.
+//-----------------------------------------------------------------------------
+void dpiData_setIntervalDS(dpiData *data, int32_t days, int32_t hours,
+        int32_t minutes, int32_t seconds, int32_t fseconds)
+{
+    dpiIntervalDS *interval = &data->value.asIntervalDS;
+
+    data->isNull = 0;
+    interval->days = days;
+    interval->hours = hours;
+    interval->minutes = minutes;
+    interval->seconds = seconds;
+    interval->fseconds = fseconds;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_setIntervalYM() [PUBLIC]
+//   Set the interval (years/months) portion of the data.
+//-----------------------------------------------------------------------------
+void dpiData_setIntervalYM(dpiData *data, int32_t years, int32_t months)
+{
+    dpiIntervalYM *interval = &data->value.asIntervalYM;
+
+    data->isNull = 0;
+    interval->years = years;
+    interval->months = months;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_setLOB() [PUBLIC]
+//   Set the LOB portion of the data.
+//-----------------------------------------------------------------------------
+void dpiData_setLOB(dpiData *data, dpiLob *lob)
+{
+    data->isNull = 0;
+    data->value.asLOB = lob;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_setNull() [PUBLIC]
+//   Set the data to be treated as a null value.
+//-----------------------------------------------------------------------------
+void dpiData_setNull(dpiData *data)
+{
+    data->isNull = 1;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_setObject() [PUBLIC]
+//   Set the object portion of the data.
+//-----------------------------------------------------------------------------
+void dpiData_setObject(dpiData *data, dpiObject *obj)
+{
+    data->isNull = 0;
+    data->value.asObject = obj;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_setStmt() [PUBLIC]
+//   Set the statement portion of the data.
+//-----------------------------------------------------------------------------
+void dpiData_setStmt(dpiData *data, dpiStmt *obj)
+{
+    data->isNull = 0;
+    data->value.asStmt = obj;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_setTimestamp() [PUBLIC]
+//   Set the timestamp portion of the data.
+//-----------------------------------------------------------------------------
+void dpiData_setTimestamp(dpiData *data, int16_t year, uint8_t month,
+        uint8_t day, uint8_t hour, uint8_t minute, uint8_t second,
+        uint32_t fsecond, int8_t tzHourOffset, int8_t tzMinuteOffset)
+{
+    dpiTimestamp *timestamp = &data->value.asTimestamp;
+
+    data->isNull = 0;
+    timestamp->year = year;
+    timestamp->month = month;
+    timestamp->day = day;
+    timestamp->hour = hour;
+    timestamp->minute = minute;
+    timestamp->second = second;
+    timestamp->fsecond = fsecond;
+    timestamp->tzHourOffset = tzHourOffset;
+    timestamp->tzMinuteOffset = tzMinuteOffset;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiData_setUint64() [PUBLIC]
+//   Set the unsigned integer portion of the data.
+//-----------------------------------------------------------------------------
+void dpiData_setUint64(dpiData *data, uint64_t value)
+{
+    data->isNull = 0;
+    data->value.asUint64 = value;
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiDebug.c ./odpi/src/dpiDebug.c
--- patched-godror/odpi/src/dpiDebug.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiDebug.c	1970-01-01 01:00:00
@@ -1,196 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2017, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiDebug.c
-//   Methods used for debugging ODPI-C.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-#define DPI_DEBUG_THREAD_FORMAT         "%.5" PRIu64
-#define DPI_DEBUG_DATE_FORMAT           "%.4d-%.2d-%.2d"
-#define DPI_DEBUG_TIME_FORMAT           "%.2d:%.2d:%.2d.%.3d"
-
-// debug level (populated by environment variable DPI_DEBUG_LEVEL)
-unsigned long dpiDebugLevel = 0;
-
-// debug prefix format (populated by environment variable DPI_DEBUG_PREFIX)
-static char dpiDebugPrefixFormat[64] = "ODPI [%i] %d %t: ";
-
-// debug file for printing (currently unchangeable)
-static FILE *dpiDebugStream = NULL;
-
-
-//-----------------------------------------------------------------------------
-// dpiDebug__getFormatWithPrefix() [INTERNAL]
-//   Adjust the provided format to include the prefix requested by the user.
-// This method is not permitted to fail, so if there is not enough space, the
-// prefix is truncated as needed -- although this is a very unlikely scenario.
-//-----------------------------------------------------------------------------
-static void dpiDebug__getFormatWithPrefix(const char *format,
-        char *formatWithPrefix, size_t maxFormatWithPrefixSize)
-{
-    char *sourcePtr, *targetPtr;
-    int gotTime, tempSize;
-    uint64_t threadId;
-    size_t size;
-#ifdef _WIN32
-    SYSTEMTIME time;
-#else
-    struct timeval timeOfDay;
-    struct tm time;
-#endif
-
-    gotTime = 0;
-    sourcePtr = dpiDebugPrefixFormat;
-    targetPtr = formatWithPrefix;
-    size = maxFormatWithPrefixSize - strlen(format);
-    while (*sourcePtr && size > 20) {
-
-        // all characters except '%' are copied verbatim to the target
-        if (*sourcePtr != '%') {
-            *targetPtr++ = *sourcePtr++;
-            maxFormatWithPrefixSize--;
-            continue;
-        }
-
-        // handle the different directives
-        sourcePtr++;
-        switch (*sourcePtr) {
-            case 'i':
-#ifdef _WIN32
-                threadId = (uint64_t) GetCurrentThreadId();
-#elif defined __linux
-                threadId = (uint64_t) syscall(SYS_gettid);
-#elif defined __APPLE__
-                pthread_threadid_np(NULL, &threadId);
-#else
-                threadId = (uint64_t) pthread_self();
-#endif
-                tempSize = sprintf(targetPtr, DPI_DEBUG_THREAD_FORMAT,
-                        threadId);
-                size -= tempSize;
-                targetPtr += tempSize;
-                sourcePtr++;
-                break;
-            case 'd':
-            case 't':
-                if (!gotTime) {
-                    gotTime = 1;
-#ifdef _WIN32
-                    GetLocalTime(&time);
-#else
-                    gettimeofday(&timeOfDay, NULL);
-                    localtime_r(&timeOfDay.tv_sec, &time);
-#endif
-                }
-#ifdef _WIN32
-                if (*sourcePtr == 'd')
-                    tempSize = sprintf(targetPtr, DPI_DEBUG_DATE_FORMAT,
-                            time.wYear, time.wMonth, time.wDay);
-                else tempSize = sprintf(targetPtr, DPI_DEBUG_TIME_FORMAT,
-                        time.wHour, time.wMinute, time.wSecond,
-                        time.wMilliseconds);
-#else
-                if (*sourcePtr == 'd')
-                    tempSize = sprintf(targetPtr, DPI_DEBUG_DATE_FORMAT,
-                            time.tm_year + 1900, time.tm_mon + 1,
-                            time.tm_mday);
-                else tempSize = sprintf(targetPtr, DPI_DEBUG_TIME_FORMAT,
-                        time.tm_hour, time.tm_min, time.tm_sec,
-                        (int) (timeOfDay.tv_usec / 1000));
-#endif
-                size -= tempSize;
-                targetPtr += tempSize;
-                sourcePtr++;
-                break;
-            case '\0':
-                break;
-            default:
-                *targetPtr++ = '%';
-                *targetPtr++ = *sourcePtr++;
-                break;
-        }
-    }
-
-    // append original format
-    strcpy(targetPtr, format);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDebug__initialize() [INTERNAL]
-//   Initialize debugging infrastructure. This reads the environment variables
-// and populates the global variables used for determining which messages to
-// print and what prefix should be placed in front of each message.
-//-----------------------------------------------------------------------------
-void dpiDebug__initialize(void)
-{
-    char *envValue;
-
-    // determine the value of the environment variable DPI_DEBUG_LEVEL and
-    // convert to an integer; if the value in the environment variable is not a
-    // valid integer, it is ignored
-    envValue = getenv("DPI_DEBUG_LEVEL");
-    if (envValue)
-        dpiDebugLevel = (unsigned long) strtol(envValue, NULL, 10);
-
-    // determine the value of the environment variable DPI_DEBUG_PREFIX and
-    // store it in the static buffer available for it; a static buffer is used
-    // since this runs during startup and may not fail; if the value of the
-    // environment variable is too large for the buffer, the value is ignored
-    // and the default value is used instead
-    envValue = getenv("DPI_DEBUG_PREFIX");
-    if (envValue && strlen(envValue) < sizeof(dpiDebugPrefixFormat))
-        strcpy(dpiDebugPrefixFormat, envValue);
-
-    // messages are written to stderr
-    dpiDebugStream = stderr;
-
-    // for any debugging level > 0 print a message indicating that tracing
-    // has started
-    if (dpiDebugLevel) {
-        dpiDebug__print("ODPI-C %s\n", DPI_VERSION_STRING);
-        dpiDebug__print("debugging messages initialized at level %lu\n",
-                dpiDebugLevel);
-    }
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDebug__print() [INTERNAL]
-//   Print the specified debugging message with a newly calculated prefix.
-//-----------------------------------------------------------------------------
-void dpiDebug__print(const char *format, ...)
-{
-    char formatWithPrefix[512];
-    va_list varArgs;
-
-    dpiDebug__getFormatWithPrefix(format, formatWithPrefix,
-            sizeof(formatWithPrefix));
-    va_start(varArgs, format);
-    (void) vfprintf(dpiDebugStream, formatWithPrefix, varArgs);
-    va_end(varArgs);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiDebug.h ./odpi/src/dpiDebug.h
--- patched-godror/odpi/src/dpiDebug.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiDebug.h	2024-05-14 14:55:13
@@ -0,0 +1,196 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2017, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiDebug.c
+//   Methods used for debugging ODPI-C.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+#define DPI_DEBUG_THREAD_FORMAT         "%.5" PRIu64
+#define DPI_DEBUG_DATE_FORMAT           "%.4d-%.2d-%.2d"
+#define DPI_DEBUG_TIME_FORMAT           "%.2d:%.2d:%.2d.%.3d"
+
+// debug level (populated by environment variable DPI_DEBUG_LEVEL)
+unsigned long dpiDebugLevel = 0;
+
+// debug prefix format (populated by environment variable DPI_DEBUG_PREFIX)
+static char dpiDebugPrefixFormat[64] = "ODPI [%i] %d %t: ";
+
+// debug file for printing (currently unchangeable)
+static FILE *dpiDebugStream = NULL;
+
+
+//-----------------------------------------------------------------------------
+// dpiDebug__getFormatWithPrefix() [INTERNAL]
+//   Adjust the provided format to include the prefix requested by the user.
+// This method is not permitted to fail, so if there is not enough space, the
+// prefix is truncated as needed -- although this is a very unlikely scenario.
+//-----------------------------------------------------------------------------
+static void dpiDebug__getFormatWithPrefix(const char *format,
+        char *formatWithPrefix, size_t maxFormatWithPrefixSize)
+{
+    char *sourcePtr, *targetPtr;
+    int gotTime, tempSize;
+    uint64_t threadId;
+    size_t size;
+#ifdef _WIN32
+    SYSTEMTIME time;
+#else
+    struct timeval timeOfDay;
+    struct tm time;
+#endif
+
+    gotTime = 0;
+    sourcePtr = dpiDebugPrefixFormat;
+    targetPtr = formatWithPrefix;
+    size = maxFormatWithPrefixSize - strlen(format);
+    while (*sourcePtr && size > 20) {
+
+        // all characters except '%' are copied verbatim to the target
+        if (*sourcePtr != '%') {
+            *targetPtr++ = *sourcePtr++;
+            maxFormatWithPrefixSize--;
+            continue;
+        }
+
+        // handle the different directives
+        sourcePtr++;
+        switch (*sourcePtr) {
+            case 'i':
+#ifdef _WIN32
+                threadId = (uint64_t) GetCurrentThreadId();
+#elif defined __linux
+                threadId = (uint64_t) syscall(SYS_gettid);
+#elif defined __APPLE__
+                pthread_threadid_np(NULL, &threadId);
+#else
+                threadId = (uint64_t) pthread_self();
+#endif
+                tempSize = sprintf(targetPtr, DPI_DEBUG_THREAD_FORMAT,
+                        threadId);
+                size -= tempSize;
+                targetPtr += tempSize;
+                sourcePtr++;
+                break;
+            case 'd':
+            case 't':
+                if (!gotTime) {
+                    gotTime = 1;
+#ifdef _WIN32
+                    GetLocalTime(&time);
+#else
+                    gettimeofday(&timeOfDay, NULL);
+                    localtime_r(&timeOfDay.tv_sec, &time);
+#endif
+                }
+#ifdef _WIN32
+                if (*sourcePtr == 'd')
+                    tempSize = sprintf(targetPtr, DPI_DEBUG_DATE_FORMAT,
+                            time.wYear, time.wMonth, time.wDay);
+                else tempSize = sprintf(targetPtr, DPI_DEBUG_TIME_FORMAT,
+                        time.wHour, time.wMinute, time.wSecond,
+                        time.wMilliseconds);
+#else
+                if (*sourcePtr == 'd')
+                    tempSize = sprintf(targetPtr, DPI_DEBUG_DATE_FORMAT,
+                            time.tm_year + 1900, time.tm_mon + 1,
+                            time.tm_mday);
+                else tempSize = sprintf(targetPtr, DPI_DEBUG_TIME_FORMAT,
+                        time.tm_hour, time.tm_min, time.tm_sec,
+                        (int) (timeOfDay.tv_usec / 1000));
+#endif
+                size -= tempSize;
+                targetPtr += tempSize;
+                sourcePtr++;
+                break;
+            case '\0':
+                break;
+            default:
+                *targetPtr++ = '%';
+                *targetPtr++ = *sourcePtr++;
+                break;
+        }
+    }
+
+    // append original format
+    strcpy(targetPtr, format);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDebug__initialize() [INTERNAL]
+//   Initialize debugging infrastructure. This reads the environment variables
+// and populates the global variables used for determining which messages to
+// print and what prefix should be placed in front of each message.
+//-----------------------------------------------------------------------------
+void dpiDebug__initialize(void)
+{
+    char *envValue;
+
+    // determine the value of the environment variable DPI_DEBUG_LEVEL and
+    // convert to an integer; if the value in the environment variable is not a
+    // valid integer, it is ignored
+    envValue = getenv("DPI_DEBUG_LEVEL");
+    if (envValue)
+        dpiDebugLevel = (unsigned long) strtol(envValue, NULL, 10);
+
+    // determine the value of the environment variable DPI_DEBUG_PREFIX and
+    // store it in the static buffer available for it; a static buffer is used
+    // since this runs during startup and may not fail; if the value of the
+    // environment variable is too large for the buffer, the value is ignored
+    // and the default value is used instead
+    envValue = getenv("DPI_DEBUG_PREFIX");
+    if (envValue && strlen(envValue) < sizeof(dpiDebugPrefixFormat))
+        strcpy(dpiDebugPrefixFormat, envValue);
+
+    // messages are written to stderr
+    dpiDebugStream = stderr;
+
+    // for any debugging level > 0 print a message indicating that tracing
+    // has started
+    if (dpiDebugLevel) {
+        dpiDebug__print("ODPI-C %s\n", DPI_VERSION_STRING);
+        dpiDebug__print("debugging messages initialized at level %lu\n",
+                dpiDebugLevel);
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDebug__print() [INTERNAL]
+//   Print the specified debugging message with a newly calculated prefix.
+//-----------------------------------------------------------------------------
+void dpiDebug__print(const char *format, ...)
+{
+    char formatWithPrefix[512];
+    va_list varArgs;
+
+    dpiDebug__getFormatWithPrefix(format, formatWithPrefix,
+            sizeof(formatWithPrefix));
+    va_start(varArgs, format);
+    (void) vfprintf(dpiDebugStream, formatWithPrefix, varArgs);
+    va_end(varArgs);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiDeqOptions.c ./odpi/src/dpiDeqOptions.c
--- patched-godror/odpi/src/dpiDeqOptions.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiDeqOptions.c	1970-01-01 01:00:00
@@ -1,384 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions.c
-//   Implementation of AQ dequeue options.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions__create() [INTERNAL]
-//   Create a new subscription structure and return it. In case of error NULL
-// is returned.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions__create(dpiDeqOptions *options, dpiConn *conn,
-        dpiError *error)
-{
-    dpiGen__setRefCount(conn, error, 1);
-    options->conn = conn;
-    return dpiOci__descriptorAlloc(conn->env->handle, &options->handle,
-            DPI_OCI_DTYPE_AQDEQ_OPTIONS, "allocate descriptor", error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions__free() [INTERNAL]
-//   Free the memory for a dequeue options structure.
-//-----------------------------------------------------------------------------
-void dpiDeqOptions__free(dpiDeqOptions *options, dpiError *error)
-{
-    if (options->msgIdRaw) {
-        dpiOci__rawResize(options->env->handle, &options->msgIdRaw, 0, error);
-        options->msgIdRaw = NULL;
-    }
-    if (options->handle) {
-        dpiOci__descriptorFree(options->handle, DPI_OCI_DTYPE_AQDEQ_OPTIONS);
-        options->handle = NULL;
-    }
-    if (options->conn) {
-        dpiGen__setRefCount(options->conn, error, -1);
-        options->conn = NULL;
-    }
-    dpiUtils__freeMemory(options);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions__getAttrValue() [INTERNAL]
-//   Get the attribute value in OCI.
-//-----------------------------------------------------------------------------
-static int dpiDeqOptions__getAttrValue(dpiDeqOptions *options,
-        uint32_t attribute, const char *fnName, void *value,
-        uint32_t *valueLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiGen__startPublicFn(options, DPI_HTYPE_DEQ_OPTIONS, fnName,
-            &error) < 0)
-        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(options, value)
-    DPI_CHECK_PTR_NOT_NULL(options, valueLength)
-    status = dpiOci__attrGet(options->handle, DPI_OCI_DTYPE_AQDEQ_OPTIONS,
-            value, valueLength, attribute, "get attribute value", &error);
-    return dpiGen__endPublicFn(options, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions__setAttrValue() [INTERNAL]
-//   Set the attribute value in OCI.
-//-----------------------------------------------------------------------------
-static int dpiDeqOptions__setAttrValue(dpiDeqOptions *options,
-        uint32_t attribute, const char *fnName, const void *value,
-        uint32_t valueLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiGen__startPublicFn(options, DPI_HTYPE_DEQ_OPTIONS, fnName,
-            &error) < 0)
-        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(options, value)
-    status = dpiOci__attrSet(options->handle, DPI_OCI_DTYPE_AQDEQ_OPTIONS,
-            (void*) value, valueLength, attribute, "set attribute value",
-            &error);
-    return dpiGen__endPublicFn(options, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_addRef() [PUBLIC]
-//   Add a reference to the dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_addRef(dpiDeqOptions *options)
-{
-    return dpiGen__addRef(options, DPI_HTYPE_DEQ_OPTIONS, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_getCondition() [PUBLIC]
-//   Return condition associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_getCondition(dpiDeqOptions *options, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_DEQCOND, __func__,
-            (void*) value, valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_getConsumerName() [PUBLIC]
-//   Return consumer name associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_getConsumerName(dpiDeqOptions *options, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_CONSUMER_NAME,
-            __func__, (void*) value, valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_getCorrelation() [PUBLIC]
-//   Return correlation associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_getCorrelation(dpiDeqOptions *options, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_CORRELATION,
-            __func__, (void*) value, valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_getMode() [PUBLIC]
-//   Return mode associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_getMode(dpiDeqOptions *options, dpiDeqMode *value)
-{
-    uint32_t valueLength = sizeof(uint32_t);
-
-    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_DEQ_MODE,
-            __func__, value, &valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_getMsgId() [PUBLIC]
-//   Return message id associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_getMsgId(dpiDeqOptions *options, const char **value,
-        uint32_t *valueLength)
-{
-    dpiError error;
-    void *rawValue;
-
-    if (dpiGen__startPublicFn(options, DPI_HTYPE_DEQ_OPTIONS, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(options, value)
-    DPI_CHECK_PTR_NOT_NULL(options, valueLength)
-    if (dpiOci__attrGet(options->handle, DPI_OCI_DTYPE_AQDEQ_OPTIONS,
-            &rawValue, NULL, DPI_OCI_ATTR_DEQ_MSGID, "get attribute value",
-            &error) < 0)
-        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
-    dpiOci__rawPtr(options->env->handle, rawValue, (void**) value);
-    dpiOci__rawSize(options->env->handle, rawValue, valueLength);
-    return dpiGen__endPublicFn(options, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_getNavigation() [PUBLIC]
-//   Return navigation associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_getNavigation(dpiDeqOptions *options,
-        dpiDeqNavigation *value)
-{
-    uint32_t valueLength = sizeof(uint32_t);
-
-    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_NAVIGATION,
-            __func__, value, &valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_getTransformation() [PUBLIC]
-//   Return transformation associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_getTransformation(dpiDeqOptions *options, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_TRANSFORMATION,
-            __func__, (void*) value, valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_getVisibility() [PUBLIC]
-//   Return visibility associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_getVisibility(dpiDeqOptions *options, dpiVisibility *value)
-{
-    uint32_t valueLength = sizeof(uint32_t);
-
-    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_VISIBILITY,
-            __func__, value, &valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_getWait() [PUBLIC]
-//   Return the number of seconds to wait for a message when dequeuing.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_getWait(dpiDeqOptions *options, uint32_t *value)
-{
-    uint32_t valueLength = sizeof(uint32_t);
-
-    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_WAIT, __func__,
-            value, &valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_release() [PUBLIC]
-//   Release a reference to the dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_release(dpiDeqOptions *options)
-{
-    return dpiGen__release(options, DPI_HTYPE_DEQ_OPTIONS, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_setCondition() [PUBLIC]
-//   Set condition associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_setCondition(dpiDeqOptions *options, const char *value,
-        uint32_t valueLength)
-{
-    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_DEQCOND, __func__,
-            value, valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_setConsumerName() [PUBLIC]
-//   Set consumer name associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_setConsumerName(dpiDeqOptions *options, const char *value,
-        uint32_t valueLength)
-{
-    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_CONSUMER_NAME,
-            __func__, value, valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_setCorrelation() [PUBLIC]
-//   Set correlation associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_setCorrelation(dpiDeqOptions *options, const char *value,
-        uint32_t valueLength)
-{
-    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_CORRELATION,
-            __func__, value, valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_setDeliveryMode() [PUBLIC]
-//   Set the delivery mode associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_setDeliveryMode(dpiDeqOptions *options,
-        dpiMessageDeliveryMode value)
-{
-    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_MSG_DELIVERY_MODE,
-            __func__, &value, 0);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_setMode() [PUBLIC]
-//   Set the mode associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_setMode(dpiDeqOptions *options, dpiDeqMode value)
-{
-    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_DEQ_MODE,
-            __func__, &value, 0);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_setMsgId() [PUBLIC]
-//   Set the message id associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_setMsgId(dpiDeqOptions *options, const char *value,
-        uint32_t valueLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiGen__startPublicFn(options, DPI_HTYPE_DEQ_OPTIONS, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(options, value)
-    if (dpiOci__rawAssignBytes(options->env->handle, value, valueLength,
-            &options->msgIdRaw, &error) < 0)
-        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
-    status = dpiOci__attrSet(options->handle, DPI_OCI_DTYPE_AQDEQ_OPTIONS,
-            (void*) &options->msgIdRaw, valueLength, DPI_OCI_ATTR_DEQ_MSGID,
-            "set value", &error);
-    return dpiGen__endPublicFn(options, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_setNavigation() [PUBLIC]
-//   Set navigation associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_setNavigation(dpiDeqOptions *options, dpiDeqNavigation value)
-{
-    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_NAVIGATION,
-            __func__, &value, 0);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_setTransformation() [PUBLIC]
-//   Set transformation associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_setTransformation(dpiDeqOptions *options, const char *value,
-        uint32_t valueLength)
-{
-    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_TRANSFORMATION,
-            __func__, value, valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_setVisibility() [PUBLIC]
-//   Set visibility associated with dequeue options.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_setVisibility(dpiDeqOptions *options, dpiVisibility value)
-{
-    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_VISIBILITY,
-            __func__, &value, 0);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiDeqOptions_setWait() [PUBLIC]
-//   Set the number of seconds to wait for a message when dequeuing.
-//-----------------------------------------------------------------------------
-int dpiDeqOptions_setWait(dpiDeqOptions *options, uint32_t value)
-{
-    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_WAIT, __func__,
-            &value, 0);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiDeqOptions.h ./odpi/src/dpiDeqOptions.h
--- patched-godror/odpi/src/dpiDeqOptions.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiDeqOptions.h	2024-05-14 14:55:13
@@ -0,0 +1,384 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions.c
+//   Implementation of AQ dequeue options.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions__create() [INTERNAL]
+//   Create a new subscription structure and return it. In case of error NULL
+// is returned.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions__create(dpiDeqOptions *options, dpiConn *conn,
+        dpiError *error)
+{
+    dpiGen__setRefCount(conn, error, 1);
+    options->conn = conn;
+    return dpiOci__descriptorAlloc(conn->env->handle, &options->handle,
+            DPI_OCI_DTYPE_AQDEQ_OPTIONS, "allocate descriptor", error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions__free() [INTERNAL]
+//   Free the memory for a dequeue options structure.
+//-----------------------------------------------------------------------------
+void dpiDeqOptions__free(dpiDeqOptions *options, dpiError *error)
+{
+    if (options->msgIdRaw) {
+        dpiOci__rawResize(options->env->handle, &options->msgIdRaw, 0, error);
+        options->msgIdRaw = NULL;
+    }
+    if (options->handle) {
+        dpiOci__descriptorFree(options->handle, DPI_OCI_DTYPE_AQDEQ_OPTIONS);
+        options->handle = NULL;
+    }
+    if (options->conn) {
+        dpiGen__setRefCount(options->conn, error, -1);
+        options->conn = NULL;
+    }
+    dpiUtils__freeMemory(options);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions__getAttrValue() [INTERNAL]
+//   Get the attribute value in OCI.
+//-----------------------------------------------------------------------------
+static int dpiDeqOptions__getAttrValue(dpiDeqOptions *options,
+        uint32_t attribute, const char *fnName, void *value,
+        uint32_t *valueLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiGen__startPublicFn(options, DPI_HTYPE_DEQ_OPTIONS, fnName,
+            &error) < 0)
+        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(options, value)
+    DPI_CHECK_PTR_NOT_NULL(options, valueLength)
+    status = dpiOci__attrGet(options->handle, DPI_OCI_DTYPE_AQDEQ_OPTIONS,
+            value, valueLength, attribute, "get attribute value", &error);
+    return dpiGen__endPublicFn(options, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions__setAttrValue() [INTERNAL]
+//   Set the attribute value in OCI.
+//-----------------------------------------------------------------------------
+static int dpiDeqOptions__setAttrValue(dpiDeqOptions *options,
+        uint32_t attribute, const char *fnName, const void *value,
+        uint32_t valueLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiGen__startPublicFn(options, DPI_HTYPE_DEQ_OPTIONS, fnName,
+            &error) < 0)
+        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(options, value)
+    status = dpiOci__attrSet(options->handle, DPI_OCI_DTYPE_AQDEQ_OPTIONS,
+            (void*) value, valueLength, attribute, "set attribute value",
+            &error);
+    return dpiGen__endPublicFn(options, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_addRef() [PUBLIC]
+//   Add a reference to the dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_addRef(dpiDeqOptions *options)
+{
+    return dpiGen__addRef(options, DPI_HTYPE_DEQ_OPTIONS, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_getCondition() [PUBLIC]
+//   Return condition associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_getCondition(dpiDeqOptions *options, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_DEQCOND, __func__,
+            (void*) value, valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_getConsumerName() [PUBLIC]
+//   Return consumer name associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_getConsumerName(dpiDeqOptions *options, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_CONSUMER_NAME,
+            __func__, (void*) value, valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_getCorrelation() [PUBLIC]
+//   Return correlation associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_getCorrelation(dpiDeqOptions *options, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_CORRELATION,
+            __func__, (void*) value, valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_getMode() [PUBLIC]
+//   Return mode associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_getMode(dpiDeqOptions *options, dpiDeqMode *value)
+{
+    uint32_t valueLength = sizeof(uint32_t);
+
+    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_DEQ_MODE,
+            __func__, value, &valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_getMsgId() [PUBLIC]
+//   Return message id associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_getMsgId(dpiDeqOptions *options, const char **value,
+        uint32_t *valueLength)
+{
+    dpiError error;
+    void *rawValue;
+
+    if (dpiGen__startPublicFn(options, DPI_HTYPE_DEQ_OPTIONS, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(options, value)
+    DPI_CHECK_PTR_NOT_NULL(options, valueLength)
+    if (dpiOci__attrGet(options->handle, DPI_OCI_DTYPE_AQDEQ_OPTIONS,
+            &rawValue, NULL, DPI_OCI_ATTR_DEQ_MSGID, "get attribute value",
+            &error) < 0)
+        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
+    dpiOci__rawPtr(options->env->handle, rawValue, (void**) value);
+    dpiOci__rawSize(options->env->handle, rawValue, valueLength);
+    return dpiGen__endPublicFn(options, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_getNavigation() [PUBLIC]
+//   Return navigation associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_getNavigation(dpiDeqOptions *options,
+        dpiDeqNavigation *value)
+{
+    uint32_t valueLength = sizeof(uint32_t);
+
+    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_NAVIGATION,
+            __func__, value, &valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_getTransformation() [PUBLIC]
+//   Return transformation associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_getTransformation(dpiDeqOptions *options, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_TRANSFORMATION,
+            __func__, (void*) value, valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_getVisibility() [PUBLIC]
+//   Return visibility associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_getVisibility(dpiDeqOptions *options, dpiVisibility *value)
+{
+    uint32_t valueLength = sizeof(uint32_t);
+
+    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_VISIBILITY,
+            __func__, value, &valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_getWait() [PUBLIC]
+//   Return the number of seconds to wait for a message when dequeuing.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_getWait(dpiDeqOptions *options, uint32_t *value)
+{
+    uint32_t valueLength = sizeof(uint32_t);
+
+    return dpiDeqOptions__getAttrValue(options, DPI_OCI_ATTR_WAIT, __func__,
+            value, &valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_release() [PUBLIC]
+//   Release a reference to the dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_release(dpiDeqOptions *options)
+{
+    return dpiGen__release(options, DPI_HTYPE_DEQ_OPTIONS, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_setCondition() [PUBLIC]
+//   Set condition associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_setCondition(dpiDeqOptions *options, const char *value,
+        uint32_t valueLength)
+{
+    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_DEQCOND, __func__,
+            value, valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_setConsumerName() [PUBLIC]
+//   Set consumer name associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_setConsumerName(dpiDeqOptions *options, const char *value,
+        uint32_t valueLength)
+{
+    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_CONSUMER_NAME,
+            __func__, value, valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_setCorrelation() [PUBLIC]
+//   Set correlation associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_setCorrelation(dpiDeqOptions *options, const char *value,
+        uint32_t valueLength)
+{
+    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_CORRELATION,
+            __func__, value, valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_setDeliveryMode() [PUBLIC]
+//   Set the delivery mode associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_setDeliveryMode(dpiDeqOptions *options,
+        dpiMessageDeliveryMode value)
+{
+    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_MSG_DELIVERY_MODE,
+            __func__, &value, 0);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_setMode() [PUBLIC]
+//   Set the mode associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_setMode(dpiDeqOptions *options, dpiDeqMode value)
+{
+    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_DEQ_MODE,
+            __func__, &value, 0);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_setMsgId() [PUBLIC]
+//   Set the message id associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_setMsgId(dpiDeqOptions *options, const char *value,
+        uint32_t valueLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiGen__startPublicFn(options, DPI_HTYPE_DEQ_OPTIONS, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(options, value)
+    if (dpiOci__rawAssignBytes(options->env->handle, value, valueLength,
+            &options->msgIdRaw, &error) < 0)
+        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
+    status = dpiOci__attrSet(options->handle, DPI_OCI_DTYPE_AQDEQ_OPTIONS,
+            (void*) &options->msgIdRaw, valueLength, DPI_OCI_ATTR_DEQ_MSGID,
+            "set value", &error);
+    return dpiGen__endPublicFn(options, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_setNavigation() [PUBLIC]
+//   Set navigation associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_setNavigation(dpiDeqOptions *options, dpiDeqNavigation value)
+{
+    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_NAVIGATION,
+            __func__, &value, 0);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_setTransformation() [PUBLIC]
+//   Set transformation associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_setTransformation(dpiDeqOptions *options, const char *value,
+        uint32_t valueLength)
+{
+    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_TRANSFORMATION,
+            __func__, value, valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_setVisibility() [PUBLIC]
+//   Set visibility associated with dequeue options.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_setVisibility(dpiDeqOptions *options, dpiVisibility value)
+{
+    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_VISIBILITY,
+            __func__, &value, 0);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiDeqOptions_setWait() [PUBLIC]
+//   Set the number of seconds to wait for a message when dequeuing.
+//-----------------------------------------------------------------------------
+int dpiDeqOptions_setWait(dpiDeqOptions *options, uint32_t value)
+{
+    return dpiDeqOptions__setAttrValue(options, DPI_OCI_ATTR_WAIT, __func__,
+            &value, 0);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiEnqOptions.c ./odpi/src/dpiEnqOptions.c
--- patched-godror/odpi/src/dpiEnqOptions.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiEnqOptions.c	1970-01-01 01:00:00
@@ -1,186 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiEnqOptions.c
-//   Implementation of AQ enqueue options.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiEnqOptions__create() [INTERNAL]
-//   Create a new subscription structure and return it. In case of error NULL
-// is returned.
-//-----------------------------------------------------------------------------
-int dpiEnqOptions__create(dpiEnqOptions *options, dpiConn *conn,
-        dpiError *error)
-{
-    dpiGen__setRefCount(conn, error, 1);
-    options->conn = conn;
-    return dpiOci__descriptorAlloc(conn->env->handle, &options->handle,
-            DPI_OCI_DTYPE_AQENQ_OPTIONS, "allocate descriptor", error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiEnqOptions__free() [INTERNAL]
-//   Free the memory for a enqueue options structure.
-//-----------------------------------------------------------------------------
-void dpiEnqOptions__free(dpiEnqOptions *options, dpiError *error)
-{
-    if (options->handle) {
-        dpiOci__descriptorFree(options->handle, DPI_OCI_DTYPE_AQENQ_OPTIONS);
-        options->handle = NULL;
-    }
-    if (options->conn) {
-        dpiGen__setRefCount(options->conn, error, -1);
-        options->conn = NULL;
-    }
-    dpiUtils__freeMemory(options);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiEnqOptions__getAttrValue() [INTERNAL]
-//   Get the attribute value in OCI.
-//-----------------------------------------------------------------------------
-static int dpiEnqOptions__getAttrValue(dpiEnqOptions *options,
-        uint32_t attribute, const char *fnName, void *value,
-        uint32_t *valueLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiGen__startPublicFn(options, DPI_HTYPE_ENQ_OPTIONS, fnName,
-            &error) < 0)
-        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(options, value)
-    DPI_CHECK_PTR_NOT_NULL(options, valueLength)
-    status = dpiOci__attrGet(options->handle, DPI_OCI_DTYPE_AQENQ_OPTIONS,
-            value, valueLength, attribute, "get attribute value", &error);
-    return dpiGen__endPublicFn(options, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiEnqOptions__setAttrValue() [INTERNAL]
-//   Set the attribute value in OCI.
-//-----------------------------------------------------------------------------
-static int dpiEnqOptions__setAttrValue(dpiEnqOptions *options,
-        uint32_t attribute, const char *fnName, const void *value,
-        uint32_t valueLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiGen__startPublicFn(options, DPI_HTYPE_ENQ_OPTIONS, fnName,
-            &error) < 0)
-        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(options, value)
-    status = dpiOci__attrSet(options->handle, DPI_OCI_DTYPE_AQENQ_OPTIONS,
-            (void*) value, valueLength, attribute, "set attribute value",
-            &error);
-    return dpiGen__endPublicFn(options, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiEnqOptions_addRef() [PUBLIC]
-//   Add a reference to the enqueue options.
-//-----------------------------------------------------------------------------
-int dpiEnqOptions_addRef(dpiEnqOptions *options)
-{
-    return dpiGen__addRef(options, DPI_HTYPE_ENQ_OPTIONS, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiEnqOptions_getTransformation() [PUBLIC]
-//   Return transformation associated with enqueue options.
-//-----------------------------------------------------------------------------
-int dpiEnqOptions_getTransformation(dpiEnqOptions *options, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiEnqOptions__getAttrValue(options, DPI_OCI_ATTR_TRANSFORMATION,
-            __func__, (void*) value, valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiEnqOptions_getVisibility() [PUBLIC]
-//   Return visibility associated with enqueue options.
-//-----------------------------------------------------------------------------
-int dpiEnqOptions_getVisibility(dpiEnqOptions *options, dpiVisibility *value)
-{
-    uint32_t valueLength = sizeof(uint32_t);
-
-    return dpiEnqOptions__getAttrValue(options, DPI_OCI_ATTR_VISIBILITY,
-            __func__, value, &valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiEnqOptions_release() [PUBLIC]
-//   Release a reference to the enqueue options.
-//-----------------------------------------------------------------------------
-int dpiEnqOptions_release(dpiEnqOptions *options)
-{
-    return dpiGen__release(options, DPI_HTYPE_ENQ_OPTIONS, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiEnqOptions_setDeliveryMode() [PUBLIC]
-//   Set the delivery mode associated with enqueue options.
-//-----------------------------------------------------------------------------
-int dpiEnqOptions_setDeliveryMode(dpiEnqOptions *options,
-        dpiMessageDeliveryMode value)
-{
-    return dpiEnqOptions__setAttrValue(options, DPI_OCI_ATTR_MSG_DELIVERY_MODE,
-            __func__, &value, 0);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiEnqOptions_setTransformation() [PUBLIC]
-//   Set transformation associated with enqueue options.
-//-----------------------------------------------------------------------------
-int dpiEnqOptions_setTransformation(dpiEnqOptions *options, const char *value,
-        uint32_t valueLength)
-{
-    return dpiEnqOptions__setAttrValue(options, DPI_OCI_ATTR_TRANSFORMATION,
-            __func__,  value, valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiEnqOptions_setVisibility() [PUBLIC]
-//   Set visibility associated with enqueue options.
-//-----------------------------------------------------------------------------
-int dpiEnqOptions_setVisibility(dpiEnqOptions *options, dpiVisibility value)
-{
-    return dpiEnqOptions__setAttrValue(options, DPI_OCI_ATTR_VISIBILITY,
-            __func__, &value, 0);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiEnqOptions.h ./odpi/src/dpiEnqOptions.h
--- patched-godror/odpi/src/dpiEnqOptions.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiEnqOptions.h	2024-05-14 14:55:13
@@ -0,0 +1,186 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiEnqOptions.c
+//   Implementation of AQ enqueue options.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiEnqOptions__create() [INTERNAL]
+//   Create a new subscription structure and return it. In case of error NULL
+// is returned.
+//-----------------------------------------------------------------------------
+int dpiEnqOptions__create(dpiEnqOptions *options, dpiConn *conn,
+        dpiError *error)
+{
+    dpiGen__setRefCount(conn, error, 1);
+    options->conn = conn;
+    return dpiOci__descriptorAlloc(conn->env->handle, &options->handle,
+            DPI_OCI_DTYPE_AQENQ_OPTIONS, "allocate descriptor", error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiEnqOptions__free() [INTERNAL]
+//   Free the memory for a enqueue options structure.
+//-----------------------------------------------------------------------------
+void dpiEnqOptions__free(dpiEnqOptions *options, dpiError *error)
+{
+    if (options->handle) {
+        dpiOci__descriptorFree(options->handle, DPI_OCI_DTYPE_AQENQ_OPTIONS);
+        options->handle = NULL;
+    }
+    if (options->conn) {
+        dpiGen__setRefCount(options->conn, error, -1);
+        options->conn = NULL;
+    }
+    dpiUtils__freeMemory(options);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiEnqOptions__getAttrValue() [INTERNAL]
+//   Get the attribute value in OCI.
+//-----------------------------------------------------------------------------
+static int dpiEnqOptions__getAttrValue(dpiEnqOptions *options,
+        uint32_t attribute, const char *fnName, void *value,
+        uint32_t *valueLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiGen__startPublicFn(options, DPI_HTYPE_ENQ_OPTIONS, fnName,
+            &error) < 0)
+        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(options, value)
+    DPI_CHECK_PTR_NOT_NULL(options, valueLength)
+    status = dpiOci__attrGet(options->handle, DPI_OCI_DTYPE_AQENQ_OPTIONS,
+            value, valueLength, attribute, "get attribute value", &error);
+    return dpiGen__endPublicFn(options, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiEnqOptions__setAttrValue() [INTERNAL]
+//   Set the attribute value in OCI.
+//-----------------------------------------------------------------------------
+static int dpiEnqOptions__setAttrValue(dpiEnqOptions *options,
+        uint32_t attribute, const char *fnName, const void *value,
+        uint32_t valueLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiGen__startPublicFn(options, DPI_HTYPE_ENQ_OPTIONS, fnName,
+            &error) < 0)
+        return dpiGen__endPublicFn(options, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(options, value)
+    status = dpiOci__attrSet(options->handle, DPI_OCI_DTYPE_AQENQ_OPTIONS,
+            (void*) value, valueLength, attribute, "set attribute value",
+            &error);
+    return dpiGen__endPublicFn(options, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiEnqOptions_addRef() [PUBLIC]
+//   Add a reference to the enqueue options.
+//-----------------------------------------------------------------------------
+int dpiEnqOptions_addRef(dpiEnqOptions *options)
+{
+    return dpiGen__addRef(options, DPI_HTYPE_ENQ_OPTIONS, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiEnqOptions_getTransformation() [PUBLIC]
+//   Return transformation associated with enqueue options.
+//-----------------------------------------------------------------------------
+int dpiEnqOptions_getTransformation(dpiEnqOptions *options, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiEnqOptions__getAttrValue(options, DPI_OCI_ATTR_TRANSFORMATION,
+            __func__, (void*) value, valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiEnqOptions_getVisibility() [PUBLIC]
+//   Return visibility associated with enqueue options.
+//-----------------------------------------------------------------------------
+int dpiEnqOptions_getVisibility(dpiEnqOptions *options, dpiVisibility *value)
+{
+    uint32_t valueLength = sizeof(uint32_t);
+
+    return dpiEnqOptions__getAttrValue(options, DPI_OCI_ATTR_VISIBILITY,
+            __func__, value, &valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiEnqOptions_release() [PUBLIC]
+//   Release a reference to the enqueue options.
+//-----------------------------------------------------------------------------
+int dpiEnqOptions_release(dpiEnqOptions *options)
+{
+    return dpiGen__release(options, DPI_HTYPE_ENQ_OPTIONS, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiEnqOptions_setDeliveryMode() [PUBLIC]
+//   Set the delivery mode associated with enqueue options.
+//-----------------------------------------------------------------------------
+int dpiEnqOptions_setDeliveryMode(dpiEnqOptions *options,
+        dpiMessageDeliveryMode value)
+{
+    return dpiEnqOptions__setAttrValue(options, DPI_OCI_ATTR_MSG_DELIVERY_MODE,
+            __func__, &value, 0);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiEnqOptions_setTransformation() [PUBLIC]
+//   Set transformation associated with enqueue options.
+//-----------------------------------------------------------------------------
+int dpiEnqOptions_setTransformation(dpiEnqOptions *options, const char *value,
+        uint32_t valueLength)
+{
+    return dpiEnqOptions__setAttrValue(options, DPI_OCI_ATTR_TRANSFORMATION,
+            __func__,  value, valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiEnqOptions_setVisibility() [PUBLIC]
+//   Set visibility associated with enqueue options.
+//-----------------------------------------------------------------------------
+int dpiEnqOptions_setVisibility(dpiEnqOptions *options, dpiVisibility value)
+{
+    return dpiEnqOptions__setAttrValue(options, DPI_OCI_ATTR_VISIBILITY,
+            __func__, &value, 0);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiEnv.c ./odpi/src/dpiEnv.c
--- patched-godror/odpi/src/dpiEnv.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiEnv.c	1970-01-01 01:00:00
@@ -1,241 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiEnv.c
-//   Implementation of environment.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiEnv__getBaseDate() [INTERNAL]
-//   Return the base date (January 1, 1970 UTC) for the specified handle type.
-// OCI doesn't permit mixing and matching types so a separate bae date is
-// required for each of the three timestamp types. If the type has not been
-// populated already it is created.
-//-----------------------------------------------------------------------------
-int dpiEnv__getBaseDate(dpiEnv *env, uint32_t dataType, void **baseDate,
-        dpiError *error)
-{
-    uint32_t descriptorType;
-    char timezoneBuffer[20];
-    size_t timezoneLength;
-    void **storedBaseDate;
-
-    // determine type of descriptor and location of stored base date
-    switch (dataType) {
-        case DPI_ORACLE_TYPE_TIMESTAMP:
-            storedBaseDate = &env->baseDate;
-            descriptorType = DPI_OCI_DTYPE_TIMESTAMP;
-            break;
-        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
-            storedBaseDate = &env->baseDateTZ;
-            descriptorType = DPI_OCI_DTYPE_TIMESTAMP_TZ;
-            break;
-        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
-            storedBaseDate = &env->baseDateLTZ;
-            descriptorType = DPI_OCI_DTYPE_TIMESTAMP_LTZ;
-            break;
-        default:
-            return dpiError__set(error, "get base date",
-                    DPI_ERR_UNHANDLED_DATA_TYPE, dataType);
-    }
-
-    // if a base date has not been stored already, create it
-    if (!*storedBaseDate) {
-        if (dpiOci__descriptorAlloc(env->handle, storedBaseDate,
-                descriptorType, "alloc base date descriptor", error) < 0)
-            return DPI_FAILURE;
-        if (dpiOci__nlsCharSetConvert(env->handle, env->charsetId,
-                timezoneBuffer, sizeof(timezoneBuffer), DPI_CHARSET_ID_ASCII,
-                "+00:00", 6, &timezoneLength, error) < 0)
-            return DPI_FAILURE;
-        if (dpiOci__dateTimeConstruct(env->handle, *storedBaseDate, 1970, 1, 1,
-                0, 0, 0, 0, timezoneBuffer, timezoneLength, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    *baseDate = *storedBaseDate;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiEnv__free() [INTERNAL]
-//   Free the memory associated with the environment.
-//-----------------------------------------------------------------------------
-void dpiEnv__free(dpiEnv *env, dpiError *error)
-{
-    if (env->threaded)
-        dpiMutex__destroy(env->mutex);
-    if (env->handle && !env->externalHandle) {
-        dpiOci__handleFree(env->handle, DPI_OCI_HTYPE_ENV);
-        env->handle = NULL;
-    }
-    if (env->errorHandles) {
-        dpiHandlePool__free(env->errorHandles);
-        env->errorHandles = NULL;
-        error->handle = NULL;
-    }
-    dpiUtils__freeMemory(env);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiEnv__getCharacterSetIdAndName() [INTERNAL]
-//   Retrieve and store the IANA character set name for the attribute.
-//-----------------------------------------------------------------------------
-static int dpiEnv__getCharacterSetIdAndName(dpiEnv *env, uint16_t attribute,
-        uint16_t *charsetId, char *encoding, dpiError *error)
-{
-    *charsetId = 0;
-    dpiOci__attrGet(env->handle, DPI_OCI_HTYPE_ENV, charsetId, NULL, attribute,
-            "get environment", error);
-    return dpiGlobal__lookupEncoding(*charsetId, encoding, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiEnv__getEncodingInfo() [INTERNAL]
-//   Populate the structure with the encoding info.
-//-----------------------------------------------------------------------------
-int dpiEnv__getEncodingInfo(dpiEnv *env, dpiEncodingInfo *info)
-{
-    info->encoding = env->encoding;
-    info->maxBytesPerCharacter = env->maxBytesPerCharacter;
-    info->nencoding = env->nencoding;
-    info->nmaxBytesPerCharacter = env->nmaxBytesPerCharacter;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiEnv__init() [INTERNAL]
-//   Initialize the environment structure. If an external handle is provided it
-// is used directly; otherwise, a new OCI environment handle is created. In
-// either case, information about the environment is stored for later use.
-//-----------------------------------------------------------------------------
-int dpiEnv__init(dpiEnv *env, const dpiContext *context,
-        const dpiCommonCreateParams *params, void *externalHandle,
-        dpiCreateMode createMode, dpiError *error)
-{
-    int temp;
-
-    // store context and version information
-    env->context = context;
-    env->versionInfo = context->versionInfo;
-
-    // an external handle is available, use it directly
-    if (externalHandle) {
-        env->handle = externalHandle;
-        env->externalHandle = 1;
-
-    // otherwise, lookup encodings
-    } else {
-
-        // lookup encoding
-        if (params->encoding && dpiGlobal__lookupCharSet(params->encoding,
-                &env->charsetId, error) < 0)
-            return DPI_FAILURE;
-
-        // check for identical encoding before performing lookup of national
-        // character set encoding
-        if (params->nencoding && params->encoding &&
-                strcmp(params->nencoding, params->encoding) == 0)
-            env->ncharsetId = env->charsetId;
-        else if (params->nencoding &&
-                dpiGlobal__lookupCharSet(params->nencoding,
-                        &env->ncharsetId, error) < 0)
-            return DPI_FAILURE;
-
-        // both charsetId and ncharsetId must be zero or both must be non-zero
-        // use NLS routine to look up missing value, if needed
-        if (env->charsetId && !env->ncharsetId) {
-            if (dpiOci__nlsEnvironmentVariableGet(DPI_OCI_NLS_NCHARSET_ID,
-                    &env->ncharsetId, error) < 0)
-                return DPI_FAILURE;
-        } else if (!env->charsetId && env->ncharsetId) {
-            if (dpiOci__nlsEnvironmentVariableGet(DPI_OCI_NLS_CHARSET_ID,
-                    &env->charsetId, error) < 0)
-                return DPI_FAILURE;
-        }
-
-        // create new environment handle
-        if (dpiOci__envNlsCreate(&env->handle, createMode | DPI_OCI_OBJECT,
-                env->charsetId, env->ncharsetId, error) < 0)
-            return DPI_FAILURE;
-
-    }
-
-    // create the error handle pool
-    if (dpiHandlePool__create(&env->errorHandles, error) < 0)
-        return DPI_FAILURE;
-    error->env = env;
-
-    // if threaded, create mutex for reference counts
-    if (createMode & DPI_OCI_THREADED)
-        dpiMutex__initialize(env->mutex);
-
-    // determine encodings in use
-    if (dpiEnv__getCharacterSetIdAndName(env, DPI_OCI_ATTR_CHARSET_ID,
-            &env->charsetId, env->encoding, error) < 0)
-        return DPI_FAILURE;
-    if (dpiEnv__getCharacterSetIdAndName(env, DPI_OCI_ATTR_NCHARSET_ID,
-            &env->ncharsetId, env->nencoding, error) < 0)
-        return DPI_FAILURE;
-
-    // acquire max bytes per character
-    if (dpiOci__nlsNumericInfoGet(env->handle, &env->maxBytesPerCharacter,
-            DPI_OCI_NLS_CHARSET_MAXBYTESZ, error) < 0)
-        return DPI_FAILURE;
-
-    // for NCHAR we have no idea of how many so we simply take the worst case
-    // unless the charsets are identical
-    if (env->ncharsetId == env->charsetId)
-        env->nmaxBytesPerCharacter = env->maxBytesPerCharacter;
-    else env->nmaxBytesPerCharacter = 4;
-
-    // set whether or not we are threaded
-    if (createMode & DPI_MODE_CREATE_THREADED)
-        env->threaded = 1;
-
-    // set whether or not events mode has been set
-    if (createMode & DPI_MODE_CREATE_EVENTS)
-        env->events = 1;
-
-    // enable SODA metadata cache, if applicable
-    if (params->sodaMetadataCache) {
-        if (dpiUtils__checkClientVersionMulti(env->versionInfo, 19, 11, 21, 3,
-                error) < 0)
-            return DPI_FAILURE;
-        temp = 1;
-        if (dpiOci__attrSet(env->handle, DPI_OCI_HTYPE_ENV, &temp, 0,
-                DPI_OCI_ATTR_SODA_METADATA_CACHE, "set SODA metadata cache",
-                error) < 0)
-            return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiEnv.h ./odpi/src/dpiEnv.h
--- patched-godror/odpi/src/dpiEnv.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiEnv.h	2024-05-14 14:55:13
@@ -0,0 +1,241 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiEnv.c
+//   Implementation of environment.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiEnv__getBaseDate() [INTERNAL]
+//   Return the base date (January 1, 1970 UTC) for the specified handle type.
+// OCI doesn't permit mixing and matching types so a separate bae date is
+// required for each of the three timestamp types. If the type has not been
+// populated already it is created.
+//-----------------------------------------------------------------------------
+int dpiEnv__getBaseDate(dpiEnv *env, uint32_t dataType, void **baseDate,
+        dpiError *error)
+{
+    uint32_t descriptorType;
+    char timezoneBuffer[20];
+    size_t timezoneLength;
+    void **storedBaseDate;
+
+    // determine type of descriptor and location of stored base date
+    switch (dataType) {
+        case DPI_ORACLE_TYPE_TIMESTAMP:
+            storedBaseDate = &env->baseDate;
+            descriptorType = DPI_OCI_DTYPE_TIMESTAMP;
+            break;
+        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
+            storedBaseDate = &env->baseDateTZ;
+            descriptorType = DPI_OCI_DTYPE_TIMESTAMP_TZ;
+            break;
+        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
+            storedBaseDate = &env->baseDateLTZ;
+            descriptorType = DPI_OCI_DTYPE_TIMESTAMP_LTZ;
+            break;
+        default:
+            return dpiError__set(error, "get base date",
+                    DPI_ERR_UNHANDLED_DATA_TYPE, dataType);
+    }
+
+    // if a base date has not been stored already, create it
+    if (!*storedBaseDate) {
+        if (dpiOci__descriptorAlloc(env->handle, storedBaseDate,
+                descriptorType, "alloc base date descriptor", error) < 0)
+            return DPI_FAILURE;
+        if (dpiOci__nlsCharSetConvert(env->handle, env->charsetId,
+                timezoneBuffer, sizeof(timezoneBuffer), DPI_CHARSET_ID_ASCII,
+                "+00:00", 6, &timezoneLength, error) < 0)
+            return DPI_FAILURE;
+        if (dpiOci__dateTimeConstruct(env->handle, *storedBaseDate, 1970, 1, 1,
+                0, 0, 0, 0, timezoneBuffer, timezoneLength, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    *baseDate = *storedBaseDate;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiEnv__free() [INTERNAL]
+//   Free the memory associated with the environment.
+//-----------------------------------------------------------------------------
+void dpiEnv__free(dpiEnv *env, dpiError *error)
+{
+    if (env->threaded)
+        dpiMutex__destroy(env->mutex);
+    if (env->handle && !env->externalHandle) {
+        dpiOci__handleFree(env->handle, DPI_OCI_HTYPE_ENV);
+        env->handle = NULL;
+    }
+    if (env->errorHandles) {
+        dpiHandlePool__free(env->errorHandles);
+        env->errorHandles = NULL;
+        error->handle = NULL;
+    }
+    dpiUtils__freeMemory(env);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiEnv__getCharacterSetIdAndName() [INTERNAL]
+//   Retrieve and store the IANA character set name for the attribute.
+//-----------------------------------------------------------------------------
+static int dpiEnv__getCharacterSetIdAndName(dpiEnv *env, uint16_t attribute,
+        uint16_t *charsetId, char *encoding, dpiError *error)
+{
+    *charsetId = 0;
+    dpiOci__attrGet(env->handle, DPI_OCI_HTYPE_ENV, charsetId, NULL, attribute,
+            "get environment", error);
+    return dpiGlobal__lookupEncoding(*charsetId, encoding, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiEnv__getEncodingInfo() [INTERNAL]
+//   Populate the structure with the encoding info.
+//-----------------------------------------------------------------------------
+int dpiEnv__getEncodingInfo(dpiEnv *env, dpiEncodingInfo *info)
+{
+    info->encoding = env->encoding;
+    info->maxBytesPerCharacter = env->maxBytesPerCharacter;
+    info->nencoding = env->nencoding;
+    info->nmaxBytesPerCharacter = env->nmaxBytesPerCharacter;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiEnv__init() [INTERNAL]
+//   Initialize the environment structure. If an external handle is provided it
+// is used directly; otherwise, a new OCI environment handle is created. In
+// either case, information about the environment is stored for later use.
+//-----------------------------------------------------------------------------
+int dpiEnv__init(dpiEnv *env, const dpiContext *context,
+        const dpiCommonCreateParams *params, void *externalHandle,
+        dpiCreateMode createMode, dpiError *error)
+{
+    int temp;
+
+    // store context and version information
+    env->context = context;
+    env->versionInfo = context->versionInfo;
+
+    // an external handle is available, use it directly
+    if (externalHandle) {
+        env->handle = externalHandle;
+        env->externalHandle = 1;
+
+    // otherwise, lookup encodings
+    } else {
+
+        // lookup encoding
+        if (params->encoding && dpiGlobal__lookupCharSet(params->encoding,
+                &env->charsetId, error) < 0)
+            return DPI_FAILURE;
+
+        // check for identical encoding before performing lookup of national
+        // character set encoding
+        if (params->nencoding && params->encoding &&
+                strcmp(params->nencoding, params->encoding) == 0)
+            env->ncharsetId = env->charsetId;
+        else if (params->nencoding &&
+                dpiGlobal__lookupCharSet(params->nencoding,
+                        &env->ncharsetId, error) < 0)
+            return DPI_FAILURE;
+
+        // both charsetId and ncharsetId must be zero or both must be non-zero
+        // use NLS routine to look up missing value, if needed
+        if (env->charsetId && !env->ncharsetId) {
+            if (dpiOci__nlsEnvironmentVariableGet(DPI_OCI_NLS_NCHARSET_ID,
+                    &env->ncharsetId, error) < 0)
+                return DPI_FAILURE;
+        } else if (!env->charsetId && env->ncharsetId) {
+            if (dpiOci__nlsEnvironmentVariableGet(DPI_OCI_NLS_CHARSET_ID,
+                    &env->charsetId, error) < 0)
+                return DPI_FAILURE;
+        }
+
+        // create new environment handle
+        if (dpiOci__envNlsCreate(&env->handle, createMode | DPI_OCI_OBJECT,
+                env->charsetId, env->ncharsetId, error) < 0)
+            return DPI_FAILURE;
+
+    }
+
+    // create the error handle pool
+    if (dpiHandlePool__create(&env->errorHandles, error) < 0)
+        return DPI_FAILURE;
+    error->env = env;
+
+    // if threaded, create mutex for reference counts
+    if (createMode & DPI_OCI_THREADED)
+        dpiMutex__initialize(env->mutex);
+
+    // determine encodings in use
+    if (dpiEnv__getCharacterSetIdAndName(env, DPI_OCI_ATTR_CHARSET_ID,
+            &env->charsetId, env->encoding, error) < 0)
+        return DPI_FAILURE;
+    if (dpiEnv__getCharacterSetIdAndName(env, DPI_OCI_ATTR_NCHARSET_ID,
+            &env->ncharsetId, env->nencoding, error) < 0)
+        return DPI_FAILURE;
+
+    // acquire max bytes per character
+    if (dpiOci__nlsNumericInfoGet(env->handle, &env->maxBytesPerCharacter,
+            DPI_OCI_NLS_CHARSET_MAXBYTESZ, error) < 0)
+        return DPI_FAILURE;
+
+    // for NCHAR we have no idea of how many so we simply take the worst case
+    // unless the charsets are identical
+    if (env->ncharsetId == env->charsetId)
+        env->nmaxBytesPerCharacter = env->maxBytesPerCharacter;
+    else env->nmaxBytesPerCharacter = 4;
+
+    // set whether or not we are threaded
+    if (createMode & DPI_MODE_CREATE_THREADED)
+        env->threaded = 1;
+
+    // set whether or not events mode has been set
+    if (createMode & DPI_MODE_CREATE_EVENTS)
+        env->events = 1;
+
+    // enable SODA metadata cache, if applicable
+    if (params->sodaMetadataCache) {
+        if (dpiUtils__checkClientVersionMulti(env->versionInfo, 19, 11, 21, 3,
+                error) < 0)
+            return DPI_FAILURE;
+        temp = 1;
+        if (dpiOci__attrSet(env->handle, DPI_OCI_HTYPE_ENV, &temp, 0,
+                DPI_OCI_ATTR_SODA_METADATA_CACHE, "set SODA metadata cache",
+                error) < 0)
+            return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiError.c ./odpi/src/dpiError.c
--- patched-godror/odpi/src/dpiError.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiError.c	1970-01-01 01:00:00
@@ -1,289 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiError.c
-//   Implementation of error.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-#include "dpiErrorMessages.h"
-
-//-----------------------------------------------------------------------------
-// dpiError__getInfo() [INTERNAL]
-//   Get the error state from the error structure. Returns DPI_FAILURE as a
-// convenience to the caller.
-//-----------------------------------------------------------------------------
-int dpiError__getInfo(dpiError *error, dpiErrorInfo *info)
-{
-    if (!info)
-        return DPI_FAILURE;
-    info->code = error->buffer->code;
-    info->offset = error->buffer->offset;
-    info->offset16 = (uint16_t) error->buffer->offset;
-    info->message = error->buffer->message;
-    info->messageLength = error->buffer->messageLength;
-    info->fnName = error->buffer->fnName;
-    info->action = error->buffer->action;
-    info->isRecoverable = error->buffer->isRecoverable;
-    info->encoding = error->buffer->encoding;
-    info->isWarning = error->buffer->isWarning;
-    if (info->code == 12154) {
-        info->sqlState = "42S02";
-    } else if (error->buffer->errorNum == DPI_ERR_CONN_CLOSED) {
-        info->sqlState = "01002";
-    } else if (error->buffer->code == 0 &&
-            error->buffer->errorNum == (dpiErrorNum) 0) {
-        info->sqlState = "00000";
-    } else {
-        info->sqlState = "HY000";
-    }
-    return DPI_FAILURE;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiError__initHandle() [INTERNAL]
-//   Retrieve the OCI error handle to use for error handling, from a pool of
-// error handles common to the environment handle stored on the error. This
-// environment also controls the encoding of OCI errors (which uses the CHAR
-// encoding of the environment).
-//-----------------------------------------------------------------------------
-int dpiError__initHandle(dpiError *error)
-{
-    if (dpiHandlePool__acquire(error->env->errorHandles, &error->handle,
-            error) < 0)
-        return DPI_FAILURE;
-    if (!error->handle) {
-        if (dpiOci__handleAlloc(error->env->handle, &error->handle,
-                DPI_OCI_HTYPE_ERROR, "allocate OCI error", error) < 0)
-            return DPI_FAILURE;
-    }
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiError__set() [INTERNAL]
-//   Set the error buffer to the specified DPI error. Returns DPI_FAILURE as a
-// convenience to the caller.
-//-----------------------------------------------------------------------------
-int dpiError__set(dpiError *error, const char *action, dpiErrorNum errorNum,
-        ...)
-{
-    va_list varArgs;
-
-    if (error) {
-        error->buffer->code = 0;
-        error->buffer->isRecoverable = 0;
-        error->buffer->isWarning = 0;
-        error->buffer->offset = 0;
-        strcpy(error->buffer->encoding, DPI_CHARSET_NAME_UTF8);
-        error->buffer->action = action;
-        error->buffer->errorNum = errorNum;
-        va_start(varArgs, errorNum);
-        error->buffer->messageLength =
-                (uint32_t) vsnprintf(error->buffer->message,
-                sizeof(error->buffer->message),
-                dpiErrorMessages[errorNum - DPI_ERR_NO_ERR], varArgs);
-        va_end(varArgs);
-        if (dpiDebugLevel & DPI_DEBUG_LEVEL_ERRORS)
-            dpiDebug__print("internal error %.*s (%s / %s)\n",
-                    error->buffer->messageLength, error->buffer->message,
-                    error->buffer->fnName, action);
-    }
-    return DPI_FAILURE;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiError__setFromOCI() [INTERNAL]
-//   Called when an OCI error has occurred and sets the error structure with
-// the contents of that error. Note that trailing newlines and spaces are
-// truncated from the message if they exist. If the connection is not NULL a
-// check is made to see if the connection is no longer viable. The value
-// DPI_FAILURE is returned as a convenience to the caller, except when the
-// status of the call is DPI_OCI_SUCCESS_WITH_INFO, which is treated as a
-// successful call.
-//-----------------------------------------------------------------------------
-int dpiError__setFromOCI(dpiError *error, int status, dpiConn *conn,
-        const char *action)
-{
-    uint32_t callTimeout, serverStatus;
-
-    // special error cases
-    if (status == DPI_OCI_INVALID_HANDLE)
-        return dpiError__set(error, action, DPI_ERR_INVALID_HANDLE, "OCI");
-    else if (!error)
-        return DPI_FAILURE;
-    else if (!error->handle)
-        return dpiError__set(error, action, DPI_ERR_ERR_NOT_INITIALIZED);
-    else if (status != DPI_OCI_ERROR && status != DPI_OCI_NO_DATA &&
-            status != DPI_OCI_SUCCESS_WITH_INFO)
-        return dpiError__set(error, action,
-                DPI_ERR_UNEXPECTED_OCI_RETURN_VALUE, status,
-                error->buffer->fnName);
-
-    // fetch OCI error
-    error->buffer->action = action;
-    strcpy(error->buffer->encoding, error->env->encoding);
-    if (dpiOci__errorGet(error->handle, DPI_OCI_HTYPE_ERROR,
-            error->env->charsetId, action, error) < 0)
-        return DPI_FAILURE;
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_ERRORS)
-        dpiDebug__print("OCI error %.*s (%s / %s)\n",
-                error->buffer->messageLength, error->buffer->message,
-                error->buffer->fnName, action);
-    if (status == DPI_OCI_SUCCESS_WITH_INFO) {
-        error->buffer->isWarning = 1;
-        return DPI_SUCCESS;
-    }
-
-    // determine if error is recoverable (Transaction Guard)
-    // if the attribute cannot be read properly, simply leave it as false;
-    // otherwise, that error will mask the one that we really want to see
-    error->buffer->isRecoverable = 0;
-    dpiOci__attrGet(error->handle, DPI_OCI_HTYPE_ERROR,
-            (void*) &error->buffer->isRecoverable, 0,
-            DPI_OCI_ATTR_ERROR_IS_RECOVERABLE, NULL, error);
-
-    // check the health of the connection (if one was specified in this call
-    // and we are not in the middle of creating that connection)
-    if (conn && !conn->creating && !conn->deadSession) {
-
-        // first check the attribute specifically designed to check the health
-        // of the connection, if possible
-        if (conn->serverHandle) {
-            if (dpiOci__attrGet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
-                    &serverStatus, NULL, DPI_OCI_ATTR_SERVER_STATUS,
-                    "get server status", error) < 0 ||
-                    serverStatus != DPI_OCI_SERVER_NORMAL) {
-                conn->deadSession = 1;
-            }
-        }
-
-        // check for certain errors which indicate that the session is dead
-        if (!conn->deadSession) {
-            switch (error->buffer->code) {
-                case    22: // invalid session ID; access denied
-                case    28: // your session has been killed
-                case    31: // your session has been marked for kill
-                case    45: // your session has been terminated with no replay
-                case   378: // buffer pools cannot be created as specified
-                case   602: // internal programming exception
-                case   603: // ORACLE server session terminated by fatal error
-                case   609: // could not attach to incoming connection
-                case  1012: // not logged on
-                case  1041: // internal error. hostdef extension doesn't exist
-                case  1043: // user side memory corruption
-                case  1089: // immediate shutdown or close in progress
-                case  1092: // ORACLE instance terminated. Disconnection forced
-                case  2396: // exceeded maximum idle time, please connect again
-                case  3113: // end-of-file on communication channel
-                case  3114: // not connected to ORACLE
-                case  3122: // attempt to close ORACLE-side window on user side
-                case  3135: // connection lost contact
-                case 12153: // TNS:not connected
-                case 12537: // TNS:connection closed
-                case 12547: // TNS:lost contact
-                case 12570: // TNS:packet reader failure
-                case 12583: // TNS:no reader
-                case 27146: // post/wait initialization failed
-                case 28511: // lost RPC connection
-                case 56600: // an illegal OCI function call was issued
-                    conn->deadSession = 1;
-                    break;
-            }
-        }
-
-        // if session is marked as dead, return a unified error message
-        if (conn->deadSession) {
-            dpiError__set(error, action, DPI_ERR_CONN_CLOSED,
-                    error->buffer->code);
-            error->buffer->code = 0;
-            return DPI_FAILURE;
-        }
-
-        // check for call timeout and return a unified message instead
-        switch (error->buffer->code) {
-            case  3136: // inbound connection timed out
-            case  3156: // OCI call timed out
-            case 12161: // TNS:internal error: partial data received
-                callTimeout = 0;
-                if (conn->env->versionInfo->versionNum >= 18)
-                    dpiOci__attrGet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
-                            (void*) &callTimeout, 0, DPI_OCI_ATTR_CALL_TIMEOUT,
-                            NULL, error);
-                if (callTimeout > 0) {
-                    dpiError__set(error, action, DPI_ERR_CALL_TIMEOUT,
-                            callTimeout, error->buffer->code);
-                    error->buffer->code = 0;
-                }
-                break;
-        }
-
-    }
-
-    return DPI_FAILURE;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiError__setFromOS() [INTERNAL]
-//   Set the error buffer to a general OS error. Returns DPI_FAILURE as a
-// convenience to the caller.
-//-----------------------------------------------------------------------------
-int dpiError__setFromOS(dpiError *error, const char *action)
-{
-    char *message;
-
-#ifdef _WIN32
-
-    size_t messageLength = 0;
-
-    message = NULL;
-    if (dpiUtils__getWindowsError(GetLastError(), &message, &messageLength,
-            error) < 0)
-        return DPI_FAILURE;
-    dpiError__set(error, action, DPI_ERR_OS, message);
-    dpiUtils__freeMemory(message);
-
-#else
-
-    char buffer[512];
-    int err = errno;
-#if defined(__GLIBC__) || defined(__CYGWIN__)
-    message = strerror_r(err, buffer, sizeof(buffer));
-#else
-    message = (strerror_r(err, buffer, sizeof(buffer)) == 0) ? buffer : NULL;
-#endif
-    if (!message) {
-        (void) sprintf(buffer, "unable to get OS error %d", err);
-        message = buffer;
-    }
-    dpiError__set(error, action, DPI_ERR_OS, message);
-
-#endif
-    return DPI_FAILURE;
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiError.h ./odpi/src/dpiError.h
--- patched-godror/odpi/src/dpiError.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiError.h	2024-05-14 14:55:13
@@ -0,0 +1,289 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiError.c
+//   Implementation of error.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+#include "dpiErrorMessages.h"
+
+//-----------------------------------------------------------------------------
+// dpiError__getInfo() [INTERNAL]
+//   Get the error state from the error structure. Returns DPI_FAILURE as a
+// convenience to the caller.
+//-----------------------------------------------------------------------------
+int dpiError__getInfo(dpiError *error, dpiErrorInfo *info)
+{
+    if (!info)
+        return DPI_FAILURE;
+    info->code = error->buffer->code;
+    info->offset = error->buffer->offset;
+    info->offset16 = (uint16_t) error->buffer->offset;
+    info->message = error->buffer->message;
+    info->messageLength = error->buffer->messageLength;
+    info->fnName = error->buffer->fnName;
+    info->action = error->buffer->action;
+    info->isRecoverable = error->buffer->isRecoverable;
+    info->encoding = error->buffer->encoding;
+    info->isWarning = error->buffer->isWarning;
+    if (info->code == 12154) {
+        info->sqlState = "42S02";
+    } else if (error->buffer->errorNum == DPI_ERR_CONN_CLOSED) {
+        info->sqlState = "01002";
+    } else if (error->buffer->code == 0 &&
+            error->buffer->errorNum == (dpiErrorNum) 0) {
+        info->sqlState = "00000";
+    } else {
+        info->sqlState = "HY000";
+    }
+    return DPI_FAILURE;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiError__initHandle() [INTERNAL]
+//   Retrieve the OCI error handle to use for error handling, from a pool of
+// error handles common to the environment handle stored on the error. This
+// environment also controls the encoding of OCI errors (which uses the CHAR
+// encoding of the environment).
+//-----------------------------------------------------------------------------
+int dpiError__initHandle(dpiError *error)
+{
+    if (dpiHandlePool__acquire(error->env->errorHandles, &error->handle,
+            error) < 0)
+        return DPI_FAILURE;
+    if (!error->handle) {
+        if (dpiOci__handleAlloc(error->env->handle, &error->handle,
+                DPI_OCI_HTYPE_ERROR, "allocate OCI error", error) < 0)
+            return DPI_FAILURE;
+    }
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiError__set() [INTERNAL]
+//   Set the error buffer to the specified DPI error. Returns DPI_FAILURE as a
+// convenience to the caller.
+//-----------------------------------------------------------------------------
+int dpiError__set(dpiError *error, const char *action, dpiErrorNum errorNum,
+        ...)
+{
+    va_list varArgs;
+
+    if (error) {
+        error->buffer->code = 0;
+        error->buffer->isRecoverable = 0;
+        error->buffer->isWarning = 0;
+        error->buffer->offset = 0;
+        strcpy(error->buffer->encoding, DPI_CHARSET_NAME_UTF8);
+        error->buffer->action = action;
+        error->buffer->errorNum = errorNum;
+        va_start(varArgs, errorNum);
+        error->buffer->messageLength =
+                (uint32_t) vsnprintf(error->buffer->message,
+                sizeof(error->buffer->message),
+                dpiErrorMessages[errorNum - DPI_ERR_NO_ERR], varArgs);
+        va_end(varArgs);
+        if (dpiDebugLevel & DPI_DEBUG_LEVEL_ERRORS)
+            dpiDebug__print("internal error %.*s (%s / %s)\n",
+                    error->buffer->messageLength, error->buffer->message,
+                    error->buffer->fnName, action);
+    }
+    return DPI_FAILURE;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiError__setFromOCI() [INTERNAL]
+//   Called when an OCI error has occurred and sets the error structure with
+// the contents of that error. Note that trailing newlines and spaces are
+// truncated from the message if they exist. If the connection is not NULL a
+// check is made to see if the connection is no longer viable. The value
+// DPI_FAILURE is returned as a convenience to the caller, except when the
+// status of the call is DPI_OCI_SUCCESS_WITH_INFO, which is treated as a
+// successful call.
+//-----------------------------------------------------------------------------
+int dpiError__setFromOCI(dpiError *error, int status, dpiConn *conn,
+        const char *action)
+{
+    uint32_t callTimeout, serverStatus;
+
+    // special error cases
+    if (status == DPI_OCI_INVALID_HANDLE)
+        return dpiError__set(error, action, DPI_ERR_INVALID_HANDLE, "OCI");
+    else if (!error)
+        return DPI_FAILURE;
+    else if (!error->handle)
+        return dpiError__set(error, action, DPI_ERR_ERR_NOT_INITIALIZED);
+    else if (status != DPI_OCI_ERROR && status != DPI_OCI_NO_DATA &&
+            status != DPI_OCI_SUCCESS_WITH_INFO)
+        return dpiError__set(error, action,
+                DPI_ERR_UNEXPECTED_OCI_RETURN_VALUE, status,
+                error->buffer->fnName);
+
+    // fetch OCI error
+    error->buffer->action = action;
+    strcpy(error->buffer->encoding, error->env->encoding);
+    if (dpiOci__errorGet(error->handle, DPI_OCI_HTYPE_ERROR,
+            error->env->charsetId, action, error) < 0)
+        return DPI_FAILURE;
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_ERRORS)
+        dpiDebug__print("OCI error %.*s (%s / %s)\n",
+                error->buffer->messageLength, error->buffer->message,
+                error->buffer->fnName, action);
+    if (status == DPI_OCI_SUCCESS_WITH_INFO) {
+        error->buffer->isWarning = 1;
+        return DPI_SUCCESS;
+    }
+
+    // determine if error is recoverable (Transaction Guard)
+    // if the attribute cannot be read properly, simply leave it as false;
+    // otherwise, that error will mask the one that we really want to see
+    error->buffer->isRecoverable = 0;
+    dpiOci__attrGet(error->handle, DPI_OCI_HTYPE_ERROR,
+            (void*) &error->buffer->isRecoverable, 0,
+            DPI_OCI_ATTR_ERROR_IS_RECOVERABLE, NULL, error);
+
+    // check the health of the connection (if one was specified in this call
+    // and we are not in the middle of creating that connection)
+    if (conn && !conn->creating && !conn->deadSession) {
+
+        // first check the attribute specifically designed to check the health
+        // of the connection, if possible
+        if (conn->serverHandle) {
+            if (dpiOci__attrGet(conn->serverHandle, DPI_OCI_HTYPE_SERVER,
+                    &serverStatus, NULL, DPI_OCI_ATTR_SERVER_STATUS,
+                    "get server status", error) < 0 ||
+                    serverStatus != DPI_OCI_SERVER_NORMAL) {
+                conn->deadSession = 1;
+            }
+        }
+
+        // check for certain errors which indicate that the session is dead
+        if (!conn->deadSession) {
+            switch (error->buffer->code) {
+                case    22: // invalid session ID; access denied
+                case    28: // your session has been killed
+                case    31: // your session has been marked for kill
+                case    45: // your session has been terminated with no replay
+                case   378: // buffer pools cannot be created as specified
+                case   602: // internal programming exception
+                case   603: // ORACLE server session terminated by fatal error
+                case   609: // could not attach to incoming connection
+                case  1012: // not logged on
+                case  1041: // internal error. hostdef extension doesn't exist
+                case  1043: // user side memory corruption
+                case  1089: // immediate shutdown or close in progress
+                case  1092: // ORACLE instance terminated. Disconnection forced
+                case  2396: // exceeded maximum idle time, please connect again
+                case  3113: // end-of-file on communication channel
+                case  3114: // not connected to ORACLE
+                case  3122: // attempt to close ORACLE-side window on user side
+                case  3135: // connection lost contact
+                case 12153: // TNS:not connected
+                case 12537: // TNS:connection closed
+                case 12547: // TNS:lost contact
+                case 12570: // TNS:packet reader failure
+                case 12583: // TNS:no reader
+                case 27146: // post/wait initialization failed
+                case 28511: // lost RPC connection
+                case 56600: // an illegal OCI function call was issued
+                    conn->deadSession = 1;
+                    break;
+            }
+        }
+
+        // if session is marked as dead, return a unified error message
+        if (conn->deadSession) {
+            dpiError__set(error, action, DPI_ERR_CONN_CLOSED,
+                    error->buffer->code);
+            error->buffer->code = 0;
+            return DPI_FAILURE;
+        }
+
+        // check for call timeout and return a unified message instead
+        switch (error->buffer->code) {
+            case  3136: // inbound connection timed out
+            case  3156: // OCI call timed out
+            case 12161: // TNS:internal error: partial data received
+                callTimeout = 0;
+                if (conn->env->versionInfo->versionNum >= 18)
+                    dpiOci__attrGet(conn->handle, DPI_OCI_HTYPE_SVCCTX,
+                            (void*) &callTimeout, 0, DPI_OCI_ATTR_CALL_TIMEOUT,
+                            NULL, error);
+                if (callTimeout > 0) {
+                    dpiError__set(error, action, DPI_ERR_CALL_TIMEOUT,
+                            callTimeout, error->buffer->code);
+                    error->buffer->code = 0;
+                }
+                break;
+        }
+
+    }
+
+    return DPI_FAILURE;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiError__setFromOS() [INTERNAL]
+//   Set the error buffer to a general OS error. Returns DPI_FAILURE as a
+// convenience to the caller.
+//-----------------------------------------------------------------------------
+int dpiError__setFromOS(dpiError *error, const char *action)
+{
+    char *message;
+
+#ifdef _WIN32
+
+    size_t messageLength = 0;
+
+    message = NULL;
+    if (dpiUtils__getWindowsError(GetLastError(), &message, &messageLength,
+            error) < 0)
+        return DPI_FAILURE;
+    dpiError__set(error, action, DPI_ERR_OS, message);
+    dpiUtils__freeMemory(message);
+
+#else
+
+    char buffer[512];
+    int err = errno;
+#if defined(__GLIBC__) || defined(__CYGWIN__)
+    message = strerror_r(err, buffer, sizeof(buffer));
+#else
+    message = (strerror_r(err, buffer, sizeof(buffer)) == 0) ? buffer : NULL;
+#endif
+    if (!message) {
+        (void) sprintf(buffer, "unable to get OS error %d", err);
+        message = buffer;
+    }
+    dpiError__set(error, action, DPI_ERR_OS, message);
+
+#endif
+    return DPI_FAILURE;
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiGen.c ./odpi/src/dpiGen.c
--- patched-godror/odpi/src/dpiGen.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiGen.c	1970-01-01 01:00:00
@@ -1,326 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiGen.c
-//   Generic routines for managing the types available through public APIs.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// definition of handle types
-//-----------------------------------------------------------------------------
-static const dpiTypeDef dpiAllTypeDefs[DPI_HTYPE_MAX - DPI_HTYPE_NONE - 1] = {
-    {
-        "dpiConn",                      // name
-        sizeof(dpiConn),                // size of structure
-        0x49DC600C,                     // check integer
-        (dpiTypeFreeProc) dpiConn__free
-    },
-    {
-        "dpiPool",                      // name
-        sizeof(dpiPool),                // size of structure
-        0x18E1AA4B,                     // check integer
-        (dpiTypeFreeProc) dpiPool__free
-    },
-    {
-        "dpiStmt",                      // name
-        sizeof(dpiStmt),                // size of structure
-        0x31B02B2E,                     // check integer
-        (dpiTypeFreeProc) dpiStmt__free
-    },
-    {
-        "dpiVar",                       // name
-        sizeof(dpiVar),                 // size of structure
-        0x2AE8C6DC,                     // check integer
-        (dpiTypeFreeProc) dpiVar__free
-    },
-    {
-        "dpiLob",                       // name
-        sizeof(dpiLob),                 // size of structure
-        0xD8F31746,                     // check integer
-        (dpiTypeFreeProc) dpiLob__free
-    },
-    {
-        "dpiObject",                    // name
-        sizeof(dpiObject),              // size of structure
-        0x38616080,                     // check integer
-        (dpiTypeFreeProc) dpiObject__free
-    },
-    {
-        "dpiObjectType",                // name
-        sizeof(dpiObjectType),          // size of structure
-        0x86036059,                     // check integer
-        (dpiTypeFreeProc) dpiObjectType__free
-    },
-    {
-        "dpiObjectAttr",                // name
-        sizeof(dpiObjectAttr),          // size of structure
-        0xea6d5dde,                     // check integer
-        (dpiTypeFreeProc) dpiObjectAttr__free
-    },
-    {
-        "dpiSubscr",                    // name
-        sizeof(dpiSubscr),              // size of structure
-        0xa415a1c0,                     // check integer
-        (dpiTypeFreeProc) dpiSubscr__free
-    },
-    {
-        "dpiDeqOptions",                // name
-        sizeof(dpiDeqOptions),          // size of structure
-        0x70ee498d,                     // check integer
-        (dpiTypeFreeProc) dpiDeqOptions__free
-    },
-    {
-        "dpiEnqOptions",                // name
-        sizeof(dpiEnqOptions),          // size of structure
-        0x682f3946,                     // check integer
-        (dpiTypeFreeProc) dpiEnqOptions__free
-    },
-    {
-        "dpiMsgProps",                  // name
-        sizeof(dpiMsgProps),            // size of structure
-        0xa2b75506,                     // check integer
-        (dpiTypeFreeProc) dpiMsgProps__free
-    },
-    {
-        "dpiRowid",                     // name
-        sizeof(dpiRowid),               // size of structure
-        0x6204fa04,                     // check integer
-        (dpiTypeFreeProc) dpiRowid__free
-    },
-    {
-        "dpiContext",                   // name
-        sizeof(dpiContext),             // size of structure
-        0xd81b9181,                     // check integer
-        NULL
-    },
-    {
-        "dpiSodaColl",                  // name
-        sizeof(dpiSodaColl),            // size of structure
-        0x3684db22,                     // check integer
-        (dpiTypeFreeProc) dpiSodaColl__free
-    },
-    {
-        "dpiSodaCollCursor",            // name
-        sizeof(dpiSodaCollCursor),      // size of structure
-        0xcdc73b86,                     // check integer
-        (dpiTypeFreeProc) dpiSodaCollCursor__free
-    },
-    {
-        "dpiSodaDb",                    // name
-        sizeof(dpiSodaDb),              // size of structure
-        0x1f386121,                     // check integer
-        (dpiTypeFreeProc) dpiSodaDb__free
-    },
-    {
-        "dpiSodaDoc",                   // name
-        sizeof(dpiSodaDoc),             // size of structure
-        0xaffd950a,                     // check integer
-        (dpiTypeFreeProc) dpiSodaDoc__free
-    },
-    {
-        "dpiSodaDocCursor",             // name
-        sizeof(dpiSodaDocCursor),       // size of structure
-        0x80ceb83b,                     // check integer
-        (dpiTypeFreeProc) dpiSodaDocCursor__free
-    },
-    {
-        "dpiQueue",                     // name
-        sizeof(dpiQueue),               // size of structure
-        0x54904ba2,                     // check integer
-        (dpiTypeFreeProc) dpiQueue__free
-    },
-    {
-        "dpiJson",                      // name
-        sizeof(dpiJson),                // size of structure
-        0xf6712bec,                     // check integer
-        (dpiTypeFreeProc) dpiJson__free
-    }
-};
-
-
-//-----------------------------------------------------------------------------
-// dpiGen__addRef() [INTERNAL]
-//   Add a reference to the specified handle.
-//-----------------------------------------------------------------------------
-int dpiGen__addRef(void *ptr, dpiHandleTypeNum typeNum, const char *fnName)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(ptr, typeNum, fnName, &error) < 0)
-        return dpiGen__endPublicFn(ptr, DPI_FAILURE, &error);
-    dpiGen__setRefCount(ptr, &error, 1);
-    return dpiGen__endPublicFn(ptr, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiGen__allocate() [INTERNAL]
-//   Allocate memory for the specified type and initialize the base fields. The
-// type specified is assumed to be valid. If the environment is specified, use
-// it; otherwise, create a new one. No additional initialization is performed.
-//-----------------------------------------------------------------------------
-int dpiGen__allocate(dpiHandleTypeNum typeNum, dpiEnv *env, void **handle,
-        dpiError *error)
-{
-    const dpiTypeDef *typeDef;
-    dpiBaseType *value;
-
-    typeDef = &dpiAllTypeDefs[typeNum - DPI_HTYPE_NONE - 1];
-    if (dpiUtils__allocateMemory(1, typeDef->size, 1, "allocate handle",
-            (void**) &value, error) < 0)
-        return DPI_FAILURE;
-    value->typeDef = typeDef;
-    value->checkInt = typeDef->checkInt;
-    value->refCount = 1;
-    if (!env && typeNum != DPI_HTYPE_CONTEXT) {
-        if (dpiUtils__allocateMemory(1, sizeof(dpiEnv), 1, "allocate env",
-                (void**) &env, error) < 0) {
-            dpiUtils__freeMemory(value);
-            return DPI_FAILURE;
-        }
-    }
-    value->env = env;
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_REFS)
-        dpiDebug__print("ref %p (%s) -> 1 [NEW]\n", value, typeDef->name);
-
-    *handle = value;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiGen__checkHandle() [INTERNAL]
-//   Check that the specific handle is valid, that it matches the type
-// requested and that the check integer is still in place.
-//-----------------------------------------------------------------------------
-int dpiGen__checkHandle(const void *ptr, dpiHandleTypeNum typeNum,
-        const char *action, dpiError *error)
-{
-    dpiBaseType *value = (dpiBaseType*) ptr;
-    const dpiTypeDef *typeDef;
-
-    typeDef = &dpiAllTypeDefs[typeNum - DPI_HTYPE_NONE - 1];
-    if (!ptr || value->typeDef != typeDef ||
-            value->checkInt != typeDef->checkInt)
-        return dpiError__set(error, action, DPI_ERR_INVALID_HANDLE,
-                typeDef->name);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiGen__endPublicFn() [INTERNAL]
-//   This method should be the last call made in any public method using an
-// ODPI-C handle (other than dpiContext which is handled differently).
-//-----------------------------------------------------------------------------
-int dpiGen__endPublicFn(const void *ptr, int returnValue, dpiError *error)
-{
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_FNS)
-        dpiDebug__print("fn end %s(%p) -> %d\n", error->buffer->fnName, ptr,
-                returnValue);
-    if (error->handle)
-        dpiHandlePool__release(error->env->errorHandles, &error->handle);
-
-    return returnValue;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiGen__release() [INTERNAL]
-//   Release a reference to the specified handle. If the reference count
-// reaches zero, the resources associated with the handle are released and
-// the memory associated with the handle is freed. Any internal references
-// held to other handles are also released.
-//-----------------------------------------------------------------------------
-int dpiGen__release(void *ptr, dpiHandleTypeNum typeNum, const char *fnName)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(ptr, typeNum, fnName, &error) < 0)
-        return dpiGen__endPublicFn(ptr, DPI_FAILURE, &error);
-    dpiGen__setRefCount(ptr, &error, -1);
-    return dpiGen__endPublicFn(ptr, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiGen__setRefCount() [INTERNAL]
-//   Increase or decrease the reference count by the given amount. The handle
-// is assumed to be valid at this point. If the environment is in threaded
-// mode, acquire the mutex first before making any adjustments to the reference
-// count. If the operation sets the reference count to zero, release all
-// resources and free the memory associated with the structure.
-//-----------------------------------------------------------------------------
-void dpiGen__setRefCount(void *ptr, dpiError *error, int increment)
-{
-    dpiBaseType *value = (dpiBaseType*) ptr;
-    unsigned localRefCount;
-
-    // if threaded need to protect modification of the refCount with a mutex;
-    // also ensure that if the reference count reaches zero that it is
-    // immediately marked invalid in order to avoid race conditions
-    if (value->env->threaded)
-        dpiMutex__acquire(value->env->mutex);
-    value->refCount += increment;
-    localRefCount = value->refCount;
-    if (localRefCount == 0)
-        dpiUtils__clearMemory(&value->checkInt, sizeof(value->checkInt));
-    if (value->env->threaded)
-        dpiMutex__release(value->env->mutex);
-
-    // reference count debugging
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_REFS)
-        dpiDebug__print("ref %p (%s) -> %d\n", ptr, value->typeDef->name,
-                localRefCount);
-
-    // if the refCount has reached zero, call the free routine
-    if (localRefCount == 0)
-        (*value->typeDef->freeProc)(value, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiGen__startPublicFn() [INTERNAL]
-//   This method should be the first call made in any public method using an
-// ODPI-C handle (other than dpiContext which is handled differently). The
-// handle is checked for validity and an error handle is acquired for use in
-// all subsequent calls.
-//-----------------------------------------------------------------------------
-int dpiGen__startPublicFn(const void *ptr, dpiHandleTypeNum typeNum,
-        const char *fnName, dpiError *error)
-{
-    dpiBaseType *value = (dpiBaseType*) ptr;
-
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_FNS)
-        dpiDebug__print("fn start %s(%p)\n", fnName, ptr);
-    if (dpiGlobal__initError(fnName, error) < 0)
-        return DPI_FAILURE;
-    if (dpiGen__checkHandle(ptr, typeNum, "check main handle", error) < 0)
-        return DPI_FAILURE;
-    error->env = value->env;
-    return DPI_SUCCESS;
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiGen.h ./odpi/src/dpiGen.h
--- patched-godror/odpi/src/dpiGen.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiGen.h	2024-05-14 14:55:13
@@ -0,0 +1,326 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiGen.c
+//   Generic routines for managing the types available through public APIs.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// definition of handle types
+//-----------------------------------------------------------------------------
+static const dpiTypeDef dpiAllTypeDefs[DPI_HTYPE_MAX - DPI_HTYPE_NONE - 1] = {
+    {
+        "dpiConn",                      // name
+        sizeof(dpiConn),                // size of structure
+        0x49DC600C,                     // check integer
+        (dpiTypeFreeProc) dpiConn__free
+    },
+    {
+        "dpiPool",                      // name
+        sizeof(dpiPool),                // size of structure
+        0x18E1AA4B,                     // check integer
+        (dpiTypeFreeProc) dpiPool__free
+    },
+    {
+        "dpiStmt",                      // name
+        sizeof(dpiStmt),                // size of structure
+        0x31B02B2E,                     // check integer
+        (dpiTypeFreeProc) dpiStmt__free
+    },
+    {
+        "dpiVar",                       // name
+        sizeof(dpiVar),                 // size of structure
+        0x2AE8C6DC,                     // check integer
+        (dpiTypeFreeProc) dpiVar__free
+    },
+    {
+        "dpiLob",                       // name
+        sizeof(dpiLob),                 // size of structure
+        0xD8F31746,                     // check integer
+        (dpiTypeFreeProc) dpiLob__free
+    },
+    {
+        "dpiObject",                    // name
+        sizeof(dpiObject),              // size of structure
+        0x38616080,                     // check integer
+        (dpiTypeFreeProc) dpiObject__free
+    },
+    {
+        "dpiObjectType",                // name
+        sizeof(dpiObjectType),          // size of structure
+        0x86036059,                     // check integer
+        (dpiTypeFreeProc) dpiObjectType__free
+    },
+    {
+        "dpiObjectAttr",                // name
+        sizeof(dpiObjectAttr),          // size of structure
+        0xea6d5dde,                     // check integer
+        (dpiTypeFreeProc) dpiObjectAttr__free
+    },
+    {
+        "dpiSubscr",                    // name
+        sizeof(dpiSubscr),              // size of structure
+        0xa415a1c0,                     // check integer
+        (dpiTypeFreeProc) dpiSubscr__free
+    },
+    {
+        "dpiDeqOptions",                // name
+        sizeof(dpiDeqOptions),          // size of structure
+        0x70ee498d,                     // check integer
+        (dpiTypeFreeProc) dpiDeqOptions__free
+    },
+    {
+        "dpiEnqOptions",                // name
+        sizeof(dpiEnqOptions),          // size of structure
+        0x682f3946,                     // check integer
+        (dpiTypeFreeProc) dpiEnqOptions__free
+    },
+    {
+        "dpiMsgProps",                  // name
+        sizeof(dpiMsgProps),            // size of structure
+        0xa2b75506,                     // check integer
+        (dpiTypeFreeProc) dpiMsgProps__free
+    },
+    {
+        "dpiRowid",                     // name
+        sizeof(dpiRowid),               // size of structure
+        0x6204fa04,                     // check integer
+        (dpiTypeFreeProc) dpiRowid__free
+    },
+    {
+        "dpiContext",                   // name
+        sizeof(dpiContext),             // size of structure
+        0xd81b9181,                     // check integer
+        NULL
+    },
+    {
+        "dpiSodaColl",                  // name
+        sizeof(dpiSodaColl),            // size of structure
+        0x3684db22,                     // check integer
+        (dpiTypeFreeProc) dpiSodaColl__free
+    },
+    {
+        "dpiSodaCollCursor",            // name
+        sizeof(dpiSodaCollCursor),      // size of structure
+        0xcdc73b86,                     // check integer
+        (dpiTypeFreeProc) dpiSodaCollCursor__free
+    },
+    {
+        "dpiSodaDb",                    // name
+        sizeof(dpiSodaDb),              // size of structure
+        0x1f386121,                     // check integer
+        (dpiTypeFreeProc) dpiSodaDb__free
+    },
+    {
+        "dpiSodaDoc",                   // name
+        sizeof(dpiSodaDoc),             // size of structure
+        0xaffd950a,                     // check integer
+        (dpiTypeFreeProc) dpiSodaDoc__free
+    },
+    {
+        "dpiSodaDocCursor",             // name
+        sizeof(dpiSodaDocCursor),       // size of structure
+        0x80ceb83b,                     // check integer
+        (dpiTypeFreeProc) dpiSodaDocCursor__free
+    },
+    {
+        "dpiQueue",                     // name
+        sizeof(dpiQueue),               // size of structure
+        0x54904ba2,                     // check integer
+        (dpiTypeFreeProc) dpiQueue__free
+    },
+    {
+        "dpiJson",                      // name
+        sizeof(dpiJson),                // size of structure
+        0xf6712bec,                     // check integer
+        (dpiTypeFreeProc) dpiJson__free
+    }
+};
+
+
+//-----------------------------------------------------------------------------
+// dpiGen__addRef() [INTERNAL]
+//   Add a reference to the specified handle.
+//-----------------------------------------------------------------------------
+int dpiGen__addRef(void *ptr, dpiHandleTypeNum typeNum, const char *fnName)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(ptr, typeNum, fnName, &error) < 0)
+        return dpiGen__endPublicFn(ptr, DPI_FAILURE, &error);
+    dpiGen__setRefCount(ptr, &error, 1);
+    return dpiGen__endPublicFn(ptr, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiGen__allocate() [INTERNAL]
+//   Allocate memory for the specified type and initialize the base fields. The
+// type specified is assumed to be valid. If the environment is specified, use
+// it; otherwise, create a new one. No additional initialization is performed.
+//-----------------------------------------------------------------------------
+int dpiGen__allocate(dpiHandleTypeNum typeNum, dpiEnv *env, void **handle,
+        dpiError *error)
+{
+    const dpiTypeDef *typeDef;
+    dpiBaseType *value;
+
+    typeDef = &dpiAllTypeDefs[typeNum - DPI_HTYPE_NONE - 1];
+    if (dpiUtils__allocateMemory(1, typeDef->size, 1, "allocate handle",
+            (void**) &value, error) < 0)
+        return DPI_FAILURE;
+    value->typeDef = typeDef;
+    value->checkInt = typeDef->checkInt;
+    value->refCount = 1;
+    if (!env && typeNum != DPI_HTYPE_CONTEXT) {
+        if (dpiUtils__allocateMemory(1, sizeof(dpiEnv), 1, "allocate env",
+                (void**) &env, error) < 0) {
+            dpiUtils__freeMemory(value);
+            return DPI_FAILURE;
+        }
+    }
+    value->env = env;
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_REFS)
+        dpiDebug__print("ref %p (%s) -> 1 [NEW]\n", value, typeDef->name);
+
+    *handle = value;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiGen__checkHandle() [INTERNAL]
+//   Check that the specific handle is valid, that it matches the type
+// requested and that the check integer is still in place.
+//-----------------------------------------------------------------------------
+int dpiGen__checkHandle(const void *ptr, dpiHandleTypeNum typeNum,
+        const char *action, dpiError *error)
+{
+    dpiBaseType *value = (dpiBaseType*) ptr;
+    const dpiTypeDef *typeDef;
+
+    typeDef = &dpiAllTypeDefs[typeNum - DPI_HTYPE_NONE - 1];
+    if (!ptr || value->typeDef != typeDef ||
+            value->checkInt != typeDef->checkInt)
+        return dpiError__set(error, action, DPI_ERR_INVALID_HANDLE,
+                typeDef->name);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiGen__endPublicFn() [INTERNAL]
+//   This method should be the last call made in any public method using an
+// ODPI-C handle (other than dpiContext which is handled differently).
+//-----------------------------------------------------------------------------
+int dpiGen__endPublicFn(const void *ptr, int returnValue, dpiError *error)
+{
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_FNS)
+        dpiDebug__print("fn end %s(%p) -> %d\n", error->buffer->fnName, ptr,
+                returnValue);
+    if (error->handle)
+        dpiHandlePool__release(error->env->errorHandles, &error->handle);
+
+    return returnValue;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiGen__release() [INTERNAL]
+//   Release a reference to the specified handle. If the reference count
+// reaches zero, the resources associated with the handle are released and
+// the memory associated with the handle is freed. Any internal references
+// held to other handles are also released.
+//-----------------------------------------------------------------------------
+int dpiGen__release(void *ptr, dpiHandleTypeNum typeNum, const char *fnName)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(ptr, typeNum, fnName, &error) < 0)
+        return dpiGen__endPublicFn(ptr, DPI_FAILURE, &error);
+    dpiGen__setRefCount(ptr, &error, -1);
+    return dpiGen__endPublicFn(ptr, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiGen__setRefCount() [INTERNAL]
+//   Increase or decrease the reference count by the given amount. The handle
+// is assumed to be valid at this point. If the environment is in threaded
+// mode, acquire the mutex first before making any adjustments to the reference
+// count. If the operation sets the reference count to zero, release all
+// resources and free the memory associated with the structure.
+//-----------------------------------------------------------------------------
+void dpiGen__setRefCount(void *ptr, dpiError *error, int increment)
+{
+    dpiBaseType *value = (dpiBaseType*) ptr;
+    unsigned localRefCount;
+
+    // if threaded need to protect modification of the refCount with a mutex;
+    // also ensure that if the reference count reaches zero that it is
+    // immediately marked invalid in order to avoid race conditions
+    if (value->env->threaded)
+        dpiMutex__acquire(value->env->mutex);
+    value->refCount += increment;
+    localRefCount = value->refCount;
+    if (localRefCount == 0)
+        dpiUtils__clearMemory(&value->checkInt, sizeof(value->checkInt));
+    if (value->env->threaded)
+        dpiMutex__release(value->env->mutex);
+
+    // reference count debugging
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_REFS)
+        dpiDebug__print("ref %p (%s) -> %d\n", ptr, value->typeDef->name,
+                localRefCount);
+
+    // if the refCount has reached zero, call the free routine
+    if (localRefCount == 0)
+        (*value->typeDef->freeProc)(value, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiGen__startPublicFn() [INTERNAL]
+//   This method should be the first call made in any public method using an
+// ODPI-C handle (other than dpiContext which is handled differently). The
+// handle is checked for validity and an error handle is acquired for use in
+// all subsequent calls.
+//-----------------------------------------------------------------------------
+int dpiGen__startPublicFn(const void *ptr, dpiHandleTypeNum typeNum,
+        const char *fnName, dpiError *error)
+{
+    dpiBaseType *value = (dpiBaseType*) ptr;
+
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_FNS)
+        dpiDebug__print("fn start %s(%p)\n", fnName, ptr);
+    if (dpiGlobal__initError(fnName, error) < 0)
+        return DPI_FAILURE;
+    if (dpiGen__checkHandle(ptr, typeNum, "check main handle", error) < 0)
+        return DPI_FAILURE;
+    error->env = value->env;
+    return DPI_SUCCESS;
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiGlobal.c ./odpi/src/dpiGlobal.c
--- patched-godror/odpi/src/dpiGlobal.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiGlobal.c	1970-01-01 01:00:00
@@ -1,366 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiGlobal.c
-//   Global environment used for managing errors in a thread safe manner as
-// well as for looking up encodings.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-// cross platform way of defining an initializer that runs at application
-// startup (similar to what is done for the constructor calls for static C++
-// objects)
-#if defined(_MSC_VER)
-    #pragma section(".CRT$XCU", read)
-    #define DPI_INITIALIZER_HELPER(f, p) \
-        static void f(void); \
-        __declspec(allocate(".CRT$XCU")) void (*f##_)(void) = f; \
-        __pragma(comment(linker,"/include:" p #f "_")) \
-        static void f(void)
-    #ifdef _WIN64
-        #define DPI_INITIALIZER(f) DPI_INITIALIZER_HELPER(f, "")
-    #else
-        #define DPI_INITIALIZER(f) DPI_INITIALIZER_HELPER(f, "_")
-    #endif
-#else
-    #define DPI_INITIALIZER(f) \
-        static void f(void) __attribute__((constructor)); \
-        static void f(void)
-#endif
-
-// a global OCI environment is used for managing error buffers in a thread-safe
-// manner; each thread is given its own error buffer; OCI error handles,
-// though, must be created within the OCI environment created for use by
-// standalone connections and session pools
-static void *dpiGlobalEnvHandle = NULL;
-static void *dpiGlobalErrorHandle = NULL;
-static void *dpiGlobalThreadKey = NULL;
-static dpiErrorBuffer dpiGlobalErrorBuffer;
-static dpiVersionInfo dpiGlobalClientVersionInfo;
-static int dpiGlobalInitialized = 0;
-
-// a global mutex is used to ensure that only one thread is used to perform
-// initialization of ODPI-C
-static dpiMutexType dpiGlobalMutex;
-
-// forward declarations of internal functions only used in this file
-static int dpiGlobal__extendedInitialize(dpiContextCreateParams *params,
-        const char *fnName, dpiError *error);
-static void dpiGlobal__finalize(void);
-static int dpiGlobal__getErrorBuffer(const char *fnName, dpiError *error);
-
-
-//-----------------------------------------------------------------------------
-// dpiGlobal__ensureInitialized() [INTERNAL]
-//   Ensure that all initializations of the global infrastructure used by
-// ODPI-C have been performed.  This is done by the first thread to execute
-// this function and includes loading the Oracle Call Interface (OCI) library
-// and creating a thread key used for managing error buffers in a thread-safe
-// manner.
-//-----------------------------------------------------------------------------
-int dpiGlobal__ensureInitialized(const char *fnName,
-        dpiContextCreateParams *params, dpiVersionInfo **clientVersionInfo,
-        dpiError *error)
-{
-    // initialize error buffer output to global error buffer structure; this is
-    // the value that is used if an error takes place before the thread local
-    // error structure can be returned
-    error->handle = NULL;
-    error->buffer = &dpiGlobalErrorBuffer;
-    error->buffer->fnName = fnName;
-
-    // perform global initializations, if needed
-    if (!dpiGlobalInitialized) {
-        dpiMutex__acquire(dpiGlobalMutex);
-        if (!dpiGlobalInitialized)
-            dpiGlobal__extendedInitialize(params, fnName, error);
-        dpiMutex__release(dpiGlobalMutex);
-        if (!dpiGlobalInitialized)
-            return DPI_FAILURE;
-    }
-
-    *clientVersionInfo = &dpiGlobalClientVersionInfo;
-    return dpiGlobal__getErrorBuffer(fnName, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiGlobal__extendedInitialize() [INTERNAL]
-//   Create the global environment used for managing error buffers in a
-// thread-safe manner. This environment is solely used for implementing thread
-// local storage for the error buffers and for looking up encodings given an
-// IANA or Oracle character set name.
-//-----------------------------------------------------------------------------
-static int dpiGlobal__extendedInitialize(dpiContextCreateParams *params,
-        const char *fnName, dpiError *error)
-{
-    int status;
-
-    // initialize debugging
-    dpiDebug__initialize();
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_FNS)
-        dpiDebug__print("fn start %s\n", fnName);
-
-    // load OCI library
-    if (dpiOci__loadLib(params, &dpiGlobalClientVersionInfo, error) < 0)
-        return DPI_FAILURE;
-
-    // create threaded OCI environment for storing error buffers and for
-    // looking up character sets; use character set AL32UTF8 solely to avoid
-    // the overhead of processing the environment variables; no error messages
-    // from this environment are ever used (ODPI-C specific error messages are
-    // used)
-    if (dpiOci__envNlsCreate(&dpiGlobalEnvHandle, DPI_OCI_THREADED,
-            DPI_CHARSET_ID_UTF8, DPI_CHARSET_ID_UTF8, error) < 0)
-        return DPI_FAILURE;
-
-    // create global error handle
-    if (dpiOci__handleAlloc(dpiGlobalEnvHandle, &dpiGlobalErrorHandle,
-            DPI_OCI_HTYPE_ERROR, "create global error", error) < 0) {
-        dpiOci__handleFree(dpiGlobalEnvHandle, DPI_OCI_HTYPE_ENV);
-        return DPI_FAILURE;
-    }
-
-    // create global thread key
-    status = dpiOci__threadKeyInit(dpiGlobalEnvHandle, dpiGlobalErrorHandle,
-            &dpiGlobalThreadKey, (void*) dpiUtils__freeMemory, error);
-    if (status < 0) {
-        dpiOci__handleFree(dpiGlobalEnvHandle, DPI_OCI_HTYPE_ENV);
-        return DPI_FAILURE;
-    }
-
-    // mark library as fully initialized
-    dpiGlobalInitialized = 1;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiGlobal__finalize() [INTERNAL]
-//   Called when the process terminates and ensures that everything is cleaned
-// up.
-//-----------------------------------------------------------------------------
-static void dpiGlobal__finalize(void)
-{
-    void *errorBuffer = NULL;
-    dpiError error;
-
-    dpiMutex__acquire(dpiGlobalMutex);
-    dpiGlobalInitialized = 0;
-    error.buffer = &dpiGlobalErrorBuffer;
-    if (dpiGlobalThreadKey) {
-        dpiOci__threadKeyGet(dpiGlobalEnvHandle, dpiGlobalErrorHandle,
-                dpiGlobalThreadKey, &errorBuffer, &error);
-        if (errorBuffer) {
-            dpiOci__threadKeySet(dpiGlobalEnvHandle, dpiGlobalErrorHandle,
-                    dpiGlobalThreadKey, NULL, &error);
-            dpiUtils__freeMemory(errorBuffer);
-        }
-        dpiOci__threadKeyDestroy(dpiGlobalEnvHandle, dpiGlobalErrorHandle,
-                &dpiGlobalThreadKey, &error);
-        dpiGlobalThreadKey = NULL;
-    }
-    if (dpiGlobalEnvHandle) {
-        dpiOci__handleFree(dpiGlobalEnvHandle, DPI_OCI_HTYPE_ENV);
-        dpiGlobalEnvHandle = NULL;
-    }
-    dpiMutex__release(dpiGlobalMutex);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiGlobal__getErrorBuffer() [INTERNAL]
-//   Get the thread local error buffer. This will replace use of the global
-// error buffer which is used until this function has completed successfully.
-// At this point it is assumed that the global infrastructure has been
-// initialialized successfully.
-//-----------------------------------------------------------------------------
-static int dpiGlobal__getErrorBuffer(const char *fnName, dpiError *error)
-{
-    dpiErrorBuffer *tempErrorBuffer;
-
-    // look up the error buffer specific to this thread
-    if (dpiOci__threadKeyGet(dpiGlobalEnvHandle, dpiGlobalErrorHandle,
-            dpiGlobalThreadKey, (void**) &tempErrorBuffer, error) < 0)
-        return DPI_FAILURE;
-
-    // if NULL, key has never been set for this thread, allocate new error
-    // buffer and set it
-    if (!tempErrorBuffer) {
-        if (dpiUtils__allocateMemory(1, sizeof(dpiErrorBuffer), 1,
-                "allocate error buffer", (void**) &tempErrorBuffer, error) < 0)
-            return DPI_FAILURE;
-        if (dpiOci__threadKeySet(dpiGlobalEnvHandle, dpiGlobalErrorHandle,
-                dpiGlobalThreadKey, tempErrorBuffer, error) < 0) {
-            dpiUtils__freeMemory(tempErrorBuffer);
-            return DPI_FAILURE;
-        }
-    }
-
-    // if a function name has been specified, clear error
-    // the only time a function name is not specified is for
-    // dpiContext_getError() when the error information is being retrieved
-    if (fnName) {
-        tempErrorBuffer->code = 0;
-        tempErrorBuffer->offset = 0;
-        tempErrorBuffer->errorNum = (dpiErrorNum) 0;
-        tempErrorBuffer->isRecoverable = 0;
-        tempErrorBuffer->messageLength = 0;
-        tempErrorBuffer->fnName = fnName;
-        tempErrorBuffer->action = "start";
-        tempErrorBuffer->isWarning = 0;
-        strcpy(tempErrorBuffer->encoding, DPI_CHARSET_NAME_UTF8);
-    }
-
-    error->buffer = tempErrorBuffer;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiGlobal__initError() [INTERNAL]
-//   Get the thread local error structure for use in all other functions. If
-// an error structure cannot be determined for some reason, the global error
-// buffer structure is returned instead.
-//-----------------------------------------------------------------------------
-int dpiGlobal__initError(const char *fnName, dpiError *error)
-{
-    // initialize error buffer output to global error buffer structure; this is
-    // the value that is used if an error takes place before the thread local
-    // error structure can be returned
-    error->handle = NULL;
-    error->buffer = &dpiGlobalErrorBuffer;
-    if (fnName)
-        error->buffer->fnName = fnName;
-
-    // check to see if global environment has been initialized; if not, no call
-    // to dpiContext_createWithParams() was made successfully
-    if (!dpiGlobalInitialized)
-        return dpiError__set(error, "check context creation",
-                DPI_ERR_CONTEXT_NOT_CREATED);
-
-    // acquire error buffer for the thread, if possible
-    return dpiGlobal__getErrorBuffer(fnName, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiGlobal__initialize() [INTERNAL]
-//   Initialization function that runs at process startup or when the library
-// is first loaded. Some operating systems have limits on what can be run in
-// this function, so most work is done in the dpiGlobal__extendedInitialize()
-// function that runs when the first call to dpiContext_createWithParams() is
-// made.
-//-----------------------------------------------------------------------------
-DPI_INITIALIZER(dpiGlobal__initialize)
-{
-    memset(&dpiGlobalErrorBuffer, 0, sizeof(dpiGlobalErrorBuffer));
-    strcpy(dpiGlobalErrorBuffer.encoding, DPI_CHARSET_NAME_UTF8);
-    dpiMutex__initialize(dpiGlobalMutex);
-    atexit(dpiGlobal__finalize);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiGlobal__lookupCharSet() [INTERNAL]
-//   Lookup the character set id that can be used in the call to
-// OCINlsEnvCreate().
-//-----------------------------------------------------------------------------
-int dpiGlobal__lookupCharSet(const char *name, uint16_t *charsetId,
-        dpiError *error)
-{
-    char oraCharsetName[DPI_OCI_NLS_MAXBUFSZ];
-
-    // check for well-known encodings first
-    if (strcmp(name, DPI_CHARSET_NAME_UTF8) == 0)
-        *charsetId = DPI_CHARSET_ID_UTF8;
-    else if (strcmp(name, DPI_CHARSET_NAME_UTF16) == 0)
-        *charsetId = DPI_CHARSET_ID_UTF16;
-    else if (strcmp(name, DPI_CHARSET_NAME_ASCII) == 0)
-        *charsetId = DPI_CHARSET_ID_ASCII;
-    else if (strcmp(name, DPI_CHARSET_NAME_UTF16LE) == 0 ||
-            strcmp(name, DPI_CHARSET_NAME_UTF16BE) == 0)
-        return dpiError__set(error, "check encoding", DPI_ERR_NOT_SUPPORTED);
-
-    // perform lookup; check for the Oracle character set name first and if
-    // that fails, lookup using the IANA character set name
-    else {
-        if (dpiOci__nlsCharSetNameToId(dpiGlobalEnvHandle, name, charsetId,
-                error) < 0)
-            return DPI_FAILURE;
-        if (!*charsetId) {
-            if (dpiOci__nlsNameMap(dpiGlobalEnvHandle, oraCharsetName,
-                    sizeof(oraCharsetName), name, DPI_OCI_NLS_CS_IANA_TO_ORA,
-                    error) < 0)
-                return dpiError__set(error, "lookup charset",
-                        DPI_ERR_INVALID_CHARSET, name);
-            dpiOci__nlsCharSetNameToId(dpiGlobalEnvHandle, oraCharsetName,
-                    charsetId, error);
-        }
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiGlobal__lookupEncoding() [INTERNAL]
-//   Get the IANA character set name (encoding) given the Oracle character set
-// id.
-//-----------------------------------------------------------------------------
-int dpiGlobal__lookupEncoding(uint16_t charsetId, char *encoding,
-        dpiError *error)
-{
-    char oracleName[DPI_OCI_NLS_MAXBUFSZ];
-
-    // check for well-known encodings first
-    switch (charsetId) {
-        case DPI_CHARSET_ID_UTF8:
-            strcpy(encoding, DPI_CHARSET_NAME_UTF8);
-            return DPI_SUCCESS;
-        case DPI_CHARSET_ID_UTF16:
-            strcpy(encoding, DPI_CHARSET_NAME_UTF16);
-            return DPI_SUCCESS;
-        case DPI_CHARSET_ID_ASCII:
-            strcpy(encoding, DPI_CHARSET_NAME_ASCII);
-            return DPI_SUCCESS;
-    }
-
-    // get character set name
-    if (dpiOci__nlsCharSetIdToName(dpiGlobalEnvHandle, oracleName,
-            sizeof(oracleName), charsetId, error) < 0)
-        return dpiError__set(error, "lookup Oracle character set name",
-                DPI_ERR_INVALID_CHARSET_ID, charsetId);
-
-    // get IANA character set name
-    if (dpiOci__nlsNameMap(dpiGlobalEnvHandle, encoding, DPI_OCI_NLS_MAXBUFSZ,
-            oracleName, DPI_OCI_NLS_CS_ORA_TO_IANA, error) < 0)
-        return dpiError__set(error, "lookup IANA name",
-                DPI_ERR_INVALID_CHARSET_ID, charsetId);
-
-    return DPI_SUCCESS;
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiGlobal.h ./odpi/src/dpiGlobal.h
--- patched-godror/odpi/src/dpiGlobal.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiGlobal.h	2024-05-14 14:55:13
@@ -0,0 +1,366 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiGlobal.c
+//   Global environment used for managing errors in a thread safe manner as
+// well as for looking up encodings.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+// cross platform way of defining an initializer that runs at application
+// startup (similar to what is done for the constructor calls for static C++
+// objects)
+#if defined(_MSC_VER)
+    #pragma section(".CRT$XCU", read)
+    #define DPI_INITIALIZER_HELPER(f, p) \
+        static void f(void); \
+        __declspec(allocate(".CRT$XCU")) void (*f##_)(void) = f; \
+        __pragma(comment(linker,"/include:" p #f "_")) \
+        static void f(void)
+    #ifdef _WIN64
+        #define DPI_INITIALIZER(f) DPI_INITIALIZER_HELPER(f, "")
+    #else
+        #define DPI_INITIALIZER(f) DPI_INITIALIZER_HELPER(f, "_")
+    #endif
+#else
+    #define DPI_INITIALIZER(f) \
+        static void f(void) __attribute__((constructor)); \
+        static void f(void)
+#endif
+
+// a global OCI environment is used for managing error buffers in a thread-safe
+// manner; each thread is given its own error buffer; OCI error handles,
+// though, must be created within the OCI environment created for use by
+// standalone connections and session pools
+static void *dpiGlobalEnvHandle = NULL;
+static void *dpiGlobalErrorHandle = NULL;
+static void *dpiGlobalThreadKey = NULL;
+static dpiErrorBuffer dpiGlobalErrorBuffer;
+static dpiVersionInfo dpiGlobalClientVersionInfo;
+static int dpiGlobalInitialized = 0;
+
+// a global mutex is used to ensure that only one thread is used to perform
+// initialization of ODPI-C
+static dpiMutexType dpiGlobalMutex;
+
+// forward declarations of internal functions only used in this file
+static int dpiGlobal__extendedInitialize(dpiContextCreateParams *params,
+        const char *fnName, dpiError *error);
+static void dpiGlobal__finalize(void);
+static int dpiGlobal__getErrorBuffer(const char *fnName, dpiError *error);
+
+
+//-----------------------------------------------------------------------------
+// dpiGlobal__ensureInitialized() [INTERNAL]
+//   Ensure that all initializations of the global infrastructure used by
+// ODPI-C have been performed.  This is done by the first thread to execute
+// this function and includes loading the Oracle Call Interface (OCI) library
+// and creating a thread key used for managing error buffers in a thread-safe
+// manner.
+//-----------------------------------------------------------------------------
+int dpiGlobal__ensureInitialized(const char *fnName,
+        dpiContextCreateParams *params, dpiVersionInfo **clientVersionInfo,
+        dpiError *error)
+{
+    // initialize error buffer output to global error buffer structure; this is
+    // the value that is used if an error takes place before the thread local
+    // error structure can be returned
+    error->handle = NULL;
+    error->buffer = &dpiGlobalErrorBuffer;
+    error->buffer->fnName = fnName;
+
+    // perform global initializations, if needed
+    if (!dpiGlobalInitialized) {
+        dpiMutex__acquire(dpiGlobalMutex);
+        if (!dpiGlobalInitialized)
+            dpiGlobal__extendedInitialize(params, fnName, error);
+        dpiMutex__release(dpiGlobalMutex);
+        if (!dpiGlobalInitialized)
+            return DPI_FAILURE;
+    }
+
+    *clientVersionInfo = &dpiGlobalClientVersionInfo;
+    return dpiGlobal__getErrorBuffer(fnName, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiGlobal__extendedInitialize() [INTERNAL]
+//   Create the global environment used for managing error buffers in a
+// thread-safe manner. This environment is solely used for implementing thread
+// local storage for the error buffers and for looking up encodings given an
+// IANA or Oracle character set name.
+//-----------------------------------------------------------------------------
+static int dpiGlobal__extendedInitialize(dpiContextCreateParams *params,
+        const char *fnName, dpiError *error)
+{
+    int status;
+
+    // initialize debugging
+    dpiDebug__initialize();
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_FNS)
+        dpiDebug__print("fn start %s\n", fnName);
+
+    // load OCI library
+    if (dpiOci__loadLib(params, &dpiGlobalClientVersionInfo, error) < 0)
+        return DPI_FAILURE;
+
+    // create threaded OCI environment for storing error buffers and for
+    // looking up character sets; use character set AL32UTF8 solely to avoid
+    // the overhead of processing the environment variables; no error messages
+    // from this environment are ever used (ODPI-C specific error messages are
+    // used)
+    if (dpiOci__envNlsCreate(&dpiGlobalEnvHandle, DPI_OCI_THREADED,
+            DPI_CHARSET_ID_UTF8, DPI_CHARSET_ID_UTF8, error) < 0)
+        return DPI_FAILURE;
+
+    // create global error handle
+    if (dpiOci__handleAlloc(dpiGlobalEnvHandle, &dpiGlobalErrorHandle,
+            DPI_OCI_HTYPE_ERROR, "create global error", error) < 0) {
+        dpiOci__handleFree(dpiGlobalEnvHandle, DPI_OCI_HTYPE_ENV);
+        return DPI_FAILURE;
+    }
+
+    // create global thread key
+    status = dpiOci__threadKeyInit(dpiGlobalEnvHandle, dpiGlobalErrorHandle,
+            &dpiGlobalThreadKey, (void*) dpiUtils__freeMemory, error);
+    if (status < 0) {
+        dpiOci__handleFree(dpiGlobalEnvHandle, DPI_OCI_HTYPE_ENV);
+        return DPI_FAILURE;
+    }
+
+    // mark library as fully initialized
+    dpiGlobalInitialized = 1;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiGlobal__finalize() [INTERNAL]
+//   Called when the process terminates and ensures that everything is cleaned
+// up.
+//-----------------------------------------------------------------------------
+static void dpiGlobal__finalize(void)
+{
+    void *errorBuffer = NULL;
+    dpiError error;
+
+    dpiMutex__acquire(dpiGlobalMutex);
+    dpiGlobalInitialized = 0;
+    error.buffer = &dpiGlobalErrorBuffer;
+    if (dpiGlobalThreadKey) {
+        dpiOci__threadKeyGet(dpiGlobalEnvHandle, dpiGlobalErrorHandle,
+                dpiGlobalThreadKey, &errorBuffer, &error);
+        if (errorBuffer) {
+            dpiOci__threadKeySet(dpiGlobalEnvHandle, dpiGlobalErrorHandle,
+                    dpiGlobalThreadKey, NULL, &error);
+            dpiUtils__freeMemory(errorBuffer);
+        }
+        dpiOci__threadKeyDestroy(dpiGlobalEnvHandle, dpiGlobalErrorHandle,
+                &dpiGlobalThreadKey, &error);
+        dpiGlobalThreadKey = NULL;
+    }
+    if (dpiGlobalEnvHandle) {
+        dpiOci__handleFree(dpiGlobalEnvHandle, DPI_OCI_HTYPE_ENV);
+        dpiGlobalEnvHandle = NULL;
+    }
+    dpiMutex__release(dpiGlobalMutex);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiGlobal__getErrorBuffer() [INTERNAL]
+//   Get the thread local error buffer. This will replace use of the global
+// error buffer which is used until this function has completed successfully.
+// At this point it is assumed that the global infrastructure has been
+// initialialized successfully.
+//-----------------------------------------------------------------------------
+static int dpiGlobal__getErrorBuffer(const char *fnName, dpiError *error)
+{
+    dpiErrorBuffer *tempErrorBuffer;
+
+    // look up the error buffer specific to this thread
+    if (dpiOci__threadKeyGet(dpiGlobalEnvHandle, dpiGlobalErrorHandle,
+            dpiGlobalThreadKey, (void**) &tempErrorBuffer, error) < 0)
+        return DPI_FAILURE;
+
+    // if NULL, key has never been set for this thread, allocate new error
+    // buffer and set it
+    if (!tempErrorBuffer) {
+        if (dpiUtils__allocateMemory(1, sizeof(dpiErrorBuffer), 1,
+                "allocate error buffer", (void**) &tempErrorBuffer, error) < 0)
+            return DPI_FAILURE;
+        if (dpiOci__threadKeySet(dpiGlobalEnvHandle, dpiGlobalErrorHandle,
+                dpiGlobalThreadKey, tempErrorBuffer, error) < 0) {
+            dpiUtils__freeMemory(tempErrorBuffer);
+            return DPI_FAILURE;
+        }
+    }
+
+    // if a function name has been specified, clear error
+    // the only time a function name is not specified is for
+    // dpiContext_getError() when the error information is being retrieved
+    if (fnName) {
+        tempErrorBuffer->code = 0;
+        tempErrorBuffer->offset = 0;
+        tempErrorBuffer->errorNum = (dpiErrorNum) 0;
+        tempErrorBuffer->isRecoverable = 0;
+        tempErrorBuffer->messageLength = 0;
+        tempErrorBuffer->fnName = fnName;
+        tempErrorBuffer->action = "start";
+        tempErrorBuffer->isWarning = 0;
+        strcpy(tempErrorBuffer->encoding, DPI_CHARSET_NAME_UTF8);
+    }
+
+    error->buffer = tempErrorBuffer;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiGlobal__initError() [INTERNAL]
+//   Get the thread local error structure for use in all other functions. If
+// an error structure cannot be determined for some reason, the global error
+// buffer structure is returned instead.
+//-----------------------------------------------------------------------------
+int dpiGlobal__initError(const char *fnName, dpiError *error)
+{
+    // initialize error buffer output to global error buffer structure; this is
+    // the value that is used if an error takes place before the thread local
+    // error structure can be returned
+    error->handle = NULL;
+    error->buffer = &dpiGlobalErrorBuffer;
+    if (fnName)
+        error->buffer->fnName = fnName;
+
+    // check to see if global environment has been initialized; if not, no call
+    // to dpiContext_createWithParams() was made successfully
+    if (!dpiGlobalInitialized)
+        return dpiError__set(error, "check context creation",
+                DPI_ERR_CONTEXT_NOT_CREATED);
+
+    // acquire error buffer for the thread, if possible
+    return dpiGlobal__getErrorBuffer(fnName, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiGlobal__initialize() [INTERNAL]
+//   Initialization function that runs at process startup or when the library
+// is first loaded. Some operating systems have limits on what can be run in
+// this function, so most work is done in the dpiGlobal__extendedInitialize()
+// function that runs when the first call to dpiContext_createWithParams() is
+// made.
+//-----------------------------------------------------------------------------
+DPI_INITIALIZER(dpiGlobal__initialize)
+{
+    memset(&dpiGlobalErrorBuffer, 0, sizeof(dpiGlobalErrorBuffer));
+    strcpy(dpiGlobalErrorBuffer.encoding, DPI_CHARSET_NAME_UTF8);
+    dpiMutex__initialize(dpiGlobalMutex);
+    atexit(dpiGlobal__finalize);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiGlobal__lookupCharSet() [INTERNAL]
+//   Lookup the character set id that can be used in the call to
+// OCINlsEnvCreate().
+//-----------------------------------------------------------------------------
+int dpiGlobal__lookupCharSet(const char *name, uint16_t *charsetId,
+        dpiError *error)
+{
+    char oraCharsetName[DPI_OCI_NLS_MAXBUFSZ];
+
+    // check for well-known encodings first
+    if (strcmp(name, DPI_CHARSET_NAME_UTF8) == 0)
+        *charsetId = DPI_CHARSET_ID_UTF8;
+    else if (strcmp(name, DPI_CHARSET_NAME_UTF16) == 0)
+        *charsetId = DPI_CHARSET_ID_UTF16;
+    else if (strcmp(name, DPI_CHARSET_NAME_ASCII) == 0)
+        *charsetId = DPI_CHARSET_ID_ASCII;
+    else if (strcmp(name, DPI_CHARSET_NAME_UTF16LE) == 0 ||
+            strcmp(name, DPI_CHARSET_NAME_UTF16BE) == 0)
+        return dpiError__set(error, "check encoding", DPI_ERR_NOT_SUPPORTED);
+
+    // perform lookup; check for the Oracle character set name first and if
+    // that fails, lookup using the IANA character set name
+    else {
+        if (dpiOci__nlsCharSetNameToId(dpiGlobalEnvHandle, name, charsetId,
+                error) < 0)
+            return DPI_FAILURE;
+        if (!*charsetId) {
+            if (dpiOci__nlsNameMap(dpiGlobalEnvHandle, oraCharsetName,
+                    sizeof(oraCharsetName), name, DPI_OCI_NLS_CS_IANA_TO_ORA,
+                    error) < 0)
+                return dpiError__set(error, "lookup charset",
+                        DPI_ERR_INVALID_CHARSET, name);
+            dpiOci__nlsCharSetNameToId(dpiGlobalEnvHandle, oraCharsetName,
+                    charsetId, error);
+        }
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiGlobal__lookupEncoding() [INTERNAL]
+//   Get the IANA character set name (encoding) given the Oracle character set
+// id.
+//-----------------------------------------------------------------------------
+int dpiGlobal__lookupEncoding(uint16_t charsetId, char *encoding,
+        dpiError *error)
+{
+    char oracleName[DPI_OCI_NLS_MAXBUFSZ];
+
+    // check for well-known encodings first
+    switch (charsetId) {
+        case DPI_CHARSET_ID_UTF8:
+            strcpy(encoding, DPI_CHARSET_NAME_UTF8);
+            return DPI_SUCCESS;
+        case DPI_CHARSET_ID_UTF16:
+            strcpy(encoding, DPI_CHARSET_NAME_UTF16);
+            return DPI_SUCCESS;
+        case DPI_CHARSET_ID_ASCII:
+            strcpy(encoding, DPI_CHARSET_NAME_ASCII);
+            return DPI_SUCCESS;
+    }
+
+    // get character set name
+    if (dpiOci__nlsCharSetIdToName(dpiGlobalEnvHandle, oracleName,
+            sizeof(oracleName), charsetId, error) < 0)
+        return dpiError__set(error, "lookup Oracle character set name",
+                DPI_ERR_INVALID_CHARSET_ID, charsetId);
+
+    // get IANA character set name
+    if (dpiOci__nlsNameMap(dpiGlobalEnvHandle, encoding, DPI_OCI_NLS_MAXBUFSZ,
+            oracleName, DPI_OCI_NLS_CS_ORA_TO_IANA, error) < 0)
+        return dpiError__set(error, "lookup IANA name",
+                DPI_ERR_INVALID_CHARSET_ID, charsetId);
+
+    return DPI_SUCCESS;
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiHandleList.c ./odpi/src/dpiHandleList.c
--- patched-godror/odpi/src/dpiHandleList.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiHandleList.c	1970-01-01 01:00:00
@@ -1,129 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2018, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiHandleList.c
-//   Implementation of a list of handles which are managed in a thread-safe
-// manner. The references to these handles are assumed to be held by other
-// structures. No references are held by the list of handles defined here.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiHandleList__addHandle() [INTERNAL]
-//   Add a handle to the list. The list is expanded in sets of 8 handles as
-// needed. A current position is maintained to reduce the number of scans of
-// the list are required. An empty slot is designated by a NULL pointer.
-//-----------------------------------------------------------------------------
-int dpiHandleList__addHandle(dpiHandleList *list, void *handle,
-        uint32_t *slotNum, dpiError *error)
-{
-    uint32_t numSlots, i;
-    void **tempHandles;
-
-    dpiMutex__acquire(list->mutex);
-    if (list->numUsedSlots == list->numSlots) {
-        numSlots = list->numSlots + 8;
-        if (dpiUtils__allocateMemory(numSlots, sizeof(void*), 1,
-                "allocate slots", (void**) &tempHandles, error) < 0) {
-            dpiMutex__release(list->mutex);
-            return DPI_FAILURE;
-        }
-        memcpy(tempHandles, list->handles, list->numSlots * sizeof(void*));
-        dpiUtils__freeMemory(list->handles);
-        list->handles = tempHandles;
-        list->numSlots = numSlots;
-        *slotNum = list->numUsedSlots++;
-        list->currentPos = list->numUsedSlots;
-    } else {
-        for (i = 0; i < list->numSlots; i++) {
-            if (!list->handles[list->currentPos])
-                break;
-            list->currentPos++;
-            if (list->currentPos == list->numSlots)
-                list->currentPos = 0;
-        }
-        list->numUsedSlots++;
-        *slotNum = list->currentPos++;
-        if (list->currentPos == list->numSlots)
-            list->currentPos = 0;
-    }
-    list->handles[*slotNum] = handle;
-    dpiMutex__release(list->mutex);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiHandleList__create() [INTERNAL]
-//   Create a new (empty) list of handles.
-//-----------------------------------------------------------------------------
-int dpiHandleList__create(dpiHandleList **list, dpiError *error)
-{
-    dpiHandleList *tempList;
-
-    if (dpiUtils__allocateMemory(1, sizeof(dpiHandleList), 0,
-            "allocate handle list", (void**) &tempList, error) < 0)
-        return DPI_FAILURE;
-    tempList->numSlots = 8;
-    tempList->numUsedSlots = 0;
-    if (dpiUtils__allocateMemory(tempList->numSlots, sizeof(void*), 1,
-            "allocate handle list slots", (void**) &tempList->handles,
-            error) < 0) {
-        dpiUtils__freeMemory(tempList);
-        return DPI_FAILURE;
-    }
-    dpiMutex__initialize(tempList->mutex);
-    tempList->currentPos = 0;
-    *list = tempList;
-    return DPI_SUCCESS;
-}
-
-//-----------------------------------------------------------------------------
-// dpiHandleList__free() [INTERNAL]
-//   Free the memory associated with the handle list.
-//-----------------------------------------------------------------------------
-void dpiHandleList__free(dpiHandleList *list)
-{
-    if (list->handles) {
-        dpiUtils__freeMemory(list->handles);
-        list->handles = NULL;
-    }
-    dpiMutex__destroy(list->mutex);
-    dpiUtils__freeMemory(list);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiHandleList__removeHandle() [INTERNAL]
-//   Remove the handle at the specified location from the list.
-//-----------------------------------------------------------------------------
-void dpiHandleList__removeHandle(dpiHandleList *list, uint32_t slotNum)
-{
-    dpiMutex__acquire(list->mutex);
-    list->handles[slotNum] = NULL;
-    list->numUsedSlots--;
-    dpiMutex__release(list->mutex);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiHandleList.h ./odpi/src/dpiHandleList.h
--- patched-godror/odpi/src/dpiHandleList.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiHandleList.h	2024-05-14 14:55:13
@@ -0,0 +1,129 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2018, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiHandleList.c
+//   Implementation of a list of handles which are managed in a thread-safe
+// manner. The references to these handles are assumed to be held by other
+// structures. No references are held by the list of handles defined here.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiHandleList__addHandle() [INTERNAL]
+//   Add a handle to the list. The list is expanded in sets of 8 handles as
+// needed. A current position is maintained to reduce the number of scans of
+// the list are required. An empty slot is designated by a NULL pointer.
+//-----------------------------------------------------------------------------
+int dpiHandleList__addHandle(dpiHandleList *list, void *handle,
+        uint32_t *slotNum, dpiError *error)
+{
+    uint32_t numSlots, i;
+    void **tempHandles;
+
+    dpiMutex__acquire(list->mutex);
+    if (list->numUsedSlots == list->numSlots) {
+        numSlots = list->numSlots + 8;
+        if (dpiUtils__allocateMemory(numSlots, sizeof(void*), 1,
+                "allocate slots", (void**) &tempHandles, error) < 0) {
+            dpiMutex__release(list->mutex);
+            return DPI_FAILURE;
+        }
+        memcpy(tempHandles, list->handles, list->numSlots * sizeof(void*));
+        dpiUtils__freeMemory(list->handles);
+        list->handles = tempHandles;
+        list->numSlots = numSlots;
+        *slotNum = list->numUsedSlots++;
+        list->currentPos = list->numUsedSlots;
+    } else {
+        for (i = 0; i < list->numSlots; i++) {
+            if (!list->handles[list->currentPos])
+                break;
+            list->currentPos++;
+            if (list->currentPos == list->numSlots)
+                list->currentPos = 0;
+        }
+        list->numUsedSlots++;
+        *slotNum = list->currentPos++;
+        if (list->currentPos == list->numSlots)
+            list->currentPos = 0;
+    }
+    list->handles[*slotNum] = handle;
+    dpiMutex__release(list->mutex);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiHandleList__create() [INTERNAL]
+//   Create a new (empty) list of handles.
+//-----------------------------------------------------------------------------
+int dpiHandleList__create(dpiHandleList **list, dpiError *error)
+{
+    dpiHandleList *tempList;
+
+    if (dpiUtils__allocateMemory(1, sizeof(dpiHandleList), 0,
+            "allocate handle list", (void**) &tempList, error) < 0)
+        return DPI_FAILURE;
+    tempList->numSlots = 8;
+    tempList->numUsedSlots = 0;
+    if (dpiUtils__allocateMemory(tempList->numSlots, sizeof(void*), 1,
+            "allocate handle list slots", (void**) &tempList->handles,
+            error) < 0) {
+        dpiUtils__freeMemory(tempList);
+        return DPI_FAILURE;
+    }
+    dpiMutex__initialize(tempList->mutex);
+    tempList->currentPos = 0;
+    *list = tempList;
+    return DPI_SUCCESS;
+}
+
+//-----------------------------------------------------------------------------
+// dpiHandleList__free() [INTERNAL]
+//   Free the memory associated with the handle list.
+//-----------------------------------------------------------------------------
+void dpiHandleList__free(dpiHandleList *list)
+{
+    if (list->handles) {
+        dpiUtils__freeMemory(list->handles);
+        list->handles = NULL;
+    }
+    dpiMutex__destroy(list->mutex);
+    dpiUtils__freeMemory(list);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiHandleList__removeHandle() [INTERNAL]
+//   Remove the handle at the specified location from the list.
+//-----------------------------------------------------------------------------
+void dpiHandleList__removeHandle(dpiHandleList *list, uint32_t slotNum)
+{
+    dpiMutex__acquire(list->mutex);
+    list->handles[slotNum] = NULL;
+    list->numUsedSlots--;
+    dpiMutex__release(list->mutex);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiHandlePool.c ./odpi/src/dpiHandlePool.c
--- patched-godror/odpi/src/dpiHandlePool.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiHandlePool.c	1970-01-01 01:00:00
@@ -1,132 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2017, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiHandlePool.c
-//   Implementation of a pool of handles which can be acquired and released in
-// a thread-safe manner. The pool is a circular queue where handles are
-// acquired from the front and released to the back.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiHandlePool__acquire() [INTERNAL]
-//   Acquire a handle from the pool. If a handle is available, it will be
-// cleared out of the pool and returned to the caller. It is the caller's
-// responsibility to return the handle back to the pool when it is finished
-// with it. If no handle is available, a NULL value is returned. The caller is
-// expected to create a new handle and return it to the pool when it is
-// finished with it.
-//-----------------------------------------------------------------------------
-int dpiHandlePool__acquire(dpiHandlePool *pool, void **handle, dpiError *error)
-{
-    void **tempHandles;
-    uint32_t numSlots;
-
-    dpiMutex__acquire(pool->mutex);
-    if (pool->acquirePos != pool->releasePos) {
-        *handle = pool->handles[pool->acquirePos];
-        pool->handles[pool->acquirePos++] = NULL;
-        if (pool->acquirePos == pool->numSlots)
-            pool->acquirePos = 0;
-    } else {
-        *handle = NULL;
-        pool->numUsedSlots++;
-        if (pool->numUsedSlots > pool->numSlots) {
-            numSlots = pool->numSlots + 8;
-            if (dpiUtils__allocateMemory(numSlots, sizeof(void*), 1,
-                    "allocate slots", (void**) &tempHandles, error) < 0) {
-                dpiMutex__release(pool->mutex);
-                return DPI_FAILURE;
-            }
-            memcpy(tempHandles, pool->handles, pool->numSlots * sizeof(void*));
-            dpiUtils__freeMemory(pool->handles);
-            pool->handles = tempHandles;
-            pool->numSlots = numSlots;
-        }
-    }
-    dpiMutex__release(pool->mutex);
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiHandlePool__create() [INTERNAL]
-//   Create a new handle pool.
-//-----------------------------------------------------------------------------
-int dpiHandlePool__create(dpiHandlePool **pool, dpiError *error)
-{
-    dpiHandlePool *tempPool;
-
-    if (dpiUtils__allocateMemory(1, sizeof(dpiHandlePool), 0,
-            "allocate handle pool", (void**) &tempPool, error) < 0)
-        return DPI_FAILURE;
-    tempPool->numSlots = 8;
-    tempPool->numUsedSlots = 0;
-    if (dpiUtils__allocateMemory(tempPool->numSlots, sizeof(void*), 1,
-            "allocate handle pool slots", (void**) &tempPool->handles,
-            error) < 0) {
-        dpiUtils__freeMemory(tempPool);
-        return DPI_FAILURE;
-    }
-    dpiMutex__initialize(tempPool->mutex);
-    tempPool->acquirePos = 0;
-    tempPool->releasePos = 0;
-    *pool = tempPool;
-    return DPI_SUCCESS;
-}
-
-//-----------------------------------------------------------------------------
-// dpiHandlePool__free() [INTERNAL]
-//   Free the memory associated with the error pool.
-//-----------------------------------------------------------------------------
-void dpiHandlePool__free(dpiHandlePool *pool)
-{
-    if (pool->handles) {
-        dpiUtils__freeMemory(pool->handles);
-        pool->handles = NULL;
-    }
-    dpiMutex__destroy(pool->mutex);
-    dpiUtils__freeMemory(pool);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiHandlePool__release() [INTERNAL]
-//   Release a handle back to the pool. No checks are performed on the handle
-// that is being returned to the pool; It will simply be placed back in the
-// pool. The handle is then NULLed in order to avoid multiple attempts to
-// release the handle back to the pool.
-//-----------------------------------------------------------------------------
-void dpiHandlePool__release(dpiHandlePool *pool, void **handle)
-{
-    dpiMutex__acquire(pool->mutex);
-    pool->handles[pool->releasePos++] = *handle;
-    *handle = NULL;
-    if (pool->releasePos == pool->numSlots)
-        pool->releasePos = 0;
-    dpiMutex__release(pool->mutex);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiHandlePool.h ./odpi/src/dpiHandlePool.h
--- patched-godror/odpi/src/dpiHandlePool.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiHandlePool.h	2024-05-14 14:55:13
@@ -0,0 +1,132 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2017, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiHandlePool.c
+//   Implementation of a pool of handles which can be acquired and released in
+// a thread-safe manner. The pool is a circular queue where handles are
+// acquired from the front and released to the back.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiHandlePool__acquire() [INTERNAL]
+//   Acquire a handle from the pool. If a handle is available, it will be
+// cleared out of the pool and returned to the caller. It is the caller's
+// responsibility to return the handle back to the pool when it is finished
+// with it. If no handle is available, a NULL value is returned. The caller is
+// expected to create a new handle and return it to the pool when it is
+// finished with it.
+//-----------------------------------------------------------------------------
+int dpiHandlePool__acquire(dpiHandlePool *pool, void **handle, dpiError *error)
+{
+    void **tempHandles;
+    uint32_t numSlots;
+
+    dpiMutex__acquire(pool->mutex);
+    if (pool->acquirePos != pool->releasePos) {
+        *handle = pool->handles[pool->acquirePos];
+        pool->handles[pool->acquirePos++] = NULL;
+        if (pool->acquirePos == pool->numSlots)
+            pool->acquirePos = 0;
+    } else {
+        *handle = NULL;
+        pool->numUsedSlots++;
+        if (pool->numUsedSlots > pool->numSlots) {
+            numSlots = pool->numSlots + 8;
+            if (dpiUtils__allocateMemory(numSlots, sizeof(void*), 1,
+                    "allocate slots", (void**) &tempHandles, error) < 0) {
+                dpiMutex__release(pool->mutex);
+                return DPI_FAILURE;
+            }
+            memcpy(tempHandles, pool->handles, pool->numSlots * sizeof(void*));
+            dpiUtils__freeMemory(pool->handles);
+            pool->handles = tempHandles;
+            pool->numSlots = numSlots;
+        }
+    }
+    dpiMutex__release(pool->mutex);
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiHandlePool__create() [INTERNAL]
+//   Create a new handle pool.
+//-----------------------------------------------------------------------------
+int dpiHandlePool__create(dpiHandlePool **pool, dpiError *error)
+{
+    dpiHandlePool *tempPool;
+
+    if (dpiUtils__allocateMemory(1, sizeof(dpiHandlePool), 0,
+            "allocate handle pool", (void**) &tempPool, error) < 0)
+        return DPI_FAILURE;
+    tempPool->numSlots = 8;
+    tempPool->numUsedSlots = 0;
+    if (dpiUtils__allocateMemory(tempPool->numSlots, sizeof(void*), 1,
+            "allocate handle pool slots", (void**) &tempPool->handles,
+            error) < 0) {
+        dpiUtils__freeMemory(tempPool);
+        return DPI_FAILURE;
+    }
+    dpiMutex__initialize(tempPool->mutex);
+    tempPool->acquirePos = 0;
+    tempPool->releasePos = 0;
+    *pool = tempPool;
+    return DPI_SUCCESS;
+}
+
+//-----------------------------------------------------------------------------
+// dpiHandlePool__free() [INTERNAL]
+//   Free the memory associated with the error pool.
+//-----------------------------------------------------------------------------
+void dpiHandlePool__free(dpiHandlePool *pool)
+{
+    if (pool->handles) {
+        dpiUtils__freeMemory(pool->handles);
+        pool->handles = NULL;
+    }
+    dpiMutex__destroy(pool->mutex);
+    dpiUtils__freeMemory(pool);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiHandlePool__release() [INTERNAL]
+//   Release a handle back to the pool. No checks are performed on the handle
+// that is being returned to the pool; It will simply be placed back in the
+// pool. The handle is then NULLed in order to avoid multiple attempts to
+// release the handle back to the pool.
+//-----------------------------------------------------------------------------
+void dpiHandlePool__release(dpiHandlePool *pool, void **handle)
+{
+    dpiMutex__acquire(pool->mutex);
+    pool->handles[pool->releasePos++] = *handle;
+    *handle = NULL;
+    if (pool->releasePos == pool->numSlots)
+        pool->releasePos = 0;
+    dpiMutex__release(pool->mutex);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiJson.c ./odpi/src/dpiJson.c
--- patched-godror/odpi/src/dpiJson.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiJson.c	1970-01-01 01:00:00
@@ -1,832 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2020, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiJson.c
-//   Implementation of JSON manipulation routines.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-// define number of nodes which are processed in each batch
-#define DPI_JSON_BATCH_NODES            64
-
-// define batch size of space allocated for temporary buffers used for
-// converting numbers to text
-#define DPI_JSON_TEMP_BUFFER_SIZE       1024
-
-// forward declarations of internal functions only used in this file
-static int dpiJsonNode__fromOracleArrayToNative(dpiJson *json,
-        dpiJsonNode *node, dpiJznDomDoc *domDoc, void *oracleNode,
-        uint32_t options, dpiError *error);
-static int dpiJsonNode__fromOracleObjectToNative(dpiJson *json,
-        dpiJsonNode *node, dpiJznDomDoc *domDoc, void *oracleNode,
-        uint32_t options, dpiError *error);
-static int dpiJsonNode__fromOracleScalarToNative(dpiJson *json,
-        dpiJsonNode *node, dpiJznDomDoc *domDoc, void *oracleNode,
-        uint32_t options, dpiError *error);
-static int dpiJsonNode__fromOracleToNative(dpiJson *json, dpiJsonNode *node,
-        dpiJznDomDoc *domDoc, void *oracleNode, uint32_t options,
-        dpiError *error);
-static int dpiJsonNode__toOracleFromNative(dpiJson *json, dpiJsonNode *node,
-        dpiJznDomDoc *domDoc, void **oracleNode, dpiError *error);
-
-
-//-----------------------------------------------------------------------------
-// dpiJson__allocate() [INTERNAL]
-//   Allocate and initialize a JSON object.
-//-----------------------------------------------------------------------------
-int dpiJson__allocate(dpiConn *conn, dpiJson **json, dpiError *error)
-{
-    dpiJson *tempJson;
-
-    if (dpiUtils__checkClientVersion(conn->env->versionInfo, 21, 0, error) < 0)
-        return DPI_FAILURE;
-    if (dpiGen__allocate(DPI_HTYPE_JSON, conn->env, (void**) &tempJson,
-            error) < 0)
-        return DPI_FAILURE;
-    dpiGen__setRefCount(conn, error, 1);
-    tempJson->conn = conn;
-    if (dpiOci__descriptorAlloc(conn->env->handle, &tempJson->handle,
-            DPI_OCI_DTYPE_JSON, "allocate JSON descriptor", error) < 0) {
-        dpiJson__free(tempJson, error);
-        return DPI_FAILURE;
-    }
-    tempJson->topNode.value = &tempJson->topNodeBuffer;
-    tempJson->topNode.oracleTypeNum = DPI_ORACLE_TYPE_NONE;
-    tempJson->topNode.nativeTypeNum = DPI_NATIVE_TYPE_NULL;
-
-    *json = tempJson;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJsonNode__fromOracleArrayToNative() [INTERNAL]
-//   Populate an array node from the Oracle JSON node.
-//-----------------------------------------------------------------------------
-static int dpiJsonNode__fromOracleArrayToNative(dpiJson *json,
-        dpiJsonNode *node, dpiJznDomDoc *domDoc, void *oracleNode,
-        uint32_t options, dpiError *error)
-{
-    void *oracleElementNodes[DPI_JSON_BATCH_NODES];
-    uint32_t pos, i, numInBatch;
-    dpiJsonNode *elementNode;
-    dpiJsonArray *array;
-
-    // define node types
-    node->oracleTypeNum = DPI_ORACLE_TYPE_JSON_ARRAY;
-    node->nativeTypeNum = DPI_NATIVE_TYPE_JSON_ARRAY;
-
-    // determine number of elements in the array; if no elements exist in the
-    // array, nothing further needs to be done at this point
-    array = &node->value->asJsonArray;
-    array->numElements = (*domDoc->methods->fnGetArraySize)(domDoc,
-            oracleNode);
-    if (array->numElements == 0)
-        return DPI_SUCCESS;
-
-    // allocate memory
-    if (dpiUtils__allocateMemory(array->numElements, sizeof(dpiJsonNode), 1,
-            "allocate JSON array element nodes", (void**) &array->elements,
-            error) < 0)
-        return DPI_FAILURE;
-    if (dpiUtils__allocateMemory(array->numElements, sizeof(dpiDataBuffer), 1,
-            "allocate JSON array element values",
-            (void**) &array->elementValues, error) < 0)
-        return DPI_FAILURE;
-
-    // process all of the nodes in the array in batches
-    pos = 0;
-    while (pos < array->numElements) {
-        numInBatch = (*domDoc->methods->fnGetArrayElemBatch)(domDoc,
-                oracleNode, pos, DPI_JSON_BATCH_NODES,
-                oracleElementNodes);
-        for (i = 0; i < numInBatch; i++) {
-            elementNode = &array->elements[pos + i];
-            elementNode->value = &array->elementValues[pos + i];
-            if (dpiJsonNode__fromOracleToNative(json, elementNode, domDoc,
-                    oracleElementNodes[i], options, error) < 0)
-                return DPI_FAILURE;
-        }
-        pos += numInBatch;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJsonNode__fromOracleObjectToNative() [INTERNAL]
-//   Populate an object node from the Oracle JSON node.
-//-----------------------------------------------------------------------------
-static int dpiJsonNode__fromOracleObjectToNative(dpiJson *json,
-        dpiJsonNode *node, dpiJznDomDoc *domDoc, void *oracleNode,
-        uint32_t options, dpiError *error)
-{
-    dpiJznDomNameValuePair nameValuePairs[DPI_JSON_BATCH_NODES];
-    uint32_t pos, i, numInBatch;
-    dpiJsonNode *fieldNode;
-    dpiJsonObject *obj;
-
-    // define node types
-    node->oracleTypeNum = DPI_ORACLE_TYPE_JSON_OBJECT;
-    node->nativeTypeNum = DPI_NATIVE_TYPE_JSON_OBJECT;
-
-    // determine number of fields in the object; if no fields exist in the
-    // object, nothing further needs to be done at this point
-    obj = &node->value->asJsonObject;
-    obj->numFields = (*domDoc->methods->fnGetNumObjField)(domDoc, oracleNode);
-    if (obj->numFields == 0)
-        return DPI_SUCCESS;
-
-    // allocate memory
-    if (dpiUtils__allocateMemory(obj->numFields, sizeof(char*), 1,
-            "allocate JSON object field names", (void**) &obj->fieldNames,
-            error) < 0)
-        return DPI_FAILURE;
-    if (dpiUtils__allocateMemory(obj->numFields, sizeof(uint32_t), 1,
-            "allocate JSON object field name lengths",
-            (void**) &obj->fieldNameLengths, error) < 0)
-        return DPI_FAILURE;
-    if (dpiUtils__allocateMemory(obj->numFields, sizeof(dpiJsonNode), 1,
-            "allocate JSON object field nodes", (void**) &obj->fields,
-            error) < 0)
-        return DPI_FAILURE;
-    if (dpiUtils__allocateMemory(obj->numFields, sizeof(dpiDataBuffer), 1,
-            "allocate JSON object field values", (void**) &obj->fieldValues,
-            error) < 0)
-        return DPI_FAILURE;
-
-    // process all of the nodes in the object in batches
-    pos = 0;
-    while (pos < obj->numFields) {
-        numInBatch = (*domDoc->methods->fnGetFieldNamesAndValsBatch)(domDoc,
-                oracleNode, pos, DPI_JSON_BATCH_NODES, nameValuePairs);
-        for (i = 0; i < numInBatch; i++) {
-            obj->fieldNames[pos + i] = nameValuePairs[i].name.ptr;
-            obj->fieldNameLengths[pos + i] = nameValuePairs[i].name.length;
-            fieldNode = &obj->fields[pos + i];
-            fieldNode->value = &obj->fieldValues[pos + i];
-            if (dpiJsonNode__fromOracleToNative(json, fieldNode, domDoc,
-                    nameValuePairs[i].value, options, error) < 0)
-                return DPI_FAILURE;
-        }
-        pos += numInBatch;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJsonNode__fromOracleNumberAsText() [INTERNAL]
-//   Populate a scalar number as a text buffer. Temporary buffers are allocated
-// as needed and an array of these are stored in the JSON object. Each
-// temporary buffer contains as many numbers as can be fit before a new
-// temporary buffer is allocated.
-//-----------------------------------------------------------------------------
-static int dpiJsonNode__fromOracleNumberAsText(dpiJson *json,
-        dpiJsonNode *node, uint8_t *numBuffer, dpiError *error)
-{
-    char **tempBuffers;
-
-    // if there is no room in the current temporary buffer, allocate a new one
-    if (json->tempBufferUsed + DPI_NUMBER_AS_TEXT_CHARS <
-            DPI_JSON_TEMP_BUFFER_SIZE) {
-
-        // if no room is available in the temp buffer array, increase the size
-        // of the array
-        if (json->numTempBuffers == json->allocatedTempBuffers) {
-            json->allocatedTempBuffers += 16;
-            if (dpiUtils__allocateMemory(json->allocatedTempBuffers,
-                    sizeof(char*), 0, "allocate JSON temp buffer array",
-                    (void**) &tempBuffers, error) < 0)
-                return DPI_FAILURE;
-            if (json->numTempBuffers > 0) {
-                memcpy(tempBuffers, json->tempBuffers,
-                        json->numTempBuffers * sizeof(char*));
-                dpiUtils__freeMemory(json->tempBuffers);
-            }
-            json->tempBuffers = tempBuffers;
-        }
-
-        // allocate a new temporary buffer
-        if (dpiUtils__allocateMemory(1, DPI_JSON_TEMP_BUFFER_SIZE, 0,
-                "allocate JSON temp buffer",
-                (void**) &json->tempBuffers[json->numTempBuffers], error) < 0)
-            return DPI_FAILURE;
-        json->numTempBuffers++;
-        json->tempBufferUsed = 0;
-
-    }
-
-    // perform the conversion
-    node->value->asBytes.ptr = json->tempBuffers[json->numTempBuffers - 1] +
-            json->tempBufferUsed;
-    node->value->asBytes.length = DPI_NUMBER_AS_TEXT_CHARS;
-    return dpiDataBuffer__fromOracleNumberAsText(node->value, json->env,
-            error, numBuffer);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJsonNode__fromOracleScalarToNative() [INTERNAL]
-//   Populate a scalar node from the Oracle JSON node.
-//-----------------------------------------------------------------------------
-static int dpiJsonNode__fromOracleScalarToNative(dpiJson *json,
-        dpiJsonNode *node, dpiJznDomDoc *domDoc, void *oracleNode,
-        uint32_t options, dpiError *error)
-{
-    dpiJznDomScalar scalar;
-    dpiJsonOciVal ociVal;
-
-    (*domDoc->methods->fnGetScalarInfoOci)(domDoc, oracleNode, &scalar,
-            &ociVal);
-    switch (scalar.valueType) {
-        case DPI_JZNVAL_BINARY:
-        case DPI_JZNVAL_STRING:
-            node->oracleTypeNum = (scalar.valueType == DPI_JZNVAL_STRING) ?
-                    DPI_ORACLE_TYPE_VARCHAR : DPI_ORACLE_TYPE_RAW;
-            node->nativeTypeNum = DPI_NATIVE_TYPE_BYTES;
-            node->value->asBytes.ptr = scalar.value.asBytes.value;
-            node->value->asBytes.length = scalar.value.asBytes.valueLength;
-            return DPI_SUCCESS;
-        case DPI_JZNVAL_FLOAT:
-            node->oracleTypeNum = DPI_ORACLE_TYPE_NUMBER;
-            node->nativeTypeNum = DPI_NATIVE_TYPE_DOUBLE;
-            node->value->asDouble = scalar.value.asFloat.value;
-            return DPI_SUCCESS;
-        case DPI_JZNVAL_DOUBLE:
-            node->oracleTypeNum = DPI_ORACLE_TYPE_NUMBER;
-            node->nativeTypeNum = DPI_NATIVE_TYPE_DOUBLE;
-            node->value->asDouble = scalar.value.asDouble.value;
-            return DPI_SUCCESS;
-        case DPI_JZNVAL_ORA_SIGNED_INT:
-        case DPI_JZNVAL_ORA_SIGNED_LONG:
-        case DPI_JZNVAL_ORA_DECIMAL128:
-        case DPI_JZNVAL_ORA_NUMBER:
-            if (scalar.valueType != DPI_JZNVAL_ORA_NUMBER) {
-                ociVal.asJsonNumber[0] =
-                        (uint8_t) scalar.value.asOciVal.valueLength;
-                memcpy(&ociVal.asJsonNumber[1], scalar.value.asOciVal.value,
-                        scalar.value.asOciVal.valueLength);
-            }
-            node->oracleTypeNum = DPI_ORACLE_TYPE_NUMBER;
-            if (options & DPI_JSON_OPT_NUMBER_AS_STRING) {
-                node->nativeTypeNum = DPI_NATIVE_TYPE_BYTES;
-                return dpiJsonNode__fromOracleNumberAsText(json, node,
-                        ociVal.asJsonNumber, error);
-            }
-            node->nativeTypeNum = DPI_NATIVE_TYPE_DOUBLE;
-            return dpiDataBuffer__fromOracleNumberAsDouble(node->value, error,
-                    ociVal.asJsonNumber);
-        case DPI_JZNVAL_ORA_DATE:
-        case DPI_JZNVAL_ORA_TIMESTAMP:
-        case DPI_JZNVAL_ORA_TIMESTAMPTZ:
-            node->oracleTypeNum = (scalar.valueType == DPI_JZNVAL_ORA_DATE) ?
-                    DPI_ORACLE_TYPE_DATE : DPI_ORACLE_TYPE_TIMESTAMP;
-            if (options & DPI_JSON_OPT_DATE_AS_DOUBLE) {
-                node->nativeTypeNum = DPI_NATIVE_TYPE_DOUBLE;
-                if (dpiDataBuffer__fromOracleDateAsDouble(node->value,
-                        json->env, error,
-                        (dpiOciDate*) &ociVal.asJsonDateTime) < 0)
-                    return DPI_FAILURE;
-                node->value->asDouble +=
-                        (ociVal.asJsonDateTime.fsecond / 1000000);
-                return DPI_SUCCESS;
-            }
-            node->nativeTypeNum = DPI_NATIVE_TYPE_TIMESTAMP;
-            node->value->asTimestamp.year = ociVal.asJsonDateTime.year;
-            node->value->asTimestamp.month = ociVal.asJsonDateTime.month;
-            node->value->asTimestamp.day = ociVal.asJsonDateTime.day;
-            node->value->asTimestamp.hour = ociVal.asJsonDateTime.hour;
-            node->value->asTimestamp.minute = ociVal.asJsonDateTime.minute;
-            node->value->asTimestamp.second = ociVal.asJsonDateTime.second;
-            node->value->asTimestamp.fsecond = ociVal.asJsonDateTime.fsecond;
-            node->value->asTimestamp.tzHourOffset =
-                    ociVal.asJsonDateTime.tzHourOffset;
-            node->value->asTimestamp.tzMinuteOffset =
-                    ociVal.asJsonDateTime.tzMinuteOffset;
-            return DPI_SUCCESS;
-        case DPI_JZNVAL_ORA_DAYSECOND_DUR:
-            node->oracleTypeNum = DPI_ORACLE_TYPE_INTERVAL_DS;
-            node->nativeTypeNum = DPI_NATIVE_TYPE_INTERVAL_DS;
-            node->value->asIntervalDS.days = ociVal.asJsonDayInterval.days;
-            node->value->asIntervalDS.hours = ociVal.asJsonDayInterval.hours;
-            node->value->asIntervalDS.minutes =
-                    ociVal.asJsonDayInterval.minutes;
-            node->value->asIntervalDS.seconds =
-                    ociVal.asJsonDayInterval.seconds;
-            node->value->asIntervalDS.fseconds =
-                    ociVal.asJsonDayInterval.fseconds;
-            return DPI_SUCCESS;
-        case DPI_JZNVAL_ORA_YEARMONTH_DUR:
-            node->oracleTypeNum = DPI_ORACLE_TYPE_INTERVAL_YM;
-            node->nativeTypeNum = DPI_NATIVE_TYPE_INTERVAL_YM;
-            node->value->asIntervalYM.years = ociVal.asJsonYearInterval.years;
-            node->value->asIntervalYM.months =
-                    ociVal.asJsonYearInterval.months;
-            return DPI_SUCCESS;
-        case DPI_JZNVAL_FALSE:
-        case DPI_JZNVAL_TRUE:
-            node->oracleTypeNum = DPI_ORACLE_TYPE_BOOLEAN;
-            node->nativeTypeNum = DPI_NATIVE_TYPE_BOOLEAN;
-            node->value->asBoolean = (scalar.valueType == DPI_JZNVAL_TRUE);
-            return DPI_SUCCESS;
-        case DPI_JZNVAL_NULL:
-            node->oracleTypeNum = DPI_ORACLE_TYPE_NONE;
-            node->nativeTypeNum = DPI_NATIVE_TYPE_NULL;
-            return DPI_SUCCESS;
-        default:
-            break;
-    }
-
-    return dpiError__set(error, "populate scalar node from Oracle",
-            DPI_ERR_UNHANDLED_JSON_SCALAR_TYPE, scalar.valueType);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJsonNode__fromOracleToNative() [INTERNAL]
-//   Populate the JSON node structure from the Oracle JSON node.
-//-----------------------------------------------------------------------------
-static int dpiJsonNode__fromOracleToNative(dpiJson *json, dpiJsonNode *node,
-        dpiJznDomDoc *domDoc, void *oracleNode, uint32_t options,
-        dpiError *error)
-{
-    int nodeType;
-
-    nodeType = (*domDoc->methods->fnGetNodeType)(domDoc, oracleNode);
-    switch (nodeType) {
-        case DPI_JZNDOM_ARRAY:
-            return dpiJsonNode__fromOracleArrayToNative(json, node, domDoc,
-                    oracleNode, options, error);
-        case DPI_JZNDOM_OBJECT:
-            return dpiJsonNode__fromOracleObjectToNative(json, node, domDoc,
-                    oracleNode, options, error);
-        case DPI_JZNDOM_SCALAR:
-            return dpiJsonNode__fromOracleScalarToNative(json, node, domDoc,
-                    oracleNode, options, error);
-        default:
-            break;
-    }
-    return dpiError__set(error, "from Oracle to native node",
-            DPI_ERR_UNHANDLED_JSON_NODE_TYPE, nodeType);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJsonNode__toOracleArrayFromNative() [INTERNAL]
-//   Populate an Oracle array node from the JSON array node.
-//-----------------------------------------------------------------------------
-static int dpiJsonNode__toOracleArrayFromNative(dpiJson *json,
-        dpiJsonArray *array, dpiJznDomDoc *domDoc, void **oracleNode,
-        dpiError *error)
-{
-    dpiJsonNode *childNode;
-    void *oracleChildNode;
-    uint32_t i;
-
-    *oracleNode = domDoc->methods->fnNewArray(domDoc, array->numElements);
-    for (i = 0; i < array->numElements; i++) {
-        childNode = &array->elements[i];
-        if (dpiJsonNode__toOracleFromNative(json, childNode, domDoc,
-                &oracleChildNode, error) < 0) {
-            domDoc->methods->fnFreeNode(domDoc, *oracleNode);
-            return DPI_FAILURE;
-        }
-        domDoc->methods->fnAppendItem(domDoc, *oracleNode, oracleChildNode);
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJsonNode__toOracleObjectFromNative() [INTERNAL]
-//   Populate an Oracle object node from the JSON object node.
-//-----------------------------------------------------------------------------
-static int dpiJsonNode__toOracleObjectFromNative(dpiJson *json,
-        dpiJsonObject *obj, dpiJznDomDoc *domDoc, void **oracleNode,
-        dpiError *error)
-{
-    dpiJsonNode *childNode;
-    void *oracleChildNode;
-    uint32_t i;
-
-    *oracleNode = domDoc->methods->fnNewObject(domDoc, obj->numFields);
-    for (i = 0; i < obj->numFields; i++) {
-        childNode = &obj->fields[i];
-        if (dpiJsonNode__toOracleFromNative(json, childNode, domDoc,
-                &oracleChildNode, error) < 0) {
-            domDoc->methods->fnFreeNode(domDoc, *oracleNode);
-            return DPI_FAILURE;
-        }
-        domDoc->methods->fnPutFieldValue(domDoc, *oracleNode,
-                obj->fieldNames[i], (uint16_t) obj->fieldNameLengths[i],
-                oracleChildNode);
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJsonNode__toOracleFromNative() [INTERNAL]
-//   Create an Oracle node from the native node.
-//-----------------------------------------------------------------------------
-static int dpiJsonNode__toOracleFromNative(dpiJson *json, dpiJsonNode *node,
-        dpiJznDomDoc *domDoc, void **oracleNode, dpiError *error)
-{
-    dpiOracleDataBuffer dataBuffer;
-    int scalarType;
-
-    switch (node->oracleTypeNum) {
-        case DPI_ORACLE_TYPE_JSON_ARRAY:
-            if (node->nativeTypeNum == DPI_NATIVE_TYPE_JSON_ARRAY) {
-                return dpiJsonNode__toOracleArrayFromNative(json,
-                        &node->value->asJsonArray, domDoc, oracleNode, error);
-            }
-            break;
-        case DPI_ORACLE_TYPE_JSON_OBJECT:
-            if (node->nativeTypeNum == DPI_NATIVE_TYPE_JSON_OBJECT) {
-                return dpiJsonNode__toOracleObjectFromNative(json,
-                        &node->value->asJsonObject, domDoc, oracleNode, error);
-            }
-            break;
-        case DPI_ORACLE_TYPE_NUMBER:
-            if (node->nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
-                if (dpiDataBuffer__toOracleNumberFromDouble(node->value,
-                        error, &dataBuffer.asNumber) < 0)
-                    return DPI_FAILURE;
-            } else if (node->nativeTypeNum == DPI_NATIVE_TYPE_INT64) {
-                if (dpiDataBuffer__toOracleNumberFromInteger(node->value,
-                        error, &dataBuffer.asNumber) < 0)
-                    return DPI_FAILURE;
-            } else if (node->nativeTypeNum == DPI_NATIVE_TYPE_UINT64) {
-                if (dpiDataBuffer__toOracleNumberFromUnsignedInteger(
-                        node->value, error, &dataBuffer.asNumber) < 0)
-                    return DPI_FAILURE;
-            } else if (node->nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
-                if (dpiDataBuffer__toOracleNumberFromText(node->value,
-                        json->env, error, &dataBuffer.asNumber) < 0)
-                    return DPI_FAILURE;
-            } else {
-                break;
-            }
-            *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
-                    DPI_JZNVAL_OCI_NUMBER, &dataBuffer.asNumber);
-            return DPI_SUCCESS;
-        case DPI_ORACLE_TYPE_NATIVE_DOUBLE:
-            if (node->nativeTypeNum != DPI_NATIVE_TYPE_DOUBLE)
-                break;
-            *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
-                    DPI_JZNVAL_DOUBLE, node->value->asDouble);
-            return DPI_SUCCESS;
-        case DPI_ORACLE_TYPE_NATIVE_FLOAT:
-            if (node->nativeTypeNum != DPI_NATIVE_TYPE_FLOAT)
-                break;
-            *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
-                    DPI_JZNVAL_FLOAT, node->value->asFloat);
-            return DPI_SUCCESS;
-        case DPI_ORACLE_TYPE_RAW:
-        case DPI_ORACLE_TYPE_VARCHAR:
-            if (node->nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
-                scalarType = (node->oracleTypeNum == DPI_ORACLE_TYPE_RAW) ?
-                        DPI_JZNVAL_BINARY : DPI_JZNVAL_STRING;
-                *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
-                        scalarType, node->value->asBytes.ptr,
-                        node->value->asBytes.length);
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_DATE:
-            if (node->nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP) {
-                if (dpiDataBuffer__toOracleDate(node->value,
-                        &dataBuffer.asDate) < 0)
-                    return DPI_FAILURE;
-            } else if (node->nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
-                if (dpiDataBuffer__toOracleDateFromDouble(node->value,
-                        json->env, error, &dataBuffer.asDate) < 0)
-                    return DPI_FAILURE;
-            } else {
-                break;
-            }
-            *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
-                    DPI_JZNVAL_OCI_DATE, &dataBuffer.asDate);
-            return DPI_SUCCESS;
-        case DPI_ORACLE_TYPE_TIMESTAMP:
-            if (!json->convTimestamp) {
-                if (dpiOci__descriptorAlloc(json->env->handle,
-                        &json->convTimestamp, DPI_OCI_DTYPE_TIMESTAMP,
-                        "alloc timestamp for JSON", error) < 0)
-                    return DPI_FAILURE;
-            }
-            if (node->nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP) {
-                if (dpiDataBuffer__toOracleTimestamp(node->value, json->env,
-                        error, json->convTimestamp, 0) < 0)
-                    return DPI_FAILURE;
-            } else if (node->nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
-                if (dpiDataBuffer__toOracleTimestampFromDouble(node->value,
-                        node->oracleTypeNum, json->env, error,
-                        json->convTimestamp) < 0)
-                    return DPI_FAILURE;
-            } else {
-                break;
-            }
-            *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
-                    DPI_JZNVAL_OCI_DATETIME, json->convTimestamp);
-            return DPI_SUCCESS;
-        case DPI_ORACLE_TYPE_INTERVAL_DS:
-            if (!json->convIntervalDS) {
-                if (dpiOci__descriptorAlloc(json->env->handle,
-                        &json->convIntervalDS, DPI_OCI_DTYPE_INTERVAL_DS,
-                        "alloc interval DS for JSON", error) < 0)
-                    return DPI_FAILURE;
-            }
-            if (node->nativeTypeNum == DPI_NATIVE_TYPE_INTERVAL_DS) {
-                if (dpiDataBuffer__toOracleIntervalDS(node->value, json->env,
-                        error, json->convIntervalDS) < 0)
-                    return DPI_FAILURE;
-                *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
-                        DPI_JZNVAL_OCI_INTERVAL, json->convIntervalDS);
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_INTERVAL_YM:
-            if (!json->convIntervalYM) {
-                if (dpiOci__descriptorAlloc(json->env->handle,
-                        &json->convIntervalYM, DPI_OCI_DTYPE_INTERVAL_YM,
-                        "alloc interval YM for JSON", error) < 0)
-                    return DPI_FAILURE;
-            }
-            if (node->nativeTypeNum == DPI_NATIVE_TYPE_INTERVAL_YM) {
-                if (dpiDataBuffer__toOracleIntervalYM(node->value, json->env,
-                        error, json->convIntervalYM) < 0)
-                    return DPI_FAILURE;
-                *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
-                        DPI_JZNVAL_OCI_INTERVAL, json->convIntervalYM);
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_BOOLEAN:
-            if (node->nativeTypeNum == DPI_NATIVE_TYPE_BOOLEAN) {
-                scalarType = (node->value->asBoolean) ?
-                        DPI_JZNVAL_TRUE: DPI_JZNVAL_FALSE;
-                *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
-                        scalarType, NULL);
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_NONE:
-            if (node->nativeTypeNum == DPI_NATIVE_TYPE_NULL) {
-                *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
-                        DPI_JZNVAL_NULL, NULL);
-                return DPI_SUCCESS;
-            }
-            break;
-    }
-    *oracleNode = NULL;
-    return dpiError__set(error, "from native to Oracle node",
-            DPI_ERR_UNHANDLED_CONVERSION_TO_JSON, node->nativeTypeNum,
-            node->oracleTypeNum);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJson__setValue() [INTERNAL]
-//   Sets the value of the JSON object, given a hierarchy of nodes.
-//-----------------------------------------------------------------------------
-static int dpiJson__setValue(dpiJson *json, dpiJsonNode *topNode,
-        dpiError *error)
-{
-    const char *dummyValue = "0";
-    dpiJznDomDoc *domDoc;
-    void *oracleTopNode;
-    int mutable = 1;
-    uint32_t jsonFlags = 0;
-
-    // first, set the JSON descriptor as mutable
-    if (dpiOci__attrSet(json->handle, DPI_OCI_DTYPE_JSON,
-            (void*) &mutable, 0, DPI_OCI_ATTR_JSON_DOM_MUTABLE,
-            "set JSON descriptor mutable", error) < 0)
-        return DPI_FAILURE;
-
-    // write a dummy value to the JSON descriptor
-    if (dpiOci__jsonTextBufferParse(json, dummyValue, strlen(dummyValue),
-            jsonFlags, error) < 0)
-        return DPI_FAILURE;
-
-    // acquire the DOM doc which will be used to create the Oracle nodes
-    if (dpiOci__jsonDomDocGet(json, &domDoc, error) < 0)
-        return dpiGen__endPublicFn(json, DPI_FAILURE, error);
-
-    // convert the top node (and all of the child nodes to Oracle nodes)
-    if (dpiJsonNode__toOracleFromNative(json, topNode, domDoc, &oracleTopNode,
-            error) < 0)
-        return DPI_FAILURE;
-
-    // set the top node
-    domDoc->methods->fnSetRootNode(domDoc, oracleTopNode);
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJsonNode__free() [INTERNAL]
-//   Free the buffers allocated for the JSON node.
-//-----------------------------------------------------------------------------
-static void dpiJsonNode__free(dpiJsonNode *node)
-{
-    dpiJsonArray *array;
-    dpiJsonObject *obj;
-    uint32_t i;
-
-    if (node->oracleTypeNum == DPI_ORACLE_TYPE_JSON_ARRAY) {
-        array = &node->value->asJsonArray;
-        if (array->elements) {
-            for (i = 0; i < array->numElements; i++) {
-                if (array->elements[i].value)
-                    dpiJsonNode__free(&array->elements[i]);
-            }
-            dpiUtils__freeMemory(array->elements);
-            array->elements = NULL;
-        }
-        if (array->elementValues) {
-            dpiUtils__freeMemory(array->elementValues);
-            array->elementValues = NULL;
-        }
-    } else if (node->oracleTypeNum == DPI_ORACLE_TYPE_JSON_OBJECT) {
-        obj = &node->value->asJsonObject;
-        if (obj->fields) {
-            for (i = 0; i < obj->numFields; i++) {
-                if (obj->fields[i].value)
-                    dpiJsonNode__free(&obj->fields[i]);
-            }
-            dpiUtils__freeMemory(obj->fields);
-            obj->fields = NULL;
-        }
-        if (obj->fieldNames) {
-            dpiUtils__freeMemory(obj->fieldNames);
-            obj->fieldNames = NULL;
-        }
-        if (obj->fieldNameLengths) {
-            dpiUtils__freeMemory(obj->fieldNameLengths);
-            obj->fieldNameLengths = NULL;
-        }
-        if (obj->fieldValues) {
-            dpiUtils__freeMemory(obj->fieldValues);
-            obj->fieldValues = NULL;
-        }
-    }
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJson__free() [INTERNAL]
-//   Free the buffers allocated for the JSON value and all of its nodes, if
-// applicable.
-//-----------------------------------------------------------------------------
-void dpiJson__free(dpiJson *json, dpiError *error)
-{
-    uint32_t i;
-
-    if (json->handle) {
-        dpiOci__descriptorFree(json->handle, DPI_OCI_DTYPE_JSON);
-        json->handle = NULL;
-    }
-    if (json->conn) {
-        dpiGen__setRefCount(json->conn, error, -1);
-        json->conn = NULL;
-    }
-    if (json->tempBuffers) {
-        for (i = 0; i < json->numTempBuffers; i++)
-            dpiUtils__freeMemory(json->tempBuffers[i]);
-        dpiUtils__freeMemory(json->tempBuffers);
-        json->tempBuffers = NULL;
-    }
-    if (json->convTimestamp) {
-        dpiOci__descriptorFree(json->convTimestamp, DPI_OCI_DTYPE_TIMESTAMP);
-        json->convTimestamp = NULL;
-    }
-    if (json->convIntervalDS) {
-        dpiOci__descriptorFree(json->convIntervalDS,
-                DPI_OCI_DTYPE_INTERVAL_DS);
-        json->convIntervalDS = NULL;
-    }
-    if (json->convIntervalYM) {
-        dpiOci__descriptorFree(json->convIntervalYM,
-                DPI_OCI_DTYPE_INTERVAL_YM);
-        json->convIntervalYM = NULL;
-    }
-    dpiJsonNode__free(&json->topNode);
-    dpiUtils__freeMemory(json);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJson_addRef() [PUBLIC]
-//   Add a reference to the JSON object.
-//-----------------------------------------------------------------------------
-int dpiJson_addRef(dpiJson *json)
-{
-    return dpiGen__addRef(json, DPI_HTYPE_JSON, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJson_getValue() [PUBLIC]
-//   Gets the value of the JSON object as a hierarchy of nodes.
-//-----------------------------------------------------------------------------
-int dpiJson_getValue(dpiJson *json, uint32_t options, dpiJsonNode **topNode)
-{
-    dpiJznDomDoc *domDoc;
-    void *oracleNode;
-    dpiError error;
-
-    if (dpiGen__startPublicFn(json, DPI_HTYPE_JSON, __func__, &error) < 0)
-        return dpiGen__endPublicFn(json, DPI_FAILURE, &error);
-    dpiJsonNode__free(&json->topNode);
-    json->topNode.value = &json->topNodeBuffer;
-    json->topNode.oracleTypeNum = DPI_ORACLE_TYPE_NONE;
-    json->topNode.nativeTypeNum = DPI_NATIVE_TYPE_NULL;
-    if (dpiOci__jsonDomDocGet(json, &domDoc, &error) < 0)
-        return dpiGen__endPublicFn(json, DPI_FAILURE, &error);
-    if (domDoc) {
-        oracleNode = (*domDoc->methods->fnGetRootNode)(domDoc);
-        if (dpiJsonNode__fromOracleToNative(json, &json->topNode, domDoc,
-                oracleNode, options, &error) < 0)
-            return dpiGen__endPublicFn(json, DPI_FAILURE, &error);
-    }
-
-    *topNode = &json->topNode;
-    return dpiGen__endPublicFn(json, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJson_release() [PUBLIC]
-//   Release a reference to the JSON object.
-//-----------------------------------------------------------------------------
-int dpiJson_release(dpiJson *json)
-{
-    return dpiGen__release(json, DPI_HTYPE_JSON, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJson_setFromText() [PUBLIC]
-//   Sets the value of the JSON handle, given a JSON string.
-//-----------------------------------------------------------------------------
-int dpiJson_setFromText(dpiJson *json, const char *value, uint64_t valueLength,
-        uint32_t flags)
-{
-    dpiError error;
-    int status;
-
-    if (dpiGen__startPublicFn(json, DPI_HTYPE_JSON, __func__, &error) < 0)
-        return dpiGen__endPublicFn(json, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(json, value)
-    status = dpiOci__jsonTextBufferParse(json, value, valueLength,
-                flags, &error);
-    return dpiGen__endPublicFn(json, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiJson_setValue() [PUBLIC]
-//   Sets the value of the JSON object, given a hierarchy of nodes.
-//-----------------------------------------------------------------------------
-int dpiJson_setValue(dpiJson *json, dpiJsonNode *topNode)
-{
-    dpiError error;
-    int status;
-
-    if (dpiGen__startPublicFn(json, DPI_HTYPE_JSON, __func__, &error) < 0)
-        return dpiGen__endPublicFn(json, DPI_FAILURE, &error);
-    status = dpiJson__setValue(json, topNode, &error);
-    return dpiGen__endPublicFn(json, status, &error);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiJson.h ./odpi/src/dpiJson.h
--- patched-godror/odpi/src/dpiJson.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiJson.h	2024-05-14 14:55:13
@@ -0,0 +1,832 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2020, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiJson.c
+//   Implementation of JSON manipulation routines.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+// define number of nodes which are processed in each batch
+#define DPI_JSON_BATCH_NODES            64
+
+// define batch size of space allocated for temporary buffers used for
+// converting numbers to text
+#define DPI_JSON_TEMP_BUFFER_SIZE       1024
+
+// forward declarations of internal functions only used in this file
+static int dpiJsonNode__fromOracleArrayToNative(dpiJson *json,
+        dpiJsonNode *node, dpiJznDomDoc *domDoc, void *oracleNode,
+        uint32_t options, dpiError *error);
+static int dpiJsonNode__fromOracleObjectToNative(dpiJson *json,
+        dpiJsonNode *node, dpiJznDomDoc *domDoc, void *oracleNode,
+        uint32_t options, dpiError *error);
+static int dpiJsonNode__fromOracleScalarToNative(dpiJson *json,
+        dpiJsonNode *node, dpiJznDomDoc *domDoc, void *oracleNode,
+        uint32_t options, dpiError *error);
+static int dpiJsonNode__fromOracleToNative(dpiJson *json, dpiJsonNode *node,
+        dpiJznDomDoc *domDoc, void *oracleNode, uint32_t options,
+        dpiError *error);
+static int dpiJsonNode__toOracleFromNative(dpiJson *json, dpiJsonNode *node,
+        dpiJznDomDoc *domDoc, void **oracleNode, dpiError *error);
+
+
+//-----------------------------------------------------------------------------
+// dpiJson__allocate() [INTERNAL]
+//   Allocate and initialize a JSON object.
+//-----------------------------------------------------------------------------
+int dpiJson__allocate(dpiConn *conn, dpiJson **json, dpiError *error)
+{
+    dpiJson *tempJson;
+
+    if (dpiUtils__checkClientVersion(conn->env->versionInfo, 21, 0, error) < 0)
+        return DPI_FAILURE;
+    if (dpiGen__allocate(DPI_HTYPE_JSON, conn->env, (void**) &tempJson,
+            error) < 0)
+        return DPI_FAILURE;
+    dpiGen__setRefCount(conn, error, 1);
+    tempJson->conn = conn;
+    if (dpiOci__descriptorAlloc(conn->env->handle, &tempJson->handle,
+            DPI_OCI_DTYPE_JSON, "allocate JSON descriptor", error) < 0) {
+        dpiJson__free(tempJson, error);
+        return DPI_FAILURE;
+    }
+    tempJson->topNode.value = &tempJson->topNodeBuffer;
+    tempJson->topNode.oracleTypeNum = DPI_ORACLE_TYPE_NONE;
+    tempJson->topNode.nativeTypeNum = DPI_NATIVE_TYPE_NULL;
+
+    *json = tempJson;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJsonNode__fromOracleArrayToNative() [INTERNAL]
+//   Populate an array node from the Oracle JSON node.
+//-----------------------------------------------------------------------------
+static int dpiJsonNode__fromOracleArrayToNative(dpiJson *json,
+        dpiJsonNode *node, dpiJznDomDoc *domDoc, void *oracleNode,
+        uint32_t options, dpiError *error)
+{
+    void *oracleElementNodes[DPI_JSON_BATCH_NODES];
+    uint32_t pos, i, numInBatch;
+    dpiJsonNode *elementNode;
+    dpiJsonArray *array;
+
+    // define node types
+    node->oracleTypeNum = DPI_ORACLE_TYPE_JSON_ARRAY;
+    node->nativeTypeNum = DPI_NATIVE_TYPE_JSON_ARRAY;
+
+    // determine number of elements in the array; if no elements exist in the
+    // array, nothing further needs to be done at this point
+    array = &node->value->asJsonArray;
+    array->numElements = (*domDoc->methods->fnGetArraySize)(domDoc,
+            oracleNode);
+    if (array->numElements == 0)
+        return DPI_SUCCESS;
+
+    // allocate memory
+    if (dpiUtils__allocateMemory(array->numElements, sizeof(dpiJsonNode), 1,
+            "allocate JSON array element nodes", (void**) &array->elements,
+            error) < 0)
+        return DPI_FAILURE;
+    if (dpiUtils__allocateMemory(array->numElements, sizeof(dpiDataBuffer), 1,
+            "allocate JSON array element values",
+            (void**) &array->elementValues, error) < 0)
+        return DPI_FAILURE;
+
+    // process all of the nodes in the array in batches
+    pos = 0;
+    while (pos < array->numElements) {
+        numInBatch = (*domDoc->methods->fnGetArrayElemBatch)(domDoc,
+                oracleNode, pos, DPI_JSON_BATCH_NODES,
+                oracleElementNodes);
+        for (i = 0; i < numInBatch; i++) {
+            elementNode = &array->elements[pos + i];
+            elementNode->value = &array->elementValues[pos + i];
+            if (dpiJsonNode__fromOracleToNative(json, elementNode, domDoc,
+                    oracleElementNodes[i], options, error) < 0)
+                return DPI_FAILURE;
+        }
+        pos += numInBatch;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJsonNode__fromOracleObjectToNative() [INTERNAL]
+//   Populate an object node from the Oracle JSON node.
+//-----------------------------------------------------------------------------
+static int dpiJsonNode__fromOracleObjectToNative(dpiJson *json,
+        dpiJsonNode *node, dpiJznDomDoc *domDoc, void *oracleNode,
+        uint32_t options, dpiError *error)
+{
+    dpiJznDomNameValuePair nameValuePairs[DPI_JSON_BATCH_NODES];
+    uint32_t pos, i, numInBatch;
+    dpiJsonNode *fieldNode;
+    dpiJsonObject *obj;
+
+    // define node types
+    node->oracleTypeNum = DPI_ORACLE_TYPE_JSON_OBJECT;
+    node->nativeTypeNum = DPI_NATIVE_TYPE_JSON_OBJECT;
+
+    // determine number of fields in the object; if no fields exist in the
+    // object, nothing further needs to be done at this point
+    obj = &node->value->asJsonObject;
+    obj->numFields = (*domDoc->methods->fnGetNumObjField)(domDoc, oracleNode);
+    if (obj->numFields == 0)
+        return DPI_SUCCESS;
+
+    // allocate memory
+    if (dpiUtils__allocateMemory(obj->numFields, sizeof(char*), 1,
+            "allocate JSON object field names", (void**) &obj->fieldNames,
+            error) < 0)
+        return DPI_FAILURE;
+    if (dpiUtils__allocateMemory(obj->numFields, sizeof(uint32_t), 1,
+            "allocate JSON object field name lengths",
+            (void**) &obj->fieldNameLengths, error) < 0)
+        return DPI_FAILURE;
+    if (dpiUtils__allocateMemory(obj->numFields, sizeof(dpiJsonNode), 1,
+            "allocate JSON object field nodes", (void**) &obj->fields,
+            error) < 0)
+        return DPI_FAILURE;
+    if (dpiUtils__allocateMemory(obj->numFields, sizeof(dpiDataBuffer), 1,
+            "allocate JSON object field values", (void**) &obj->fieldValues,
+            error) < 0)
+        return DPI_FAILURE;
+
+    // process all of the nodes in the object in batches
+    pos = 0;
+    while (pos < obj->numFields) {
+        numInBatch = (*domDoc->methods->fnGetFieldNamesAndValsBatch)(domDoc,
+                oracleNode, pos, DPI_JSON_BATCH_NODES, nameValuePairs);
+        for (i = 0; i < numInBatch; i++) {
+            obj->fieldNames[pos + i] = nameValuePairs[i].name.ptr;
+            obj->fieldNameLengths[pos + i] = nameValuePairs[i].name.length;
+            fieldNode = &obj->fields[pos + i];
+            fieldNode->value = &obj->fieldValues[pos + i];
+            if (dpiJsonNode__fromOracleToNative(json, fieldNode, domDoc,
+                    nameValuePairs[i].value, options, error) < 0)
+                return DPI_FAILURE;
+        }
+        pos += numInBatch;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJsonNode__fromOracleNumberAsText() [INTERNAL]
+//   Populate a scalar number as a text buffer. Temporary buffers are allocated
+// as needed and an array of these are stored in the JSON object. Each
+// temporary buffer contains as many numbers as can be fit before a new
+// temporary buffer is allocated.
+//-----------------------------------------------------------------------------
+static int dpiJsonNode__fromOracleNumberAsText(dpiJson *json,
+        dpiJsonNode *node, uint8_t *numBuffer, dpiError *error)
+{
+    char **tempBuffers;
+
+    // if there is no room in the current temporary buffer, allocate a new one
+    if (json->tempBufferUsed + DPI_NUMBER_AS_TEXT_CHARS <
+            DPI_JSON_TEMP_BUFFER_SIZE) {
+
+        // if no room is available in the temp buffer array, increase the size
+        // of the array
+        if (json->numTempBuffers == json->allocatedTempBuffers) {
+            json->allocatedTempBuffers += 16;
+            if (dpiUtils__allocateMemory(json->allocatedTempBuffers,
+                    sizeof(char*), 0, "allocate JSON temp buffer array",
+                    (void**) &tempBuffers, error) < 0)
+                return DPI_FAILURE;
+            if (json->numTempBuffers > 0) {
+                memcpy(tempBuffers, json->tempBuffers,
+                        json->numTempBuffers * sizeof(char*));
+                dpiUtils__freeMemory(json->tempBuffers);
+            }
+            json->tempBuffers = tempBuffers;
+        }
+
+        // allocate a new temporary buffer
+        if (dpiUtils__allocateMemory(1, DPI_JSON_TEMP_BUFFER_SIZE, 0,
+                "allocate JSON temp buffer",
+                (void**) &json->tempBuffers[json->numTempBuffers], error) < 0)
+            return DPI_FAILURE;
+        json->numTempBuffers++;
+        json->tempBufferUsed = 0;
+
+    }
+
+    // perform the conversion
+    node->value->asBytes.ptr = json->tempBuffers[json->numTempBuffers - 1] +
+            json->tempBufferUsed;
+    node->value->asBytes.length = DPI_NUMBER_AS_TEXT_CHARS;
+    return dpiDataBuffer__fromOracleNumberAsText(node->value, json->env,
+            error, numBuffer);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJsonNode__fromOracleScalarToNative() [INTERNAL]
+//   Populate a scalar node from the Oracle JSON node.
+//-----------------------------------------------------------------------------
+static int dpiJsonNode__fromOracleScalarToNative(dpiJson *json,
+        dpiJsonNode *node, dpiJznDomDoc *domDoc, void *oracleNode,
+        uint32_t options, dpiError *error)
+{
+    dpiJznDomScalar scalar;
+    dpiJsonOciVal ociVal;
+
+    (*domDoc->methods->fnGetScalarInfoOci)(domDoc, oracleNode, &scalar,
+            &ociVal);
+    switch (scalar.valueType) {
+        case DPI_JZNVAL_BINARY:
+        case DPI_JZNVAL_STRING:
+            node->oracleTypeNum = (scalar.valueType == DPI_JZNVAL_STRING) ?
+                    DPI_ORACLE_TYPE_VARCHAR : DPI_ORACLE_TYPE_RAW;
+            node->nativeTypeNum = DPI_NATIVE_TYPE_BYTES;
+            node->value->asBytes.ptr = scalar.value.asBytes.value;
+            node->value->asBytes.length = scalar.value.asBytes.valueLength;
+            return DPI_SUCCESS;
+        case DPI_JZNVAL_FLOAT:
+            node->oracleTypeNum = DPI_ORACLE_TYPE_NUMBER;
+            node->nativeTypeNum = DPI_NATIVE_TYPE_DOUBLE;
+            node->value->asDouble = scalar.value.asFloat.value;
+            return DPI_SUCCESS;
+        case DPI_JZNVAL_DOUBLE:
+            node->oracleTypeNum = DPI_ORACLE_TYPE_NUMBER;
+            node->nativeTypeNum = DPI_NATIVE_TYPE_DOUBLE;
+            node->value->asDouble = scalar.value.asDouble.value;
+            return DPI_SUCCESS;
+        case DPI_JZNVAL_ORA_SIGNED_INT:
+        case DPI_JZNVAL_ORA_SIGNED_LONG:
+        case DPI_JZNVAL_ORA_DECIMAL128:
+        case DPI_JZNVAL_ORA_NUMBER:
+            if (scalar.valueType != DPI_JZNVAL_ORA_NUMBER) {
+                ociVal.asJsonNumber[0] =
+                        (uint8_t) scalar.value.asOciVal.valueLength;
+                memcpy(&ociVal.asJsonNumber[1], scalar.value.asOciVal.value,
+                        scalar.value.asOciVal.valueLength);
+            }
+            node->oracleTypeNum = DPI_ORACLE_TYPE_NUMBER;
+            if (options & DPI_JSON_OPT_NUMBER_AS_STRING) {
+                node->nativeTypeNum = DPI_NATIVE_TYPE_BYTES;
+                return dpiJsonNode__fromOracleNumberAsText(json, node,
+                        ociVal.asJsonNumber, error);
+            }
+            node->nativeTypeNum = DPI_NATIVE_TYPE_DOUBLE;
+            return dpiDataBuffer__fromOracleNumberAsDouble(node->value, error,
+                    ociVal.asJsonNumber);
+        case DPI_JZNVAL_ORA_DATE:
+        case DPI_JZNVAL_ORA_TIMESTAMP:
+        case DPI_JZNVAL_ORA_TIMESTAMPTZ:
+            node->oracleTypeNum = (scalar.valueType == DPI_JZNVAL_ORA_DATE) ?
+                    DPI_ORACLE_TYPE_DATE : DPI_ORACLE_TYPE_TIMESTAMP;
+            if (options & DPI_JSON_OPT_DATE_AS_DOUBLE) {
+                node->nativeTypeNum = DPI_NATIVE_TYPE_DOUBLE;
+                if (dpiDataBuffer__fromOracleDateAsDouble(node->value,
+                        json->env, error,
+                        (dpiOciDate*) &ociVal.asJsonDateTime) < 0)
+                    return DPI_FAILURE;
+                node->value->asDouble +=
+                        (ociVal.asJsonDateTime.fsecond / 1000000);
+                return DPI_SUCCESS;
+            }
+            node->nativeTypeNum = DPI_NATIVE_TYPE_TIMESTAMP;
+            node->value->asTimestamp.year = ociVal.asJsonDateTime.year;
+            node->value->asTimestamp.month = ociVal.asJsonDateTime.month;
+            node->value->asTimestamp.day = ociVal.asJsonDateTime.day;
+            node->value->asTimestamp.hour = ociVal.asJsonDateTime.hour;
+            node->value->asTimestamp.minute = ociVal.asJsonDateTime.minute;
+            node->value->asTimestamp.second = ociVal.asJsonDateTime.second;
+            node->value->asTimestamp.fsecond = ociVal.asJsonDateTime.fsecond;
+            node->value->asTimestamp.tzHourOffset =
+                    ociVal.asJsonDateTime.tzHourOffset;
+            node->value->asTimestamp.tzMinuteOffset =
+                    ociVal.asJsonDateTime.tzMinuteOffset;
+            return DPI_SUCCESS;
+        case DPI_JZNVAL_ORA_DAYSECOND_DUR:
+            node->oracleTypeNum = DPI_ORACLE_TYPE_INTERVAL_DS;
+            node->nativeTypeNum = DPI_NATIVE_TYPE_INTERVAL_DS;
+            node->value->asIntervalDS.days = ociVal.asJsonDayInterval.days;
+            node->value->asIntervalDS.hours = ociVal.asJsonDayInterval.hours;
+            node->value->asIntervalDS.minutes =
+                    ociVal.asJsonDayInterval.minutes;
+            node->value->asIntervalDS.seconds =
+                    ociVal.asJsonDayInterval.seconds;
+            node->value->asIntervalDS.fseconds =
+                    ociVal.asJsonDayInterval.fseconds;
+            return DPI_SUCCESS;
+        case DPI_JZNVAL_ORA_YEARMONTH_DUR:
+            node->oracleTypeNum = DPI_ORACLE_TYPE_INTERVAL_YM;
+            node->nativeTypeNum = DPI_NATIVE_TYPE_INTERVAL_YM;
+            node->value->asIntervalYM.years = ociVal.asJsonYearInterval.years;
+            node->value->asIntervalYM.months =
+                    ociVal.asJsonYearInterval.months;
+            return DPI_SUCCESS;
+        case DPI_JZNVAL_FALSE:
+        case DPI_JZNVAL_TRUE:
+            node->oracleTypeNum = DPI_ORACLE_TYPE_BOOLEAN;
+            node->nativeTypeNum = DPI_NATIVE_TYPE_BOOLEAN;
+            node->value->asBoolean = (scalar.valueType == DPI_JZNVAL_TRUE);
+            return DPI_SUCCESS;
+        case DPI_JZNVAL_NULL:
+            node->oracleTypeNum = DPI_ORACLE_TYPE_NONE;
+            node->nativeTypeNum = DPI_NATIVE_TYPE_NULL;
+            return DPI_SUCCESS;
+        default:
+            break;
+    }
+
+    return dpiError__set(error, "populate scalar node from Oracle",
+            DPI_ERR_UNHANDLED_JSON_SCALAR_TYPE, scalar.valueType);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJsonNode__fromOracleToNative() [INTERNAL]
+//   Populate the JSON node structure from the Oracle JSON node.
+//-----------------------------------------------------------------------------
+static int dpiJsonNode__fromOracleToNative(dpiJson *json, dpiJsonNode *node,
+        dpiJznDomDoc *domDoc, void *oracleNode, uint32_t options,
+        dpiError *error)
+{
+    int nodeType;
+
+    nodeType = (*domDoc->methods->fnGetNodeType)(domDoc, oracleNode);
+    switch (nodeType) {
+        case DPI_JZNDOM_ARRAY:
+            return dpiJsonNode__fromOracleArrayToNative(json, node, domDoc,
+                    oracleNode, options, error);
+        case DPI_JZNDOM_OBJECT:
+            return dpiJsonNode__fromOracleObjectToNative(json, node, domDoc,
+                    oracleNode, options, error);
+        case DPI_JZNDOM_SCALAR:
+            return dpiJsonNode__fromOracleScalarToNative(json, node, domDoc,
+                    oracleNode, options, error);
+        default:
+            break;
+    }
+    return dpiError__set(error, "from Oracle to native node",
+            DPI_ERR_UNHANDLED_JSON_NODE_TYPE, nodeType);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJsonNode__toOracleArrayFromNative() [INTERNAL]
+//   Populate an Oracle array node from the JSON array node.
+//-----------------------------------------------------------------------------
+static int dpiJsonNode__toOracleArrayFromNative(dpiJson *json,
+        dpiJsonArray *array, dpiJznDomDoc *domDoc, void **oracleNode,
+        dpiError *error)
+{
+    dpiJsonNode *childNode;
+    void *oracleChildNode;
+    uint32_t i;
+
+    *oracleNode = domDoc->methods->fnNewArray(domDoc, array->numElements);
+    for (i = 0; i < array->numElements; i++) {
+        childNode = &array->elements[i];
+        if (dpiJsonNode__toOracleFromNative(json, childNode, domDoc,
+                &oracleChildNode, error) < 0) {
+            domDoc->methods->fnFreeNode(domDoc, *oracleNode);
+            return DPI_FAILURE;
+        }
+        domDoc->methods->fnAppendItem(domDoc, *oracleNode, oracleChildNode);
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJsonNode__toOracleObjectFromNative() [INTERNAL]
+//   Populate an Oracle object node from the JSON object node.
+//-----------------------------------------------------------------------------
+static int dpiJsonNode__toOracleObjectFromNative(dpiJson *json,
+        dpiJsonObject *obj, dpiJznDomDoc *domDoc, void **oracleNode,
+        dpiError *error)
+{
+    dpiJsonNode *childNode;
+    void *oracleChildNode;
+    uint32_t i;
+
+    *oracleNode = domDoc->methods->fnNewObject(domDoc, obj->numFields);
+    for (i = 0; i < obj->numFields; i++) {
+        childNode = &obj->fields[i];
+        if (dpiJsonNode__toOracleFromNative(json, childNode, domDoc,
+                &oracleChildNode, error) < 0) {
+            domDoc->methods->fnFreeNode(domDoc, *oracleNode);
+            return DPI_FAILURE;
+        }
+        domDoc->methods->fnPutFieldValue(domDoc, *oracleNode,
+                obj->fieldNames[i], (uint16_t) obj->fieldNameLengths[i],
+                oracleChildNode);
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJsonNode__toOracleFromNative() [INTERNAL]
+//   Create an Oracle node from the native node.
+//-----------------------------------------------------------------------------
+static int dpiJsonNode__toOracleFromNative(dpiJson *json, dpiJsonNode *node,
+        dpiJznDomDoc *domDoc, void **oracleNode, dpiError *error)
+{
+    dpiOracleDataBuffer dataBuffer;
+    int scalarType;
+
+    switch (node->oracleTypeNum) {
+        case DPI_ORACLE_TYPE_JSON_ARRAY:
+            if (node->nativeTypeNum == DPI_NATIVE_TYPE_JSON_ARRAY) {
+                return dpiJsonNode__toOracleArrayFromNative(json,
+                        &node->value->asJsonArray, domDoc, oracleNode, error);
+            }
+            break;
+        case DPI_ORACLE_TYPE_JSON_OBJECT:
+            if (node->nativeTypeNum == DPI_NATIVE_TYPE_JSON_OBJECT) {
+                return dpiJsonNode__toOracleObjectFromNative(json,
+                        &node->value->asJsonObject, domDoc, oracleNode, error);
+            }
+            break;
+        case DPI_ORACLE_TYPE_NUMBER:
+            if (node->nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
+                if (dpiDataBuffer__toOracleNumberFromDouble(node->value,
+                        error, &dataBuffer.asNumber) < 0)
+                    return DPI_FAILURE;
+            } else if (node->nativeTypeNum == DPI_NATIVE_TYPE_INT64) {
+                if (dpiDataBuffer__toOracleNumberFromInteger(node->value,
+                        error, &dataBuffer.asNumber) < 0)
+                    return DPI_FAILURE;
+            } else if (node->nativeTypeNum == DPI_NATIVE_TYPE_UINT64) {
+                if (dpiDataBuffer__toOracleNumberFromUnsignedInteger(
+                        node->value, error, &dataBuffer.asNumber) < 0)
+                    return DPI_FAILURE;
+            } else if (node->nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
+                if (dpiDataBuffer__toOracleNumberFromText(node->value,
+                        json->env, error, &dataBuffer.asNumber) < 0)
+                    return DPI_FAILURE;
+            } else {
+                break;
+            }
+            *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
+                    DPI_JZNVAL_OCI_NUMBER, &dataBuffer.asNumber);
+            return DPI_SUCCESS;
+        case DPI_ORACLE_TYPE_NATIVE_DOUBLE:
+            if (node->nativeTypeNum != DPI_NATIVE_TYPE_DOUBLE)
+                break;
+            *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
+                    DPI_JZNVAL_DOUBLE, node->value->asDouble);
+            return DPI_SUCCESS;
+        case DPI_ORACLE_TYPE_NATIVE_FLOAT:
+            if (node->nativeTypeNum != DPI_NATIVE_TYPE_FLOAT)
+                break;
+            *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
+                    DPI_JZNVAL_FLOAT, node->value->asFloat);
+            return DPI_SUCCESS;
+        case DPI_ORACLE_TYPE_RAW:
+        case DPI_ORACLE_TYPE_VARCHAR:
+            if (node->nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
+                scalarType = (node->oracleTypeNum == DPI_ORACLE_TYPE_RAW) ?
+                        DPI_JZNVAL_BINARY : DPI_JZNVAL_STRING;
+                *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
+                        scalarType, node->value->asBytes.ptr,
+                        node->value->asBytes.length);
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_DATE:
+            if (node->nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP) {
+                if (dpiDataBuffer__toOracleDate(node->value,
+                        &dataBuffer.asDate) < 0)
+                    return DPI_FAILURE;
+            } else if (node->nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
+                if (dpiDataBuffer__toOracleDateFromDouble(node->value,
+                        json->env, error, &dataBuffer.asDate) < 0)
+                    return DPI_FAILURE;
+            } else {
+                break;
+            }
+            *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
+                    DPI_JZNVAL_OCI_DATE, &dataBuffer.asDate);
+            return DPI_SUCCESS;
+        case DPI_ORACLE_TYPE_TIMESTAMP:
+            if (!json->convTimestamp) {
+                if (dpiOci__descriptorAlloc(json->env->handle,
+                        &json->convTimestamp, DPI_OCI_DTYPE_TIMESTAMP,
+                        "alloc timestamp for JSON", error) < 0)
+                    return DPI_FAILURE;
+            }
+            if (node->nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP) {
+                if (dpiDataBuffer__toOracleTimestamp(node->value, json->env,
+                        error, json->convTimestamp, 0) < 0)
+                    return DPI_FAILURE;
+            } else if (node->nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
+                if (dpiDataBuffer__toOracleTimestampFromDouble(node->value,
+                        node->oracleTypeNum, json->env, error,
+                        json->convTimestamp) < 0)
+                    return DPI_FAILURE;
+            } else {
+                break;
+            }
+            *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
+                    DPI_JZNVAL_OCI_DATETIME, json->convTimestamp);
+            return DPI_SUCCESS;
+        case DPI_ORACLE_TYPE_INTERVAL_DS:
+            if (!json->convIntervalDS) {
+                if (dpiOci__descriptorAlloc(json->env->handle,
+                        &json->convIntervalDS, DPI_OCI_DTYPE_INTERVAL_DS,
+                        "alloc interval DS for JSON", error) < 0)
+                    return DPI_FAILURE;
+            }
+            if (node->nativeTypeNum == DPI_NATIVE_TYPE_INTERVAL_DS) {
+                if (dpiDataBuffer__toOracleIntervalDS(node->value, json->env,
+                        error, json->convIntervalDS) < 0)
+                    return DPI_FAILURE;
+                *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
+                        DPI_JZNVAL_OCI_INTERVAL, json->convIntervalDS);
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_INTERVAL_YM:
+            if (!json->convIntervalYM) {
+                if (dpiOci__descriptorAlloc(json->env->handle,
+                        &json->convIntervalYM, DPI_OCI_DTYPE_INTERVAL_YM,
+                        "alloc interval YM for JSON", error) < 0)
+                    return DPI_FAILURE;
+            }
+            if (node->nativeTypeNum == DPI_NATIVE_TYPE_INTERVAL_YM) {
+                if (dpiDataBuffer__toOracleIntervalYM(node->value, json->env,
+                        error, json->convIntervalYM) < 0)
+                    return DPI_FAILURE;
+                *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
+                        DPI_JZNVAL_OCI_INTERVAL, json->convIntervalYM);
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_BOOLEAN:
+            if (node->nativeTypeNum == DPI_NATIVE_TYPE_BOOLEAN) {
+                scalarType = (node->value->asBoolean) ?
+                        DPI_JZNVAL_TRUE: DPI_JZNVAL_FALSE;
+                *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
+                        scalarType, NULL);
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_NONE:
+            if (node->nativeTypeNum == DPI_NATIVE_TYPE_NULL) {
+                *oracleNode = domDoc->methods->fnNewScalarVal(domDoc,
+                        DPI_JZNVAL_NULL, NULL);
+                return DPI_SUCCESS;
+            }
+            break;
+    }
+    *oracleNode = NULL;
+    return dpiError__set(error, "from native to Oracle node",
+            DPI_ERR_UNHANDLED_CONVERSION_TO_JSON, node->nativeTypeNum,
+            node->oracleTypeNum);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJson__setValue() [INTERNAL]
+//   Sets the value of the JSON object, given a hierarchy of nodes.
+//-----------------------------------------------------------------------------
+static int dpiJson__setValue(dpiJson *json, dpiJsonNode *topNode,
+        dpiError *error)
+{
+    const char *dummyValue = "0";
+    dpiJznDomDoc *domDoc;
+    void *oracleTopNode;
+    int mutable = 1;
+    uint32_t jsonFlags = 0;
+
+    // first, set the JSON descriptor as mutable
+    if (dpiOci__attrSet(json->handle, DPI_OCI_DTYPE_JSON,
+            (void*) &mutable, 0, DPI_OCI_ATTR_JSON_DOM_MUTABLE,
+            "set JSON descriptor mutable", error) < 0)
+        return DPI_FAILURE;
+
+    // write a dummy value to the JSON descriptor
+    if (dpiOci__jsonTextBufferParse(json, dummyValue, strlen(dummyValue),
+            jsonFlags, error) < 0)
+        return DPI_FAILURE;
+
+    // acquire the DOM doc which will be used to create the Oracle nodes
+    if (dpiOci__jsonDomDocGet(json, &domDoc, error) < 0)
+        return dpiGen__endPublicFn(json, DPI_FAILURE, error);
+
+    // convert the top node (and all of the child nodes to Oracle nodes)
+    if (dpiJsonNode__toOracleFromNative(json, topNode, domDoc, &oracleTopNode,
+            error) < 0)
+        return DPI_FAILURE;
+
+    // set the top node
+    domDoc->methods->fnSetRootNode(domDoc, oracleTopNode);
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJsonNode__free() [INTERNAL]
+//   Free the buffers allocated for the JSON node.
+//-----------------------------------------------------------------------------
+static void dpiJsonNode__free(dpiJsonNode *node)
+{
+    dpiJsonArray *array;
+    dpiJsonObject *obj;
+    uint32_t i;
+
+    if (node->oracleTypeNum == DPI_ORACLE_TYPE_JSON_ARRAY) {
+        array = &node->value->asJsonArray;
+        if (array->elements) {
+            for (i = 0; i < array->numElements; i++) {
+                if (array->elements[i].value)
+                    dpiJsonNode__free(&array->elements[i]);
+            }
+            dpiUtils__freeMemory(array->elements);
+            array->elements = NULL;
+        }
+        if (array->elementValues) {
+            dpiUtils__freeMemory(array->elementValues);
+            array->elementValues = NULL;
+        }
+    } else if (node->oracleTypeNum == DPI_ORACLE_TYPE_JSON_OBJECT) {
+        obj = &node->value->asJsonObject;
+        if (obj->fields) {
+            for (i = 0; i < obj->numFields; i++) {
+                if (obj->fields[i].value)
+                    dpiJsonNode__free(&obj->fields[i]);
+            }
+            dpiUtils__freeMemory(obj->fields);
+            obj->fields = NULL;
+        }
+        if (obj->fieldNames) {
+            dpiUtils__freeMemory(obj->fieldNames);
+            obj->fieldNames = NULL;
+        }
+        if (obj->fieldNameLengths) {
+            dpiUtils__freeMemory(obj->fieldNameLengths);
+            obj->fieldNameLengths = NULL;
+        }
+        if (obj->fieldValues) {
+            dpiUtils__freeMemory(obj->fieldValues);
+            obj->fieldValues = NULL;
+        }
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJson__free() [INTERNAL]
+//   Free the buffers allocated for the JSON value and all of its nodes, if
+// applicable.
+//-----------------------------------------------------------------------------
+void dpiJson__free(dpiJson *json, dpiError *error)
+{
+    uint32_t i;
+
+    if (json->handle) {
+        dpiOci__descriptorFree(json->handle, DPI_OCI_DTYPE_JSON);
+        json->handle = NULL;
+    }
+    if (json->conn) {
+        dpiGen__setRefCount(json->conn, error, -1);
+        json->conn = NULL;
+    }
+    if (json->tempBuffers) {
+        for (i = 0; i < json->numTempBuffers; i++)
+            dpiUtils__freeMemory(json->tempBuffers[i]);
+        dpiUtils__freeMemory(json->tempBuffers);
+        json->tempBuffers = NULL;
+    }
+    if (json->convTimestamp) {
+        dpiOci__descriptorFree(json->convTimestamp, DPI_OCI_DTYPE_TIMESTAMP);
+        json->convTimestamp = NULL;
+    }
+    if (json->convIntervalDS) {
+        dpiOci__descriptorFree(json->convIntervalDS,
+                DPI_OCI_DTYPE_INTERVAL_DS);
+        json->convIntervalDS = NULL;
+    }
+    if (json->convIntervalYM) {
+        dpiOci__descriptorFree(json->convIntervalYM,
+                DPI_OCI_DTYPE_INTERVAL_YM);
+        json->convIntervalYM = NULL;
+    }
+    dpiJsonNode__free(&json->topNode);
+    dpiUtils__freeMemory(json);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJson_addRef() [PUBLIC]
+//   Add a reference to the JSON object.
+//-----------------------------------------------------------------------------
+int dpiJson_addRef(dpiJson *json)
+{
+    return dpiGen__addRef(json, DPI_HTYPE_JSON, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJson_getValue() [PUBLIC]
+//   Gets the value of the JSON object as a hierarchy of nodes.
+//-----------------------------------------------------------------------------
+int dpiJson_getValue(dpiJson *json, uint32_t options, dpiJsonNode **topNode)
+{
+    dpiJznDomDoc *domDoc;
+    void *oracleNode;
+    dpiError error;
+
+    if (dpiGen__startPublicFn(json, DPI_HTYPE_JSON, __func__, &error) < 0)
+        return dpiGen__endPublicFn(json, DPI_FAILURE, &error);
+    dpiJsonNode__free(&json->topNode);
+    json->topNode.value = &json->topNodeBuffer;
+    json->topNode.oracleTypeNum = DPI_ORACLE_TYPE_NONE;
+    json->topNode.nativeTypeNum = DPI_NATIVE_TYPE_NULL;
+    if (dpiOci__jsonDomDocGet(json, &domDoc, &error) < 0)
+        return dpiGen__endPublicFn(json, DPI_FAILURE, &error);
+    if (domDoc) {
+        oracleNode = (*domDoc->methods->fnGetRootNode)(domDoc);
+        if (dpiJsonNode__fromOracleToNative(json, &json->topNode, domDoc,
+                oracleNode, options, &error) < 0)
+            return dpiGen__endPublicFn(json, DPI_FAILURE, &error);
+    }
+
+    *topNode = &json->topNode;
+    return dpiGen__endPublicFn(json, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJson_release() [PUBLIC]
+//   Release a reference to the JSON object.
+//-----------------------------------------------------------------------------
+int dpiJson_release(dpiJson *json)
+{
+    return dpiGen__release(json, DPI_HTYPE_JSON, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJson_setFromText() [PUBLIC]
+//   Sets the value of the JSON handle, given a JSON string.
+//-----------------------------------------------------------------------------
+int dpiJson_setFromText(dpiJson *json, const char *value, uint64_t valueLength,
+        uint32_t flags)
+{
+    dpiError error;
+    int status;
+
+    if (dpiGen__startPublicFn(json, DPI_HTYPE_JSON, __func__, &error) < 0)
+        return dpiGen__endPublicFn(json, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(json, value)
+    status = dpiOci__jsonTextBufferParse(json, value, valueLength,
+                flags, &error);
+    return dpiGen__endPublicFn(json, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiJson_setValue() [PUBLIC]
+//   Sets the value of the JSON object, given a hierarchy of nodes.
+//-----------------------------------------------------------------------------
+int dpiJson_setValue(dpiJson *json, dpiJsonNode *topNode)
+{
+    dpiError error;
+    int status;
+
+    if (dpiGen__startPublicFn(json, DPI_HTYPE_JSON, __func__, &error) < 0)
+        return dpiGen__endPublicFn(json, DPI_FAILURE, &error);
+    status = dpiJson__setValue(json, topNode, &error);
+    return dpiGen__endPublicFn(json, status, &error);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiLob.c ./odpi/src/dpiLob.c
--- patched-godror/odpi/src/dpiLob.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiLob.c	1970-01-01 01:00:00
@@ -1,533 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiLob.c
-//   Implementation of LOB data.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiLob__allocate() [INTERNAL]
-//   Allocate and initialize LOB object.
-//-----------------------------------------------------------------------------
-int dpiLob__allocate(dpiConn *conn, const dpiOracleType *type, dpiLob **lob,
-        dpiError *error)
-{
-    dpiLob *tempLob;
-
-    if (dpiGen__allocate(DPI_HTYPE_LOB, conn->env, (void**) &tempLob,
-            error) < 0)
-        return DPI_FAILURE;
-    dpiGen__setRefCount(conn, error, 1);
-    tempLob->conn = conn;
-    tempLob->type = type;
-    if (dpiOci__descriptorAlloc(conn->env->handle, &tempLob->locator,
-            DPI_OCI_DTYPE_LOB, "allocate descriptor", error) < 0) {
-        dpiLob__free(tempLob, error);
-        return DPI_FAILURE;
-    }
-    if (dpiHandleList__addHandle(conn->openLobs, tempLob,
-            &tempLob->openSlotNum, error) < 0) {
-        dpiOci__descriptorFree(tempLob->locator, DPI_OCI_DTYPE_LOB);
-        tempLob->locator = NULL;
-        dpiLob__free(tempLob, error);
-        return DPI_FAILURE;
-    }
-
-    *lob = tempLob;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob__check() [INTERNAL]
-//   Check that the LOB is valid and get an error handle for subsequent calls.
-//-----------------------------------------------------------------------------
-static int dpiLob__check(dpiLob *lob, const char *fnName, dpiError *error)
-{
-    if (dpiGen__startPublicFn(lob, DPI_HTYPE_LOB, fnName, error) < 0)
-        return DPI_FAILURE;
-    if (!lob->locator)
-        return dpiError__set(error, "check closed", DPI_ERR_LOB_CLOSED);
-    return dpiConn__checkConnected(lob->conn, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob__close() [INTERNAL]
-//   Internal method used for closing the LOB.
-//-----------------------------------------------------------------------------
-int dpiLob__close(dpiLob *lob, int propagateErrors, dpiError *error)
-{
-    int isTemporary, closing, status = DPI_SUCCESS;
-
-    // determine whether LOB is already being closed and if not, mark LOB as
-    // being closed; this MUST be done while holding the lock (if in threaded
-    // mode) to avoid race conditions!
-    if (lob->env->threaded)
-        dpiMutex__acquire(lob->env->mutex);
-    closing = lob->closing;
-    lob->closing = 1;
-    if (lob->env->threaded)
-        dpiMutex__release(lob->env->mutex);
-
-    // if LOB is already being closed, nothing needs to be done
-    if (closing)
-        return DPI_SUCCESS;
-
-    // perform actual work of closing LOB
-    if (lob->locator) {
-        if (!lob->conn->deadSession && lob->conn->handle) {
-            status = dpiOci__lobIsTemporary(lob, &isTemporary, propagateErrors,
-                    error);
-            if (isTemporary && status == DPI_SUCCESS)
-                status = dpiOci__lobFreeTemporary(lob->conn,
-                        lob->locator, propagateErrors, error);
-        }
-        dpiOci__descriptorFree(lob->locator, DPI_OCI_DTYPE_LOB);
-        if (!lob->conn->closing)
-            dpiHandleList__removeHandle(lob->conn->openLobs, lob->openSlotNum);
-        lob->locator = NULL;
-    }
-    if (lob->buffer) {
-        dpiUtils__freeMemory(lob->buffer);
-        lob->buffer = NULL;
-    }
-
-    // if actual close fails, reset closing flag; again, this must be done
-    // while holding the lock (if in threaded mode) in order to avoid race
-    // conditions!
-    if (status < 0) {
-        if (lob->env->threaded)
-            dpiMutex__acquire(lob->env->mutex);
-        lob->closing = 0;
-        if (lob->env->threaded)
-            dpiMutex__release(lob->env->mutex);
-    }
-
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob__free() [INTERNAL]
-//   Free the memory for a LOB.
-//-----------------------------------------------------------------------------
-void dpiLob__free(dpiLob *lob, dpiError *error)
-{
-    dpiLob__close(lob, 0, error);
-    if (lob->conn) {
-        dpiGen__setRefCount(lob->conn, error, -1);
-        lob->conn = NULL;
-    }
-    dpiUtils__freeMemory(lob);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob__readBytes() [INTERNAL]
-//   Return a portion (or all) of the data in the LOB.
-//-----------------------------------------------------------------------------
-int dpiLob__readBytes(dpiLob *lob, uint64_t offset, uint64_t amount,
-        char *value, uint64_t *valueLength, dpiError *error)
-{
-    uint64_t lengthInBytes = 0, lengthInChars = 0;
-    int isOpen = 0;
-
-    // amount is in characters for character LOBs and bytes for binary LOBs
-    if (lob->type->isCharacterData)
-        lengthInChars = amount;
-    else lengthInBytes = amount;
-
-    // for files, open the file if needed
-    if (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_BFILE) {
-        if (dpiOci__lobIsOpen(lob, &isOpen, error) < 0)
-            return DPI_FAILURE;
-        if (!isOpen) {
-            if (dpiOci__lobOpen(lob, error) < 0)
-                return DPI_FAILURE;
-        }
-    }
-
-    // read the bytes from the LOB
-    if (dpiOci__lobRead2(lob, offset, &lengthInBytes, &lengthInChars,
-            value, *valueLength, error) < 0)
-        return DPI_FAILURE;
-    *valueLength = lengthInBytes;
-
-    // if file was opened in this routine, close it again
-    if (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_BFILE && !isOpen) {
-        if (dpiOci__lobClose(lob, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob__setFromBytes() [INTERNAL]
-//   Clear the LOB completely and then write the specified bytes to it.
-//-----------------------------------------------------------------------------
-int dpiLob__setFromBytes(dpiLob *lob, const char *value, uint64_t valueLength,
-        dpiError *error)
-{
-    if (dpiOci__lobTrim2(lob, 0, error) < 0)
-        return DPI_FAILURE;
-    if (valueLength == 0)
-        return DPI_SUCCESS;
-    return dpiOci__lobWrite2(lob, 1, value, valueLength, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_addRef() [PUBLIC]
-//   Add a reference to the LOB.
-//-----------------------------------------------------------------------------
-int dpiLob_addRef(dpiLob *lob)
-{
-    return dpiGen__addRef(lob, DPI_HTYPE_LOB, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_close() [PUBLIC]
-//   Close the LOB and make it unusable for further operations.
-//-----------------------------------------------------------------------------
-int dpiLob_close(dpiLob *lob)
-{
-    dpiError error;
-    int status;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    status = dpiLob__close(lob, 1, &error);
-    return dpiGen__endPublicFn(lob, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_closeResource() [PUBLIC]
-//   Close the LOB's resources.
-//-----------------------------------------------------------------------------
-int dpiLob_closeResource(dpiLob *lob)
-{
-    dpiError error;
-    int status;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    status = dpiOci__lobClose(lob, &error);
-    return dpiGen__endPublicFn(lob, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_copy() [PUBLIC]
-//   Create a copy of the LOB and return it.
-//-----------------------------------------------------------------------------
-int dpiLob_copy(dpiLob *lob, dpiLob **copiedLob)
-{
-    dpiLob *tempLob;
-    dpiError error;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(lob, copiedLob)
-    if (dpiLob__allocate(lob->conn, lob->type, &tempLob, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    if (dpiOci__lobLocatorAssign(lob, &tempLob->locator, &error) < 0) {
-        dpiLob__free(tempLob, &error);
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    }
-    *copiedLob = tempLob;
-    return dpiGen__endPublicFn(lob, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_getBufferSize() [PUBLIC]
-//   Get the required size of a buffer given the number of characters. If the
-// LOB does not refer to a character LOB the value is returned unchanged.
-//-----------------------------------------------------------------------------
-int dpiLob_getBufferSize(dpiLob *lob, uint64_t sizeInChars,
-        uint64_t *sizeInBytes)
-{
-    dpiError error;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(lob, sizeInBytes)
-    if (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_CLOB)
-        *sizeInBytes = sizeInChars * lob->env->maxBytesPerCharacter;
-    else if (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_NCLOB)
-        *sizeInBytes = sizeInChars * lob->env->nmaxBytesPerCharacter;
-    else *sizeInBytes = sizeInChars;
-    return dpiGen__endPublicFn(lob, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_getChunkSize() [PUBLIC]
-//   Return the chunk size associated with the LOB.
-//-----------------------------------------------------------------------------
-int dpiLob_getChunkSize(dpiLob *lob, uint32_t *size)
-{
-    dpiError error;
-    int status;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(lob, size)
-    status = dpiOci__lobGetChunkSize(lob, size, &error);
-    return dpiGen__endPublicFn(lob, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_getDirectoryAndFileName() [PUBLIC]
-//   Return the directory alias and file name for the BFILE lob.
-//-----------------------------------------------------------------------------
-int dpiLob_getDirectoryAndFileName(dpiLob *lob, const char **directoryAlias,
-        uint32_t *directoryAliasLength, const char **fileName,
-        uint32_t *fileNameLength)
-{
-    uint16_t ociDirectoryAliasLength, ociFileNameLength;
-    dpiError error;
-
-    // validate parameters
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(lob, directoryAlias)
-    DPI_CHECK_PTR_NOT_NULL(lob, directoryAliasLength)
-    DPI_CHECK_PTR_NOT_NULL(lob, fileName)
-    DPI_CHECK_PTR_NOT_NULL(lob, fileNameLength)
-
-    // get directory and file name
-    ociDirectoryAliasLength = 30;
-    ociFileNameLength = 255;
-    if (!lob->buffer) {
-        if (dpiUtils__allocateMemory(1,
-                ociDirectoryAliasLength + ociFileNameLength, 0,
-                "allocate name buffer", (void**) &lob->buffer, &error) < 0)
-            return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    }
-    *directoryAlias = lob->buffer;
-    *fileName = lob->buffer + ociDirectoryAliasLength;
-    if (dpiOci__lobFileGetName(lob, (char*) *directoryAlias,
-            &ociDirectoryAliasLength, (char*) *fileName, &ociFileNameLength,
-            &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    *directoryAliasLength = ociDirectoryAliasLength;
-    *fileNameLength = ociFileNameLength;
-    return dpiGen__endPublicFn(lob, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_getFileExists() [PUBLIC]
-//   Return whether or not the file pointed to by the locator exists.
-//-----------------------------------------------------------------------------
-int dpiLob_getFileExists(dpiLob *lob, int *exists)
-{
-    dpiError error;
-    int status;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(lob, exists)
-    status = dpiOci__lobFileExists(lob, exists, &error);
-    return dpiGen__endPublicFn(lob, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_getIsResourceOpen() [PUBLIC]
-//   Return whether or not the LOB' resources are open.
-//-----------------------------------------------------------------------------
-int dpiLob_getIsResourceOpen(dpiLob *lob, int *isOpen)
-{
-    dpiError error;
-    int status;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(lob, isOpen)
-    status = dpiOci__lobIsOpen(lob, isOpen, &error);
-    return dpiGen__endPublicFn(lob, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_getSize() [PUBLIC]
-//   Returns the size of the LOB.
-//-----------------------------------------------------------------------------
-int dpiLob_getSize(dpiLob *lob, uint64_t *size)
-{
-    dpiError error;
-    int status;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(lob, size)
-    status = dpiOci__lobGetLength2(lob, size, &error);
-    return dpiGen__endPublicFn(lob, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_getType() [PUBLIC]
-//   Returns the type of the LOB.
-//-----------------------------------------------------------------------------
-int dpiLob_getType(dpiLob *lob, dpiOracleTypeNum *type)
-{
-    dpiError error;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(lob, type)
-    *type = lob->type->oracleTypeNum;
-    return dpiGen__endPublicFn(lob, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_openResource() [PUBLIC]
-//   Open the LOB's resources to speed further accesses.
-//-----------------------------------------------------------------------------
-int dpiLob_openResource(dpiLob *lob)
-{
-    dpiError error;
-    int status;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    status = dpiOci__lobOpen(lob, &error);
-    return dpiGen__endPublicFn(lob, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_readBytes() [PUBLIC]
-//   Return a portion (or all) of the data in the LOB.
-//-----------------------------------------------------------------------------
-int dpiLob_readBytes(dpiLob *lob, uint64_t offset, uint64_t amount,
-        char *value, uint64_t *valueLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(lob, value)
-    DPI_CHECK_PTR_NOT_NULL(lob, valueLength)
-    status = dpiLob__readBytes(lob, offset, amount, value, valueLength,
-            &error);
-    return dpiGen__endPublicFn(lob, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_release() [PUBLIC]
-//   Release a reference to the LOB.
-//-----------------------------------------------------------------------------
-int dpiLob_release(dpiLob *lob)
-{
-    return dpiGen__release(lob, DPI_HTYPE_LOB, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_setDirectoryAndFileName() [PUBLIC]
-//   Set the directory alias and file name for the BFILE LOB.
-//-----------------------------------------------------------------------------
-int dpiLob_setDirectoryAndFileName(dpiLob *lob, const char *directoryAlias,
-        uint32_t directoryAliasLength, const char *fileName,
-        uint32_t fileNameLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(lob, directoryAlias)
-    DPI_CHECK_PTR_NOT_NULL(lob, fileName)
-    status = dpiOci__lobFileSetName(lob, directoryAlias,
-            (uint16_t) directoryAliasLength, fileName,
-            (uint16_t) fileNameLength, &error);
-    return dpiGen__endPublicFn(lob, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_setFromBytes() [PUBLIC]
-//   Clear the LOB completely and then write the specified bytes to it.
-//-----------------------------------------------------------------------------
-int dpiLob_setFromBytes(dpiLob *lob, const char *value, uint64_t valueLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(lob, value)
-    status = dpiLob__setFromBytes(lob, value, valueLength, &error);
-    return dpiGen__endPublicFn(lob, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_trim() [PUBLIC]
-//   Trim the LOB to the specified length.
-//-----------------------------------------------------------------------------
-int dpiLob_trim(dpiLob *lob, uint64_t newSize)
-{
-    dpiError error;
-    int status;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    status = dpiOci__lobTrim2(lob, newSize, &error);
-    return dpiGen__endPublicFn(lob, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiLob_writeBytes() [PUBLIC]
-//   Write the data to the LOB at the offset specified.
-//-----------------------------------------------------------------------------
-int dpiLob_writeBytes(dpiLob *lob, uint64_t offset, const char *value,
-        uint64_t valueLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiLob__check(lob, __func__, &error) < 0)
-        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(lob, value)
-    status = dpiOci__lobWrite2(lob, offset, value, valueLength, &error);
-    return dpiGen__endPublicFn(lob, status, &error);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiLob.h ./odpi/src/dpiLob.h
--- patched-godror/odpi/src/dpiLob.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiLob.h	2024-05-14 14:55:13
@@ -0,0 +1,533 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiLob.c
+//   Implementation of LOB data.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiLob__allocate() [INTERNAL]
+//   Allocate and initialize LOB object.
+//-----------------------------------------------------------------------------
+int dpiLob__allocate(dpiConn *conn, const dpiOracleType *type, dpiLob **lob,
+        dpiError *error)
+{
+    dpiLob *tempLob;
+
+    if (dpiGen__allocate(DPI_HTYPE_LOB, conn->env, (void**) &tempLob,
+            error) < 0)
+        return DPI_FAILURE;
+    dpiGen__setRefCount(conn, error, 1);
+    tempLob->conn = conn;
+    tempLob->type = type;
+    if (dpiOci__descriptorAlloc(conn->env->handle, &tempLob->locator,
+            DPI_OCI_DTYPE_LOB, "allocate descriptor", error) < 0) {
+        dpiLob__free(tempLob, error);
+        return DPI_FAILURE;
+    }
+    if (dpiHandleList__addHandle(conn->openLobs, tempLob,
+            &tempLob->openSlotNum, error) < 0) {
+        dpiOci__descriptorFree(tempLob->locator, DPI_OCI_DTYPE_LOB);
+        tempLob->locator = NULL;
+        dpiLob__free(tempLob, error);
+        return DPI_FAILURE;
+    }
+
+    *lob = tempLob;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob__check() [INTERNAL]
+//   Check that the LOB is valid and get an error handle for subsequent calls.
+//-----------------------------------------------------------------------------
+static int dpiLob__check(dpiLob *lob, const char *fnName, dpiError *error)
+{
+    if (dpiGen__startPublicFn(lob, DPI_HTYPE_LOB, fnName, error) < 0)
+        return DPI_FAILURE;
+    if (!lob->locator)
+        return dpiError__set(error, "check closed", DPI_ERR_LOB_CLOSED);
+    return dpiConn__checkConnected(lob->conn, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob__close() [INTERNAL]
+//   Internal method used for closing the LOB.
+//-----------------------------------------------------------------------------
+int dpiLob__close(dpiLob *lob, int propagateErrors, dpiError *error)
+{
+    int isTemporary, closing, status = DPI_SUCCESS;
+
+    // determine whether LOB is already being closed and if not, mark LOB as
+    // being closed; this MUST be done while holding the lock (if in threaded
+    // mode) to avoid race conditions!
+    if (lob->env->threaded)
+        dpiMutex__acquire(lob->env->mutex);
+    closing = lob->closing;
+    lob->closing = 1;
+    if (lob->env->threaded)
+        dpiMutex__release(lob->env->mutex);
+
+    // if LOB is already being closed, nothing needs to be done
+    if (closing)
+        return DPI_SUCCESS;
+
+    // perform actual work of closing LOB
+    if (lob->locator) {
+        if (!lob->conn->deadSession && lob->conn->handle) {
+            status = dpiOci__lobIsTemporary(lob, &isTemporary, propagateErrors,
+                    error);
+            if (isTemporary && status == DPI_SUCCESS)
+                status = dpiOci__lobFreeTemporary(lob->conn,
+                        lob->locator, propagateErrors, error);
+        }
+        dpiOci__descriptorFree(lob->locator, DPI_OCI_DTYPE_LOB);
+        if (!lob->conn->closing)
+            dpiHandleList__removeHandle(lob->conn->openLobs, lob->openSlotNum);
+        lob->locator = NULL;
+    }
+    if (lob->buffer) {
+        dpiUtils__freeMemory(lob->buffer);
+        lob->buffer = NULL;
+    }
+
+    // if actual close fails, reset closing flag; again, this must be done
+    // while holding the lock (if in threaded mode) in order to avoid race
+    // conditions!
+    if (status < 0) {
+        if (lob->env->threaded)
+            dpiMutex__acquire(lob->env->mutex);
+        lob->closing = 0;
+        if (lob->env->threaded)
+            dpiMutex__release(lob->env->mutex);
+    }
+
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob__free() [INTERNAL]
+//   Free the memory for a LOB.
+//-----------------------------------------------------------------------------
+void dpiLob__free(dpiLob *lob, dpiError *error)
+{
+    dpiLob__close(lob, 0, error);
+    if (lob->conn) {
+        dpiGen__setRefCount(lob->conn, error, -1);
+        lob->conn = NULL;
+    }
+    dpiUtils__freeMemory(lob);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob__readBytes() [INTERNAL]
+//   Return a portion (or all) of the data in the LOB.
+//-----------------------------------------------------------------------------
+int dpiLob__readBytes(dpiLob *lob, uint64_t offset, uint64_t amount,
+        char *value, uint64_t *valueLength, dpiError *error)
+{
+    uint64_t lengthInBytes = 0, lengthInChars = 0;
+    int isOpen = 0;
+
+    // amount is in characters for character LOBs and bytes for binary LOBs
+    if (lob->type->isCharacterData)
+        lengthInChars = amount;
+    else lengthInBytes = amount;
+
+    // for files, open the file if needed
+    if (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_BFILE) {
+        if (dpiOci__lobIsOpen(lob, &isOpen, error) < 0)
+            return DPI_FAILURE;
+        if (!isOpen) {
+            if (dpiOci__lobOpen(lob, error) < 0)
+                return DPI_FAILURE;
+        }
+    }
+
+    // read the bytes from the LOB
+    if (dpiOci__lobRead2(lob, offset, &lengthInBytes, &lengthInChars,
+            value, *valueLength, error) < 0)
+        return DPI_FAILURE;
+    *valueLength = lengthInBytes;
+
+    // if file was opened in this routine, close it again
+    if (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_BFILE && !isOpen) {
+        if (dpiOci__lobClose(lob, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob__setFromBytes() [INTERNAL]
+//   Clear the LOB completely and then write the specified bytes to it.
+//-----------------------------------------------------------------------------
+int dpiLob__setFromBytes(dpiLob *lob, const char *value, uint64_t valueLength,
+        dpiError *error)
+{
+    if (dpiOci__lobTrim2(lob, 0, error) < 0)
+        return DPI_FAILURE;
+    if (valueLength == 0)
+        return DPI_SUCCESS;
+    return dpiOci__lobWrite2(lob, 1, value, valueLength, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_addRef() [PUBLIC]
+//   Add a reference to the LOB.
+//-----------------------------------------------------------------------------
+int dpiLob_addRef(dpiLob *lob)
+{
+    return dpiGen__addRef(lob, DPI_HTYPE_LOB, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_close() [PUBLIC]
+//   Close the LOB and make it unusable for further operations.
+//-----------------------------------------------------------------------------
+int dpiLob_close(dpiLob *lob)
+{
+    dpiError error;
+    int status;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    status = dpiLob__close(lob, 1, &error);
+    return dpiGen__endPublicFn(lob, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_closeResource() [PUBLIC]
+//   Close the LOB's resources.
+//-----------------------------------------------------------------------------
+int dpiLob_closeResource(dpiLob *lob)
+{
+    dpiError error;
+    int status;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    status = dpiOci__lobClose(lob, &error);
+    return dpiGen__endPublicFn(lob, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_copy() [PUBLIC]
+//   Create a copy of the LOB and return it.
+//-----------------------------------------------------------------------------
+int dpiLob_copy(dpiLob *lob, dpiLob **copiedLob)
+{
+    dpiLob *tempLob;
+    dpiError error;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(lob, copiedLob)
+    if (dpiLob__allocate(lob->conn, lob->type, &tempLob, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    if (dpiOci__lobLocatorAssign(lob, &tempLob->locator, &error) < 0) {
+        dpiLob__free(tempLob, &error);
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    }
+    *copiedLob = tempLob;
+    return dpiGen__endPublicFn(lob, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_getBufferSize() [PUBLIC]
+//   Get the required size of a buffer given the number of characters. If the
+// LOB does not refer to a character LOB the value is returned unchanged.
+//-----------------------------------------------------------------------------
+int dpiLob_getBufferSize(dpiLob *lob, uint64_t sizeInChars,
+        uint64_t *sizeInBytes)
+{
+    dpiError error;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(lob, sizeInBytes)
+    if (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_CLOB)
+        *sizeInBytes = sizeInChars * lob->env->maxBytesPerCharacter;
+    else if (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_NCLOB)
+        *sizeInBytes = sizeInChars * lob->env->nmaxBytesPerCharacter;
+    else *sizeInBytes = sizeInChars;
+    return dpiGen__endPublicFn(lob, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_getChunkSize() [PUBLIC]
+//   Return the chunk size associated with the LOB.
+//-----------------------------------------------------------------------------
+int dpiLob_getChunkSize(dpiLob *lob, uint32_t *size)
+{
+    dpiError error;
+    int status;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(lob, size)
+    status = dpiOci__lobGetChunkSize(lob, size, &error);
+    return dpiGen__endPublicFn(lob, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_getDirectoryAndFileName() [PUBLIC]
+//   Return the directory alias and file name for the BFILE lob.
+//-----------------------------------------------------------------------------
+int dpiLob_getDirectoryAndFileName(dpiLob *lob, const char **directoryAlias,
+        uint32_t *directoryAliasLength, const char **fileName,
+        uint32_t *fileNameLength)
+{
+    uint16_t ociDirectoryAliasLength, ociFileNameLength;
+    dpiError error;
+
+    // validate parameters
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(lob, directoryAlias)
+    DPI_CHECK_PTR_NOT_NULL(lob, directoryAliasLength)
+    DPI_CHECK_PTR_NOT_NULL(lob, fileName)
+    DPI_CHECK_PTR_NOT_NULL(lob, fileNameLength)
+
+    // get directory and file name
+    ociDirectoryAliasLength = 30;
+    ociFileNameLength = 255;
+    if (!lob->buffer) {
+        if (dpiUtils__allocateMemory(1,
+                ociDirectoryAliasLength + ociFileNameLength, 0,
+                "allocate name buffer", (void**) &lob->buffer, &error) < 0)
+            return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    }
+    *directoryAlias = lob->buffer;
+    *fileName = lob->buffer + ociDirectoryAliasLength;
+    if (dpiOci__lobFileGetName(lob, (char*) *directoryAlias,
+            &ociDirectoryAliasLength, (char*) *fileName, &ociFileNameLength,
+            &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    *directoryAliasLength = ociDirectoryAliasLength;
+    *fileNameLength = ociFileNameLength;
+    return dpiGen__endPublicFn(lob, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_getFileExists() [PUBLIC]
+//   Return whether or not the file pointed to by the locator exists.
+//-----------------------------------------------------------------------------
+int dpiLob_getFileExists(dpiLob *lob, int *exists)
+{
+    dpiError error;
+    int status;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(lob, exists)
+    status = dpiOci__lobFileExists(lob, exists, &error);
+    return dpiGen__endPublicFn(lob, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_getIsResourceOpen() [PUBLIC]
+//   Return whether or not the LOB' resources are open.
+//-----------------------------------------------------------------------------
+int dpiLob_getIsResourceOpen(dpiLob *lob, int *isOpen)
+{
+    dpiError error;
+    int status;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(lob, isOpen)
+    status = dpiOci__lobIsOpen(lob, isOpen, &error);
+    return dpiGen__endPublicFn(lob, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_getSize() [PUBLIC]
+//   Returns the size of the LOB.
+//-----------------------------------------------------------------------------
+int dpiLob_getSize(dpiLob *lob, uint64_t *size)
+{
+    dpiError error;
+    int status;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(lob, size)
+    status = dpiOci__lobGetLength2(lob, size, &error);
+    return dpiGen__endPublicFn(lob, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_getType() [PUBLIC]
+//   Returns the type of the LOB.
+//-----------------------------------------------------------------------------
+int dpiLob_getType(dpiLob *lob, dpiOracleTypeNum *type)
+{
+    dpiError error;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(lob, type)
+    *type = lob->type->oracleTypeNum;
+    return dpiGen__endPublicFn(lob, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_openResource() [PUBLIC]
+//   Open the LOB's resources to speed further accesses.
+//-----------------------------------------------------------------------------
+int dpiLob_openResource(dpiLob *lob)
+{
+    dpiError error;
+    int status;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    status = dpiOci__lobOpen(lob, &error);
+    return dpiGen__endPublicFn(lob, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_readBytes() [PUBLIC]
+//   Return a portion (or all) of the data in the LOB.
+//-----------------------------------------------------------------------------
+int dpiLob_readBytes(dpiLob *lob, uint64_t offset, uint64_t amount,
+        char *value, uint64_t *valueLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(lob, value)
+    DPI_CHECK_PTR_NOT_NULL(lob, valueLength)
+    status = dpiLob__readBytes(lob, offset, amount, value, valueLength,
+            &error);
+    return dpiGen__endPublicFn(lob, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_release() [PUBLIC]
+//   Release a reference to the LOB.
+//-----------------------------------------------------------------------------
+int dpiLob_release(dpiLob *lob)
+{
+    return dpiGen__release(lob, DPI_HTYPE_LOB, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_setDirectoryAndFileName() [PUBLIC]
+//   Set the directory alias and file name for the BFILE LOB.
+//-----------------------------------------------------------------------------
+int dpiLob_setDirectoryAndFileName(dpiLob *lob, const char *directoryAlias,
+        uint32_t directoryAliasLength, const char *fileName,
+        uint32_t fileNameLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(lob, directoryAlias)
+    DPI_CHECK_PTR_NOT_NULL(lob, fileName)
+    status = dpiOci__lobFileSetName(lob, directoryAlias,
+            (uint16_t) directoryAliasLength, fileName,
+            (uint16_t) fileNameLength, &error);
+    return dpiGen__endPublicFn(lob, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_setFromBytes() [PUBLIC]
+//   Clear the LOB completely and then write the specified bytes to it.
+//-----------------------------------------------------------------------------
+int dpiLob_setFromBytes(dpiLob *lob, const char *value, uint64_t valueLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(lob, value)
+    status = dpiLob__setFromBytes(lob, value, valueLength, &error);
+    return dpiGen__endPublicFn(lob, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_trim() [PUBLIC]
+//   Trim the LOB to the specified length.
+//-----------------------------------------------------------------------------
+int dpiLob_trim(dpiLob *lob, uint64_t newSize)
+{
+    dpiError error;
+    int status;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    status = dpiOci__lobTrim2(lob, newSize, &error);
+    return dpiGen__endPublicFn(lob, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiLob_writeBytes() [PUBLIC]
+//   Write the data to the LOB at the offset specified.
+//-----------------------------------------------------------------------------
+int dpiLob_writeBytes(dpiLob *lob, uint64_t offset, const char *value,
+        uint64_t valueLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiLob__check(lob, __func__, &error) < 0)
+        return dpiGen__endPublicFn(lob, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(lob, value)
+    status = dpiOci__lobWrite2(lob, offset, value, valueLength, &error);
+    return dpiGen__endPublicFn(lob, status, &error);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiMsgProps.c ./odpi/src/dpiMsgProps.c
--- patched-godror/odpi/src/dpiMsgProps.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiMsgProps.c	1970-01-01 01:00:00
@@ -1,593 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps.c
-//   Implementation of AQ message properties.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps__allocate() [INTERNAL]
-//   Create a new message properties structure and return it. In case of error
-// NULL is returned.
-//-----------------------------------------------------------------------------
-int dpiMsgProps__allocate(dpiConn *conn, dpiMsgProps **props, dpiError *error)
-{
-    dpiMsgProps *tempProps;
-
-    if (dpiGen__allocate(DPI_HTYPE_MSG_PROPS, conn->env, (void**) &tempProps,
-            error) < 0)
-        return DPI_FAILURE;
-    dpiGen__setRefCount(conn, error, 1);
-    tempProps->conn = conn;
-    if (dpiOci__descriptorAlloc(conn->env->handle, &tempProps->handle,
-            DPI_OCI_DTYPE_AQMSG_PROPERTIES, "allocate descriptor",
-            error) < 0) {
-        dpiMsgProps__free(tempProps, error);
-        return DPI_FAILURE;
-    }
-
-    *props = tempProps;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps__extractMsgId() [INTERNAL]
-//   Extract bytes from the OCIRaw value containing the message id.
-//-----------------------------------------------------------------------------
-void dpiMsgProps__extractMsgId(dpiMsgProps *props, const char **msgId,
-        uint32_t *msgIdLength)
-{
-    dpiOci__rawPtr(props->env->handle, props->msgIdRaw, (void**) msgId);
-    dpiOci__rawSize(props->env->handle, props->msgIdRaw, msgIdLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps__free() [INTERNAL]
-//   Free the memory for a message properties structure.
-//-----------------------------------------------------------------------------
-void dpiMsgProps__free(dpiMsgProps *props, dpiError *error)
-{
-    if (props->handle) {
-        dpiOci__descriptorFree(props->handle, DPI_OCI_DTYPE_AQMSG_PROPERTIES);
-        props->handle = NULL;
-    }
-    if (props->payloadObj) {
-        dpiGen__setRefCount(props->payloadObj, error, -1);
-        props->payloadObj = NULL;
-    }
-    if (props->payloadRaw) {
-        dpiOci__rawResize(props->env->handle, &props->payloadRaw, 0, error);
-        props->payloadRaw = NULL;
-    }
-    if (props->msgIdRaw) {
-        dpiOci__rawResize(props->env->handle, &props->msgIdRaw, 0, error);
-        props->msgIdRaw = NULL;
-    }
-    if (props->conn) {
-        dpiGen__setRefCount(props->conn, error, -1);
-        props->conn = NULL;
-    }
-    dpiUtils__freeMemory(props);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps__getAttrValue() [INTERNAL]
-//   Get the attribute value in OCI.
-//-----------------------------------------------------------------------------
-static int dpiMsgProps__getAttrValue(dpiMsgProps *props, uint32_t attribute,
-        const char *fnName, void *value, uint32_t *valueLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, fnName, &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(props, value)
-    DPI_CHECK_PTR_NOT_NULL(props, valueLength)
-    status = dpiOci__attrGet(props->handle, DPI_OCI_DTYPE_AQMSG_PROPERTIES,
-            value, valueLength, attribute, "get attribute value", &error);
-    return dpiGen__endPublicFn(props, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps__setAttrValue() [INTERNAL]
-//   Set the attribute value in OCI.
-//-----------------------------------------------------------------------------
-static int dpiMsgProps__setAttrValue(dpiMsgProps *props, uint32_t attribute,
-        const char *fnName, const void *value, uint32_t valueLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, fnName, &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(props, value)
-    status = dpiOci__attrSet(props->handle, DPI_OCI_DTYPE_AQMSG_PROPERTIES,
-            (void*) value, valueLength, attribute, "set attribute value",
-            &error);
-    return dpiGen__endPublicFn(props, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps__setRecipients() [INTERNAL]
-//   Set the recipients value in OCI.
-//-----------------------------------------------------------------------------
-int dpiMsgProps__setRecipients(dpiMsgProps *props,
-        dpiMsgRecipient *recipients, uint32_t numRecipients,
-        void **aqAgents, dpiError *error)
-{
-    uint32_t i;
-
-    for (i = 0; i < numRecipients; i++) {
-        if (dpiOci__descriptorAlloc(props->env->handle, &aqAgents[i],
-                DPI_OCI_DTYPE_AQAGENT, "allocate agent descriptor",
-                error) < 0)
-            return DPI_FAILURE;
-        if (recipients[i].name && recipients[i].nameLength > 0) {
-            if (dpiOci__attrSet(aqAgents[i], DPI_OCI_DTYPE_AQAGENT,
-                    (void*) recipients[i].name, recipients[i].nameLength,
-                    DPI_OCI_ATTR_AGENT_NAME, "set agent name", error) < 0)
-                return DPI_FAILURE;
-        }
-    }
-    if (dpiOci__attrSet(props->handle, DPI_OCI_DTYPE_AQMSG_PROPERTIES,
-            aqAgents, numRecipients, DPI_OCI_ATTR_RECIPIENT_LIST,
-            "set recipient list", error) < 0)
-        return DPI_FAILURE;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_addRef() [PUBLIC]
-//   Add a reference to the message properties.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_addRef(dpiMsgProps *props)
-{
-    return dpiGen__addRef(props, DPI_HTYPE_MSG_PROPS, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_getCorrelation() [PUBLIC]
-//   Return correlation associated with the message.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_getCorrelation(dpiMsgProps *props, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_CORRELATION, __func__,
-            (void*) value, valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_getDelay() [PUBLIC]
-//   Return the number of seconds the message was delayed.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_getDelay(dpiMsgProps *props, int32_t *value)
-{
-    uint32_t valueLength = sizeof(uint32_t);
-
-    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_DELAY, __func__,
-            value, &valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_getDeliveryMode() [PUBLIC]
-//   Return the mode used for delivering the message.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_getDeliveryMode(dpiMsgProps *props,
-        dpiMessageDeliveryMode *value)
-{
-    uint32_t valueLength = sizeof(uint16_t);
-
-    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_MSG_DELIVERY_MODE,
-            __func__, value, &valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_getEnqTime() [PUBLIC]
-//   Return the time the message was enqueued.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_getEnqTime(dpiMsgProps *props, dpiTimestamp *value)
-{
-    dpiOciDate ociValue;
-    dpiError error;
-
-    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(props, value)
-    if (dpiOci__attrGet(props->handle, DPI_OCI_DTYPE_AQMSG_PROPERTIES,
-            &ociValue, NULL, DPI_OCI_ATTR_ENQ_TIME, "get attribute value",
-            &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    value->year = ociValue.year;
-    value->month = ociValue.month;
-    value->day = ociValue.day;
-    value->hour = ociValue.hour;
-    value->minute = ociValue.minute;
-    value->second = ociValue.second;
-    value->fsecond = 0;
-    value->tzHourOffset = 0;
-    value->tzMinuteOffset = 0;
-    return dpiGen__endPublicFn(props, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_getExceptionQ() [PUBLIC]
-//   Return the name of the exception queue associated with the message.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_getExceptionQ(dpiMsgProps *props, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_EXCEPTION_QUEUE,
-            __func__, (void*) value, valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_getExpiration() [PUBLIC]
-//   Return the number of seconds until the message expires.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_getExpiration(dpiMsgProps *props, int32_t *value)
-{
-    uint32_t valueLength = sizeof(uint32_t);
-
-    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_EXPIRATION, __func__,
-            value, &valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_getNumAttempts() [PUBLIC]
-//   Return the number of attempts made to deliver the message.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_getNumAttempts(dpiMsgProps *props, int32_t *value)
-{
-    uint32_t valueLength = sizeof(uint32_t);
-
-    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_ATTEMPTS, __func__,
-            value, &valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_getMsgId() [PUBLIC]
-//   Return the message id for the message (available after enqueuing or
-// dequeuing a message).
-//-----------------------------------------------------------------------------
-int dpiMsgProps_getMsgId(dpiMsgProps *props, const char **value,
-        uint32_t *valueLength)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(props, value)
-    DPI_CHECK_PTR_NOT_NULL(props, valueLength)
-    dpiMsgProps__extractMsgId(props, value, valueLength);
-    return dpiGen__endPublicFn(props, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_getOriginalMsgId() [PUBLIC]
-//   Return the original message id for the message.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_getOriginalMsgId(dpiMsgProps *props, const char **value,
-        uint32_t *valueLength)
-{
-    dpiError error;
-    void *rawValue;
-
-    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(props, value)
-    DPI_CHECK_PTR_NOT_NULL(props, valueLength)
-    if (dpiOci__attrGet(props->handle, DPI_OCI_DTYPE_AQMSG_PROPERTIES,
-            &rawValue, NULL, DPI_OCI_ATTR_ORIGINAL_MSGID,
-            "get attribute value", &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    dpiOci__rawPtr(props->env->handle, rawValue, (void**) value);
-    dpiOci__rawSize(props->env->handle, rawValue, valueLength);
-    return dpiGen__endPublicFn(props, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_getPayload() [PUBLIC]
-//   Get the payload for the message (as an object or a series of bytes).
-//-----------------------------------------------------------------------------
-int dpiMsgProps_getPayload(dpiMsgProps *props, dpiObject **obj,
-        const char **value, uint32_t *valueLength)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    if (obj)
-        *obj = props->payloadObj;
-    if (value && valueLength) {
-        if (props->payloadRaw) {
-            dpiOci__rawPtr(props->env->handle, props->payloadRaw,
-                    (void**) value);
-            dpiOci__rawSize(props->env->handle, props->payloadRaw,
-                    valueLength);
-        } else {
-            *value = NULL;
-            *valueLength = 0;
-        }
-    }
-
-    return dpiGen__endPublicFn(props, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_getPayloadJson() [PUBLIC]
-//   Get the JSON payload for the message (as a dpiJson).
-//-----------------------------------------------------------------------------
-int dpiMsgProps_getPayloadJson(dpiMsgProps *props, dpiJson **json)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(props, json)
-    *json = props->payloadJson;
-    return dpiGen__endPublicFn(props, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_getPriority() [PUBLIC]
-//   Return the priority of the message.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_getPriority(dpiMsgProps *props, int32_t *value)
-{
-    uint32_t valueLength = sizeof(uint32_t);
-
-    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_PRIORITY, __func__,
-            value, &valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_getState() [PUBLIC]
-//   Return the state of the message.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_getState(dpiMsgProps *props, dpiMessageState *value)
-{
-    uint32_t valueLength = sizeof(uint32_t);
-
-
-    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_MSG_STATE, __func__,
-            value, &valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_release() [PUBLIC]
-//   Release a reference to the message properties.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_release(dpiMsgProps *props)
-{
-    return dpiGen__release(props, DPI_HTYPE_MSG_PROPS, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_setCorrelation() [PUBLIC]
-//   Set correlation associated with the message.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_setCorrelation(dpiMsgProps *props, const char *value,
-        uint32_t valueLength)
-{
-    return dpiMsgProps__setAttrValue(props, DPI_OCI_ATTR_CORRELATION, __func__,
-            value, valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_setDelay() [PUBLIC]
-//   Set the number of seconds to delay the message.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_setDelay(dpiMsgProps *props, int32_t value)
-{
-    return dpiMsgProps__setAttrValue(props, DPI_OCI_ATTR_DELAY, __func__,
-            &value, 0);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_setExceptionQ() [PUBLIC]
-//   Set the name of the exception queue associated with the message.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_setExceptionQ(dpiMsgProps *props, const char *value,
-        uint32_t valueLength)
-{
-    return dpiMsgProps__setAttrValue(props, DPI_OCI_ATTR_EXCEPTION_QUEUE,
-            __func__, value, valueLength);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_setExpiration() [PUBLIC]
-//   Set the number of seconds until the message expires.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_setExpiration(dpiMsgProps *props, int32_t value)
-{
-    return dpiMsgProps__setAttrValue(props, DPI_OCI_ATTR_EXPIRATION, __func__,
-            &value, 0);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_setOriginalMsgId() [PUBLIC]
-//   Set the original message id for the message.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_setOriginalMsgId(dpiMsgProps *props, const char *value,
-        uint32_t valueLength)
-{
-    void *rawValue = NULL;
-    dpiError error;
-    int status;
-
-    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(props, value)
-    if (dpiOci__rawAssignBytes(props->env->handle, value, valueLength,
-            &rawValue, &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    status = dpiOci__attrSet(props->handle, DPI_OCI_DTYPE_AQMSG_PROPERTIES,
-            (void*) rawValue, 0, DPI_OCI_ATTR_ORIGINAL_MSGID, "set value",
-            &error);
-    dpiOci__rawResize(props->env->handle, &rawValue, 0, &error);
-    return dpiGen__endPublicFn(props, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_setPayloadBytes() [PUBLIC]
-//   Set the payload for the message (as a series of bytes).
-//-----------------------------------------------------------------------------
-int dpiMsgProps_setPayloadBytes(dpiMsgProps *props, const char *value,
-        uint32_t valueLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(props, value)
-    if (props->payloadRaw) {
-        dpiOci__rawResize(props->env->handle, &props->payloadRaw, 0, &error);
-        props->payloadRaw = NULL;
-    }
-    status = dpiOci__rawAssignBytes(props->env->handle, value, valueLength,
-            &props->payloadRaw, &error);
-    return dpiGen__endPublicFn(props, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_setPayloadJson() [PUBLIC]
-//   Set the payload for the message (as a JSON object).
-//-----------------------------------------------------------------------------
-int dpiMsgProps_setPayloadJson(dpiMsgProps *props, dpiJson *json)
-{
-    dpiError error;
-    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(json, DPI_HTYPE_JSON, "check json object",
-            &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    if (props->payloadJson)
-        dpiGen__setRefCount(props->payloadJson, &error, -1);
-    dpiGen__setRefCount(json, &error, 1);
-    props->payloadJson = json;
-    return dpiGen__endPublicFn(props, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_setPayloadObject() [PUBLIC]
-//   Set the payload for the message (as an object).
-//-----------------------------------------------------------------------------
-int dpiMsgProps_setPayloadObject(dpiMsgProps *props, dpiObject *obj)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(obj, DPI_HTYPE_OBJECT, "check object", &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    if (props->payloadObj)
-        dpiGen__setRefCount(props->payloadObj, &error, -1);
-    dpiGen__setRefCount(obj, &error, 1);
-    props->payloadObj = obj;
-    return dpiGen__endPublicFn(props, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_setPriority() [PUBLIC]
-//   Set the priority of the message.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_setPriority(dpiMsgProps *props, int32_t value)
-{
-    return dpiMsgProps__setAttrValue(props, DPI_OCI_ATTR_PRIORITY, __func__,
-            &value, 0);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiMsgProps_setRecipients() [PUBLIC]
-//   Set recipients associated with the message.
-//-----------------------------------------------------------------------------
-int dpiMsgProps_setRecipients(dpiMsgProps *props,
-        dpiMsgRecipient *recipients, uint32_t numRecipients)
-{
-    void **aqAgents;
-    dpiError error;
-    uint32_t i;
-    int status;
-
-    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(props, recipients)
-    if (dpiUtils__allocateMemory(numRecipients, sizeof(void*), 1,
-            "allocate memory for agents", (void**) &aqAgents, &error) < 0)
-        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
-    status = dpiMsgProps__setRecipients(props, recipients, numRecipients,
-            aqAgents, &error);
-    for (i = 0; i < numRecipients; i++) {
-        if (aqAgents[i])
-            dpiOci__descriptorFree(aqAgents[i], DPI_OCI_DTYPE_AQAGENT);
-    }
-    dpiUtils__freeMemory(aqAgents);
-    return dpiGen__endPublicFn(props, status, &error);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiMsgProps.h ./odpi/src/dpiMsgProps.h
--- patched-godror/odpi/src/dpiMsgProps.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiMsgProps.h	2024-05-14 14:55:13
@@ -0,0 +1,593 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps.c
+//   Implementation of AQ message properties.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps__allocate() [INTERNAL]
+//   Create a new message properties structure and return it. In case of error
+// NULL is returned.
+//-----------------------------------------------------------------------------
+int dpiMsgProps__allocate(dpiConn *conn, dpiMsgProps **props, dpiError *error)
+{
+    dpiMsgProps *tempProps;
+
+    if (dpiGen__allocate(DPI_HTYPE_MSG_PROPS, conn->env, (void**) &tempProps,
+            error) < 0)
+        return DPI_FAILURE;
+    dpiGen__setRefCount(conn, error, 1);
+    tempProps->conn = conn;
+    if (dpiOci__descriptorAlloc(conn->env->handle, &tempProps->handle,
+            DPI_OCI_DTYPE_AQMSG_PROPERTIES, "allocate descriptor",
+            error) < 0) {
+        dpiMsgProps__free(tempProps, error);
+        return DPI_FAILURE;
+    }
+
+    *props = tempProps;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps__extractMsgId() [INTERNAL]
+//   Extract bytes from the OCIRaw value containing the message id.
+//-----------------------------------------------------------------------------
+void dpiMsgProps__extractMsgId(dpiMsgProps *props, const char **msgId,
+        uint32_t *msgIdLength)
+{
+    dpiOci__rawPtr(props->env->handle, props->msgIdRaw, (void**) msgId);
+    dpiOci__rawSize(props->env->handle, props->msgIdRaw, msgIdLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps__free() [INTERNAL]
+//   Free the memory for a message properties structure.
+//-----------------------------------------------------------------------------
+void dpiMsgProps__free(dpiMsgProps *props, dpiError *error)
+{
+    if (props->handle) {
+        dpiOci__descriptorFree(props->handle, DPI_OCI_DTYPE_AQMSG_PROPERTIES);
+        props->handle = NULL;
+    }
+    if (props->payloadObj) {
+        dpiGen__setRefCount(props->payloadObj, error, -1);
+        props->payloadObj = NULL;
+    }
+    if (props->payloadRaw) {
+        dpiOci__rawResize(props->env->handle, &props->payloadRaw, 0, error);
+        props->payloadRaw = NULL;
+    }
+    if (props->msgIdRaw) {
+        dpiOci__rawResize(props->env->handle, &props->msgIdRaw, 0, error);
+        props->msgIdRaw = NULL;
+    }
+    if (props->conn) {
+        dpiGen__setRefCount(props->conn, error, -1);
+        props->conn = NULL;
+    }
+    dpiUtils__freeMemory(props);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps__getAttrValue() [INTERNAL]
+//   Get the attribute value in OCI.
+//-----------------------------------------------------------------------------
+static int dpiMsgProps__getAttrValue(dpiMsgProps *props, uint32_t attribute,
+        const char *fnName, void *value, uint32_t *valueLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, fnName, &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(props, value)
+    DPI_CHECK_PTR_NOT_NULL(props, valueLength)
+    status = dpiOci__attrGet(props->handle, DPI_OCI_DTYPE_AQMSG_PROPERTIES,
+            value, valueLength, attribute, "get attribute value", &error);
+    return dpiGen__endPublicFn(props, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps__setAttrValue() [INTERNAL]
+//   Set the attribute value in OCI.
+//-----------------------------------------------------------------------------
+static int dpiMsgProps__setAttrValue(dpiMsgProps *props, uint32_t attribute,
+        const char *fnName, const void *value, uint32_t valueLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, fnName, &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(props, value)
+    status = dpiOci__attrSet(props->handle, DPI_OCI_DTYPE_AQMSG_PROPERTIES,
+            (void*) value, valueLength, attribute, "set attribute value",
+            &error);
+    return dpiGen__endPublicFn(props, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps__setRecipients() [INTERNAL]
+//   Set the recipients value in OCI.
+//-----------------------------------------------------------------------------
+int dpiMsgProps__setRecipients(dpiMsgProps *props,
+        dpiMsgRecipient *recipients, uint32_t numRecipients,
+        void **aqAgents, dpiError *error)
+{
+    uint32_t i;
+
+    for (i = 0; i < numRecipients; i++) {
+        if (dpiOci__descriptorAlloc(props->env->handle, &aqAgents[i],
+                DPI_OCI_DTYPE_AQAGENT, "allocate agent descriptor",
+                error) < 0)
+            return DPI_FAILURE;
+        if (recipients[i].name && recipients[i].nameLength > 0) {
+            if (dpiOci__attrSet(aqAgents[i], DPI_OCI_DTYPE_AQAGENT,
+                    (void*) recipients[i].name, recipients[i].nameLength,
+                    DPI_OCI_ATTR_AGENT_NAME, "set agent name", error) < 0)
+                return DPI_FAILURE;
+        }
+    }
+    if (dpiOci__attrSet(props->handle, DPI_OCI_DTYPE_AQMSG_PROPERTIES,
+            aqAgents, numRecipients, DPI_OCI_ATTR_RECIPIENT_LIST,
+            "set recipient list", error) < 0)
+        return DPI_FAILURE;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_addRef() [PUBLIC]
+//   Add a reference to the message properties.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_addRef(dpiMsgProps *props)
+{
+    return dpiGen__addRef(props, DPI_HTYPE_MSG_PROPS, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_getCorrelation() [PUBLIC]
+//   Return correlation associated with the message.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_getCorrelation(dpiMsgProps *props, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_CORRELATION, __func__,
+            (void*) value, valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_getDelay() [PUBLIC]
+//   Return the number of seconds the message was delayed.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_getDelay(dpiMsgProps *props, int32_t *value)
+{
+    uint32_t valueLength = sizeof(uint32_t);
+
+    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_DELAY, __func__,
+            value, &valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_getDeliveryMode() [PUBLIC]
+//   Return the mode used for delivering the message.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_getDeliveryMode(dpiMsgProps *props,
+        dpiMessageDeliveryMode *value)
+{
+    uint32_t valueLength = sizeof(uint16_t);
+
+    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_MSG_DELIVERY_MODE,
+            __func__, value, &valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_getEnqTime() [PUBLIC]
+//   Return the time the message was enqueued.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_getEnqTime(dpiMsgProps *props, dpiTimestamp *value)
+{
+    dpiOciDate ociValue;
+    dpiError error;
+
+    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(props, value)
+    if (dpiOci__attrGet(props->handle, DPI_OCI_DTYPE_AQMSG_PROPERTIES,
+            &ociValue, NULL, DPI_OCI_ATTR_ENQ_TIME, "get attribute value",
+            &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    value->year = ociValue.year;
+    value->month = ociValue.month;
+    value->day = ociValue.day;
+    value->hour = ociValue.hour;
+    value->minute = ociValue.minute;
+    value->second = ociValue.second;
+    value->fsecond = 0;
+    value->tzHourOffset = 0;
+    value->tzMinuteOffset = 0;
+    return dpiGen__endPublicFn(props, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_getExceptionQ() [PUBLIC]
+//   Return the name of the exception queue associated with the message.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_getExceptionQ(dpiMsgProps *props, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_EXCEPTION_QUEUE,
+            __func__, (void*) value, valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_getExpiration() [PUBLIC]
+//   Return the number of seconds until the message expires.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_getExpiration(dpiMsgProps *props, int32_t *value)
+{
+    uint32_t valueLength = sizeof(uint32_t);
+
+    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_EXPIRATION, __func__,
+            value, &valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_getNumAttempts() [PUBLIC]
+//   Return the number of attempts made to deliver the message.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_getNumAttempts(dpiMsgProps *props, int32_t *value)
+{
+    uint32_t valueLength = sizeof(uint32_t);
+
+    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_ATTEMPTS, __func__,
+            value, &valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_getMsgId() [PUBLIC]
+//   Return the message id for the message (available after enqueuing or
+// dequeuing a message).
+//-----------------------------------------------------------------------------
+int dpiMsgProps_getMsgId(dpiMsgProps *props, const char **value,
+        uint32_t *valueLength)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(props, value)
+    DPI_CHECK_PTR_NOT_NULL(props, valueLength)
+    dpiMsgProps__extractMsgId(props, value, valueLength);
+    return dpiGen__endPublicFn(props, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_getOriginalMsgId() [PUBLIC]
+//   Return the original message id for the message.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_getOriginalMsgId(dpiMsgProps *props, const char **value,
+        uint32_t *valueLength)
+{
+    dpiError error;
+    void *rawValue;
+
+    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(props, value)
+    DPI_CHECK_PTR_NOT_NULL(props, valueLength)
+    if (dpiOci__attrGet(props->handle, DPI_OCI_DTYPE_AQMSG_PROPERTIES,
+            &rawValue, NULL, DPI_OCI_ATTR_ORIGINAL_MSGID,
+            "get attribute value", &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    dpiOci__rawPtr(props->env->handle, rawValue, (void**) value);
+    dpiOci__rawSize(props->env->handle, rawValue, valueLength);
+    return dpiGen__endPublicFn(props, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_getPayload() [PUBLIC]
+//   Get the payload for the message (as an object or a series of bytes).
+//-----------------------------------------------------------------------------
+int dpiMsgProps_getPayload(dpiMsgProps *props, dpiObject **obj,
+        const char **value, uint32_t *valueLength)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    if (obj)
+        *obj = props->payloadObj;
+    if (value && valueLength) {
+        if (props->payloadRaw) {
+            dpiOci__rawPtr(props->env->handle, props->payloadRaw,
+                    (void**) value);
+            dpiOci__rawSize(props->env->handle, props->payloadRaw,
+                    valueLength);
+        } else {
+            *value = NULL;
+            *valueLength = 0;
+        }
+    }
+
+    return dpiGen__endPublicFn(props, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_getPayloadJson() [PUBLIC]
+//   Get the JSON payload for the message (as a dpiJson).
+//-----------------------------------------------------------------------------
+int dpiMsgProps_getPayloadJson(dpiMsgProps *props, dpiJson **json)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(props, json)
+    *json = props->payloadJson;
+    return dpiGen__endPublicFn(props, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_getPriority() [PUBLIC]
+//   Return the priority of the message.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_getPriority(dpiMsgProps *props, int32_t *value)
+{
+    uint32_t valueLength = sizeof(uint32_t);
+
+    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_PRIORITY, __func__,
+            value, &valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_getState() [PUBLIC]
+//   Return the state of the message.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_getState(dpiMsgProps *props, dpiMessageState *value)
+{
+    uint32_t valueLength = sizeof(uint32_t);
+
+
+    return dpiMsgProps__getAttrValue(props, DPI_OCI_ATTR_MSG_STATE, __func__,
+            value, &valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_release() [PUBLIC]
+//   Release a reference to the message properties.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_release(dpiMsgProps *props)
+{
+    return dpiGen__release(props, DPI_HTYPE_MSG_PROPS, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_setCorrelation() [PUBLIC]
+//   Set correlation associated with the message.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_setCorrelation(dpiMsgProps *props, const char *value,
+        uint32_t valueLength)
+{
+    return dpiMsgProps__setAttrValue(props, DPI_OCI_ATTR_CORRELATION, __func__,
+            value, valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_setDelay() [PUBLIC]
+//   Set the number of seconds to delay the message.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_setDelay(dpiMsgProps *props, int32_t value)
+{
+    return dpiMsgProps__setAttrValue(props, DPI_OCI_ATTR_DELAY, __func__,
+            &value, 0);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_setExceptionQ() [PUBLIC]
+//   Set the name of the exception queue associated with the message.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_setExceptionQ(dpiMsgProps *props, const char *value,
+        uint32_t valueLength)
+{
+    return dpiMsgProps__setAttrValue(props, DPI_OCI_ATTR_EXCEPTION_QUEUE,
+            __func__, value, valueLength);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_setExpiration() [PUBLIC]
+//   Set the number of seconds until the message expires.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_setExpiration(dpiMsgProps *props, int32_t value)
+{
+    return dpiMsgProps__setAttrValue(props, DPI_OCI_ATTR_EXPIRATION, __func__,
+            &value, 0);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_setOriginalMsgId() [PUBLIC]
+//   Set the original message id for the message.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_setOriginalMsgId(dpiMsgProps *props, const char *value,
+        uint32_t valueLength)
+{
+    void *rawValue = NULL;
+    dpiError error;
+    int status;
+
+    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(props, value)
+    if (dpiOci__rawAssignBytes(props->env->handle, value, valueLength,
+            &rawValue, &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    status = dpiOci__attrSet(props->handle, DPI_OCI_DTYPE_AQMSG_PROPERTIES,
+            (void*) rawValue, 0, DPI_OCI_ATTR_ORIGINAL_MSGID, "set value",
+            &error);
+    dpiOci__rawResize(props->env->handle, &rawValue, 0, &error);
+    return dpiGen__endPublicFn(props, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_setPayloadBytes() [PUBLIC]
+//   Set the payload for the message (as a series of bytes).
+//-----------------------------------------------------------------------------
+int dpiMsgProps_setPayloadBytes(dpiMsgProps *props, const char *value,
+        uint32_t valueLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(props, value)
+    if (props->payloadRaw) {
+        dpiOci__rawResize(props->env->handle, &props->payloadRaw, 0, &error);
+        props->payloadRaw = NULL;
+    }
+    status = dpiOci__rawAssignBytes(props->env->handle, value, valueLength,
+            &props->payloadRaw, &error);
+    return dpiGen__endPublicFn(props, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_setPayloadJson() [PUBLIC]
+//   Set the payload for the message (as a JSON object).
+//-----------------------------------------------------------------------------
+int dpiMsgProps_setPayloadJson(dpiMsgProps *props, dpiJson *json)
+{
+    dpiError error;
+    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(json, DPI_HTYPE_JSON, "check json object",
+            &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    if (props->payloadJson)
+        dpiGen__setRefCount(props->payloadJson, &error, -1);
+    dpiGen__setRefCount(json, &error, 1);
+    props->payloadJson = json;
+    return dpiGen__endPublicFn(props, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_setPayloadObject() [PUBLIC]
+//   Set the payload for the message (as an object).
+//-----------------------------------------------------------------------------
+int dpiMsgProps_setPayloadObject(dpiMsgProps *props, dpiObject *obj)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(obj, DPI_HTYPE_OBJECT, "check object", &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    if (props->payloadObj)
+        dpiGen__setRefCount(props->payloadObj, &error, -1);
+    dpiGen__setRefCount(obj, &error, 1);
+    props->payloadObj = obj;
+    return dpiGen__endPublicFn(props, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_setPriority() [PUBLIC]
+//   Set the priority of the message.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_setPriority(dpiMsgProps *props, int32_t value)
+{
+    return dpiMsgProps__setAttrValue(props, DPI_OCI_ATTR_PRIORITY, __func__,
+            &value, 0);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiMsgProps_setRecipients() [PUBLIC]
+//   Set recipients associated with the message.
+//-----------------------------------------------------------------------------
+int dpiMsgProps_setRecipients(dpiMsgProps *props,
+        dpiMsgRecipient *recipients, uint32_t numRecipients)
+{
+    void **aqAgents;
+    dpiError error;
+    uint32_t i;
+    int status;
+
+    if (dpiGen__startPublicFn(props, DPI_HTYPE_MSG_PROPS, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(props, recipients)
+    if (dpiUtils__allocateMemory(numRecipients, sizeof(void*), 1,
+            "allocate memory for agents", (void**) &aqAgents, &error) < 0)
+        return dpiGen__endPublicFn(props, DPI_FAILURE, &error);
+    status = dpiMsgProps__setRecipients(props, recipients, numRecipients,
+            aqAgents, &error);
+    for (i = 0; i < numRecipients; i++) {
+        if (aqAgents[i])
+            dpiOci__descriptorFree(aqAgents[i], DPI_OCI_DTYPE_AQAGENT);
+    }
+    dpiUtils__freeMemory(aqAgents);
+    return dpiGen__endPublicFn(props, status, &error);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiObject.c ./odpi/src/dpiObject.c
--- patched-godror/odpi/src/dpiObject.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiObject.c	1970-01-01 01:00:00
@@ -1,981 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiObject.c
-//   Implementation of objects.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-// forward declarations of internal functions only used in this file
-int dpiObject__closeHelper(dpiObject *obj, int checkError, dpiError *error);
-
-
-//-----------------------------------------------------------------------------
-// dpiObject__allocate() [INTERNAL]
-//   Allocate and initialize an object structure.
-//-----------------------------------------------------------------------------
-int dpiObject__allocate(dpiObjectType *objType, void *instance,
-        void *indicator, dpiObject *dependsOnObj, dpiObject **obj,
-        dpiError *error)
-{
-    dpiObject *tempObj;
-
-    if (dpiGen__allocate(DPI_HTYPE_OBJECT, objType->env, (void**) &tempObj,
-            error) < 0)
-        return DPI_FAILURE;
-    dpiGen__setRefCount(objType, error, 1);
-    tempObj->type = objType;
-    tempObj->instance = instance;
-    tempObj->indicator = indicator;
-    if (dependsOnObj) {
-        dpiGen__setRefCount(dependsOnObj, error, 1);
-        tempObj->dependsOnObj = dependsOnObj;
-    }
-    if (!instance) {
-        if (dpiOci__objectNew(tempObj, error) < 0) {
-            dpiObject__free(tempObj, error);
-            return DPI_FAILURE;
-        }
-        if (dpiOci__objectGetInd(tempObj, error) < 0) {
-            dpiObject__free(tempObj, error);
-            return DPI_FAILURE;
-        }
-    }
-    if (tempObj->instance && !dependsOnObj) {
-        if (dpiHandleList__addHandle(objType->conn->objects, tempObj,
-                &tempObj->openSlotNum, error) < 0) {
-            dpiObject__free(tempObj, error);
-            return DPI_FAILURE;
-        }
-    }
-    *obj = tempObj;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject__check() [INTERNAL]
-//   Determine if the object handle provided is available for use.
-//-----------------------------------------------------------------------------
-static int dpiObject__check(dpiObject *obj, const char *fnName,
-        dpiError *error)
-{
-    if (dpiGen__startPublicFn(obj, DPI_HTYPE_OBJECT, fnName, error) < 0)
-        return DPI_FAILURE;
-    return dpiConn__checkConnected(obj->type->conn, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject__checkIsCollection() [INTERNAL]
-//   Check if the object is a collection, and if not, raise an exception.
-//-----------------------------------------------------------------------------
-static int dpiObject__checkIsCollection(dpiObject *obj, const char *fnName,
-        dpiError *error)
-{
-    if (dpiObject__check(obj, fnName, error) < 0)
-        return DPI_FAILURE;
-    if (!obj->type->isCollection)
-        return dpiError__set(error, "check collection", DPI_ERR_NOT_COLLECTION,
-                obj->type->schemaLength, obj->type->schema,
-                obj->type->nameLength, obj->type->name);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject__clearOracleValue() [INTERNAL]
-//   Clear the Oracle value after use.
-//-----------------------------------------------------------------------------
-static void dpiObject__clearOracleValue(dpiObject *obj, dpiError *error,
-        dpiOracleDataBuffer *buffer, dpiLob *lob,
-        dpiOracleTypeNum oracleTypeNum)
-{
-    switch (oracleTypeNum) {
-        case DPI_ORACLE_TYPE_CHAR:
-        case DPI_ORACLE_TYPE_NCHAR:
-        case DPI_ORACLE_TYPE_VARCHAR:
-        case DPI_ORACLE_TYPE_NVARCHAR:
-            if (buffer->asString)
-                dpiOci__stringResize(obj->env->handle, &buffer->asString, 0,
-                        error);
-            break;
-        case DPI_ORACLE_TYPE_RAW:
-            if (buffer->asRawData)
-                dpiOci__rawResize(obj->env->handle, &buffer->asRawData, 0,
-                        error);
-            break;
-        case DPI_ORACLE_TYPE_TIMESTAMP:
-            if (buffer->asTimestamp)
-                dpiOci__descriptorFree(buffer->asTimestamp,
-                        DPI_OCI_DTYPE_TIMESTAMP);
-            break;
-        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
-            if (buffer->asTimestamp)
-                dpiOci__descriptorFree(buffer->asTimestamp,
-                        DPI_OCI_DTYPE_TIMESTAMP_TZ);
-            break;
-        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
-            if (buffer->asTimestamp)
-                dpiOci__descriptorFree(buffer->asTimestamp,
-                        DPI_OCI_DTYPE_TIMESTAMP_LTZ);
-            break;
-        case DPI_ORACLE_TYPE_CLOB:
-        case DPI_ORACLE_TYPE_NCLOB:
-        case DPI_ORACLE_TYPE_BLOB:
-        case DPI_ORACLE_TYPE_BFILE:
-            if (lob)
-                dpiGen__setRefCount(lob, error, -1);
-            break;
-        default:
-            break;
-    };
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject__close() [INTERNAL]
-//   Close the object (frees the memory for the instance). This is needed to
-// avoid trying to do so after the connection which created the object is
-// closed. In some future release of the Oracle Client libraries this may not
-// be needed, at which point this code and all of the code for managing the
-// list of objects created by a collection can be removed.
-//-----------------------------------------------------------------------------
-int dpiObject__close(dpiObject *obj, int checkError, dpiError *error)
-{
-    int closing;
-
-    // determine whether object is already being closed and if not, mark
-    // object as being closed; this MUST be done while holding the lock (if
-    // in threaded mode) to avoid race conditions!
-    if (obj->env->threaded)
-        dpiMutex__acquire(obj->env->mutex);
-    closing = obj->closing;
-    obj->closing = 1;
-    if (obj->env->threaded)
-        dpiMutex__release(obj->env->mutex);
-
-    // if object is already being closed, nothing needs to be done
-    if (closing)
-        return DPI_SUCCESS;
-
-    // perform actual work of closing object; if this fails, reset closing
-    // flag; again, this must be done while holding the lock (if in threaded
-    // mode) in order to avoid race conditions!
-    if (obj->instance && !obj->dependsOnObj) {
-        if (dpiObject__closeHelper(obj, checkError, error) < 0) {
-            if (obj->env->threaded)
-                dpiMutex__acquire(obj->env->mutex);
-            obj->closing = 0;
-            if (obj->env->threaded)
-                dpiMutex__release(obj->env->mutex);
-            return DPI_FAILURE;
-        }
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject__closeHelper() [INTERNAL]
-//   Helper function for closing an object.
-//-----------------------------------------------------------------------------
-int dpiObject__closeHelper(dpiObject *obj, int checkError, dpiError *error)
-{
-    if (dpiOci__objectFree(obj->env->handle, obj->instance, checkError,
-            error) < 0)
-        return DPI_FAILURE;
-    obj->instance = NULL;
-    if (obj->freeIndicator && dpiOci__objectFree(obj->env->handle,
-            obj->indicator, checkError, error) < 0)
-        return DPI_FAILURE;
-    obj->indicator = NULL;
-    if (!obj->type->conn->closing)
-        dpiHandleList__removeHandle(obj->type->conn->objects,
-                obj->openSlotNum);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject__free() [INTERNAL]
-//   Free the memory for an object.
-//-----------------------------------------------------------------------------
-void dpiObject__free(dpiObject *obj, dpiError *error)
-{
-    dpiObject__close(obj, 0, error);
-    if (obj->type) {
-        dpiGen__setRefCount(obj->type, error, -1);
-        obj->type = NULL;
-    }
-    if (obj->dependsOnObj) {
-        dpiGen__setRefCount(obj->dependsOnObj, error, -1);
-        obj->dependsOnObj = NULL;
-    }
-    dpiUtils__freeMemory(obj);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject__fromOracleValue() [INTERNAL]
-//   Populate data from the Oracle value or return an error if this is not
-// possible.
-//-----------------------------------------------------------------------------
-static int dpiObject__fromOracleValue(dpiObject *obj, dpiError *error,
-        const dpiDataTypeInfo *typeInfo, dpiOracleData *value,
-        int16_t *indicator, dpiNativeTypeNum nativeTypeNum, dpiData *data)
-{
-    dpiOracleTypeNum valueOracleTypeNum;
-    dpiBytes *asBytes;
-
-    // null values are immediately returned (type is irrelevant)
-    if (*indicator == DPI_OCI_IND_NULL) {
-        data->isNull = 1;
-        return DPI_SUCCESS;
-    }
-
-    // convert all other values
-    data->isNull = 0;
-    valueOracleTypeNum = typeInfo->oracleTypeNum;
-    switch (valueOracleTypeNum) {
-        case DPI_ORACLE_TYPE_CHAR:
-        case DPI_ORACLE_TYPE_NCHAR:
-        case DPI_ORACLE_TYPE_VARCHAR:
-        case DPI_ORACLE_TYPE_NVARCHAR:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
-                asBytes = &data->value.asBytes;
-                dpiOci__stringPtr(obj->env->handle, *value->asString,
-                        &asBytes->ptr);
-                dpiOci__stringSize(obj->env->handle, *value->asString,
-                        &asBytes->length);
-                if (valueOracleTypeNum == DPI_ORACLE_TYPE_NCHAR ||
-                        valueOracleTypeNum == DPI_ORACLE_TYPE_NVARCHAR)
-                    asBytes->encoding = obj->env->nencoding;
-                else asBytes->encoding = obj->env->encoding;
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_RAW:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
-                asBytes = &data->value.asBytes;
-                dpiOci__rawPtr(obj->env->handle, *value->asRawData,
-                        (void**) &asBytes->ptr);
-                dpiOci__rawSize(obj->env->handle, *value->asRawData,
-                        &asBytes->length);
-                asBytes->encoding = NULL;
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_NATIVE_INT:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_INT64) {
-                data->value.asInt64 = *value->asInt32;
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_NATIVE_FLOAT:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_FLOAT) {
-                data->value.asFloat = *value->asFloat;
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_NATIVE_DOUBLE:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
-                data->value.asDouble = *value->asDouble;
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_NUMBER:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
-                return dpiDataBuffer__fromOracleNumberAsDouble(&data->value,
-                        error, value->asNumber);
-            else if (nativeTypeNum == DPI_NATIVE_TYPE_INT64)
-                return dpiDataBuffer__fromOracleNumberAsInteger(&data->value,
-                        error, value->asNumber);
-            else if (nativeTypeNum == DPI_NATIVE_TYPE_UINT64)
-                return dpiDataBuffer__fromOracleNumberAsUnsignedInteger(
-                        &data->value, error, value->asNumber);
-            else if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES)
-                return dpiDataBuffer__fromOracleNumberAsText(&data->value,
-                        obj->env, error, value->asNumber);
-            break;
-        case DPI_ORACLE_TYPE_DATE:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP)
-                return dpiDataBuffer__fromOracleDate(&data->value,
-                        value->asDate);
-            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
-                return dpiDataBuffer__fromOracleDateAsDouble(&data->value,
-                        obj->env, error, value->asDate);
-            break;
-        case DPI_ORACLE_TYPE_TIMESTAMP:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP)
-                return dpiDataBuffer__fromOracleTimestamp(&data->value,
-                        obj->env, error, *value->asTimestamp, 0);
-            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
-                return dpiDataBuffer__fromOracleTimestampAsDouble(&data->value,
-                        valueOracleTypeNum, obj->env, error,
-                        *value->asTimestamp);
-            break;
-        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
-        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP)
-                return dpiDataBuffer__fromOracleTimestamp(&data->value,
-                        obj->env, error, *value->asTimestamp, 1);
-            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
-                return dpiDataBuffer__fromOracleTimestampAsDouble(&data->value,
-                        valueOracleTypeNum, obj->env, error,
-                        *value->asTimestamp);
-            break;
-        case DPI_ORACLE_TYPE_OBJECT:
-            if (typeInfo->objectType &&
-                    nativeTypeNum == DPI_NATIVE_TYPE_OBJECT) {
-                void *instance = (typeInfo->objectType->isCollection) ?
-                        *value->asCollection : value->asRaw;
-                dpiObject *tempObj;
-                if (dpiObject__allocate(typeInfo->objectType, instance,
-                        indicator, obj, &tempObj, error) < 0)
-                    return DPI_FAILURE;
-                data->value.asObject = tempObj;
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_BOOLEAN:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_BOOLEAN) {
-                data->value.asBoolean = *(value->asBoolean);
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_CLOB:
-        case DPI_ORACLE_TYPE_NCLOB:
-        case DPI_ORACLE_TYPE_BLOB:
-        case DPI_ORACLE_TYPE_BFILE:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_LOB) {
-                const dpiOracleType *lobType;
-                void *tempLocator;
-                dpiLob *tempLob;
-                lobType = dpiOracleType__getFromNum(typeInfo->oracleTypeNum,
-                        error);
-                if (dpiLob__allocate(obj->type->conn, lobType, &tempLob,
-                        error) < 0)
-                    return DPI_FAILURE;
-                tempLocator = tempLob->locator;
-                tempLob->locator = *(value->asLobLocator);
-                if (dpiOci__lobLocatorAssign(tempLob, &tempLocator,
-                        error) < 0) {
-                    tempLob->locator = tempLocator;
-                    dpiLob__free(tempLob, error);
-                    return DPI_FAILURE;
-                }
-                tempLob->locator = tempLocator;
-                data->value.asLOB = tempLob;
-                return DPI_SUCCESS;
-            }
-            break;
-        default:
-            break;
-    };
-
-    return dpiError__set(error, "from Oracle value",
-            DPI_ERR_UNHANDLED_CONVERSION, valueOracleTypeNum, nativeTypeNum);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject__toOracleValue() [INTERNAL]
-//   Convert value from external type to the OCI data type required.
-//-----------------------------------------------------------------------------
-static int dpiObject__toOracleValue(dpiObject *obj, dpiError *error,
-        const dpiDataTypeInfo *dataTypeInfo, dpiOracleDataBuffer *buffer,
-        dpiLob **lob, void **ociValue, int16_t *valueIndicator,
-        void **objectIndicator, dpiNativeTypeNum nativeTypeNum, dpiData *data)
-{
-    dpiOracleTypeNum valueOracleTypeNum;
-    uint32_t handleType;
-    dpiObject *otherObj;
-    dpiBytes *bytes;
-
-    // nulls are handled easily
-    *objectIndicator = NULL;
-    if (data->isNull) {
-        *ociValue = NULL;
-        *valueIndicator = DPI_OCI_IND_NULL;
-        buffer->asRaw = NULL;
-        return DPI_SUCCESS;
-    }
-
-    // convert all other values
-    *valueIndicator = DPI_OCI_IND_NOTNULL;
-    valueOracleTypeNum = dataTypeInfo->oracleTypeNum;
-    switch (valueOracleTypeNum) {
-        case DPI_ORACLE_TYPE_CHAR:
-        case DPI_ORACLE_TYPE_NCHAR:
-        case DPI_ORACLE_TYPE_VARCHAR:
-        case DPI_ORACLE_TYPE_NVARCHAR:
-            buffer->asString = NULL;
-            if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
-                bytes = &data->value.asBytes;
-                if (dpiOci__stringAssignText(obj->env->handle, bytes->ptr,
-                        bytes->length, &buffer->asString, error) < 0)
-                    return DPI_FAILURE;
-                *ociValue = buffer->asString;
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_RAW:
-            buffer->asRawData = NULL;
-            if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
-                bytes = &data->value.asBytes;
-                if (dpiOci__rawAssignBytes(obj->env->handle, bytes->ptr,
-                        bytes->length, &buffer->asRawData, error) < 0)
-                    return DPI_FAILURE;
-                *ociValue = buffer->asRawData;
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_NATIVE_INT:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_INT64) {
-                buffer->asInt32 = (int32_t) data->value.asInt64;
-                *ociValue = &buffer->asInt32;
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_NUMBER:
-            *ociValue = &buffer->asNumber;
-            if (nativeTypeNum == DPI_NATIVE_TYPE_INT64)
-                return dpiDataBuffer__toOracleNumberFromInteger(&data->value,
-                        error, &buffer->asNumber);
-            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
-                return dpiDataBuffer__toOracleNumberFromDouble(&data->value,
-                        error, &buffer->asNumber);
-            if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES)
-                return dpiDataBuffer__toOracleNumberFromText(&data->value,
-                        obj->env, error, &buffer->asNumber);
-            break;
-        case DPI_ORACLE_TYPE_NATIVE_FLOAT:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_FLOAT) {
-                buffer->asFloat = data->value.asFloat;
-                *ociValue = &buffer->asFloat;
-                return DPI_SUCCESS;
-            } else if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
-                buffer->asFloat = (float) data->value.asDouble;
-                *ociValue = &buffer->asFloat;
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_NATIVE_DOUBLE:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
-                buffer->asDouble = data->value.asDouble;
-                *ociValue = &buffer->asDouble;
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_DATE:
-            *ociValue = &buffer->asDate;
-            if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP)
-                return dpiDataBuffer__toOracleDate(&data->value,
-                        &buffer->asDate);
-            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
-                return dpiDataBuffer__toOracleDateFromDouble(&data->value,
-                        obj->env, error, &buffer->asDate);
-            break;
-        case DPI_ORACLE_TYPE_TIMESTAMP:
-        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
-        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
-            buffer->asTimestamp = NULL;
-            if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP ||
-                    nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
-                if (valueOracleTypeNum == DPI_ORACLE_TYPE_TIMESTAMP_LTZ) {
-                    handleType = DPI_OCI_DTYPE_TIMESTAMP_LTZ;
-                } else if (valueOracleTypeNum == DPI_ORACLE_TYPE_TIMESTAMP) {
-                    handleType = DPI_OCI_DTYPE_TIMESTAMP;
-                } else {
-                    handleType = DPI_OCI_DTYPE_TIMESTAMP_TZ;
-                }
-                if (dpiOci__descriptorAlloc(obj->env->handle,
-                        &buffer->asTimestamp, handleType, "allocate timestamp",
-                        error) < 0)
-                    return DPI_FAILURE;
-                *ociValue = buffer->asTimestamp;
-                if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP)
-                    return dpiDataBuffer__toOracleTimestamp(&data->value,
-                            obj->env, error, buffer->asTimestamp,
-                            (valueOracleTypeNum != DPI_ORACLE_TYPE_TIMESTAMP));
-                return dpiDataBuffer__toOracleTimestampFromDouble(&data->value,
-                        valueOracleTypeNum, obj->env, error,
-                        buffer->asTimestamp);
-            }
-            break;
-        case DPI_ORACLE_TYPE_OBJECT:
-            otherObj = data->value.asObject;
-            if (nativeTypeNum == DPI_NATIVE_TYPE_OBJECT) {
-                if (otherObj->type->tdo != dataTypeInfo->objectType->tdo)
-                    return dpiError__set(error, "check type",
-                            DPI_ERR_WRONG_TYPE, otherObj->type->schemaLength,
-                            otherObj->type->schema, otherObj->type->nameLength,
-                            otherObj->type->name,
-                            dataTypeInfo->objectType->schemaLength,
-                            dataTypeInfo->objectType->schema,
-                            dataTypeInfo->objectType->nameLength,
-                            dataTypeInfo->objectType->name);
-                *ociValue = otherObj->instance;
-                *objectIndicator = otherObj->indicator;
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_BOOLEAN:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_BOOLEAN) {
-                buffer->asBoolean = data->value.asBoolean;
-                *ociValue = &buffer->asBoolean;
-                return DPI_SUCCESS;
-            }
-            break;
-        case DPI_ORACLE_TYPE_CLOB:
-        case DPI_ORACLE_TYPE_NCLOB:
-        case DPI_ORACLE_TYPE_BLOB:
-        case DPI_ORACLE_TYPE_BFILE:
-            buffer->asLobLocator = NULL;
-            if (nativeTypeNum == DPI_NATIVE_TYPE_LOB) {
-                *ociValue = data->value.asLOB->locator;
-                return DPI_SUCCESS;
-            } else if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
-                const dpiOracleType *lobType;
-                lobType = dpiOracleType__getFromNum(valueOracleTypeNum, error);
-                if (dpiLob__allocate(obj->type->conn, lobType, lob, error) < 0)
-                    return DPI_FAILURE;
-                bytes = &data->value.asBytes;
-                if (dpiLob__setFromBytes(*lob, bytes->ptr, bytes->length,
-                        error) < 0)
-                    return DPI_FAILURE;
-                buffer->asLobLocator = (*lob)->locator;
-                *ociValue = (*lob)->locator;
-                return DPI_SUCCESS;
-            }
-            break;
-
-        default:
-            break;
-    }
-
-    return dpiError__set(error, "to Oracle value",
-            DPI_ERR_UNHANDLED_CONVERSION, valueOracleTypeNum, nativeTypeNum);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_addRef() [PUBLIC]
-//   Add a reference to the object.
-//-----------------------------------------------------------------------------
-int dpiObject_addRef(dpiObject *obj)
-{
-    return dpiGen__addRef(obj, DPI_HTYPE_OBJECT, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_appendElement() [PUBLIC]
-//   Append an element to the collection.
-//-----------------------------------------------------------------------------
-int dpiObject_appendElement(dpiObject *obj, dpiNativeTypeNum nativeTypeNum,
-        dpiData *data)
-{
-    dpiOracleDataBuffer valueBuffer;
-    int16_t scalarValueIndicator;
-    dpiLob *lob = NULL;
-    void *indicator;
-    dpiError error;
-    void *ociValue;
-    int status;
-
-    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(obj, data)
-    status = dpiObject__toOracleValue(obj, &error, &obj->type->elementTypeInfo,
-            &valueBuffer, &lob, &ociValue, &scalarValueIndicator,
-            (void**) &indicator, nativeTypeNum, data);
-    if (status == DPI_SUCCESS) {
-        if (!indicator)
-            indicator = &scalarValueIndicator;
-        status = dpiOci__collAppend(obj->type->conn, ociValue, indicator,
-                obj->instance, &error);
-    }
-    dpiObject__clearOracleValue(obj, &error, &valueBuffer, lob,
-            obj->type->elementTypeInfo.oracleTypeNum);
-    return dpiGen__endPublicFn(obj, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_copy() [PUBLIC]
-//   Create a copy of the object and return it. Return NULL upon error.
-//-----------------------------------------------------------------------------
-int dpiObject_copy(dpiObject *obj, dpiObject **copiedObj)
-{
-    dpiObject *tempObj;
-    dpiError error;
-
-    if (dpiObject__check(obj, __func__, &error) < 0)
-        return DPI_FAILURE;
-    DPI_CHECK_PTR_NOT_NULL(obj, copiedObj)
-    if (dpiObject__allocate(obj->type, NULL, NULL, NULL, &tempObj, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    if (dpiOci__objectCopy(tempObj, obj->instance, obj->indicator,
-            &error) < 0) {
-        dpiObject__free(tempObj, &error);
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    }
-    *copiedObj = tempObj;
-    return dpiGen__endPublicFn(obj, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_deleteElementByIndex() [PUBLIC]
-//   Delete the element at the specified index in the collection.
-//-----------------------------------------------------------------------------
-int dpiObject_deleteElementByIndex(dpiObject *obj, int32_t index)
-{
-    dpiError error;
-    int status;
-
-    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    status = dpiOci__tableDelete(obj, index, &error);
-    return dpiGen__endPublicFn(obj, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_getAttributeValue() [PUBLIC]
-//   Get the value of the given attribute from the object.
-//-----------------------------------------------------------------------------
-int dpiObject_getAttributeValue(dpiObject *obj, dpiObjectAttr *attr,
-        dpiNativeTypeNum nativeTypeNum, dpiData *data)
-{
-    int16_t scalarValueIndicator;
-    void *valueIndicator, *tdo;
-    dpiOracleData value;
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiObject__check(obj, __func__, &error) < 0)
-        return DPI_FAILURE;
-    DPI_CHECK_PTR_NOT_NULL(obj, data)
-    if (dpiGen__checkHandle(attr, DPI_HTYPE_OBJECT_ATTR, "get attribute value",
-            &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    if (attr->belongsToType->tdo != obj->type->tdo) {
-        dpiError__set(&error, "get attribute value", DPI_ERR_WRONG_ATTR,
-                attr->nameLength, attr->name, obj->type->schemaLength,
-                obj->type->schema, obj->type->nameLength, obj->type->name);
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    }
-
-    // get attribute value
-    if (dpiOci__objectGetAttr(obj, attr, &scalarValueIndicator,
-            &valueIndicator, &value.asRaw, &tdo, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-
-    // determine the proper null indicator
-    if (!valueIndicator)
-        valueIndicator = &scalarValueIndicator;
-
-    // check to see if type is supported
-    if (!attr->typeInfo.oracleTypeNum) {
-        dpiError__set(&error, "get attribute value",
-                DPI_ERR_UNHANDLED_DATA_TYPE, attr->typeInfo.ociTypeCode);
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    }
-
-    // convert to output data format
-    status = dpiObject__fromOracleValue(obj, &error, &attr->typeInfo, &value,
-            (int16_t*) valueIndicator, nativeTypeNum, data);
-    return dpiGen__endPublicFn(obj, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_getElementExistsByIndex() [PUBLIC]
-//   Return boolean indicating if an element exists in the collection at the
-// specified index.
-//-----------------------------------------------------------------------------
-int dpiObject_getElementExistsByIndex(dpiObject *obj, int32_t index,
-        int *exists)
-{
-    dpiError error;
-    int status;
-
-    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(obj, exists)
-    status = dpiOci__tableExists(obj, index, exists, &error);
-    return dpiGen__endPublicFn(obj, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_getElementValueByIndex() [PUBLIC]
-//   Return the element at the given index in the collection.
-//-----------------------------------------------------------------------------
-int dpiObject_getElementValueByIndex(dpiObject *obj, int32_t index,
-        dpiNativeTypeNum nativeTypeNum, dpiData *data)
-{
-    dpiOracleData value;
-    int exists, status;
-    void *indicator;
-    dpiError error;
-
-    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(obj, data)
-    if (dpiOci__collGetElem(obj->type->conn, obj->instance, index, &exists,
-            &value.asRaw, &indicator, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    if (!exists) {
-        dpiError__set(&error, "get element value", DPI_ERR_INVALID_INDEX,
-                index);
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    }
-    status = dpiObject__fromOracleValue(obj, &error,
-            &obj->type->elementTypeInfo, &value, (int16_t*) indicator,
-            nativeTypeNum, data);
-    return dpiGen__endPublicFn(obj, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_getFirstIndex() [PUBLIC]
-//   Return the index of the first entry in the collection.
-//-----------------------------------------------------------------------------
-int dpiObject_getFirstIndex(dpiObject *obj, int32_t *index, int *exists)
-{
-    dpiError error;
-    int32_t size;
-    int status;
-
-    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(obj, index)
-    DPI_CHECK_PTR_NOT_NULL(obj, exists)
-    if (dpiOci__tableSize(obj, &size, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    *exists = (size != 0);
-    if (*exists)
-        status = dpiOci__tableFirst(obj, index, &error);
-    else status = DPI_SUCCESS;
-    return dpiGen__endPublicFn(obj, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_getLastIndex() [PUBLIC]
-//   Return the index of the last entry in the collection.
-//-----------------------------------------------------------------------------
-int dpiObject_getLastIndex(dpiObject *obj, int32_t *index, int *exists)
-{
-    dpiError error;
-    int32_t size;
-    int status;
-
-    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(obj, index)
-    DPI_CHECK_PTR_NOT_NULL(obj, exists)
-    if (dpiOci__tableSize(obj, &size, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    *exists = (size != 0);
-    if (*exists)
-        status = dpiOci__tableLast(obj, index, &error);
-    else status = DPI_SUCCESS;
-    return dpiGen__endPublicFn(obj, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_getNextIndex() [PUBLIC]
-//   Return the index of the next entry in the collection following the index
-// specified. If there is no next entry, exists is set to 0.
-//-----------------------------------------------------------------------------
-int dpiObject_getNextIndex(dpiObject *obj, int32_t index, int32_t *nextIndex,
-        int *exists)
-{
-    dpiError error;
-    int status;
-
-    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(obj, nextIndex)
-    DPI_CHECK_PTR_NOT_NULL(obj, exists)
-    status = dpiOci__tableNext(obj, index, nextIndex, exists, &error);
-    return dpiGen__endPublicFn(obj, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_getPrevIndex() [PUBLIC]
-//   Return the index of the previous entry in the collection preceding the
-// index specified. If there is no previous entry, exists is set to 0.
-//-----------------------------------------------------------------------------
-int dpiObject_getPrevIndex(dpiObject *obj, int32_t index, int32_t *prevIndex,
-        int *exists)
-{
-    dpiError error;
-    int status;
-
-    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(obj, prevIndex)
-    DPI_CHECK_PTR_NOT_NULL(obj, exists)
-    status = dpiOci__tablePrev(obj, index, prevIndex, exists, &error);
-    return dpiGen__endPublicFn(obj, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_getSize() [PUBLIC]
-//   Return the size of the collection.
-//-----------------------------------------------------------------------------
-int dpiObject_getSize(dpiObject *obj, int32_t *size)
-{
-    dpiError error;
-    int status;
-
-    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(obj, size)
-    status = dpiOci__collSize(obj->type->conn, obj->instance, size, &error);
-    return dpiGen__endPublicFn(obj, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_release() [PUBLIC]
-//   Release a reference to the object.
-//-----------------------------------------------------------------------------
-int dpiObject_release(dpiObject *obj)
-{
-    return dpiGen__release(obj, DPI_HTYPE_OBJECT, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_setAttributeValue() [PUBLIC]
-//   Create a copy of the object and return it. Return NULL upon error.
-//-----------------------------------------------------------------------------
-int dpiObject_setAttributeValue(dpiObject *obj, dpiObjectAttr *attr,
-        dpiNativeTypeNum nativeTypeNum, dpiData *data)
-{
-    void *valueIndicator, *ociValue;
-    dpiOracleDataBuffer valueBuffer;
-    int16_t scalarValueIndicator;
-    dpiLob *lob = NULL;
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiObject__check(obj, __func__, &error) < 0)
-        return DPI_FAILURE;
-    DPI_CHECK_PTR_NOT_NULL(obj, data)
-    if (dpiGen__checkHandle(attr, DPI_HTYPE_OBJECT_ATTR, "set attribute value",
-            &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    if (attr->belongsToType->tdo != obj->type->tdo) {
-        dpiError__set(&error, "set attribute value", DPI_ERR_WRONG_ATTR,
-                attr->nameLength, attr->name, obj->type->schemaLength,
-                obj->type->schema, obj->type->nameLength, obj->type->name);
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    }
-
-    // check to see if type is supported
-    if (!attr->typeInfo.oracleTypeNum) {
-        dpiError__set(&error, "get attribute value",
-                DPI_ERR_UNHANDLED_DATA_TYPE, attr->typeInfo.ociTypeCode);
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    }
-
-    // convert to input data format
-    status = dpiObject__toOracleValue(obj, &error, &attr->typeInfo,
-            &valueBuffer, &lob, &ociValue, &scalarValueIndicator,
-            &valueIndicator, nativeTypeNum, data);
-
-    // set attribute value
-    if (status == DPI_SUCCESS)
-        status = dpiOci__objectSetAttr(obj, attr, scalarValueIndicator,
-                valueIndicator, ociValue, &error);
-    dpiObject__clearOracleValue(obj, &error, &valueBuffer, lob,
-            attr->typeInfo.oracleTypeNum);
-    return dpiGen__endPublicFn(obj, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_setElementValueByIndex() [PUBLIC]
-//   Set the element at the specified index to the given value.
-//-----------------------------------------------------------------------------
-int dpiObject_setElementValueByIndex(dpiObject *obj, int32_t index,
-        dpiNativeTypeNum nativeTypeNum, dpiData *data)
-{
-    dpiOracleDataBuffer valueBuffer;
-    int16_t scalarValueIndicator;
-    dpiLob *lob = NULL;
-    void *indicator;
-    dpiError error;
-    void *ociValue;
-    int status;
-
-    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(obj, data)
-    status = dpiObject__toOracleValue(obj, &error, &obj->type->elementTypeInfo,
-            &valueBuffer, &lob, &ociValue, &scalarValueIndicator,
-            (void**) &indicator, nativeTypeNum, data);
-    if (status == DPI_SUCCESS) {
-        if (!indicator)
-            indicator = &scalarValueIndicator;
-        status = dpiOci__collAssignElem(obj->type->conn, index, ociValue,
-                indicator, obj->instance, &error);
-    }
-    dpiObject__clearOracleValue(obj, &error, &valueBuffer, lob,
-            obj->type->elementTypeInfo.oracleTypeNum);
-    return dpiGen__endPublicFn(obj, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObject_trim() [PUBLIC]
-//   Trim a number of elements from the end of the collection.
-//-----------------------------------------------------------------------------
-int dpiObject_trim(dpiObject *obj, uint32_t numToTrim)
-{
-    dpiError error;
-    int status;
-
-    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
-        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
-    status = dpiOci__collTrim(obj->type->conn, numToTrim, obj->instance,
-            &error);
-    return dpiGen__endPublicFn(obj, status, &error);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiObject.h ./odpi/src/dpiObject.h
--- patched-godror/odpi/src/dpiObject.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiObject.h	2024-05-14 14:55:13
@@ -0,0 +1,981 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiObject.c
+//   Implementation of objects.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+// forward declarations of internal functions only used in this file
+int dpiObject__closeHelper(dpiObject *obj, int checkError, dpiError *error);
+
+
+//-----------------------------------------------------------------------------
+// dpiObject__allocate() [INTERNAL]
+//   Allocate and initialize an object structure.
+//-----------------------------------------------------------------------------
+int dpiObject__allocate(dpiObjectType *objType, void *instance,
+        void *indicator, dpiObject *dependsOnObj, dpiObject **obj,
+        dpiError *error)
+{
+    dpiObject *tempObj;
+
+    if (dpiGen__allocate(DPI_HTYPE_OBJECT, objType->env, (void**) &tempObj,
+            error) < 0)
+        return DPI_FAILURE;
+    dpiGen__setRefCount(objType, error, 1);
+    tempObj->type = objType;
+    tempObj->instance = instance;
+    tempObj->indicator = indicator;
+    if (dependsOnObj) {
+        dpiGen__setRefCount(dependsOnObj, error, 1);
+        tempObj->dependsOnObj = dependsOnObj;
+    }
+    if (!instance) {
+        if (dpiOci__objectNew(tempObj, error) < 0) {
+            dpiObject__free(tempObj, error);
+            return DPI_FAILURE;
+        }
+        if (dpiOci__objectGetInd(tempObj, error) < 0) {
+            dpiObject__free(tempObj, error);
+            return DPI_FAILURE;
+        }
+    }
+    if (tempObj->instance && !dependsOnObj) {
+        if (dpiHandleList__addHandle(objType->conn->objects, tempObj,
+                &tempObj->openSlotNum, error) < 0) {
+            dpiObject__free(tempObj, error);
+            return DPI_FAILURE;
+        }
+    }
+    *obj = tempObj;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject__check() [INTERNAL]
+//   Determine if the object handle provided is available for use.
+//-----------------------------------------------------------------------------
+static int dpiObject__check(dpiObject *obj, const char *fnName,
+        dpiError *error)
+{
+    if (dpiGen__startPublicFn(obj, DPI_HTYPE_OBJECT, fnName, error) < 0)
+        return DPI_FAILURE;
+    return dpiConn__checkConnected(obj->type->conn, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject__checkIsCollection() [INTERNAL]
+//   Check if the object is a collection, and if not, raise an exception.
+//-----------------------------------------------------------------------------
+static int dpiObject__checkIsCollection(dpiObject *obj, const char *fnName,
+        dpiError *error)
+{
+    if (dpiObject__check(obj, fnName, error) < 0)
+        return DPI_FAILURE;
+    if (!obj->type->isCollection)
+        return dpiError__set(error, "check collection", DPI_ERR_NOT_COLLECTION,
+                obj->type->schemaLength, obj->type->schema,
+                obj->type->nameLength, obj->type->name);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject__clearOracleValue() [INTERNAL]
+//   Clear the Oracle value after use.
+//-----------------------------------------------------------------------------
+static void dpiObject__clearOracleValue(dpiObject *obj, dpiError *error,
+        dpiOracleDataBuffer *buffer, dpiLob *lob,
+        dpiOracleTypeNum oracleTypeNum)
+{
+    switch (oracleTypeNum) {
+        case DPI_ORACLE_TYPE_CHAR:
+        case DPI_ORACLE_TYPE_NCHAR:
+        case DPI_ORACLE_TYPE_VARCHAR:
+        case DPI_ORACLE_TYPE_NVARCHAR:
+            if (buffer->asString)
+                dpiOci__stringResize(obj->env->handle, &buffer->asString, 0,
+                        error);
+            break;
+        case DPI_ORACLE_TYPE_RAW:
+            if (buffer->asRawData)
+                dpiOci__rawResize(obj->env->handle, &buffer->asRawData, 0,
+                        error);
+            break;
+        case DPI_ORACLE_TYPE_TIMESTAMP:
+            if (buffer->asTimestamp)
+                dpiOci__descriptorFree(buffer->asTimestamp,
+                        DPI_OCI_DTYPE_TIMESTAMP);
+            break;
+        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
+            if (buffer->asTimestamp)
+                dpiOci__descriptorFree(buffer->asTimestamp,
+                        DPI_OCI_DTYPE_TIMESTAMP_TZ);
+            break;
+        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
+            if (buffer->asTimestamp)
+                dpiOci__descriptorFree(buffer->asTimestamp,
+                        DPI_OCI_DTYPE_TIMESTAMP_LTZ);
+            break;
+        case DPI_ORACLE_TYPE_CLOB:
+        case DPI_ORACLE_TYPE_NCLOB:
+        case DPI_ORACLE_TYPE_BLOB:
+        case DPI_ORACLE_TYPE_BFILE:
+            if (lob)
+                dpiGen__setRefCount(lob, error, -1);
+            break;
+        default:
+            break;
+    };
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject__close() [INTERNAL]
+//   Close the object (frees the memory for the instance). This is needed to
+// avoid trying to do so after the connection which created the object is
+// closed. In some future release of the Oracle Client libraries this may not
+// be needed, at which point this code and all of the code for managing the
+// list of objects created by a collection can be removed.
+//-----------------------------------------------------------------------------
+int dpiObject__close(dpiObject *obj, int checkError, dpiError *error)
+{
+    int closing;
+
+    // determine whether object is already being closed and if not, mark
+    // object as being closed; this MUST be done while holding the lock (if
+    // in threaded mode) to avoid race conditions!
+    if (obj->env->threaded)
+        dpiMutex__acquire(obj->env->mutex);
+    closing = obj->closing;
+    obj->closing = 1;
+    if (obj->env->threaded)
+        dpiMutex__release(obj->env->mutex);
+
+    // if object is already being closed, nothing needs to be done
+    if (closing)
+        return DPI_SUCCESS;
+
+    // perform actual work of closing object; if this fails, reset closing
+    // flag; again, this must be done while holding the lock (if in threaded
+    // mode) in order to avoid race conditions!
+    if (obj->instance && !obj->dependsOnObj) {
+        if (dpiObject__closeHelper(obj, checkError, error) < 0) {
+            if (obj->env->threaded)
+                dpiMutex__acquire(obj->env->mutex);
+            obj->closing = 0;
+            if (obj->env->threaded)
+                dpiMutex__release(obj->env->mutex);
+            return DPI_FAILURE;
+        }
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject__closeHelper() [INTERNAL]
+//   Helper function for closing an object.
+//-----------------------------------------------------------------------------
+int dpiObject__closeHelper(dpiObject *obj, int checkError, dpiError *error)
+{
+    if (dpiOci__objectFree(obj->env->handle, obj->instance, checkError,
+            error) < 0)
+        return DPI_FAILURE;
+    obj->instance = NULL;
+    if (obj->freeIndicator && dpiOci__objectFree(obj->env->handle,
+            obj->indicator, checkError, error) < 0)
+        return DPI_FAILURE;
+    obj->indicator = NULL;
+    if (!obj->type->conn->closing)
+        dpiHandleList__removeHandle(obj->type->conn->objects,
+                obj->openSlotNum);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject__free() [INTERNAL]
+//   Free the memory for an object.
+//-----------------------------------------------------------------------------
+void dpiObject__free(dpiObject *obj, dpiError *error)
+{
+    dpiObject__close(obj, 0, error);
+    if (obj->type) {
+        dpiGen__setRefCount(obj->type, error, -1);
+        obj->type = NULL;
+    }
+    if (obj->dependsOnObj) {
+        dpiGen__setRefCount(obj->dependsOnObj, error, -1);
+        obj->dependsOnObj = NULL;
+    }
+    dpiUtils__freeMemory(obj);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject__fromOracleValue() [INTERNAL]
+//   Populate data from the Oracle value or return an error if this is not
+// possible.
+//-----------------------------------------------------------------------------
+static int dpiObject__fromOracleValue(dpiObject *obj, dpiError *error,
+        const dpiDataTypeInfo *typeInfo, dpiOracleData *value,
+        int16_t *indicator, dpiNativeTypeNum nativeTypeNum, dpiData *data)
+{
+    dpiOracleTypeNum valueOracleTypeNum;
+    dpiBytes *asBytes;
+
+    // null values are immediately returned (type is irrelevant)
+    if (*indicator == DPI_OCI_IND_NULL) {
+        data->isNull = 1;
+        return DPI_SUCCESS;
+    }
+
+    // convert all other values
+    data->isNull = 0;
+    valueOracleTypeNum = typeInfo->oracleTypeNum;
+    switch (valueOracleTypeNum) {
+        case DPI_ORACLE_TYPE_CHAR:
+        case DPI_ORACLE_TYPE_NCHAR:
+        case DPI_ORACLE_TYPE_VARCHAR:
+        case DPI_ORACLE_TYPE_NVARCHAR:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
+                asBytes = &data->value.asBytes;
+                dpiOci__stringPtr(obj->env->handle, *value->asString,
+                        &asBytes->ptr);
+                dpiOci__stringSize(obj->env->handle, *value->asString,
+                        &asBytes->length);
+                if (valueOracleTypeNum == DPI_ORACLE_TYPE_NCHAR ||
+                        valueOracleTypeNum == DPI_ORACLE_TYPE_NVARCHAR)
+                    asBytes->encoding = obj->env->nencoding;
+                else asBytes->encoding = obj->env->encoding;
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_RAW:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
+                asBytes = &data->value.asBytes;
+                dpiOci__rawPtr(obj->env->handle, *value->asRawData,
+                        (void**) &asBytes->ptr);
+                dpiOci__rawSize(obj->env->handle, *value->asRawData,
+                        &asBytes->length);
+                asBytes->encoding = NULL;
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_NATIVE_INT:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_INT64) {
+                data->value.asInt64 = *value->asInt32;
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_NATIVE_FLOAT:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_FLOAT) {
+                data->value.asFloat = *value->asFloat;
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_NATIVE_DOUBLE:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
+                data->value.asDouble = *value->asDouble;
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_NUMBER:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
+                return dpiDataBuffer__fromOracleNumberAsDouble(&data->value,
+                        error, value->asNumber);
+            else if (nativeTypeNum == DPI_NATIVE_TYPE_INT64)
+                return dpiDataBuffer__fromOracleNumberAsInteger(&data->value,
+                        error, value->asNumber);
+            else if (nativeTypeNum == DPI_NATIVE_TYPE_UINT64)
+                return dpiDataBuffer__fromOracleNumberAsUnsignedInteger(
+                        &data->value, error, value->asNumber);
+            else if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES)
+                return dpiDataBuffer__fromOracleNumberAsText(&data->value,
+                        obj->env, error, value->asNumber);
+            break;
+        case DPI_ORACLE_TYPE_DATE:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP)
+                return dpiDataBuffer__fromOracleDate(&data->value,
+                        value->asDate);
+            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
+                return dpiDataBuffer__fromOracleDateAsDouble(&data->value,
+                        obj->env, error, value->asDate);
+            break;
+        case DPI_ORACLE_TYPE_TIMESTAMP:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP)
+                return dpiDataBuffer__fromOracleTimestamp(&data->value,
+                        obj->env, error, *value->asTimestamp, 0);
+            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
+                return dpiDataBuffer__fromOracleTimestampAsDouble(&data->value,
+                        valueOracleTypeNum, obj->env, error,
+                        *value->asTimestamp);
+            break;
+        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
+        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP)
+                return dpiDataBuffer__fromOracleTimestamp(&data->value,
+                        obj->env, error, *value->asTimestamp, 1);
+            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
+                return dpiDataBuffer__fromOracleTimestampAsDouble(&data->value,
+                        valueOracleTypeNum, obj->env, error,
+                        *value->asTimestamp);
+            break;
+        case DPI_ORACLE_TYPE_OBJECT:
+            if (typeInfo->objectType &&
+                    nativeTypeNum == DPI_NATIVE_TYPE_OBJECT) {
+                void *instance = (typeInfo->objectType->isCollection) ?
+                        *value->asCollection : value->asRaw;
+                dpiObject *tempObj;
+                if (dpiObject__allocate(typeInfo->objectType, instance,
+                        indicator, obj, &tempObj, error) < 0)
+                    return DPI_FAILURE;
+                data->value.asObject = tempObj;
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_BOOLEAN:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_BOOLEAN) {
+                data->value.asBoolean = *(value->asBoolean);
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_CLOB:
+        case DPI_ORACLE_TYPE_NCLOB:
+        case DPI_ORACLE_TYPE_BLOB:
+        case DPI_ORACLE_TYPE_BFILE:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_LOB) {
+                const dpiOracleType *lobType;
+                void *tempLocator;
+                dpiLob *tempLob;
+                lobType = dpiOracleType__getFromNum(typeInfo->oracleTypeNum,
+                        error);
+                if (dpiLob__allocate(obj->type->conn, lobType, &tempLob,
+                        error) < 0)
+                    return DPI_FAILURE;
+                tempLocator = tempLob->locator;
+                tempLob->locator = *(value->asLobLocator);
+                if (dpiOci__lobLocatorAssign(tempLob, &tempLocator,
+                        error) < 0) {
+                    tempLob->locator = tempLocator;
+                    dpiLob__free(tempLob, error);
+                    return DPI_FAILURE;
+                }
+                tempLob->locator = tempLocator;
+                data->value.asLOB = tempLob;
+                return DPI_SUCCESS;
+            }
+            break;
+        default:
+            break;
+    };
+
+    return dpiError__set(error, "from Oracle value",
+            DPI_ERR_UNHANDLED_CONVERSION, valueOracleTypeNum, nativeTypeNum);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject__toOracleValue() [INTERNAL]
+//   Convert value from external type to the OCI data type required.
+//-----------------------------------------------------------------------------
+static int dpiObject__toOracleValue(dpiObject *obj, dpiError *error,
+        const dpiDataTypeInfo *dataTypeInfo, dpiOracleDataBuffer *buffer,
+        dpiLob **lob, void **ociValue, int16_t *valueIndicator,
+        void **objectIndicator, dpiNativeTypeNum nativeTypeNum, dpiData *data)
+{
+    dpiOracleTypeNum valueOracleTypeNum;
+    uint32_t handleType;
+    dpiObject *otherObj;
+    dpiBytes *bytes;
+
+    // nulls are handled easily
+    *objectIndicator = NULL;
+    if (data->isNull) {
+        *ociValue = NULL;
+        *valueIndicator = DPI_OCI_IND_NULL;
+        buffer->asRaw = NULL;
+        return DPI_SUCCESS;
+    }
+
+    // convert all other values
+    *valueIndicator = DPI_OCI_IND_NOTNULL;
+    valueOracleTypeNum = dataTypeInfo->oracleTypeNum;
+    switch (valueOracleTypeNum) {
+        case DPI_ORACLE_TYPE_CHAR:
+        case DPI_ORACLE_TYPE_NCHAR:
+        case DPI_ORACLE_TYPE_VARCHAR:
+        case DPI_ORACLE_TYPE_NVARCHAR:
+            buffer->asString = NULL;
+            if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
+                bytes = &data->value.asBytes;
+                if (dpiOci__stringAssignText(obj->env->handle, bytes->ptr,
+                        bytes->length, &buffer->asString, error) < 0)
+                    return DPI_FAILURE;
+                *ociValue = buffer->asString;
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_RAW:
+            buffer->asRawData = NULL;
+            if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
+                bytes = &data->value.asBytes;
+                if (dpiOci__rawAssignBytes(obj->env->handle, bytes->ptr,
+                        bytes->length, &buffer->asRawData, error) < 0)
+                    return DPI_FAILURE;
+                *ociValue = buffer->asRawData;
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_NATIVE_INT:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_INT64) {
+                buffer->asInt32 = (int32_t) data->value.asInt64;
+                *ociValue = &buffer->asInt32;
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_NUMBER:
+            *ociValue = &buffer->asNumber;
+            if (nativeTypeNum == DPI_NATIVE_TYPE_INT64)
+                return dpiDataBuffer__toOracleNumberFromInteger(&data->value,
+                        error, &buffer->asNumber);
+            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
+                return dpiDataBuffer__toOracleNumberFromDouble(&data->value,
+                        error, &buffer->asNumber);
+            if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES)
+                return dpiDataBuffer__toOracleNumberFromText(&data->value,
+                        obj->env, error, &buffer->asNumber);
+            break;
+        case DPI_ORACLE_TYPE_NATIVE_FLOAT:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_FLOAT) {
+                buffer->asFloat = data->value.asFloat;
+                *ociValue = &buffer->asFloat;
+                return DPI_SUCCESS;
+            } else if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
+                buffer->asFloat = (float) data->value.asDouble;
+                *ociValue = &buffer->asFloat;
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_NATIVE_DOUBLE:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
+                buffer->asDouble = data->value.asDouble;
+                *ociValue = &buffer->asDouble;
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_DATE:
+            *ociValue = &buffer->asDate;
+            if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP)
+                return dpiDataBuffer__toOracleDate(&data->value,
+                        &buffer->asDate);
+            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
+                return dpiDataBuffer__toOracleDateFromDouble(&data->value,
+                        obj->env, error, &buffer->asDate);
+            break;
+        case DPI_ORACLE_TYPE_TIMESTAMP:
+        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
+        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
+            buffer->asTimestamp = NULL;
+            if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP ||
+                    nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE) {
+                if (valueOracleTypeNum == DPI_ORACLE_TYPE_TIMESTAMP_LTZ) {
+                    handleType = DPI_OCI_DTYPE_TIMESTAMP_LTZ;
+                } else if (valueOracleTypeNum == DPI_ORACLE_TYPE_TIMESTAMP) {
+                    handleType = DPI_OCI_DTYPE_TIMESTAMP;
+                } else {
+                    handleType = DPI_OCI_DTYPE_TIMESTAMP_TZ;
+                }
+                if (dpiOci__descriptorAlloc(obj->env->handle,
+                        &buffer->asTimestamp, handleType, "allocate timestamp",
+                        error) < 0)
+                    return DPI_FAILURE;
+                *ociValue = buffer->asTimestamp;
+                if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP)
+                    return dpiDataBuffer__toOracleTimestamp(&data->value,
+                            obj->env, error, buffer->asTimestamp,
+                            (valueOracleTypeNum != DPI_ORACLE_TYPE_TIMESTAMP));
+                return dpiDataBuffer__toOracleTimestampFromDouble(&data->value,
+                        valueOracleTypeNum, obj->env, error,
+                        buffer->asTimestamp);
+            }
+            break;
+        case DPI_ORACLE_TYPE_OBJECT:
+            otherObj = data->value.asObject;
+            if (nativeTypeNum == DPI_NATIVE_TYPE_OBJECT) {
+                if (otherObj->type->tdo != dataTypeInfo->objectType->tdo)
+                    return dpiError__set(error, "check type",
+                            DPI_ERR_WRONG_TYPE, otherObj->type->schemaLength,
+                            otherObj->type->schema, otherObj->type->nameLength,
+                            otherObj->type->name,
+                            dataTypeInfo->objectType->schemaLength,
+                            dataTypeInfo->objectType->schema,
+                            dataTypeInfo->objectType->nameLength,
+                            dataTypeInfo->objectType->name);
+                *ociValue = otherObj->instance;
+                *objectIndicator = otherObj->indicator;
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_BOOLEAN:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_BOOLEAN) {
+                buffer->asBoolean = data->value.asBoolean;
+                *ociValue = &buffer->asBoolean;
+                return DPI_SUCCESS;
+            }
+            break;
+        case DPI_ORACLE_TYPE_CLOB:
+        case DPI_ORACLE_TYPE_NCLOB:
+        case DPI_ORACLE_TYPE_BLOB:
+        case DPI_ORACLE_TYPE_BFILE:
+            buffer->asLobLocator = NULL;
+            if (nativeTypeNum == DPI_NATIVE_TYPE_LOB) {
+                *ociValue = data->value.asLOB->locator;
+                return DPI_SUCCESS;
+            } else if (nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
+                const dpiOracleType *lobType;
+                lobType = dpiOracleType__getFromNum(valueOracleTypeNum, error);
+                if (dpiLob__allocate(obj->type->conn, lobType, lob, error) < 0)
+                    return DPI_FAILURE;
+                bytes = &data->value.asBytes;
+                if (dpiLob__setFromBytes(*lob, bytes->ptr, bytes->length,
+                        error) < 0)
+                    return DPI_FAILURE;
+                buffer->asLobLocator = (*lob)->locator;
+                *ociValue = (*lob)->locator;
+                return DPI_SUCCESS;
+            }
+            break;
+
+        default:
+            break;
+    }
+
+    return dpiError__set(error, "to Oracle value",
+            DPI_ERR_UNHANDLED_CONVERSION, valueOracleTypeNum, nativeTypeNum);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_addRef() [PUBLIC]
+//   Add a reference to the object.
+//-----------------------------------------------------------------------------
+int dpiObject_addRef(dpiObject *obj)
+{
+    return dpiGen__addRef(obj, DPI_HTYPE_OBJECT, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_appendElement() [PUBLIC]
+//   Append an element to the collection.
+//-----------------------------------------------------------------------------
+int dpiObject_appendElement(dpiObject *obj, dpiNativeTypeNum nativeTypeNum,
+        dpiData *data)
+{
+    dpiOracleDataBuffer valueBuffer;
+    int16_t scalarValueIndicator;
+    dpiLob *lob = NULL;
+    void *indicator;
+    dpiError error;
+    void *ociValue;
+    int status;
+
+    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(obj, data)
+    status = dpiObject__toOracleValue(obj, &error, &obj->type->elementTypeInfo,
+            &valueBuffer, &lob, &ociValue, &scalarValueIndicator,
+            (void**) &indicator, nativeTypeNum, data);
+    if (status == DPI_SUCCESS) {
+        if (!indicator)
+            indicator = &scalarValueIndicator;
+        status = dpiOci__collAppend(obj->type->conn, ociValue, indicator,
+                obj->instance, &error);
+    }
+    dpiObject__clearOracleValue(obj, &error, &valueBuffer, lob,
+            obj->type->elementTypeInfo.oracleTypeNum);
+    return dpiGen__endPublicFn(obj, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_copy() [PUBLIC]
+//   Create a copy of the object and return it. Return NULL upon error.
+//-----------------------------------------------------------------------------
+int dpiObject_copy(dpiObject *obj, dpiObject **copiedObj)
+{
+    dpiObject *tempObj;
+    dpiError error;
+
+    if (dpiObject__check(obj, __func__, &error) < 0)
+        return DPI_FAILURE;
+    DPI_CHECK_PTR_NOT_NULL(obj, copiedObj)
+    if (dpiObject__allocate(obj->type, NULL, NULL, NULL, &tempObj, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    if (dpiOci__objectCopy(tempObj, obj->instance, obj->indicator,
+            &error) < 0) {
+        dpiObject__free(tempObj, &error);
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    }
+    *copiedObj = tempObj;
+    return dpiGen__endPublicFn(obj, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_deleteElementByIndex() [PUBLIC]
+//   Delete the element at the specified index in the collection.
+//-----------------------------------------------------------------------------
+int dpiObject_deleteElementByIndex(dpiObject *obj, int32_t index)
+{
+    dpiError error;
+    int status;
+
+    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    status = dpiOci__tableDelete(obj, index, &error);
+    return dpiGen__endPublicFn(obj, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_getAttributeValue() [PUBLIC]
+//   Get the value of the given attribute from the object.
+//-----------------------------------------------------------------------------
+int dpiObject_getAttributeValue(dpiObject *obj, dpiObjectAttr *attr,
+        dpiNativeTypeNum nativeTypeNum, dpiData *data)
+{
+    int16_t scalarValueIndicator;
+    void *valueIndicator, *tdo;
+    dpiOracleData value;
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiObject__check(obj, __func__, &error) < 0)
+        return DPI_FAILURE;
+    DPI_CHECK_PTR_NOT_NULL(obj, data)
+    if (dpiGen__checkHandle(attr, DPI_HTYPE_OBJECT_ATTR, "get attribute value",
+            &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    if (attr->belongsToType->tdo != obj->type->tdo) {
+        dpiError__set(&error, "get attribute value", DPI_ERR_WRONG_ATTR,
+                attr->nameLength, attr->name, obj->type->schemaLength,
+                obj->type->schema, obj->type->nameLength, obj->type->name);
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    }
+
+    // get attribute value
+    if (dpiOci__objectGetAttr(obj, attr, &scalarValueIndicator,
+            &valueIndicator, &value.asRaw, &tdo, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+
+    // determine the proper null indicator
+    if (!valueIndicator)
+        valueIndicator = &scalarValueIndicator;
+
+    // check to see if type is supported
+    if (!attr->typeInfo.oracleTypeNum) {
+        dpiError__set(&error, "get attribute value",
+                DPI_ERR_UNHANDLED_DATA_TYPE, attr->typeInfo.ociTypeCode);
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    }
+
+    // convert to output data format
+    status = dpiObject__fromOracleValue(obj, &error, &attr->typeInfo, &value,
+            (int16_t*) valueIndicator, nativeTypeNum, data);
+    return dpiGen__endPublicFn(obj, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_getElementExistsByIndex() [PUBLIC]
+//   Return boolean indicating if an element exists in the collection at the
+// specified index.
+//-----------------------------------------------------------------------------
+int dpiObject_getElementExistsByIndex(dpiObject *obj, int32_t index,
+        int *exists)
+{
+    dpiError error;
+    int status;
+
+    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(obj, exists)
+    status = dpiOci__tableExists(obj, index, exists, &error);
+    return dpiGen__endPublicFn(obj, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_getElementValueByIndex() [PUBLIC]
+//   Return the element at the given index in the collection.
+//-----------------------------------------------------------------------------
+int dpiObject_getElementValueByIndex(dpiObject *obj, int32_t index,
+        dpiNativeTypeNum nativeTypeNum, dpiData *data)
+{
+    dpiOracleData value;
+    int exists, status;
+    void *indicator;
+    dpiError error;
+
+    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(obj, data)
+    if (dpiOci__collGetElem(obj->type->conn, obj->instance, index, &exists,
+            &value.asRaw, &indicator, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    if (!exists) {
+        dpiError__set(&error, "get element value", DPI_ERR_INVALID_INDEX,
+                index);
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    }
+    status = dpiObject__fromOracleValue(obj, &error,
+            &obj->type->elementTypeInfo, &value, (int16_t*) indicator,
+            nativeTypeNum, data);
+    return dpiGen__endPublicFn(obj, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_getFirstIndex() [PUBLIC]
+//   Return the index of the first entry in the collection.
+//-----------------------------------------------------------------------------
+int dpiObject_getFirstIndex(dpiObject *obj, int32_t *index, int *exists)
+{
+    dpiError error;
+    int32_t size;
+    int status;
+
+    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(obj, index)
+    DPI_CHECK_PTR_NOT_NULL(obj, exists)
+    if (dpiOci__tableSize(obj, &size, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    *exists = (size != 0);
+    if (*exists)
+        status = dpiOci__tableFirst(obj, index, &error);
+    else status = DPI_SUCCESS;
+    return dpiGen__endPublicFn(obj, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_getLastIndex() [PUBLIC]
+//   Return the index of the last entry in the collection.
+//-----------------------------------------------------------------------------
+int dpiObject_getLastIndex(dpiObject *obj, int32_t *index, int *exists)
+{
+    dpiError error;
+    int32_t size;
+    int status;
+
+    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(obj, index)
+    DPI_CHECK_PTR_NOT_NULL(obj, exists)
+    if (dpiOci__tableSize(obj, &size, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    *exists = (size != 0);
+    if (*exists)
+        status = dpiOci__tableLast(obj, index, &error);
+    else status = DPI_SUCCESS;
+    return dpiGen__endPublicFn(obj, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_getNextIndex() [PUBLIC]
+//   Return the index of the next entry in the collection following the index
+// specified. If there is no next entry, exists is set to 0.
+//-----------------------------------------------------------------------------
+int dpiObject_getNextIndex(dpiObject *obj, int32_t index, int32_t *nextIndex,
+        int *exists)
+{
+    dpiError error;
+    int status;
+
+    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(obj, nextIndex)
+    DPI_CHECK_PTR_NOT_NULL(obj, exists)
+    status = dpiOci__tableNext(obj, index, nextIndex, exists, &error);
+    return dpiGen__endPublicFn(obj, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_getPrevIndex() [PUBLIC]
+//   Return the index of the previous entry in the collection preceding the
+// index specified. If there is no previous entry, exists is set to 0.
+//-----------------------------------------------------------------------------
+int dpiObject_getPrevIndex(dpiObject *obj, int32_t index, int32_t *prevIndex,
+        int *exists)
+{
+    dpiError error;
+    int status;
+
+    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(obj, prevIndex)
+    DPI_CHECK_PTR_NOT_NULL(obj, exists)
+    status = dpiOci__tablePrev(obj, index, prevIndex, exists, &error);
+    return dpiGen__endPublicFn(obj, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_getSize() [PUBLIC]
+//   Return the size of the collection.
+//-----------------------------------------------------------------------------
+int dpiObject_getSize(dpiObject *obj, int32_t *size)
+{
+    dpiError error;
+    int status;
+
+    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(obj, size)
+    status = dpiOci__collSize(obj->type->conn, obj->instance, size, &error);
+    return dpiGen__endPublicFn(obj, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_release() [PUBLIC]
+//   Release a reference to the object.
+//-----------------------------------------------------------------------------
+int dpiObject_release(dpiObject *obj)
+{
+    return dpiGen__release(obj, DPI_HTYPE_OBJECT, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_setAttributeValue() [PUBLIC]
+//   Create a copy of the object and return it. Return NULL upon error.
+//-----------------------------------------------------------------------------
+int dpiObject_setAttributeValue(dpiObject *obj, dpiObjectAttr *attr,
+        dpiNativeTypeNum nativeTypeNum, dpiData *data)
+{
+    void *valueIndicator, *ociValue;
+    dpiOracleDataBuffer valueBuffer;
+    int16_t scalarValueIndicator;
+    dpiLob *lob = NULL;
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiObject__check(obj, __func__, &error) < 0)
+        return DPI_FAILURE;
+    DPI_CHECK_PTR_NOT_NULL(obj, data)
+    if (dpiGen__checkHandle(attr, DPI_HTYPE_OBJECT_ATTR, "set attribute value",
+            &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    if (attr->belongsToType->tdo != obj->type->tdo) {
+        dpiError__set(&error, "set attribute value", DPI_ERR_WRONG_ATTR,
+                attr->nameLength, attr->name, obj->type->schemaLength,
+                obj->type->schema, obj->type->nameLength, obj->type->name);
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    }
+
+    // check to see if type is supported
+    if (!attr->typeInfo.oracleTypeNum) {
+        dpiError__set(&error, "get attribute value",
+                DPI_ERR_UNHANDLED_DATA_TYPE, attr->typeInfo.ociTypeCode);
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    }
+
+    // convert to input data format
+    status = dpiObject__toOracleValue(obj, &error, &attr->typeInfo,
+            &valueBuffer, &lob, &ociValue, &scalarValueIndicator,
+            &valueIndicator, nativeTypeNum, data);
+
+    // set attribute value
+    if (status == DPI_SUCCESS)
+        status = dpiOci__objectSetAttr(obj, attr, scalarValueIndicator,
+                valueIndicator, ociValue, &error);
+    dpiObject__clearOracleValue(obj, &error, &valueBuffer, lob,
+            attr->typeInfo.oracleTypeNum);
+    return dpiGen__endPublicFn(obj, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_setElementValueByIndex() [PUBLIC]
+//   Set the element at the specified index to the given value.
+//-----------------------------------------------------------------------------
+int dpiObject_setElementValueByIndex(dpiObject *obj, int32_t index,
+        dpiNativeTypeNum nativeTypeNum, dpiData *data)
+{
+    dpiOracleDataBuffer valueBuffer;
+    int16_t scalarValueIndicator;
+    dpiLob *lob = NULL;
+    void *indicator;
+    dpiError error;
+    void *ociValue;
+    int status;
+
+    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(obj, data)
+    status = dpiObject__toOracleValue(obj, &error, &obj->type->elementTypeInfo,
+            &valueBuffer, &lob, &ociValue, &scalarValueIndicator,
+            (void**) &indicator, nativeTypeNum, data);
+    if (status == DPI_SUCCESS) {
+        if (!indicator)
+            indicator = &scalarValueIndicator;
+        status = dpiOci__collAssignElem(obj->type->conn, index, ociValue,
+                indicator, obj->instance, &error);
+    }
+    dpiObject__clearOracleValue(obj, &error, &valueBuffer, lob,
+            obj->type->elementTypeInfo.oracleTypeNum);
+    return dpiGen__endPublicFn(obj, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObject_trim() [PUBLIC]
+//   Trim a number of elements from the end of the collection.
+//-----------------------------------------------------------------------------
+int dpiObject_trim(dpiObject *obj, uint32_t numToTrim)
+{
+    dpiError error;
+    int status;
+
+    if (dpiObject__checkIsCollection(obj, __func__, &error) < 0)
+        return dpiGen__endPublicFn(obj, DPI_FAILURE, &error);
+    status = dpiOci__collTrim(obj->type->conn, numToTrim, obj->instance,
+            &error);
+    return dpiGen__endPublicFn(obj, status, &error);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiObjectAttr.c ./odpi/src/dpiObjectAttr.c
--- patched-godror/odpi/src/dpiObjectAttr.c	2024-05-14 16:25:01
+++ ./odpi/src/dpiObjectAttr.c	1970-01-01 01:00:00
@@ -1,127 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiObjectAttr.c
-//   Implementation of object attributes.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiObjectAttr__allocate() [INTERNAL]
-//   Allocate and initialize an object attribute structure.
-//-----------------------------------------------------------------------------
-int dpiObjectAttr__allocate(dpiObjectType *objType, void *param,
-        dpiObjectAttr **attr, dpiError *error)
-{
-    dpiObjectAttr *tempAttr;
-
-    // allocate and assign main reference to the type this attribute belongs to
-    *attr = NULL;
-    if (dpiGen__allocate(DPI_HTYPE_OBJECT_ATTR, objType->env,
-            (void**) &tempAttr, error) < 0)
-        return DPI_FAILURE;
-    dpiGen__setRefCount(objType, error, 1);
-    tempAttr->belongsToType = objType;
-
-    // determine the name of the attribute
-    if (dpiUtils__getAttrStringWithDup("get name", param, DPI_OCI_DTYPE_PARAM,
-            DPI_OCI_ATTR_NAME, &tempAttr->name, &tempAttr->nameLength,
-            error) < 0) {
-        dpiObjectAttr__free(tempAttr, error);
-        return DPI_FAILURE;
-    }
-
-    // determine type information of the attribute
-    if (dpiOracleType__populateTypeInfo(objType->conn, param,
-            DPI_OCI_DTYPE_PARAM, &tempAttr->typeInfo, error) < 0) {
-        dpiObjectAttr__free(tempAttr, error);
-        return DPI_FAILURE;
-    }
-
-    *attr = tempAttr;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectAttr__free() [INTERNAL]
-//   Free the memory for an object attribute.
-//-----------------------------------------------------------------------------
-void dpiObjectAttr__free(dpiObjectAttr *attr, dpiError *error)
-{
-    if (attr->belongsToType) {
-        dpiGen__setRefCount(attr->belongsToType, error, -1);
-        attr->belongsToType = NULL;
-    }
-    if (attr->typeInfo.objectType) {
-        dpiGen__setRefCount(attr->typeInfo.objectType, error, -1);
-        attr->typeInfo.objectType = NULL;
-    }
-    if (attr->name) {
-        dpiUtils__freeMemory((void*) attr->name);
-        attr->name = NULL;
-    }
-    dpiUtils__freeMemory(attr);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectAttr_addRef() [PUBLIC]
-//   Add a reference to the object attribute.
-//-----------------------------------------------------------------------------
-int dpiObjectAttr_addRef(dpiObjectAttr *attr)
-{
-    return dpiGen__addRef(attr, DPI_HTYPE_OBJECT_ATTR, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectAttr_getInfo() [PUBLIC]
-//   Return information about the attribute to the caller.
-//-----------------------------------------------------------------------------
-int dpiObjectAttr_getInfo(dpiObjectAttr *attr, dpiObjectAttrInfo *info)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(attr, DPI_HTYPE_OBJECT_ATTR, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(attr, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(attr, info)
-    info->name = attr->name;
-    info->nameLength = attr->nameLength;
-    info->typeInfo = attr->typeInfo;
-    return dpiGen__endPublicFn(attr, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectAttr_release() [PUBLIC]
-//   Release a reference to the object attribute.
-//-----------------------------------------------------------------------------
-int dpiObjectAttr_release(dpiObjectAttr *attr)
-{
-    return dpiGen__release(attr, DPI_HTYPE_OBJECT_ATTR, __func__);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiObjectAttr.h ./odpi/src/dpiObjectAttr.h
--- patched-godror/odpi/src/dpiObjectAttr.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiObjectAttr.h	2024-05-14 14:55:13
@@ -0,0 +1,127 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiObjectAttr.c
+//   Implementation of object attributes.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiObjectAttr__allocate() [INTERNAL]
+//   Allocate and initialize an object attribute structure.
+//-----------------------------------------------------------------------------
+int dpiObjectAttr__allocate(dpiObjectType *objType, void *param,
+        dpiObjectAttr **attr, dpiError *error)
+{
+    dpiObjectAttr *tempAttr;
+
+    // allocate and assign main reference to the type this attribute belongs to
+    *attr = NULL;
+    if (dpiGen__allocate(DPI_HTYPE_OBJECT_ATTR, objType->env,
+            (void**) &tempAttr, error) < 0)
+        return DPI_FAILURE;
+    dpiGen__setRefCount(objType, error, 1);
+    tempAttr->belongsToType = objType;
+
+    // determine the name of the attribute
+    if (dpiUtils__getAttrStringWithDup("get name", param, DPI_OCI_DTYPE_PARAM,
+            DPI_OCI_ATTR_NAME, &tempAttr->name, &tempAttr->nameLength,
+            error) < 0) {
+        dpiObjectAttr__free(tempAttr, error);
+        return DPI_FAILURE;
+    }
+
+    // determine type information of the attribute
+    if (dpiOracleType__populateTypeInfo(objType->conn, param,
+            DPI_OCI_DTYPE_PARAM, &tempAttr->typeInfo, error) < 0) {
+        dpiObjectAttr__free(tempAttr, error);
+        return DPI_FAILURE;
+    }
+
+    *attr = tempAttr;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectAttr__free() [INTERNAL]
+//   Free the memory for an object attribute.
+//-----------------------------------------------------------------------------
+void dpiObjectAttr__free(dpiObjectAttr *attr, dpiError *error)
+{
+    if (attr->belongsToType) {
+        dpiGen__setRefCount(attr->belongsToType, error, -1);
+        attr->belongsToType = NULL;
+    }
+    if (attr->typeInfo.objectType) {
+        dpiGen__setRefCount(attr->typeInfo.objectType, error, -1);
+        attr->typeInfo.objectType = NULL;
+    }
+    if (attr->name) {
+        dpiUtils__freeMemory((void*) attr->name);
+        attr->name = NULL;
+    }
+    dpiUtils__freeMemory(attr);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectAttr_addRef() [PUBLIC]
+//   Add a reference to the object attribute.
+//-----------------------------------------------------------------------------
+int dpiObjectAttr_addRef(dpiObjectAttr *attr)
+{
+    return dpiGen__addRef(attr, DPI_HTYPE_OBJECT_ATTR, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectAttr_getInfo() [PUBLIC]
+//   Return information about the attribute to the caller.
+//-----------------------------------------------------------------------------
+int dpiObjectAttr_getInfo(dpiObjectAttr *attr, dpiObjectAttrInfo *info)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(attr, DPI_HTYPE_OBJECT_ATTR, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(attr, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(attr, info)
+    info->name = attr->name;
+    info->nameLength = attr->nameLength;
+    info->typeInfo = attr->typeInfo;
+    return dpiGen__endPublicFn(attr, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectAttr_release() [PUBLIC]
+//   Release a reference to the object attribute.
+//-----------------------------------------------------------------------------
+int dpiObjectAttr_release(dpiObjectAttr *attr)
+{
+    return dpiGen__release(attr, DPI_HTYPE_OBJECT_ATTR, __func__);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiObjectType.c ./odpi/src/dpiObjectType.c
--- patched-godror/odpi/src/dpiObjectType.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiObjectType.c	1970-01-01 01:00:00
@@ -1,371 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiObjectType.c
-//   Implementation of object types.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-// forward declarations of internal functions only used in this file
-static int dpiObjectType__init(dpiObjectType *objType, void *handle,
-        uint32_t handleType, dpiError *error);
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectType__allocate() [INTERNAL]
-//   Allocate and initialize an object type structure.
-//-----------------------------------------------------------------------------
-int dpiObjectType__allocate(dpiConn *conn, void *handle, uint32_t handleType,
-        dpiObjectType **objType, dpiError *error)
-{
-    dpiObjectType *tempObjType;
-
-    // create structure and retain reference to connection
-    *objType = NULL;
-    if (dpiGen__allocate(DPI_HTYPE_OBJECT_TYPE, conn->env,
-            (void**) &tempObjType, error) < 0)
-        return DPI_FAILURE;
-    dpiGen__setRefCount(conn, error, 1);
-    tempObjType->conn = conn;
-
-    // perform initialization
-    if (dpiObjectType__init(tempObjType, handle, handleType, error) < 0) {
-        dpiObjectType__free(tempObjType, error);
-        return DPI_FAILURE;
-    }
-
-    *objType = tempObjType;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectType__check() [INTERNAL]
-//   Validate that the connection from which the object type was created is
-// still connected and issue an error if it is not.
-//-----------------------------------------------------------------------------
-static int dpiObjectType__check(dpiObjectType *objType, const char *fnName,
-        dpiError *error)
-{
-    if (dpiGen__startPublicFn(objType, DPI_HTYPE_OBJECT_TYPE, fnName,
-            error) < 0)
-        return DPI_FAILURE;
-    return dpiConn__checkConnected(objType->conn, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectType__describe() [INTERNAL]
-//   Describe the object type and store information about it. Note that a
-// separate call to OCIDescribeAny() is made in order to support nested types;
-// an illegal attribute value is returned if this is not done.
-//-----------------------------------------------------------------------------
-static int dpiObjectType__describe(dpiObjectType *objType,
-        void *describeHandle, dpiError *error)
-{
-    void *collectionParam, *param;
-    uint16_t typeCode;
-
-    // describe the type
-    if (dpiOci__describeAny(objType->conn, objType->tdo, 0, DPI_OCI_OTYPE_PTR,
-            describeHandle, error) < 0)
-        return DPI_FAILURE;
-
-    // get top level parameter descriptor
-    if (dpiOci__attrGet(describeHandle, DPI_OCI_HTYPE_DESCRIBE, &param, 0,
-            DPI_OCI_ATTR_PARAM, "get top level parameter", error) < 0)
-        return DPI_FAILURE;
-
-    // determine type code
-    if (dpiOci__attrGet(param, DPI_OCI_DTYPE_PARAM, &typeCode, 0,
-            DPI_OCI_ATTR_TYPECODE, "get type code", error) < 0)
-        return DPI_FAILURE;
-    objType->typeCode = typeCode;
-
-    // determine the schema of the type
-    if (dpiUtils__getAttrStringWithDup("get schema", param,
-            DPI_OCI_DTYPE_PARAM, DPI_OCI_ATTR_SCHEMA_NAME, &objType->schema,
-            &objType->schemaLength, error) < 0)
-        return DPI_FAILURE;
-
-    // determine the name of the type
-    if (dpiUtils__getAttrStringWithDup("get name", param, DPI_OCI_DTYPE_PARAM,
-            DPI_OCI_ATTR_NAME, &objType->name, &objType->nameLength,
-            error) < 0)
-        return DPI_FAILURE;
-
-    // determine the package name of the type
-    if (dpiUtils__getAttrStringWithDup("get package name", param,
-            DPI_OCI_DTYPE_PARAM, DPI_OCI_ATTR_PACKAGE_NAME,
-            &objType->packageName, &objType->packageNameLength, error) < 0)
-        return DPI_FAILURE;
-
-    // determine the number of attributes
-    if (dpiOci__attrGet(param, DPI_OCI_DTYPE_PARAM,
-            (void*) &objType->numAttributes, 0, DPI_OCI_ATTR_NUM_TYPE_ATTRS,
-            "get number of attributes", error) < 0)
-        return DPI_FAILURE;
-
-    // if a collection, need to determine the element type
-    if (typeCode == DPI_SQLT_NCO) {
-        objType->isCollection = 1;
-
-        // acquire collection parameter descriptor
-        if (dpiOci__attrGet(param, DPI_OCI_DTYPE_PARAM, &collectionParam, 0,
-                DPI_OCI_ATTR_COLLECTION_ELEMENT, "get collection descriptor",
-                error) < 0)
-            return DPI_FAILURE;
-
-        // determine type of element
-        if (dpiOracleType__populateTypeInfo(objType->conn, collectionParam,
-                DPI_OCI_DTYPE_PARAM, &objType->elementTypeInfo, error) < 0)
-            return DPI_FAILURE;
-
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectType__free() [INTERNAL]
-//   Free the memory for an object type.
-//-----------------------------------------------------------------------------
-void dpiObjectType__free(dpiObjectType *objType, dpiError *error)
-{
-    if (objType->conn) {
-        dpiGen__setRefCount(objType->conn, error, -1);
-        objType->conn = NULL;
-    }
-    if (objType->elementTypeInfo.objectType) {
-        dpiGen__setRefCount(objType->elementTypeInfo.objectType, error, -1);
-        objType->elementTypeInfo.objectType = NULL;
-    }
-    if (objType->schema) {
-        dpiUtils__freeMemory((void*) objType->schema);
-        objType->schema = NULL;
-    }
-    if (objType->name) {
-        dpiUtils__freeMemory((void*) objType->name);
-        objType->name = NULL;
-    }
-    if (objType->packageName) {
-        dpiUtils__freeMemory((void*) objType->packageName);
-        objType->packageName = NULL;
-    }
-    dpiUtils__freeMemory(objType);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectType__init() [INTERNAL]
-//   Initialize the object type.
-//-----------------------------------------------------------------------------
-static int dpiObjectType__init(dpiObjectType *objType, void *handle,
-        uint32_t handleType, dpiError *error)
-{
-    void *describeHandle, *tdoReference;
-
-    // retrieve TDO of the parameter and pin it in the cache
-    if (dpiOci__attrGet(handle, handleType, (void*) &tdoReference, 0,
-            DPI_OCI_ATTR_REF_TDO, "get TDO reference", error) < 0)
-        return DPI_FAILURE;
-    if (dpiOci__objectPin(objType->env->handle, tdoReference, &objType->tdo,
-            error) < 0)
-        return DPI_FAILURE;
-
-    // acquire a describe handle
-    if (dpiOci__handleAlloc(objType->env->handle, &describeHandle,
-            DPI_OCI_HTYPE_DESCRIBE, "allocate describe handle", error) < 0)
-        return DPI_FAILURE;
-
-    // describe the type
-    if (dpiObjectType__describe(objType, describeHandle, error) < 0) {
-        dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
-        return DPI_FAILURE;
-    }
-
-    // free the describe handle
-    dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectType__isXmlType() [INTERNAL]
-//   Returns a boolean indicating if the object type in question refers to the
-// type SYS.XMLTYPE.
-//-----------------------------------------------------------------------------
-int dpiObjectType__isXmlType(dpiObjectType *objType)
-{
-    static const char *schema = "SYS", *name = "XMLTYPE";
-    size_t schemaLength, nameLength;
-
-    schemaLength = strlen(schema);
-    nameLength = strlen(name);
-    return (objType->schemaLength == schemaLength &&
-            strncmp(objType->schema, schema, schemaLength) == 0 &&
-            objType->nameLength == nameLength &&
-            strncmp(objType->name, name, nameLength) == 0);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectType_addRef() [PUBLIC]
-//   Add a reference to the object type.
-//-----------------------------------------------------------------------------
-int dpiObjectType_addRef(dpiObjectType *objType)
-{
-    return dpiGen__addRef(objType, DPI_HTYPE_OBJECT_TYPE, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectType_createObject() [PUBLIC]
-//   Create a new object of the specified type and return it. Return NULL on
-// error.
-//-----------------------------------------------------------------------------
-int dpiObjectType_createObject(dpiObjectType *objType, dpiObject **obj)
-{
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiObjectType__check(objType, __func__, &error) < 0)
-        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(objType, obj)
-    status = dpiObject__allocate(objType, NULL, NULL, NULL, obj, &error);
-    return dpiGen__endPublicFn(objType, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectType_getAttributes() [PUBLIC]
-//   Get the attributes for the object type in the provided array.
-//-----------------------------------------------------------------------------
-int dpiObjectType_getAttributes(dpiObjectType *objType, uint16_t numAttributes,
-        dpiObjectAttr **attributes)
-{
-    void *topLevelParam, *attrListParam, *attrParam, *describeHandle;
-    dpiError error;
-    uint16_t i;
-
-    // validate object type and the number of attributes
-    if (dpiObjectType__check(objType, __func__, &error) < 0)
-        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(objType, attributes)
-    if (numAttributes < objType->numAttributes) {
-        dpiError__set(&error, "get attributes", DPI_ERR_ARRAY_SIZE_TOO_SMALL,
-                numAttributes);
-        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
-    }
-    if (numAttributes == 0)
-        return dpiGen__endPublicFn(objType, DPI_SUCCESS, &error);
-
-    // acquire a describe handle
-    if (dpiOci__handleAlloc(objType->env->handle, &describeHandle,
-            DPI_OCI_HTYPE_DESCRIBE, "allocate describe handle", &error) < 0)
-        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
-
-    // describe the type
-    if (dpiOci__describeAny(objType->conn, objType->tdo, 0, DPI_OCI_OTYPE_PTR,
-            describeHandle, &error) < 0) {
-        dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
-        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
-    }
-
-    // get the top level parameter descriptor
-    if (dpiOci__attrGet(describeHandle, DPI_OCI_HTYPE_DESCRIBE, &topLevelParam,
-            0, DPI_OCI_ATTR_PARAM, "get top level param", &error) < 0) {
-        dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
-        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
-    }
-
-    // get the attribute list parameter descriptor
-    if (dpiOci__attrGet(topLevelParam, DPI_OCI_DTYPE_PARAM,
-            (void*) &attrListParam, 0, DPI_OCI_ATTR_LIST_TYPE_ATTRS,
-            "get attr list param", &error) < 0) {
-        dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
-        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
-    }
-
-    // create attribute structure for each attribute
-    for (i = 0; i < objType->numAttributes; i++) {
-        if (dpiOci__paramGet(attrListParam, DPI_OCI_DTYPE_PARAM, &attrParam,
-                (uint32_t) i + 1, "get attribute param", &error) < 0) {
-            dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
-            return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
-        }
-        if (dpiObjectAttr__allocate(objType, attrParam, &attributes[i],
-                &error) < 0) {
-            dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
-            return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
-        }
-    }
-
-    // free the describe handle
-    dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
-
-    return dpiGen__endPublicFn(objType, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectType_getInfo() [PUBLIC]
-//   Return information about the object type.
-//-----------------------------------------------------------------------------
-int dpiObjectType_getInfo(dpiObjectType *objType, dpiObjectTypeInfo *info)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(objType, DPI_HTYPE_OBJECT_TYPE, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(objType, info)
-    info->name = objType->name;
-    info->nameLength = objType->nameLength;
-    if (objType->env->context->dpiMinorVersion > 5) {
-        info->packageName = objType->packageName;
-        info->packageNameLength = objType->packageNameLength;
-    }
-    info->schema = objType->schema;
-    info->schemaLength = objType->schemaLength;
-    info->isCollection = objType->isCollection;
-    info->elementTypeInfo = objType->elementTypeInfo;
-    info->numAttributes = objType->numAttributes;
-    return dpiGen__endPublicFn(objType, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiObjectType_release() [PUBLIC]
-//   Release a reference to the object type.
-//-----------------------------------------------------------------------------
-int dpiObjectType_release(dpiObjectType *objType)
-{
-    return dpiGen__release(objType, DPI_HTYPE_OBJECT_TYPE, __func__);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiObjectType.h ./odpi/src/dpiObjectType.h
--- patched-godror/odpi/src/dpiObjectType.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiObjectType.h	2024-05-14 14:55:13
@@ -0,0 +1,371 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiObjectType.c
+//   Implementation of object types.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+// forward declarations of internal functions only used in this file
+static int dpiObjectType__init(dpiObjectType *objType, void *handle,
+        uint32_t handleType, dpiError *error);
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectType__allocate() [INTERNAL]
+//   Allocate and initialize an object type structure.
+//-----------------------------------------------------------------------------
+int dpiObjectType__allocate(dpiConn *conn, void *handle, uint32_t handleType,
+        dpiObjectType **objType, dpiError *error)
+{
+    dpiObjectType *tempObjType;
+
+    // create structure and retain reference to connection
+    *objType = NULL;
+    if (dpiGen__allocate(DPI_HTYPE_OBJECT_TYPE, conn->env,
+            (void**) &tempObjType, error) < 0)
+        return DPI_FAILURE;
+    dpiGen__setRefCount(conn, error, 1);
+    tempObjType->conn = conn;
+
+    // perform initialization
+    if (dpiObjectType__init(tempObjType, handle, handleType, error) < 0) {
+        dpiObjectType__free(tempObjType, error);
+        return DPI_FAILURE;
+    }
+
+    *objType = tempObjType;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectType__check() [INTERNAL]
+//   Validate that the connection from which the object type was created is
+// still connected and issue an error if it is not.
+//-----------------------------------------------------------------------------
+static int dpiObjectType__check(dpiObjectType *objType, const char *fnName,
+        dpiError *error)
+{
+    if (dpiGen__startPublicFn(objType, DPI_HTYPE_OBJECT_TYPE, fnName,
+            error) < 0)
+        return DPI_FAILURE;
+    return dpiConn__checkConnected(objType->conn, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectType__describe() [INTERNAL]
+//   Describe the object type and store information about it. Note that a
+// separate call to OCIDescribeAny() is made in order to support nested types;
+// an illegal attribute value is returned if this is not done.
+//-----------------------------------------------------------------------------
+static int dpiObjectType__describe(dpiObjectType *objType,
+        void *describeHandle, dpiError *error)
+{
+    void *collectionParam, *param;
+    uint16_t typeCode;
+
+    // describe the type
+    if (dpiOci__describeAny(objType->conn, objType->tdo, 0, DPI_OCI_OTYPE_PTR,
+            describeHandle, error) < 0)
+        return DPI_FAILURE;
+
+    // get top level parameter descriptor
+    if (dpiOci__attrGet(describeHandle, DPI_OCI_HTYPE_DESCRIBE, &param, 0,
+            DPI_OCI_ATTR_PARAM, "get top level parameter", error) < 0)
+        return DPI_FAILURE;
+
+    // determine type code
+    if (dpiOci__attrGet(param, DPI_OCI_DTYPE_PARAM, &typeCode, 0,
+            DPI_OCI_ATTR_TYPECODE, "get type code", error) < 0)
+        return DPI_FAILURE;
+    objType->typeCode = typeCode;
+
+    // determine the schema of the type
+    if (dpiUtils__getAttrStringWithDup("get schema", param,
+            DPI_OCI_DTYPE_PARAM, DPI_OCI_ATTR_SCHEMA_NAME, &objType->schema,
+            &objType->schemaLength, error) < 0)
+        return DPI_FAILURE;
+
+    // determine the name of the type
+    if (dpiUtils__getAttrStringWithDup("get name", param, DPI_OCI_DTYPE_PARAM,
+            DPI_OCI_ATTR_NAME, &objType->name, &objType->nameLength,
+            error) < 0)
+        return DPI_FAILURE;
+
+    // determine the package name of the type
+    if (dpiUtils__getAttrStringWithDup("get package name", param,
+            DPI_OCI_DTYPE_PARAM, DPI_OCI_ATTR_PACKAGE_NAME,
+            &objType->packageName, &objType->packageNameLength, error) < 0)
+        return DPI_FAILURE;
+
+    // determine the number of attributes
+    if (dpiOci__attrGet(param, DPI_OCI_DTYPE_PARAM,
+            (void*) &objType->numAttributes, 0, DPI_OCI_ATTR_NUM_TYPE_ATTRS,
+            "get number of attributes", error) < 0)
+        return DPI_FAILURE;
+
+    // if a collection, need to determine the element type
+    if (typeCode == DPI_SQLT_NCO) {
+        objType->isCollection = 1;
+
+        // acquire collection parameter descriptor
+        if (dpiOci__attrGet(param, DPI_OCI_DTYPE_PARAM, &collectionParam, 0,
+                DPI_OCI_ATTR_COLLECTION_ELEMENT, "get collection descriptor",
+                error) < 0)
+            return DPI_FAILURE;
+
+        // determine type of element
+        if (dpiOracleType__populateTypeInfo(objType->conn, collectionParam,
+                DPI_OCI_DTYPE_PARAM, &objType->elementTypeInfo, error) < 0)
+            return DPI_FAILURE;
+
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectType__free() [INTERNAL]
+//   Free the memory for an object type.
+//-----------------------------------------------------------------------------
+void dpiObjectType__free(dpiObjectType *objType, dpiError *error)
+{
+    if (objType->conn) {
+        dpiGen__setRefCount(objType->conn, error, -1);
+        objType->conn = NULL;
+    }
+    if (objType->elementTypeInfo.objectType) {
+        dpiGen__setRefCount(objType->elementTypeInfo.objectType, error, -1);
+        objType->elementTypeInfo.objectType = NULL;
+    }
+    if (objType->schema) {
+        dpiUtils__freeMemory((void*) objType->schema);
+        objType->schema = NULL;
+    }
+    if (objType->name) {
+        dpiUtils__freeMemory((void*) objType->name);
+        objType->name = NULL;
+    }
+    if (objType->packageName) {
+        dpiUtils__freeMemory((void*) objType->packageName);
+        objType->packageName = NULL;
+    }
+    dpiUtils__freeMemory(objType);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectType__init() [INTERNAL]
+//   Initialize the object type.
+//-----------------------------------------------------------------------------
+static int dpiObjectType__init(dpiObjectType *objType, void *handle,
+        uint32_t handleType, dpiError *error)
+{
+    void *describeHandle, *tdoReference;
+
+    // retrieve TDO of the parameter and pin it in the cache
+    if (dpiOci__attrGet(handle, handleType, (void*) &tdoReference, 0,
+            DPI_OCI_ATTR_REF_TDO, "get TDO reference", error) < 0)
+        return DPI_FAILURE;
+    if (dpiOci__objectPin(objType->env->handle, tdoReference, &objType->tdo,
+            error) < 0)
+        return DPI_FAILURE;
+
+    // acquire a describe handle
+    if (dpiOci__handleAlloc(objType->env->handle, &describeHandle,
+            DPI_OCI_HTYPE_DESCRIBE, "allocate describe handle", error) < 0)
+        return DPI_FAILURE;
+
+    // describe the type
+    if (dpiObjectType__describe(objType, describeHandle, error) < 0) {
+        dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
+        return DPI_FAILURE;
+    }
+
+    // free the describe handle
+    dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectType__isXmlType() [INTERNAL]
+//   Returns a boolean indicating if the object type in question refers to the
+// type SYS.XMLTYPE.
+//-----------------------------------------------------------------------------
+int dpiObjectType__isXmlType(dpiObjectType *objType)
+{
+    static const char *schema = "SYS", *name = "XMLTYPE";
+    size_t schemaLength, nameLength;
+
+    schemaLength = strlen(schema);
+    nameLength = strlen(name);
+    return (objType->schemaLength == schemaLength &&
+            strncmp(objType->schema, schema, schemaLength) == 0 &&
+            objType->nameLength == nameLength &&
+            strncmp(objType->name, name, nameLength) == 0);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectType_addRef() [PUBLIC]
+//   Add a reference to the object type.
+//-----------------------------------------------------------------------------
+int dpiObjectType_addRef(dpiObjectType *objType)
+{
+    return dpiGen__addRef(objType, DPI_HTYPE_OBJECT_TYPE, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectType_createObject() [PUBLIC]
+//   Create a new object of the specified type and return it. Return NULL on
+// error.
+//-----------------------------------------------------------------------------
+int dpiObjectType_createObject(dpiObjectType *objType, dpiObject **obj)
+{
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiObjectType__check(objType, __func__, &error) < 0)
+        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(objType, obj)
+    status = dpiObject__allocate(objType, NULL, NULL, NULL, obj, &error);
+    return dpiGen__endPublicFn(objType, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectType_getAttributes() [PUBLIC]
+//   Get the attributes for the object type in the provided array.
+//-----------------------------------------------------------------------------
+int dpiObjectType_getAttributes(dpiObjectType *objType, uint16_t numAttributes,
+        dpiObjectAttr **attributes)
+{
+    void *topLevelParam, *attrListParam, *attrParam, *describeHandle;
+    dpiError error;
+    uint16_t i;
+
+    // validate object type and the number of attributes
+    if (dpiObjectType__check(objType, __func__, &error) < 0)
+        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(objType, attributes)
+    if (numAttributes < objType->numAttributes) {
+        dpiError__set(&error, "get attributes", DPI_ERR_ARRAY_SIZE_TOO_SMALL,
+                numAttributes);
+        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
+    }
+    if (numAttributes == 0)
+        return dpiGen__endPublicFn(objType, DPI_SUCCESS, &error);
+
+    // acquire a describe handle
+    if (dpiOci__handleAlloc(objType->env->handle, &describeHandle,
+            DPI_OCI_HTYPE_DESCRIBE, "allocate describe handle", &error) < 0)
+        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
+
+    // describe the type
+    if (dpiOci__describeAny(objType->conn, objType->tdo, 0, DPI_OCI_OTYPE_PTR,
+            describeHandle, &error) < 0) {
+        dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
+        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
+    }
+
+    // get the top level parameter descriptor
+    if (dpiOci__attrGet(describeHandle, DPI_OCI_HTYPE_DESCRIBE, &topLevelParam,
+            0, DPI_OCI_ATTR_PARAM, "get top level param", &error) < 0) {
+        dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
+        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
+    }
+
+    // get the attribute list parameter descriptor
+    if (dpiOci__attrGet(topLevelParam, DPI_OCI_DTYPE_PARAM,
+            (void*) &attrListParam, 0, DPI_OCI_ATTR_LIST_TYPE_ATTRS,
+            "get attr list param", &error) < 0) {
+        dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
+        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
+    }
+
+    // create attribute structure for each attribute
+    for (i = 0; i < objType->numAttributes; i++) {
+        if (dpiOci__paramGet(attrListParam, DPI_OCI_DTYPE_PARAM, &attrParam,
+                (uint32_t) i + 1, "get attribute param", &error) < 0) {
+            dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
+            return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
+        }
+        if (dpiObjectAttr__allocate(objType, attrParam, &attributes[i],
+                &error) < 0) {
+            dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
+            return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
+        }
+    }
+
+    // free the describe handle
+    dpiOci__handleFree(describeHandle, DPI_OCI_HTYPE_DESCRIBE);
+
+    return dpiGen__endPublicFn(objType, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectType_getInfo() [PUBLIC]
+//   Return information about the object type.
+//-----------------------------------------------------------------------------
+int dpiObjectType_getInfo(dpiObjectType *objType, dpiObjectTypeInfo *info)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(objType, DPI_HTYPE_OBJECT_TYPE, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(objType, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(objType, info)
+    info->name = objType->name;
+    info->nameLength = objType->nameLength;
+    if (objType->env->context->dpiMinorVersion > 5) {
+        info->packageName = objType->packageName;
+        info->packageNameLength = objType->packageNameLength;
+    }
+    info->schema = objType->schema;
+    info->schemaLength = objType->schemaLength;
+    info->isCollection = objType->isCollection;
+    info->elementTypeInfo = objType->elementTypeInfo;
+    info->numAttributes = objType->numAttributes;
+    return dpiGen__endPublicFn(objType, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiObjectType_release() [PUBLIC]
+//   Release a reference to the object type.
+//-----------------------------------------------------------------------------
+int dpiObjectType_release(dpiObjectType *objType)
+{
+    return dpiGen__release(objType, DPI_HTYPE_OBJECT_TYPE, __func__);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiOci.c ./odpi/src/dpiOci.c
--- patched-godror/odpi/src/dpiOci.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiOci.c	1970-01-01 01:00:00
@@ -1,4311 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2017, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiOci.c
-//   Link to OCI using dynamic linking. The OCI library (11.2+) is loaded
-// dynamically and a function table kept for the functions that are used by
-// DPI. This function table is populated as functions are used and permits use
-// of all versions of OCI from one driver.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-// define structure used for loading the OCI library
-typedef struct {
-    void *handle;
-    char *nameBuffer;
-    size_t nameBufferLength;
-    char *moduleNameBuffer;
-    size_t moduleNameBufferLength;
-    char *loadError;
-    size_t loadErrorLength;
-    char *errorBuffer;
-    size_t errorBufferLength;
-} dpiOciLoadLibParams;
-
-
-// forward declarations of internal functions only used in this file
-static void *dpiOci__allocateMem(void *unused, size_t size);
-static void dpiOci__freeMem(void *unused, void *ptr);
-static int dpiOci__loadLibValidate(dpiVersionInfo *versionInfo,
-        dpiError *error);
-static int dpiOci__loadLibWithDir(dpiOciLoadLibParams *loadParams,
-        const char *dirName, size_t dirNameLength, int scanAllNames,
-        dpiError *error);
-static int dpiOci__loadLibWithName(dpiOciLoadLibParams *loadParams,
-        const char *libName, dpiError *error);
-static int dpiOci__loadSymbol(const char *symbolName, void **symbol,
-        dpiError *error);
-static void *dpiOci__reallocMem(void *unused, void *ptr, size_t newSize);
-
-
-// macro to simplify code for loading each symbol
-#define DPI_OCI_LOAD_SYMBOL(symbolName, symbol) \
-    if (!symbol && dpiOci__loadSymbol(symbolName, (void**) &symbol, \
-            error) < 0) \
-        return DPI_FAILURE;
-
-// macro to ensure that an error handle is available
-#define DPI_OCI_ENSURE_ERROR_HANDLE(error) \
-    if (!error->handle && dpiError__initHandle(error) < 0) \
-        return DPI_FAILURE;
-
-// macros to simplify code for checking results of OCI calls
-#define DPI_OCI_ERROR_OCCURRED(status) \
-    (status != DPI_OCI_SUCCESS && status != DPI_OCI_SUCCESS_WITH_INFO)
-#define DPI_OCI_CHECK_AND_RETURN(error, status, conn, action) \
-    if (status != DPI_OCI_SUCCESS) \
-        return dpiError__setFromOCI(error, status, conn, action); \
-    return DPI_SUCCESS;
-
-
-// typedefs for all OCI functions used by ODPI-C
-typedef int (*dpiOciFnType__aqDeq)(void *svchp, void *errhp,
-        const char *queue_name, void *deqopt, void *msgprop, void *payload_tdo,
-        void **payload, void **payload_ind, void **msgid, uint32_t flags);
-typedef int (*dpiOciFnType__aqDeqArray)(void *svchp, void *errhp,
-        const char *queue_name, void *deqopt, uint32_t *iters, void **msgprop,
-        void *payload_tdo, void **payload, void **payload_ind, void **msgid,
-        void *ctxp, void *deqcbfp, uint32_t flags);
-typedef int (*dpiOciFnType__aqEnq)(void *svchp, void *errhp,
-        const char *queue_name, void *enqopt, void *msgprop, void *payload_tdo,
-        void **payload, void **payload_ind, void **msgid, uint32_t flags);
-typedef int (*dpiOciFnType__aqEnqArray)(void *svchp, void *errhp,
-        const char *queue_name, void *enqopt, uint32_t *iters, void **msgprop,
-        void *payload_tdo, void **payload, void **payload_ind, void **msgid,
-        void *ctxp, void *enqcbfp, uint32_t flags);
-typedef int (*dpiOciFnType__arrayDescriptorAlloc)(const void *parenth,
-        void **descpp, const uint32_t type, uint32_t array_size,
-        const size_t xtramem_sz, void **usrmempp);
-typedef int (*dpiOciFnType__arrayDescriptorFree)(void **descp,
-        const uint32_t type);
-typedef int (*dpiOciFnType__attrGet)(const void  *trgthndlp,
-        uint32_t trghndltyp, void *attributep, uint32_t *sizep,
-        uint32_t attrtype, void *errhp);
-typedef int (*dpiOciFnType__attrSet)(void *trgthndlp, uint32_t trghndltyp,
-        void *attributep, uint32_t size, uint32_t attrtype, void *errhp);
-typedef int (*dpiOciFnType__bindByName)(void *stmtp, void **bindp, void *errhp,
-        const char *placeholder, int32_t placeh_len, void *valuep,
-        int32_t value_sz, uint16_t dty, void *indp, uint16_t *alenp,
-        uint16_t *rcodep, uint32_t maxarr_len, uint32_t *curelep,
-        uint32_t mode);
-typedef int (*dpiOciFnType__bindByName2)(void *stmtp, void **bindp,
-        void *errhp, const char *placeholder, int32_t placeh_len, void *valuep,
-        int64_t value_sz, uint16_t dty, void *indp, uint32_t *alenp,
-        uint16_t *rcodep, uint32_t maxarr_len, uint32_t *curelep,
-        uint32_t mode);
-typedef int (*dpiOciFnType__bindByPos)(void *stmtp, void **bindp, void *errhp,
-        uint32_t position, void *valuep, int32_t value_sz, uint16_t dty,
-        void *indp, uint16_t *alenp, uint16_t *rcodep, uint32_t maxarr_len,
-        uint32_t *curelep, uint32_t mode);
-typedef int (*dpiOciFnType__bindByPos2)(void *stmtp, void **bindp, void *errhp,
-        uint32_t position, void *valuep, int64_t value_sz, uint16_t dty,
-        void *indp, uint32_t *alenp, uint16_t *rcodep, uint32_t maxarr_len,
-        uint32_t *curelep, uint32_t mode);
-typedef int (*dpiOciFnType__bindDynamic)(void *bindp, void *errhp, void *ictxp,
-        void *icbfp, void *octxp, void *ocbfp);
-typedef int (*dpiOciFnType__bindObject)(void *bindp, void *errhp,
-        const void *type, void **pgvpp, uint32_t *pvszsp, void **indpp,
-        uint32_t *indszp);
-typedef int (*dpiOciFnType__break)(void *hndlp, void *errhp);
-typedef void (*dpiOciFnType__clientVersion)(int *major_version,
-        int *minor_version, int *update_num, int *patch_num,
-        int *port_update_num);
-typedef int (*dpiOciFnType__collAppend)(void *env, void *err, const void *elem,
-        const void *elemind, void *coll);
-typedef int (*dpiOciFnType__collAssignElem)(void *env, void *err,
-        int32_t index, const void *elem, const void *elemind, void *coll);
-typedef int (*dpiOciFnType__collGetElem)(void *env, void *err,
-        const void *coll, int32_t index, int *exists, void **elem,
-        void **elemind);
-typedef int (*dpiOciFnType__collSize)(void *env, void *err, const void *coll,
-        int32_t *size);
-typedef int (*dpiOciFnType__collTrim)(void *env, void *err, int32_t trim_num,
-        void *coll);
-typedef int (*dpiOciFnType__contextGetValue)(void *hdl, void *err,
-        const char *key, uint8_t keylen, void **ctx_value);
-typedef int (*dpiOciFnType__contextSetValue)(void *hdl, void *err,
-        uint16_t duration, const char *key, uint8_t keylen, void *ctx_value);
-typedef int (*dpiOciFnType__dateTimeConstruct)(void *hndl, void *err,
-        void *datetime, int16_t yr, uint8_t mnth, uint8_t dy, uint8_t hr,
-        uint8_t mm, uint8_t ss, uint32_t fsec, const char *tz,
-        size_t tzLength);
-typedef int (*dpiOciFnType__dateTimeConvert)(void *hndl, void *err,
-        void *indate, void *outdate);
-typedef int (*dpiOciFnType__dateTimeGetDate)(void *hndl, void *err,
-        const void *date, int16_t *yr, uint8_t *mnth, uint8_t *dy);
-typedef int (*dpiOciFnType__dateTimeGetTime)(void *hndl, void *err,
-        void *datetime, uint8_t *hr, uint8_t *mm, uint8_t *ss, uint32_t *fsec);
-typedef int (*dpiOciFnType__dateTimeGetTimeZoneOffset)(void *hndl, void *err,
-        const void *datetime, int8_t *hr, int8_t *mm);
-typedef int (*dpiOciFnType__dateTimeIntervalAdd)(void *hndl, void *err,
-        void *datetime, void *inter, void *outdatetime);
-typedef int (*dpiOciFnType__dateTimeSubtract)(void *hndl, void *err,
-        void *indate1, void *indate2, void *inter);
-typedef int (*dpiOciFnType__dbShutdown)(void *svchp, void *errhp, void *admhp,
-        uint32_t mode);
-typedef int (*dpiOciFnType__dbStartup)(void *svchp, void *errhp, void *admhp,
-        uint32_t mode, uint32_t flags);
-typedef int (*dpiOciFnType__defineByPos)(void *stmtp, void **defnp,
-        void *errhp, uint32_t position, void *valuep, int32_t value_sz,
-        uint16_t dty, void *indp, uint16_t *rlenp, uint16_t *rcodep,
-        uint32_t mode);
-typedef int (*dpiOciFnType__defineByPos2)(void *stmtp, void **defnp,
-        void *errhp, uint32_t position, void *valuep, uint64_t value_sz,
-        uint16_t dty, void *indp, uint32_t *rlenp, uint16_t *rcodep,
-        uint32_t mode);
-typedef int (*dpiOciFnType__defineDynamic)(void *defnp, void *errhp,
-        void *octxp, void *ocbfp);
-typedef int (*dpiOciFnType__defineObject)(void *defnp, void *errhp,
-        const void *type, void **pgvpp, uint32_t *pvszsp, void **indpp,
-        uint32_t *indszp);
-typedef int (*dpiOciFnType__describeAny)(void *svchp, void *errhp,
-        void *objptr, uint32_t objnm_len, uint8_t objptr_typ,
-        uint8_t info_level, uint8_t objtyp, void *dschp);
-typedef int (*dpiOciFnType__descriptorAlloc)(const void *parenth,
-        void **descpp, const uint32_t type, const size_t xtramem_sz,
-        void **usrmempp);
-typedef int (*dpiOciFnType__descriptorFree)(void *descp, const uint32_t type);
-typedef int (*dpiOciFnType__envNlsCreate)(void **envp, uint32_t mode,
-        void *ctxp, void *malocfp, void *ralocfp, void *mfreefp,
-        size_t xtramem_sz, void **usrmempp, uint16_t charset,
-        uint16_t ncharset);
-typedef int (*dpiOciFnType__errorGet)(void *hndlp, uint32_t recordno,
-        char *sqlstate, int32_t *errcodep, char *bufp, uint32_t bufsiz,
-        uint32_t type);
-typedef int (*dpiOciFnType__handleAlloc)(const void *parenth, void **hndlpp,
-        const uint32_t type, const size_t xtramem_sz, void **usrmempp);
-typedef int (*dpiOciFnType__handleFree)(void *hndlp, const uint32_t type);
-typedef int (*dpiOciFnType__intervalGetDaySecond)(void *hndl, void *err,
-        int32_t *dy, int32_t *hr, int32_t *mm, int32_t *ss, int32_t *fsec,
-        const void *result);
-typedef int (*dpiOciFnType__intervalGetYearMonth)(void *hndl, void *err,
-        int32_t *yr, int32_t *mnth, const void *result);
-typedef int (*dpiOciFnType__intervalSetDaySecond)(void *hndl, void *err,
-        int32_t dy, int32_t hr, int32_t mm, int32_t ss, int32_t fsec,
-        void *result);
-typedef int (*dpiOciFnType__intervalSetYearMonth)(void *hndl, void *err,
-        int32_t yr, int32_t mnth, void *result);
-typedef int (*dpiOciFnType__jsonDomDocGet)(void *svchp, void *jsond,
-        dpiJznDomDoc **jDomDoc, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__jsonTextBufferParse)(void *hndlp, void *jsond,
-        void *bufp, uint64_t buf_sz, uint32_t validation, uint16_t encoding,
-        void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__lobClose)(void *svchp, void *errhp, void *locp);
-typedef int (*dpiOciFnType__lobCreateTemporary)(void *svchp, void *errhp,
-        void *locp, uint16_t csid, uint8_t csfrm, uint8_t lobtype, int cache,
-        uint16_t duration);
-typedef int (*dpiOciFnType__lobFileExists)(void *svchp, void *errhp,
-        void *filep, int *flag);
-typedef int (*dpiOciFnType__lobFileGetName)(void *envhp, void *errhp,
-        const void *filep, char *dir_alias, uint16_t *d_length, char *filename,
-        uint16_t *f_length);
-typedef int (*dpiOciFnType__lobFileSetName)(void *envhp, void *errhp,
-        void **filepp, const char *dir_alias, uint16_t d_length,
-        const char *filename, uint16_t f_length);
-typedef int (*dpiOciFnType__lobFreeTemporary)(void *svchp, void *errhp,
-        void *locp);
-typedef int (*dpiOciFnType__lobGetChunkSize)(void *svchp, void *errhp,
-        void *locp, uint32_t *chunksizep);
-typedef int (*dpiOciFnType__lobGetLength2)(void *svchp, void *errhp,
-        void *locp, uint64_t *lenp);
-typedef int (*dpiOciFnType__lobIsOpen)(void *svchp, void *errhp, void *locp,
-        int *flag);
-typedef int (*dpiOciFnType__lobIsTemporary)(void *envp, void *errhp,
-        void *locp, int *is_temporary);
-typedef int (*dpiOciFnType__lobLocatorAssign)(void *svchp, void *errhp,
-        const void *src_locp, void **dst_locpp);
-typedef int (*dpiOciFnType__lobOpen)(void *svchp, void *errhp, void *locp,
-        uint8_t mode);
-typedef int (*dpiOciFnType__lobRead2)(void *svchp, void *errhp, void *locp,
-        uint64_t *byte_amtp, uint64_t *char_amtp, uint64_t offset, void *bufp,
-        uint64_t bufl, uint8_t piece, void *ctxp, void *cbfp, uint16_t csid,
-        uint8_t csfrm);
-typedef int (*dpiOciFnType__lobTrim2)(void *svchp, void *errhp, void *locp,
-        uint64_t newlen);
-typedef int (*dpiOciFnType__lobWrite2)(void *svchp, void *errhp, void *locp,
-        uint64_t *byte_amtp, uint64_t *char_amtp, uint64_t offset, void *bufp,
-        uint64_t buflen, uint8_t piece, void *ctxp, void *cbfp, uint16_t csid,
-        uint8_t csfrm);
-typedef int (*dpiOciFnType__memoryAlloc)(void *hdl, void *err, void **mem,
-        uint16_t dur, uint32_t size, uint32_t flags);
-typedef int (*dpiOciFnType__memoryFree)(void *hdl, void *err, void *mem);
-typedef int (*dpiOciFnType__nlsCharSetConvert)(void *envhp, void *errhp,
-        uint16_t dstid, void  *dstp, size_t dstlen, uint16_t srcid,
-        const void *srcp, size_t srclen, size_t *rsize);
-typedef int (*dpiOciFnType__nlsCharSetIdToName)(void *envhp, char *buf,
-        size_t buflen, uint16_t id);
-typedef uint16_t (*dpiOciFnType__nlsCharSetNameToId)(void *envhp,
-        const char *name);
-typedef int (*dpiOciFnType__nlsEnvironmentVariableGet)(void *val, size_t size,
-        uint16_t item, uint16_t charset, size_t *rsize);
-typedef int (*dpiOciFnType__nlsNameMap)(void *envhp, char *buf, size_t buflen,
-        const char *srcbuf, uint32_t flag);
-typedef int (*dpiOciFnType__nlsNumericInfoGet)(void *envhp, void *errhp,
-        int32_t *val, uint16_t item);
-typedef int (*dpiOciFnType__numberFromInt)(void *err, const void *inum,
-        unsigned int inum_length, unsigned int inum_s_flag, void *number);
-typedef int (*dpiOciFnType__numberFromReal)(void *err, const void *number,
-        unsigned int rsl_length, void *rsl);
-typedef int (*dpiOciFnType__numberToInt)(void *err, const void *number,
-        unsigned int rsl_length, unsigned int rsl_flag, void *rsl);
-typedef int (*dpiOciFnType__numberToReal)(void *err, const void *number,
-        unsigned int rsl_length, void *rsl);
-typedef int (*dpiOciFnType__objectCopy)(void *env, void *err, const void *svc,
-        void *source, void *null_source, void *target, void *null_target,
-        void *tdo, uint16_t duration, uint8_t option);
-typedef int (*dpiOciFnType__objectFree)(void *env, void *err, void *instance,
-        uint16_t flags);
-typedef int (*dpiOciFnType__objectGetAttr)(void *env, void *err,
-        void *instance, void *null_struct, void *tdo, const char **names,
-        const uint32_t *lengths, const uint32_t name_count,
-        const uint32_t *indexes, const uint32_t index_count,
-        int16_t *attr_null_status, void **attr_null_struct, void **attr_value,
-        void **attr_tdo);
-typedef int (*dpiOciFnType__objectGetInd)(void *env, void *err, void *instance,
-        void **null_struct);
-typedef int (*dpiOciFnType__objectNew)(void *env, void *err, const void *svc,
-        uint16_t typecode, void *tdo, void *table, uint16_t duration,
-        int value, void **instance);
-typedef int (*dpiOciFnType__objectPin)(void *env, void *err, void *object_ref,
-        void *corhdl, int pin_option, uint16_t pin_duration, int lock_option,
-        void **object);
-typedef int (*dpiOciFnType__objectSetAttr)(void *env, void *err,
-        void *instance, void *null_struct, void *tdo, const char **names,
-        const uint32_t *lengths, const uint32_t name_count,
-        const uint32_t *indexes, const uint32_t index_count,
-        const int16_t null_status, const void *attr_null_struct,
-        const void *attr_value);
-typedef int (*dpiOciFnType__paramGet)(const void *hndlp, uint32_t htype,
-        void *errhp, void **parmdpp, uint32_t pos);
-typedef int (*dpiOciFnType__passwordChange)(void *svchp, void *errhp,
-        const char *user_name, uint32_t usernm_len, const char *opasswd,
-        uint32_t opasswd_len, const char *npasswd, uint32_t npasswd_len,
-        uint32_t mode);
-typedef int (*dpiOciFnType__ping)(void *svchp, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__rawAssignBytes)(void *env, void *err,
-        const char *rhs, uint32_t rhs_len, void **lhs);
-typedef void *(*dpiOciFnType__rawPtr)(void *env, const void *raw);
-typedef int (*dpiOciFnType__rawResize)(void *env, void *err, uint32_t new_size,
-        void **raw);
-typedef uint32_t (*dpiOciFnType__rawSize)(void * env, const void *raw);
-typedef int (*dpiOciFnType__rowidToChar)(void *rowidDesc, char *outbfp,
-        uint16_t *outbflp, void *errhp);
-typedef int (*dpiOciFnType__serverAttach)(void *srvhp, void *errhp,
-        const char *dblink, int32_t dblink_len, uint32_t mode);
-typedef int (*dpiOciFnType__serverDetach)(void *srvhp, void *errhp,
-        uint32_t mode);
-typedef int (*dpiOciFnType__serverRelease)(void *hndlp, void *errhp,
-        char *bufp, uint32_t bufsz, uint8_t hndltype, uint32_t *version);
-typedef int (*dpiOciFnType__serverRelease2)(void *hndlp, void *errhp,
-        char *bufp, uint32_t bufsz, uint8_t hndltype, uint32_t *version,
-        uint32_t mode);
-typedef int (*dpiOciFnType__sessionBegin)(void *svchp, void *errhp,
-        void *usrhp, uint32_t credt, uint32_t mode);
-typedef int (*dpiOciFnType__sessionEnd)(void *svchp, void *errhp, void *usrhp,
-        uint32_t mode);
-typedef int (*dpiOciFnType__sessionGet)(void *envhp, void *errhp, void **svchp,
-        void *authhp, const char *poolName, uint32_t poolName_len,
-        const char *tagInfo, uint32_t tagInfo_len, const char **retTagInfo,
-        uint32_t *retTagInfo_len, int *found, uint32_t mode);
-typedef int (*dpiOciFnType__sessionPoolCreate)(void *envhp, void *errhp,
-        void *spoolhp, char **poolName, uint32_t *poolNameLen,
-        const char *connStr, uint32_t connStrLen, uint32_t sessMin,
-        uint32_t sessMax, uint32_t sessIncr, const char *userid,
-        uint32_t useridLen, const char *password, uint32_t passwordLen,
-        uint32_t mode);
-typedef int (*dpiOciFnType__sessionPoolDestroy)(void *spoolhp, void *errhp,
-        uint32_t mode);
-typedef int (*dpiOciFnType__sessionRelease)(void *svchp, void *errhp,
-        const char *tag, uint32_t tag_len, uint32_t mode);
-typedef int (*dpiOciFnType__shardingKeyColumnAdd)(void *shardingKey,
-        void *errhp, void *col, uint32_t colLen, uint16_t colType,
-        uint32_t mode);
-typedef int (*dpiOciFnType__sodaBulkInsert)(void *svchp,
-        void *collection, void **documentarray, uint32_t arraylen,
-        void *opoptns, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaBulkInsertAndGet)(void *svchp,
-        void *collection, void **documentarray, uint32_t arraylen,
-        void *opoptns, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaBulkInsertAndGetWithOpts)(void *svchp,
-        void *collection, void **documentarray, uint32_t arraylen,
-        void *oproptns, void *opoptns, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaCollCreateWithMetadata)(void *svchp,
-        const char *collname, uint32_t collnamelen, const char *metadata,
-        uint32_t metadatalen, void **collection, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaCollDrop)(void *svchp, void *coll,
-        int *isDropped, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaCollGetNext)(void *svchp, const void *cur,
-        void **coll, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaCollList)(void *svchp, const char *startname,
-        uint32_t stnamelen, void **cur, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaCollOpen)(void *svchp, const char *collname,
-        uint32_t collnamelen, void **coll, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaCollTruncate)(void *svchp, void *collection,
-        void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaDataGuideGet)(void *svchp,
-        const void *collection, uint32_t docFlags, void **doc, void *errhp,
-        uint32_t mode);
-typedef int (*dpiOciFnType__sodaDocCount)(void *svchp, const void *coll,
-        const void *optns, uint64_t *numdocs, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaDocGetNext)(void *svchp, const void *cur,
-        void **doc, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaFind)(void *svchp, const void *coll,
-        const void *findOptions, uint32_t docFlags, void **cursor,
-        void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaFindOne)(void *svchp, const void *coll,
-        const void *findOptions, uint32_t docFlags, void **doc, void *errhp,
-        uint32_t mode);
-typedef int (*dpiOciFnType__sodaIndexCreate)(void *svchp, const void *coll,
-        const char *indexspec, uint32_t speclen, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaIndexDrop)(void *svchp, const char *indexname,
-        uint32_t indexnamelen, int *isDropped, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaInsert)(void *svchp, void *collection,
-        void *document, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaInsertAndGet)(void *svchp, void *collection,
-        void **document, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaInsertAndGetWithOpts)(void *svchp,
-        void *collection, void **document, void *oproptns, void *errhp,
-        uint32_t mode);
-typedef int (*dpiOciFnType__sodaOperKeysSet)(const void *operhp,
-        const char **keysArray, uint32_t *lengthsArray, uint32_t count,
-        void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaRemove)(void *svchp, const void *coll,
-        const void *optns, uint64_t *removeCount, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaReplOne)(void *svchp, const void *coll,
-        const void *optns, void *document, int *isReplaced, void *errhp,
-        uint32_t mode);
-typedef int (*dpiOciFnType__sodaReplOneAndGet)(void *svchp, const void *coll,
-        const void *optns, void **document, int *isReplaced, void *errhp,
-        uint32_t mode);
-typedef int (*dpiOciFnType__sodaSave)(void *svchp, void *collection,
-        void *document, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaSaveAndGet)(void *svchp, void *collection,
-        void **document, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__sodaSaveAndGetWithOpts)(void *svchp,
-        void *collection, void **document, void *oproptns, void *errhp,
-        uint32_t mode);
-typedef int (*dpiOciFnType__stmtExecute)(void *svchp, void *stmtp, void *errhp,
-        uint32_t iters, uint32_t rowoff, const void *snap_in, void *snap_out,
-        uint32_t mode);
-typedef int (*dpiOciFnType__stmtFetch2)(void *stmtp, void *errhp,
-        uint32_t nrows, uint16_t orientation, int32_t scrollOffset,
-        uint32_t mode);
-typedef int (*dpiOciFnType__stmtGetBindInfo)(void *stmtp, void *errhp,
-        uint32_t size, uint32_t startloc, int32_t *found, char *bvnp[],
-        uint8_t bvnl[], char *invp[], uint8_t inpl[], uint8_t dupl[],
-        void **hndl);
-typedef int (*dpiOciFnType__stmtGetNextResult)(void *stmthp, void *errhp,
-        void **result, uint32_t *rtype, uint32_t mode);
-typedef int (*dpiOciFnType__stmtPrepare2)(void *svchp, void **stmtp,
-        void *errhp, const char *stmt, uint32_t stmt_len, const char *key,
-        uint32_t key_len, uint32_t language, uint32_t mode);
-typedef int (*dpiOciFnType__stmtRelease)(void *stmtp, void *errhp,
-        const char *key, uint32_t key_len, uint32_t mode);
-typedef int (*dpiOciFnType__stringAssignText)(void *env, void *err,
-        const char *rhs, uint32_t rhs_len, void **lhs);
-typedef char *(*dpiOciFnType__stringPtr)(void *env, const void *vs);
-typedef int (*dpiOciFnType__stringResize)(void *env, void *err,
-        uint32_t new_size, void **str);
-typedef uint32_t (*dpiOciFnType__stringSize)(void *env, const void *vs);
-typedef int (*dpiOciFnType__subscriptionRegister)(void *svchp,
-        void **subscrhpp, uint16_t count, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__subscriptionUnRegister)(void *svchp,
-        void *subscrhp, void *errhp, uint32_t mode);
-typedef int (*dpiOciFnType__tableDelete)(void *env, void *err, int32_t index,
-        void *tbl);
-typedef int (*dpiOciFnType__tableExists)(void *env, void *err, const void *tbl,
-        int32_t index, int *exists);
-typedef int (*dpiOciFnType__tableFirst)(void *env, void *err, const void *tbl,
-        int32_t *index);
-typedef int (*dpiOciFnType__tableLast)(void *env, void *err, const void *tbl,
-        int32_t *index);
-typedef int (*dpiOciFnType__tableNext)(void *env, void *err, int32_t index,
-        const void *tbl, int32_t *next_index, int *exists);
-typedef int (*dpiOciFnType__tablePrev)(void *env, void *err, int32_t index,
-        const void *tbl, int32_t *prev_index, int *exists);
-typedef int (*dpiOciFnType__tableSize)(void *env, void *err, const void *tbl,
-        int32_t *size);
-typedef int (*dpiOciFnType__threadKeyDestroy)(void *hndl, void *err,
-        void **key);
-typedef int (*dpiOciFnType__threadKeyGet)(void *hndl, void *err, void *key,
-        void **pValue);
-typedef int (*dpiOciFnType__threadKeyInit)(void *hndl, void *err, void **key,
-        void *destFn);
-typedef int (*dpiOciFnType__threadKeySet)(void *hndl, void *err, void *key,
-        void *value);
-typedef void (*dpiOciFnType__threadProcessInit)(void);
-typedef int (*dpiOciFnType__transCommit)(void *svchp, void *errhp,
-        uint32_t flags);
-typedef int (*dpiOciFnType__transDetach)(void *svchp, void *errhp,
-        uint32_t flags);
-typedef int (*dpiOciFnType__transForget)(void *svchp, void *errhp,
-        uint32_t flags);
-typedef int (*dpiOciFnType__transPrepare)(void *svchp, void *errhp,
-        uint32_t flags);
-typedef int (*dpiOciFnType__transRollback)(void *svchp, void *errhp,
-        uint32_t flags);
-typedef int (*dpiOciFnType__transStart)(void *svchp, void *errhp,
-        unsigned int timeout, uint32_t flags);
-typedef int (*dpiOciFnType__typeByFullName)(void *env, void *err,
-        const void *svc, const char *full_type_name,
-        uint32_t full_type_name_length, const char *version_name,
-        uint32_t version_name_length, uint16_t pin_duration, int get_option,
-        void **tdo);
-typedef int (*dpiOciFnType__typeByName)(void *env, void *err, const void *svc,
-        const char *schema_name, uint32_t s_length, const char *type_name,
-        uint32_t t_length, const char *version_name, uint32_t v_length,
-        uint16_t pin_duration, int get_option, void **tdo);
-
-
-// library handle for dynamically loaded OCI library
-static void *dpiOciLibHandle = NULL;
-
-// library names to search
-static const char *dpiOciLibNames[] = {
-#if defined _WIN32 || defined __CYGWIN__
-    "oci.dll",
-#elif __APPLE__
-    "libclntsh.dylib",
-    "libclntsh.dylib.19.1",
-    "libclntsh.dylib.18.1",
-    "libclntsh.dylib.12.1",
-    "libclntsh.dylib.11.1",
-    "libclntsh.dylib.20.1",
-    "libclntsh.dylib.21.1",
-#else
-    "libclntsh.so",
-    "libclntsh.so.19.1",
-    "libclntsh.so.18.1",
-    "libclntsh.so.12.1",
-    "libclntsh.so.11.1",
-    "libclntsh.so.20.1",
-    "libclntsh.so.21.1",
-#endif
-    NULL
-};
-
-// all OCI symbols used by ODPI-C
-static struct {
-    dpiOciFnType__aqDeq fnAqDeq;
-    dpiOciFnType__aqDeqArray fnAqDeqArray;
-    dpiOciFnType__aqEnq fnAqEnq;
-    dpiOciFnType__aqEnqArray fnAqEnqArray;
-    dpiOciFnType__arrayDescriptorAlloc fnArrayDescriptorAlloc;
-    dpiOciFnType__arrayDescriptorFree fnArrayDescriptorFree;
-    dpiOciFnType__attrGet fnAttrGet;
-    dpiOciFnType__attrSet fnAttrSet;
-    dpiOciFnType__bindByName fnBindByName;
-    dpiOciFnType__bindByName2 fnBindByName2;
-    dpiOciFnType__bindByPos fnBindByPos;
-    dpiOciFnType__bindByPos2 fnBindByPos2;
-    dpiOciFnType__bindDynamic fnBindDynamic;
-    dpiOciFnType__bindObject fnBindObject;
-    dpiOciFnType__break fnBreak;
-    dpiOciFnType__clientVersion fnClientVersion;
-    dpiOciFnType__collAppend fnCollAppend;
-    dpiOciFnType__collAssignElem fnCollAssignElem;
-    dpiOciFnType__collGetElem fnCollGetElem;
-    dpiOciFnType__collSize fnCollSize;
-    dpiOciFnType__collTrim fnCollTrim;
-    dpiOciFnType__contextGetValue fnContextGetValue;
-    dpiOciFnType__contextSetValue fnContextSetValue;
-    dpiOciFnType__dateTimeConstruct fnDateTimeConstruct;
-    dpiOciFnType__dateTimeConvert fnDateTimeConvert;
-    dpiOciFnType__dateTimeGetDate fnDateTimeGetDate;
-    dpiOciFnType__dateTimeGetTime fnDateTimeGetTime;
-    dpiOciFnType__dateTimeGetTimeZoneOffset fnDateTimeGetTimeZoneOffset;
-    dpiOciFnType__dateTimeIntervalAdd fnDateTimeIntervalAdd;
-    dpiOciFnType__dateTimeSubtract fnDateTimeSubtract;
-    dpiOciFnType__dbShutdown fnDbShutdown;
-    dpiOciFnType__dbStartup fnDbStartup;
-    dpiOciFnType__defineByPos fnDefineByPos;
-    dpiOciFnType__defineByPos2 fnDefineByPos2;
-    dpiOciFnType__defineDynamic fnDefineDynamic;
-    dpiOciFnType__defineObject fnDefineObject;
-    dpiOciFnType__describeAny fnDescribeAny;
-    dpiOciFnType__descriptorAlloc fnDescriptorAlloc;
-    dpiOciFnType__descriptorFree fnDescriptorFree;
-    dpiOciFnType__envNlsCreate fnEnvNlsCreate;
-    dpiOciFnType__errorGet fnErrorGet;
-    dpiOciFnType__handleAlloc fnHandleAlloc;
-    dpiOciFnType__handleFree fnHandleFree;
-    dpiOciFnType__intervalGetDaySecond fnIntervalGetDaySecond;
-    dpiOciFnType__intervalGetYearMonth fnIntervalGetYearMonth;
-    dpiOciFnType__intervalSetDaySecond fnIntervalSetDaySecond;
-    dpiOciFnType__intervalSetYearMonth fnIntervalSetYearMonth;
-    dpiOciFnType__jsonDomDocGet fnJsonDomDocGet;
-    dpiOciFnType__jsonTextBufferParse fnJsonTextBufferParse;
-    dpiOciFnType__lobClose fnLobClose;
-    dpiOciFnType__lobCreateTemporary fnLobCreateTemporary;
-    dpiOciFnType__lobFileExists fnLobFileExists;
-    dpiOciFnType__lobFileGetName fnLobFileGetName;
-    dpiOciFnType__lobFileSetName fnLobFileSetName;
-    dpiOciFnType__lobFreeTemporary fnLobFreeTemporary;
-    dpiOciFnType__lobGetChunkSize fnLobGetChunkSize;
-    dpiOciFnType__lobGetLength2 fnLobGetLength2;
-    dpiOciFnType__lobIsOpen fnLobIsOpen;
-    dpiOciFnType__lobIsTemporary fnLobIsTemporary;
-    dpiOciFnType__lobLocatorAssign fnLobLocatorAssign;
-    dpiOciFnType__lobOpen fnLobOpen;
-    dpiOciFnType__lobRead2 fnLobRead2;
-    dpiOciFnType__lobTrim2 fnLobTrim2;
-    dpiOciFnType__lobWrite2 fnLobWrite2;
-    dpiOciFnType__memoryAlloc fnMemoryAlloc;
-    dpiOciFnType__memoryFree fnMemoryFree;
-    dpiOciFnType__nlsCharSetConvert fnNlsCharSetConvert;
-    dpiOciFnType__nlsCharSetIdToName fnNlsCharSetIdToName;
-    dpiOciFnType__nlsCharSetNameToId fnNlsCharSetNameToId;
-    dpiOciFnType__nlsEnvironmentVariableGet fnNlsEnvironmentVariableGet;
-    dpiOciFnType__nlsNameMap fnNlsNameMap;
-    dpiOciFnType__nlsNumericInfoGet fnNlsNumericInfoGet;
-    dpiOciFnType__numberFromInt fnNumberFromInt;
-    dpiOciFnType__numberFromReal fnNumberFromReal;
-    dpiOciFnType__numberToInt fnNumberToInt;
-    dpiOciFnType__numberToReal fnNumberToReal;
-    dpiOciFnType__objectCopy fnObjectCopy;
-    dpiOciFnType__objectFree fnObjectFree;
-    dpiOciFnType__objectGetAttr fnObjectGetAttr;
-    dpiOciFnType__objectGetInd fnObjectGetInd;
-    dpiOciFnType__objectNew fnObjectNew;
-    dpiOciFnType__objectPin fnObjectPin;
-    dpiOciFnType__objectSetAttr fnObjectSetAttr;
-    dpiOciFnType__paramGet fnParamGet;
-    dpiOciFnType__passwordChange fnPasswordChange;
-    dpiOciFnType__ping fnPing;
-    dpiOciFnType__rawAssignBytes fnRawAssignBytes;
-    dpiOciFnType__rawPtr fnRawPtr;
-    dpiOciFnType__rawResize fnRawResize;
-    dpiOciFnType__rawSize fnRawSize;
-    dpiOciFnType__rowidToChar fnRowidToChar;
-    dpiOciFnType__serverAttach fnServerAttach;
-    dpiOciFnType__serverDetach fnServerDetach;
-    dpiOciFnType__serverRelease fnServerRelease;
-    dpiOciFnType__serverRelease2 fnServerRelease2;
-    dpiOciFnType__sessionBegin fnSessionBegin;
-    dpiOciFnType__sessionEnd fnSessionEnd;
-    dpiOciFnType__sessionGet fnSessionGet;
-    dpiOciFnType__sessionPoolCreate fnSessionPoolCreate;
-    dpiOciFnType__sessionPoolDestroy fnSessionPoolDestroy;
-    dpiOciFnType__sessionRelease fnSessionRelease;
-    dpiOciFnType__shardingKeyColumnAdd fnShardingKeyColumnAdd;
-    dpiOciFnType__stmtExecute fnStmtExecute;
-    dpiOciFnType__sodaBulkInsert fnSodaBulkInsert;
-    dpiOciFnType__sodaBulkInsertAndGet fnSodaBulkInsertAndGet;
-    dpiOciFnType__sodaBulkInsertAndGetWithOpts fnSodaBulkInsertAndGetWithOpts;
-    dpiOciFnType__sodaCollCreateWithMetadata fnSodaCollCreateWithMetadata;
-    dpiOciFnType__sodaCollDrop fnSodaCollDrop;
-    dpiOciFnType__sodaCollGetNext fnSodaCollGetNext;
-    dpiOciFnType__sodaCollList fnSodaCollList;
-    dpiOciFnType__sodaCollOpen fnSodaCollOpen;
-    dpiOciFnType__sodaCollTruncate fnSodaCollTruncate;
-    dpiOciFnType__sodaDataGuideGet fnSodaDataGuideGet;
-    dpiOciFnType__sodaDocCount fnSodaDocCount;
-    dpiOciFnType__sodaDocGetNext fnSodaDocGetNext;
-    dpiOciFnType__sodaFind fnSodaFind;
-    dpiOciFnType__sodaFindOne fnSodaFindOne;
-    dpiOciFnType__sodaIndexCreate fnSodaIndexCreate;
-    dpiOciFnType__sodaIndexDrop fnSodaIndexDrop;
-    dpiOciFnType__sodaInsert fnSodaInsert;
-    dpiOciFnType__sodaInsertAndGet fnSodaInsertAndGet;
-    dpiOciFnType__sodaInsertAndGetWithOpts fnSodaInsertAndGetWithOpts;
-    dpiOciFnType__sodaOperKeysSet fnSodaOperKeysSet;
-    dpiOciFnType__sodaRemove fnSodaRemove;
-    dpiOciFnType__sodaReplOne fnSodaReplOne;
-    dpiOciFnType__sodaReplOneAndGet fnSodaReplOneAndGet;
-    dpiOciFnType__sodaSave fnSodaSave;
-    dpiOciFnType__sodaSaveAndGet fnSodaSaveAndGet;
-    dpiOciFnType__sodaSaveAndGetWithOpts fnSodaSaveAndGetWithOpts;
-    dpiOciFnType__stmtFetch2 fnStmtFetch2;
-    dpiOciFnType__stmtGetBindInfo fnStmtGetBindInfo;
-    dpiOciFnType__stmtGetNextResult fnStmtGetNextResult;
-    dpiOciFnType__stmtPrepare2 fnStmtPrepare2;
-    dpiOciFnType__stmtRelease fnStmtRelease;
-    dpiOciFnType__stringAssignText fnStringAssignText;
-    dpiOciFnType__stringPtr fnStringPtr;
-    dpiOciFnType__stringResize fnStringResize;
-    dpiOciFnType__stringSize fnStringSize;
-    dpiOciFnType__subscriptionRegister fnSubscriptionRegister;
-    dpiOciFnType__subscriptionUnRegister fnSubscriptionUnRegister;
-    dpiOciFnType__tableDelete fnTableDelete;
-    dpiOciFnType__tableExists fnTableExists;
-    dpiOciFnType__tableFirst fnTableFirst;
-    dpiOciFnType__tableLast fnTableLast;
-    dpiOciFnType__tableNext fnTableNext;
-    dpiOciFnType__tablePrev fnTablePrev;
-    dpiOciFnType__tableSize fnTableSize;
-    dpiOciFnType__threadKeyDestroy fnThreadKeyDestroy;
-    dpiOciFnType__threadKeyGet fnThreadKeyGet;
-    dpiOciFnType__threadKeyInit fnThreadKeyInit;
-    dpiOciFnType__threadKeySet fnThreadKeySet;
-    dpiOciFnType__threadProcessInit fnThreadProcessInit;
-    dpiOciFnType__transCommit fnTransCommit;
-    dpiOciFnType__transDetach fnTransDetach;
-    dpiOciFnType__transForget fnTransForget;
-    dpiOciFnType__transPrepare fnTransPrepare;
-    dpiOciFnType__transRollback fnTransRollback;
-    dpiOciFnType__transStart fnTransStart;
-    dpiOciFnType__typeByFullName fnTypeByFullName;
-    dpiOciFnType__typeByName fnTypeByName;
-} dpiOciSymbols;
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__allocateMem() [INTERNAL]
-//   Wrapper for OCI allocation of memory, only used when debugging memory
-// allocation.
-//-----------------------------------------------------------------------------
-static void *dpiOci__allocateMem(UNUSED void *unused, size_t size)
-{
-    void *ptr;
-
-    ptr = malloc(size);
-    dpiDebug__print("OCI allocated %u bytes at %p\n", size, ptr);
-    return ptr;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__aqDeq() [INTERNAL]
-//   Wrapper for OCIAQDeq().
-//-----------------------------------------------------------------------------
-int dpiOci__aqDeq(dpiConn *conn, const char *queueName, void *options,
-        void *msgProps, void *payloadType, void **payload, void **payloadInd,
-        void **msgId, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIAQDeq", dpiOciSymbols.fnAqDeq)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnAqDeq)(conn->handle, error->handle, queueName,
-            options, msgProps, payloadType, payload, payloadInd, msgId,
-            DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "dequeue message");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__aqDeqArray() [INTERNAL]
-//   Wrapper for OCIAQDeqArray().
-//-----------------------------------------------------------------------------
-int dpiOci__aqDeqArray(dpiConn *conn, const char *queueName, void *options,
-        uint32_t *numIters, void **msgProps, void *payloadType, void **payload,
-        void **payloadInd, void **msgId, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIAQDeqArray", dpiOciSymbols.fnAqDeqArray)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnAqDeqArray)(conn->handle, error->handle,
-            queueName, options, numIters, msgProps, payloadType, payload,
-            payloadInd, msgId, NULL, NULL, DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "dequeue messages");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__aqEnq() [INTERNAL]
-//   Wrapper for OCIAQEnq().
-//-----------------------------------------------------------------------------
-int dpiOci__aqEnq(dpiConn *conn, const char *queueName, void *options,
-        void *msgProps, void *payloadType, void **payload, void **payloadInd,
-        void **msgId, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIAQEnq", dpiOciSymbols.fnAqEnq)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnAqEnq)(conn->handle, error->handle, queueName,
-            options, msgProps, payloadType, payload, payloadInd, msgId,
-            DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "enqueue message");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__aqEnqArray() [INTERNAL]
-//   Wrapper for OCIAQEnqArray().
-//-----------------------------------------------------------------------------
-int dpiOci__aqEnqArray(dpiConn *conn, const char *queueName, void *options,
-        uint32_t *numIters, void **msgProps, void *payloadType, void **payload,
-        void **payloadInd, void **msgId, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIAQEnqArray", dpiOciSymbols.fnAqEnqArray)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnAqEnqArray)(conn->handle, error->handle,
-            queueName, options, numIters, msgProps, payloadType, payload,
-            payloadInd, msgId, NULL, NULL, DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "enqueue messages");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__arrayDescriptorAlloc() [INTERNAL]
-//   Wrapper for OCIArrayDescriptorAlloc().
-//-----------------------------------------------------------------------------
-int dpiOci__arrayDescriptorAlloc(void *envHandle, void **handle,
-        uint32_t handleType, uint32_t arraySize, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIArrayDescriptorAlloc",
-            dpiOciSymbols.fnArrayDescriptorAlloc)
-    status = (*dpiOciSymbols.fnArrayDescriptorAlloc)(envHandle, handle,
-            handleType, arraySize, 0, NULL);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "allocate descriptors");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__arrayDescriptorFree() [INTERNAL]
-//   Wrapper for OCIArrayDescriptorFree().
-//-----------------------------------------------------------------------------
-int dpiOci__arrayDescriptorFree(void **handle, uint32_t handleType)
-{
-    dpiError *error = NULL;
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIArrayDescriptorFree",
-            dpiOciSymbols.fnArrayDescriptorFree)
-    status = (*dpiOciSymbols.fnArrayDescriptorFree)(handle, handleType);
-    if (status != DPI_OCI_SUCCESS &&
-            dpiDebugLevel & DPI_DEBUG_LEVEL_UNREPORTED_ERRORS)
-        dpiDebug__print("free array descriptors %p, handleType %d failed\n",
-                handle, handleType);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__attrGet() [INTERNAL]
-//   Wrapper for OCIAttrGet().
-//-----------------------------------------------------------------------------
-int dpiOci__attrGet(const void *handle, uint32_t handleType, void *ptr,
-        uint32_t *size, uint32_t attribute, const char *action,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnAttrGet)(handle, handleType, ptr, size,
-            attribute, error->handle);
-    if (status == DPI_OCI_NO_DATA && size) {
-        *size = 0;
-        return DPI_SUCCESS;
-    } else if (!action) {
-        return DPI_SUCCESS;
-    }
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, action);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__attrSet() [INTERNAL]
-//   Wrapper for OCIAttrSet().
-//-----------------------------------------------------------------------------
-int dpiOci__attrSet(void *handle, uint32_t handleType, void *ptr,
-        uint32_t size, uint32_t attribute, const char *action, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnAttrSet)(handle, handleType, ptr, size,
-            attribute, error->handle);
-    if (!action)
-        return DPI_SUCCESS;
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, action);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__bindByName() [INTERNAL]
-//   Wrapper for OCIBindByName().
-//-----------------------------------------------------------------------------
-int dpiOci__bindByName(dpiStmt *stmt, void **bindHandle, const char *name,
-        int32_t nameLength, int dynamicBind, dpiVar *var, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIBindByName", dpiOciSymbols.fnBindByName)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnBindByName)(stmt->handle, bindHandle,
-            error->handle, name, nameLength,
-            (dynamicBind) ? NULL : var->buffer.data.asRaw,
-            (var->isDynamic) ? INT_MAX : (int32_t) var->sizeInBytes,
-            var->type->oracleType, (dynamicBind) ? NULL :
-                    var->buffer.indicator,
-            (dynamicBind || var->type->sizeInBytes) ? NULL :
-                    var->buffer.actualLength16,
-            (dynamicBind) ? NULL : var->buffer.returnCode,
-            (var->isArray) ? var->buffer.maxArraySize : 0,
-            (var->isArray) ? &var->buffer.actualArraySize : NULL,
-            (dynamicBind) ? DPI_OCI_DATA_AT_EXEC : DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "bind by name");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__bindByName2() [INTERNAL]
-//   Wrapper for OCIBindByName2().
-//-----------------------------------------------------------------------------
-int dpiOci__bindByName2(dpiStmt *stmt, void **bindHandle, const char *name,
-        int32_t nameLength, int dynamicBind, dpiVar *var, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIBindByName2", dpiOciSymbols.fnBindByName2)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnBindByName2)(stmt->handle, bindHandle,
-            error->handle, name, nameLength,
-            (dynamicBind) ? NULL : var->buffer.data.asRaw,
-            (var->isDynamic) ? INT_MAX : var->sizeInBytes,
-            var->type->oracleType, (dynamicBind) ? NULL :
-                    var->buffer.indicator,
-            (dynamicBind || var->type->sizeInBytes) ? NULL :
-                    var->buffer.actualLength32,
-            (dynamicBind) ? NULL : var->buffer.returnCode,
-            (var->isArray) ? var->buffer.maxArraySize : 0,
-            (var->isArray) ? &var->buffer.actualArraySize : NULL,
-            (dynamicBind) ? DPI_OCI_DATA_AT_EXEC : DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "bind by name");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__bindByPos() [INTERNAL]
-//   Wrapper for OCIBindByPos().
-//-----------------------------------------------------------------------------
-int dpiOci__bindByPos(dpiStmt *stmt, void **bindHandle, uint32_t pos,
-        int dynamicBind, dpiVar *var, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIBindByPos", dpiOciSymbols.fnBindByPos)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnBindByPos)(stmt->handle, bindHandle,
-            error->handle, pos, (dynamicBind) ? NULL : var->buffer.data.asRaw,
-            (var->isDynamic) ? INT_MAX : (int32_t) var->sizeInBytes,
-            var->type->oracleType, (dynamicBind) ? NULL :
-                    var->buffer.indicator,
-            (dynamicBind || var->type->sizeInBytes) ? NULL :
-                    var->buffer.actualLength16,
-            (dynamicBind) ? NULL : var->buffer.returnCode,
-            (var->isArray) ? var->buffer.maxArraySize : 0,
-            (var->isArray) ? &var->buffer.actualArraySize : NULL,
-            (dynamicBind) ? DPI_OCI_DATA_AT_EXEC : DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "bind by position");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__bindByPos2() [INTERNAL]
-//   Wrapper for OCIBindByPos2().
-//-----------------------------------------------------------------------------
-int dpiOci__bindByPos2(dpiStmt *stmt, void **bindHandle, uint32_t pos,
-        int dynamicBind, dpiVar *var, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIBindByPos2", dpiOciSymbols.fnBindByPos2)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnBindByPos2)(stmt->handle, bindHandle,
-            error->handle, pos, (dynamicBind) ? NULL : var->buffer.data.asRaw,
-            (var->isDynamic) ? INT_MAX : var->sizeInBytes,
-            var->type->oracleType, (dynamicBind) ? NULL :
-                    var->buffer.indicator,
-            (dynamicBind || var->type->sizeInBytes) ? NULL :
-                    var->buffer.actualLength32,
-            (dynamicBind) ? NULL : var->buffer.returnCode,
-            (var->isArray) ? var->buffer.maxArraySize : 0,
-            (var->isArray) ? &var->buffer.actualArraySize : NULL,
-            (dynamicBind) ? DPI_OCI_DATA_AT_EXEC : DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "bind by position");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__bindDynamic() [INTERNAL]
-//   Wrapper for OCIBindDynamic().
-//-----------------------------------------------------------------------------
-int dpiOci__bindDynamic(dpiVar *var, void *bindHandle, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIBindDynamic", dpiOciSymbols.fnBindDynamic)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnBindDynamic)(bindHandle, error->handle, var,
-            (void*) dpiVar__inBindCallback, var,
-            (void*) dpiVar__outBindCallback);
-    DPI_OCI_CHECK_AND_RETURN(error, status, var->conn, "bind dynamic");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__bindObject() [INTERNAL]
-//   Wrapper for OCIBindObject().
-//-----------------------------------------------------------------------------
-int dpiOci__bindObject(dpiVar *var, void *bindHandle, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIBindObject", dpiOciSymbols.fnBindObject)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnBindObject)(bindHandle, error->handle,
-            var->objectType->tdo, (void**) var->buffer.data.asRaw, 0,
-            var->buffer.objectIndicator, 0);
-    DPI_OCI_CHECK_AND_RETURN(error, status, var->conn, "bind object");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__break() [INTERNAL]
-//   Wrapper for OCIBreak().
-//-----------------------------------------------------------------------------
-int dpiOci__break(dpiConn *conn, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIBreak", dpiOciSymbols.fnBreak)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnBreak)(conn->handle, error->handle);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "break execution");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__collAppend() [INTERNAL]
-//   Wrapper for OCICollAppend().
-//-----------------------------------------------------------------------------
-int dpiOci__collAppend(dpiConn *conn, const void *elem, const void *elemInd,
-        void *coll, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCICollAppend", dpiOciSymbols.fnCollAppend)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnCollAppend)(conn->env->handle, error->handle,
-            elem, elemInd, coll);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "append element");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__collAssignElem() [INTERNAL]
-//   Wrapper for OCICollAssignElem().
-//-----------------------------------------------------------------------------
-int dpiOci__collAssignElem(dpiConn *conn, int32_t index, const void *elem,
-        const void *elemInd, void *coll, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCICollAssignElem", dpiOciSymbols.fnCollAssignElem)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnCollAssignElem)(conn->env->handle,
-            error->handle, index, elem, elemInd, coll);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "assign element");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__collGetElem() [INTERNAL]
-//   Wrapper for OCICollGetElem().
-//-----------------------------------------------------------------------------
-int dpiOci__collGetElem(dpiConn *conn, void *coll, int32_t index, int *exists,
-        void **elem, void **elemInd, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCICollGetElem", dpiOciSymbols.fnCollGetElem)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnCollGetElem)(conn->env->handle, error->handle,
-            coll, index, exists, elem, elemInd);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "get element");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__collSize() [INTERNAL]
-//   Wrapper for OCICollSize().
-//-----------------------------------------------------------------------------
-int dpiOci__collSize(dpiConn *conn, void *coll, int32_t *size, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCICollSize", dpiOciSymbols.fnCollSize)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnCollSize)(conn->env->handle, error->handle,
-            coll, size);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "get size");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__collTrim() [INTERNAL]
-//   Wrapper for OCICollTrim().
-//-----------------------------------------------------------------------------
-int dpiOci__collTrim(dpiConn *conn, uint32_t numToTrim, void *coll,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCICollTrim", dpiOciSymbols.fnCollTrim)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnCollTrim)(conn->env->handle, error->handle,
-            (int32_t) numToTrim, coll);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "trim");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__contextGetValue() [INTERNAL]
-//   Wrapper for OCIContextGetValue().
-//-----------------------------------------------------------------------------
-int dpiOci__contextGetValue(dpiConn *conn, const char *key, uint32_t keyLength,
-        void **value, int checkError, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIContextGetValue", dpiOciSymbols.fnContextGetValue)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnContextGetValue)(conn->sessionHandle,
-            error->handle, key, (uint8_t) keyLength, value);
-    if (!checkError)
-        return DPI_SUCCESS;
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "get context value");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__contextSetValue() [INTERNAL]
-//   Wrapper for OCIContextSetValue().
-//-----------------------------------------------------------------------------
-int dpiOci__contextSetValue(dpiConn *conn, const char *key, uint32_t keyLength,
-        void *value, int checkError, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIContextSetValue", dpiOciSymbols.fnContextSetValue)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnContextSetValue)(conn->sessionHandle,
-            error->handle, DPI_OCI_DURATION_SESSION, key, (uint8_t) keyLength,
-            value);
-    if (!checkError)
-        return DPI_SUCCESS;
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "set context value");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__dateTimeConstruct() [INTERNAL]
-//   Wrapper for OCIDateTimeConstruct().
-//-----------------------------------------------------------------------------
-int dpiOci__dateTimeConstruct(void *envHandle, void *handle, int16_t year,
-        uint8_t month, uint8_t day, uint8_t hour, uint8_t minute,
-        uint8_t second, uint32_t fsecond, const char *tz, size_t tzLength,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDateTimeConstruct",
-            dpiOciSymbols.fnDateTimeConstruct)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnDateTimeConstruct)(envHandle, error->handle,
-            handle, year, month, day, hour, minute, second, fsecond, tz,
-            tzLength);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "construct date");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__dateTimeConvert() [INTERNAL]
-//   Wrapper for OCIDateTimeConvert().
-//-----------------------------------------------------------------------------
-int dpiOci__dateTimeConvert(void *envHandle, void *inDate, void *outDate,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDateTimeConvert", dpiOciSymbols.fnDateTimeConvert)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnDateTimeConvert)(envHandle, error->handle,
-            inDate, outDate);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "convert date");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__dateTimeGetDate() [INTERNAL]
-//   Wrapper for OCIDateTimeGetDate().
-//-----------------------------------------------------------------------------
-int dpiOci__dateTimeGetDate(void *envHandle, void *handle, int16_t *year,
-        uint8_t *month, uint8_t *day, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDateTimeGetDate", dpiOciSymbols.fnDateTimeGetDate)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnDateTimeGetDate)(envHandle, error->handle,
-            handle, year, month, day);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get date portion");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__dateTimeGetTime() [INTERNAL]
-//   Wrapper for OCIDateTimeGetTime().
-//-----------------------------------------------------------------------------
-int dpiOci__dateTimeGetTime(void *envHandle, void *handle, uint8_t *hour,
-        uint8_t *minute, uint8_t *second, uint32_t *fsecond, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDateTimeGetTime", dpiOciSymbols.fnDateTimeGetTime)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnDateTimeGetTime)(envHandle, error->handle,
-            handle, hour, minute, second, fsecond);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get time portion");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__dateTimeGetTimeZoneOffset() [INTERNAL]
-//   Wrapper for OCIDateTimeGetTimeZoneOffset().
-//-----------------------------------------------------------------------------
-int dpiOci__dateTimeGetTimeZoneOffset(void *envHandle, void *handle,
-        int8_t *tzHourOffset, int8_t *tzMinuteOffset, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDateTimeGetTimeZoneOffset",
-            dpiOciSymbols.fnDateTimeGetTimeZoneOffset)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnDateTimeGetTimeZoneOffset)(envHandle,
-            error->handle, handle, tzHourOffset, tzMinuteOffset);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get time zone portion");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__dateTimeIntervalAdd() [INTERNAL]
-//   Wrapper for OCIDateTimeIntervalAdd().
-//-----------------------------------------------------------------------------
-int dpiOci__dateTimeIntervalAdd(void *envHandle, void *handle, void *interval,
-        void *outHandle, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDateTimeIntervalAdd",
-            dpiOciSymbols.fnDateTimeIntervalAdd)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnDateTimeIntervalAdd)(envHandle, error->handle,
-            handle, interval, outHandle);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "add interval to date");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__dateTimeSubtract() [INTERNAL]
-//   Wrapper for OCIDateTimeSubtract().
-//-----------------------------------------------------------------------------
-int dpiOci__dateTimeSubtract(void *envHandle, void *handle1, void *handle2,
-        void *interval, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDateTimeSubtract",
-            dpiOciSymbols.fnDateTimeSubtract)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnDateTimeSubtract)(envHandle, error->handle,
-            handle1, handle2, interval);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "subtract date");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__dbShutdown() [INTERNAL]
-//   Wrapper for OCIDBShutdown().
-//-----------------------------------------------------------------------------
-int dpiOci__dbShutdown(dpiConn *conn, uint32_t mode, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDBShutdown", dpiOciSymbols.fnDbShutdown)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnDbShutdown)(conn->handle, error->handle, NULL,
-            mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "shutdown database");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__dbStartup() [INTERNAL]
-//   Wrapper for OCIDBStartup().
-//-----------------------------------------------------------------------------
-int dpiOci__dbStartup(dpiConn *conn, void *adminHandle, uint32_t mode,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDBStartup", dpiOciSymbols.fnDbStartup)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnDbStartup)(conn->handle, error->handle,
-            adminHandle, DPI_OCI_DEFAULT, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "startup database");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__defineByPos() [INTERNAL]
-//   Wrapper for OCIDefineByPos().
-//-----------------------------------------------------------------------------
-int dpiOci__defineByPos(dpiStmt *stmt, void **defineHandle, uint32_t pos,
-        dpiVar *var, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDefineByPos", dpiOciSymbols.fnDefineByPos)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnDefineByPos)(stmt->handle, defineHandle,
-            error->handle, pos, (var->isDynamic) ? NULL :
-                    var->buffer.data.asRaw,
-            (var->isDynamic) ? INT_MAX : (int32_t) var->sizeInBytes,
-            var->type->oracleType, (var->isDynamic) ? NULL :
-                    var->buffer.indicator,
-            (var->isDynamic) ? NULL : var->buffer.actualLength16,
-            (var->isDynamic) ? NULL : var->buffer.returnCode,
-            (var->isDynamic) ? DPI_OCI_DYNAMIC_FETCH : DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "define");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__defineByPos2() [INTERNAL]
-//   Wrapper for OCIDefineByPos2().
-//-----------------------------------------------------------------------------
-int dpiOci__defineByPos2(dpiStmt *stmt, void **defineHandle, uint32_t pos,
-        dpiVar *var, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDefineByPos2", dpiOciSymbols.fnDefineByPos2)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnDefineByPos2)(stmt->handle, defineHandle,
-            error->handle, pos, (var->isDynamic) ? NULL :
-                    var->buffer.data.asRaw,
-            (var->isDynamic) ? INT_MAX : var->sizeInBytes,
-            var->type->oracleType, (var->isDynamic) ? NULL :
-                    var->buffer.indicator,
-            (var->isDynamic) ? NULL : var->buffer.actualLength32,
-            (var->isDynamic) ? NULL : var->buffer.returnCode,
-            (var->isDynamic) ? DPI_OCI_DYNAMIC_FETCH : DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "define");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__defineDynamic() [INTERNAL]
-//   Wrapper for OCIDefineDynamic().
-//-----------------------------------------------------------------------------
-int dpiOci__defineDynamic(dpiVar *var, void *defineHandle, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDefineDynamic", dpiOciSymbols.fnDefineDynamic)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnDefineDynamic)(defineHandle, error->handle, var,
-            (void*) dpiVar__defineCallback);
-    DPI_OCI_CHECK_AND_RETURN(error, status, var->conn, "define dynamic");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__defineObject() [INTERNAL]
-//   Wrapper for OCIDefineObject().
-//-----------------------------------------------------------------------------
-int dpiOci__defineObject(dpiVar *var, void *defineHandle, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDefineObject", dpiOciSymbols.fnDefineObject)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnDefineObject)(defineHandle, error->handle,
-            var->objectType->tdo, (void**) var->buffer.data.asRaw, 0,
-            var->buffer.objectIndicator, 0);
-    DPI_OCI_CHECK_AND_RETURN(error, status, var->conn, "define object");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__describeAny() [INTERNAL]
-//   Wrapper for OCIDescribeAny().
-//-----------------------------------------------------------------------------
-int dpiOci__describeAny(dpiConn *conn, void *obj, uint32_t objLength,
-        uint8_t objType, void *describeHandle, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDescribeAny", dpiOciSymbols.fnDescribeAny)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnDescribeAny)(conn->handle, error->handle, obj,
-            objLength, objType, 0, DPI_OCI_PTYPE_TYPE, describeHandle);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "describe type");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__descriptorAlloc() [INTERNAL]
-//   Wrapper for OCIDescriptorAlloc().
-//-----------------------------------------------------------------------------
-int dpiOci__descriptorAlloc(void *envHandle, void **handle,
-        const uint32_t handleType, const char *action, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDescriptorAlloc", dpiOciSymbols.fnDescriptorAlloc)
-    status = (*dpiOciSymbols.fnDescriptorAlloc)(envHandle, handle, handleType,
-            0, NULL);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, action);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__descriptorFree() [INTERNAL]
-//   Wrapper for OCIDescriptorFree().
-//-----------------------------------------------------------------------------
-int dpiOci__descriptorFree(void *handle, uint32_t handleType)
-{
-    dpiError *error = NULL;
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIDescriptorFree", dpiOciSymbols.fnDescriptorFree)
-    status = (*dpiOciSymbols.fnDescriptorFree)(handle, handleType);
-    if (status != DPI_OCI_SUCCESS &&
-            dpiDebugLevel & DPI_DEBUG_LEVEL_UNREPORTED_ERRORS)
-        dpiDebug__print("free descriptor %p, type %d failed\n", handle,
-                handleType);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__envNlsCreate() [INTERNAL]
-//   Wrapper for OCIEnvNlsCreate().
-//-----------------------------------------------------------------------------
-int dpiOci__envNlsCreate(void **envHandle, uint32_t mode, uint16_t charsetId,
-        uint16_t ncharsetId, dpiError *error)
-{
-    void *mallocFn = NULL, *reallocFn = NULL, *freeFn = NULL;
-    int status;
-
-    *envHandle = NULL;
-    DPI_OCI_LOAD_SYMBOL("OCIEnvNlsCreate", dpiOciSymbols.fnEnvNlsCreate)
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_MEM) {
-        mallocFn = (void*) dpiOci__allocateMem;
-        reallocFn = (void*) dpiOci__reallocMem;
-        freeFn = (void*) dpiOci__freeMem;
-    }
-    status = (*dpiOciSymbols.fnEnvNlsCreate)(envHandle, mode, NULL, mallocFn,
-            reallocFn, freeFn, 0, NULL, charsetId, ncharsetId);
-    if (*envHandle) {
-        if (status == DPI_OCI_SUCCESS || status == DPI_OCI_SUCCESS_WITH_INFO)
-            return DPI_SUCCESS;
-        if (dpiOci__errorGet(*envHandle, DPI_OCI_HTYPE_ENV, charsetId,
-                "create env", error) == 0)
-            return DPI_FAILURE;
-    }
-    return dpiError__set(error, "create env", DPI_ERR_CREATE_ENV);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__errorGet() [INTERNAL]
-//   Wrapper for OCIErrorGet().
-//-----------------------------------------------------------------------------
-int dpiOci__errorGet(void *handle, uint32_t handleType, uint16_t charsetId,
-        const char *action, dpiError *error)
-{
-    uint32_t i, numChars, bufferChars;
-    uint16_t *utf16chars;
-    int status;
-    char *ptr;
-
-    DPI_OCI_LOAD_SYMBOL("OCIErrorGet", dpiOciSymbols.fnErrorGet)
-    status = (*dpiOciSymbols.fnErrorGet)(handle, 1, NULL, &error->buffer->code,
-            error->buffer->message, sizeof(error->buffer->message),
-            handleType);
-    if (status != DPI_OCI_SUCCESS)
-        return dpiError__set(error, action, DPI_ERR_GET_FAILED);
-    error->buffer->action = action;
-
-    // determine length of message since OCI does not provide this information;
-    // all encodings except UTF-16 can use normal string processing; cannot use
-    // type whar_t for processing UTF-16, though, as its size may be 4 on some
-    // platforms, not 2; also strip trailing whitespace from error messages
-    if (charsetId == DPI_CHARSET_ID_UTF16) {
-        numChars = 0;
-        utf16chars = (uint16_t*) error->buffer->message;
-        bufferChars = sizeof(error->buffer->message) / 2;
-        for (i = 0; i < bufferChars; i++) {
-            if (utf16chars[i] == 0)
-                break;
-            if (utf16chars[i] > 127 || !isspace(utf16chars[i]))
-                numChars = i + 1;
-        }
-        error->buffer->messageLength = numChars * 2;
-    } else {
-        error->buffer->messageLength =
-                (uint32_t) strlen(error->buffer->message);
-        ptr = error->buffer->message + error->buffer->messageLength - 1;
-        while (ptr > error->buffer->message && isspace((uint8_t) *ptr--))
-            error->buffer->messageLength--;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__freeMem() [INTERNAL]
-//   Wrapper for OCI allocation of memory, only used when debugging memory
-// allocation.
-//-----------------------------------------------------------------------------
-static void dpiOci__freeMem(UNUSED void *unused, void *ptr)
-{
-    char message[40];
-
-    (void) sprintf(message, "OCI freed ptr at %p", ptr);
-    free(ptr);
-    dpiDebug__print("%s\n", message);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__handleAlloc() [INTERNAL]
-//   Wrapper for OCIHandleAlloc().
-//-----------------------------------------------------------------------------
-int dpiOci__handleAlloc(void *envHandle, void **handle, uint32_t handleType,
-        const char *action, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIHandleAlloc", dpiOciSymbols.fnHandleAlloc)
-    status = (*dpiOciSymbols.fnHandleAlloc)(envHandle, handle, handleType, 0,
-            NULL);
-    if (handleType == DPI_OCI_HTYPE_ERROR && status != DPI_OCI_SUCCESS)
-        return dpiError__set(error, action, DPI_ERR_NO_MEMORY);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, action);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__handleFree() [INTERNAL]
-//   Wrapper for OCIHandleFree().
-//-----------------------------------------------------------------------------
-int dpiOci__handleFree(void *handle, uint32_t handleType)
-{
-    dpiError *error = NULL;
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIHandleFree", dpiOciSymbols.fnHandleFree)
-    status = (*dpiOciSymbols.fnHandleFree)(handle, handleType);
-    if (status != DPI_OCI_SUCCESS &&
-            dpiDebugLevel & DPI_DEBUG_LEVEL_UNREPORTED_ERRORS)
-        dpiDebug__print("free handle %p, handleType %d failed\n", handle,
-                handleType);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__intervalGetDaySecond() [INTERNAL]
-//   Wrapper for OCIIntervalGetDaySecond().
-//-----------------------------------------------------------------------------
-int dpiOci__intervalGetDaySecond(void *envHandle, int32_t *day, int32_t *hour,
-        int32_t *minute, int32_t *second, int32_t *fsecond,
-        const void *interval, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIIntervalGetDaySecond",
-            dpiOciSymbols.fnIntervalGetDaySecond)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnIntervalGetDaySecond)(envHandle,
-            error->handle, day, hour, minute, second, fsecond, interval);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get interval components");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__intervalGetYearMonth() [INTERNAL]
-//   Wrapper for OCIIntervalGetYearMonth().
-//-----------------------------------------------------------------------------
-int dpiOci__intervalGetYearMonth(void *envHandle, int32_t *year,
-        int32_t *month, const void *interval, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIIntervalGetYearMonth",
-            dpiOciSymbols.fnIntervalGetYearMonth)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnIntervalGetYearMonth)(envHandle, error->handle,
-            year, month, interval);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get interval components");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__intervalSetDaySecond() [INTERNAL]
-//   Wrapper for OCIIntervalSetDaySecond().
-//-----------------------------------------------------------------------------
-int dpiOci__intervalSetDaySecond(void *envHandle, int32_t day, int32_t hour,
-        int32_t minute, int32_t second, int32_t fsecond, void *interval,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIIntervalSetDaySecond",
-            dpiOciSymbols.fnIntervalSetDaySecond)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnIntervalSetDaySecond)(envHandle, error->handle,
-            day, hour, minute, second, fsecond, interval);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "set interval components");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__intervalSetYearMonth() [INTERNAL]
-//   Wrapper for OCIIntervalSetYearMonth().
-//-----------------------------------------------------------------------------
-int dpiOci__intervalSetYearMonth(void *envHandle, int32_t year, int32_t month,
-        void *interval, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIIntervalSetYearMonth",
-            dpiOciSymbols.fnIntervalSetYearMonth)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnIntervalSetYearMonth)(envHandle, error->handle,
-            year, month, interval);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "set interval components");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__jsonDomDocGet() [INTERNAL]
-//   Wrapper for OCIJsonDomDocGet().
-//-----------------------------------------------------------------------------
-int dpiOci__jsonDomDocGet(dpiJson *json, dpiJznDomDoc **domDoc,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIJsonDomDocGet", dpiOciSymbols.fnJsonDomDocGet)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnJsonDomDocGet)(json->conn->handle, json->handle,
-            domDoc, error->handle, DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, json->conn, "get JSON DOM doc");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__jsonTextBufferParse() [INTERNAL]
-//   Wrapper for OCIJsonTextBufferParse().
-//-----------------------------------------------------------------------------
-int dpiOci__jsonTextBufferParse(dpiJson *json, const char *value,
-        uint64_t valueLength, uint32_t flags, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIJsonTextBufferParse",
-            dpiOciSymbols.fnJsonTextBufferParse)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnJsonTextBufferParse)(json->conn->handle,
-            json->handle, (void*) value, valueLength,
-            (DPI_JZN_ALLOW_SCALAR_DOCUMENTS | flags), DPI_JZN_INPUT_UTF8,
-            error->handle, DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, json->conn, "parse JSON text");
-}
-
-
-#ifdef _WIN32
-
-//-----------------------------------------------------------------------------
-// dpiOci__checkDllArchitecture() [INTERNAL]
-//   Check the architecture of the specified DLL name and check if it
-// matches the expected architecture. If it does not, the load error is
-// modified and DPI_SUCCESS is returned; otherwise, DPI_FAILURE is returned.
-//-----------------------------------------------------------------------------
-static int dpiOci__checkDllArchitecture(dpiOciLoadLibParams *loadParams,
-        const char *name, dpiError *error)
-{
-    const char *errorFormat = "%s is not the correct architecture";
-    IMAGE_DOS_HEADER dosHeader;
-    IMAGE_NT_HEADERS ntHeaders;
-    FILE *fp;
-
-    // check DLL architecture
-    fp = fopen(name, "rb");
-    if (!fp)
-        return DPI_FAILURE;
-    fread(&dosHeader, sizeof(dosHeader), 1, fp);
-    if (dosHeader.e_magic != IMAGE_DOS_SIGNATURE) {
-        fclose(fp);
-        return DPI_FAILURE;
-    }
-    fseek(fp, dosHeader.e_lfanew, SEEK_SET);
-    fread(&ntHeaders, sizeof(ntHeaders), 1, fp);
-    fclose(fp);
-    if (ntHeaders.Signature != IMAGE_NT_SIGNATURE)
-        return DPI_FAILURE;
-
-#if defined _M_AMD64
-    if (ntHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64)
-        return DPI_FAILURE;
-#elif defined _M_IX86
-    if (ntHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_I386)
-        return DPI_FAILURE;
-#else
-    return DPI_FAILURE;
-#endif
-
-    // store a modified error in the error buffer
-    if (dpiUtils__ensureBuffer(strlen(errorFormat) + strlen(name) + 1,
-            "allocate wrong architecture load error buffer",
-            (void**) &loadParams->errorBuffer,
-            &loadParams->errorBufferLength, error) < 0)
-        return DPI_FAILURE;
-    sprintf(loadParams->errorBuffer, errorFormat, name);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__findAndCheckDllArchitecture() [INTERNAL]
-//   Attempt to find the specified DLL name using the standard search path and
-// if the DLL can be found but is of the wrong architecture, include the full
-// name of the DLL in the load error. Return DPI_SUCCESS if such a DLL was
-// found and was of the wrong architecture (in which case the load error has
-// been set); otherwise, return DPI_FAILURE so that the normal load error can
-// be determined.
-//-----------------------------------------------------------------------------
-static int dpiOci__findAndCheckDllArchitecture(dpiOciLoadLibParams *loadParams,
-        const char *name, dpiError *error)
-{
-    DWORD bufferLength;
-    char *temp, *path;
-    size_t length;
-    int status;
-
-    // if the name of the DLL is an absolute path, check it directly
-    temp = strchr(name, '\\');
-    if (temp)
-        return dpiOci__checkDllArchitecture(loadParams, name, error);
-
-    // check current directory
-    bufferLength = GetCurrentDirectory(0, NULL);
-    if (bufferLength == 0)
-        return DPI_FAILURE;
-    if (dpiUtils__ensureBuffer(strlen(name) + 1 + bufferLength,
-            "allocate load params name buffer (current dir)",
-            (void**) &loadParams->nameBuffer,
-            &loadParams->nameBufferLength, error) < 0)
-        return DPI_FAILURE;
-    if (GetCurrentDirectory(bufferLength, loadParams->nameBuffer) == 0)
-        return DPI_FAILURE;
-    temp = loadParams->nameBuffer + strlen(loadParams->nameBuffer);
-    *temp++ = '\\';
-    strcpy(temp, name);
-    status = dpiOci__checkDllArchitecture(loadParams, loadParams->nameBuffer,
-            error);
-
-    // search PATH
-    path = getenv("PATH");
-    if (path) {
-        while (status < 0) {
-            temp = strchr(path, ';');
-            if (temp) {
-                length = temp - path;
-            } else {
-                length = strlen(path);
-            }
-            if (dpiUtils__ensureBuffer(strlen(name) + length + 2,
-                    "allocate load params name buffer (PATH)",
-                    (void**) &loadParams->nameBuffer,
-                    &loadParams->nameBufferLength, error) < 0)
-                return DPI_FAILURE;
-            (void) sprintf(loadParams->nameBuffer, "%.*s\\%s", (int) length,
-                    path, name);
-            status = dpiOci__checkDllArchitecture(loadParams,
-                    loadParams->nameBuffer, error);
-            if (!temp)
-                break;
-            path = temp + 1;
-        }
-    }
-
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__loadLibWithName() [INTERNAL]
-//   Platform specific method of loading the library with a specific name.
-// Load errors are stored in the temporary load error buffer and do not cause
-// the function to fail; other errors (such as memory allocation errors) will
-// result in failure.
-//-----------------------------------------------------------------------------
-static int dpiOci__loadLibWithName(dpiOciLoadLibParams *loadParams,
-        const char *name, dpiError *error)
-{
-    DWORD errorNum;
-
-    // attempt to load the library
-    loadParams->handle = LoadLibrary(name);
-    if (loadParams->handle)
-        return DPI_SUCCESS;
-
-    // if DLL is of the wrong architecture, attempt to locate the DLL that was
-    // loaded and use that information if it can be found
-    errorNum = GetLastError();
-    if (errorNum == ERROR_BAD_EXE_FORMAT &&
-            dpiOci__findAndCheckDllArchitecture(loadParams, name, error) == 0)
-        return DPI_SUCCESS;
-
-    // otherwise, attempt to get the error message
-    return dpiUtils__getWindowsError(errorNum, &loadParams->errorBuffer,
-            &loadParams->errorBufferLength, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__loadLibInModuleDir() [INTERNAL]
-//   Attempts to load the library from the directory in which the ODPI-C module
-// (or its containing module) is located. This is platform specific.
-//-----------------------------------------------------------------------------
-static int dpiOci__loadLibInModuleDir(dpiOciLoadLibParams *loadParams,
-        dpiError *error)
-{
-    HMODULE module = NULL;
-    DWORD result = 0;
-    char *temp;
-
-    // attempt to get the module handle from a known function pointer
-    if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
-            (LPCSTR) dpiContext_createWithParams, &module) == 0)
-        return DPI_FAILURE;
-
-    // attempt to get the module name from the module; the size of the buffer
-    // is increased as needed as there is no other known way to acquire the
-    // full name (MAX_PATH is no longer the maximum path length)
-    if (dpiUtils__ensureBuffer(MAX_PATH, "allocate module name",
-            (void**) &loadParams->moduleNameBuffer,
-            &loadParams->moduleNameBufferLength, error) < 0) {
-        FreeLibrary(module);
-        return DPI_FAILURE;
-    }
-    while (1) {
-        result = GetModuleFileName(module, loadParams->moduleNameBuffer,
-                loadParams->moduleNameBufferLength);
-        if (result < (DWORD) loadParams->moduleNameBufferLength)
-            break;
-        if (dpiUtils__ensureBuffer(loadParams->moduleNameBufferLength * 2,
-                "allocate module name", (void**) &loadParams->moduleNameBuffer,
-                &loadParams->moduleNameBufferLength, error) < 0) {
-            FreeLibrary(module);
-            return DPI_FAILURE;
-        }
-    }
-    FreeLibrary(module);
-    if (result == 0)
-        return DPI_FAILURE;
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
-        dpiDebug__print("module name is %s\n", loadParams->moduleNameBuffer);
-
-    // use the module name to determine the directory and attempt to load the
-    // Oracle client libraries from there
-    temp = strrchr(loadParams->moduleNameBuffer, '\\');
-    if (temp) {
-        *temp = '\0';
-        return dpiOci__loadLibWithDir(loadParams, loadParams->moduleNameBuffer,
-                strlen(loadParams->moduleNameBuffer), 0, error);
-    }
-
-    return DPI_FAILURE;
-}
-
-
-// for platforms other than Windows
-#else
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__loadLibInModuleDir() [INTERNAL]
-//   Attempts to load the library from the directory in which the ODPI-C module
-// (or its containing module) is located. This is platform specific.
-//-----------------------------------------------------------------------------
-static int dpiOci__loadLibInModuleDir(dpiOciLoadLibParams *loadParams,
-        dpiError *error)
-{
-#ifndef _AIX
-    char *dirName;
-    Dl_info info;
-
-    if (dladdr(dpiContext_createWithParams, &info) != 0) {
-        if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
-            dpiDebug__print("module name is %s\n", info.dli_fname);
-        dirName = strrchr(info.dli_fname, '/');
-        if (dirName)
-            return dpiOci__loadLibWithDir(loadParams, info.dli_fname,
-                    (size_t) (dirName - info.dli_fname), 0, error);
-    }
-#endif
-
-    return DPI_FAILURE;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__loadLibWithName() [INTERNAL]
-//   Platform specific method of loading the library with a specific name.
-// Load errors are stored in the temporary load error buffer and do not cause
-// the function to fail; other errors (such as memory allocation errors) will
-// result in failure.
-//-----------------------------------------------------------------------------
-static int dpiOci__loadLibWithName(dpiOciLoadLibParams *loadParams,
-        const char *libName, dpiError *error)
-{
-    char *osError;
-
-    loadParams->handle = dlopen(libName, RTLD_LAZY);
-    if (!loadParams->handle) {
-        osError = dlerror();
-        if (dpiUtils__ensureBuffer(strlen(osError) + 1,
-                "allocate load error buffer",
-                (void**) &loadParams->errorBuffer,
-                &loadParams->errorBufferLength, error) < 0)
-            return DPI_FAILURE;
-        strcpy(loadParams->errorBuffer, osError);
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__loadLibWithOracleHome() [INTERNAL]
-//   Attempts to load the library from the lib subdirectory of an Oracle home
-// pointed to by the environemnt variable ORACLE_HOME.
-//-----------------------------------------------------------------------------
-static int dpiOci__loadLibWithOracleHome(dpiOciLoadLibParams *loadParams,
-        dpiError *error)
-{
-    char *oracleHome, *oracleHomeLibDir;
-    size_t oracleHomeLength;
-    int status;
-
-    // check environment variable; if not set, attempt cannot proceed
-    oracleHome = getenv("ORACLE_HOME");
-    if (!oracleHome)
-        return DPI_FAILURE;
-
-    // a zero-length directory is ignored
-    oracleHomeLength = strlen(oracleHome);
-    if (oracleHomeLength == 0)
-        return DPI_FAILURE;
-
-    // craft directory to search
-    if (dpiUtils__allocateMemory(1, oracleHomeLength + 5, 0,
-            "allocate ORACLE_HOME dir name", (void**) &oracleHomeLibDir,
-            error) < 0)
-        return DPI_FAILURE;
-    (void) sprintf(oracleHomeLibDir, "%s/lib", oracleHome);
-
-    // perform search
-    status = dpiOci__loadLibWithDir(loadParams, oracleHomeLibDir,
-           strlen(oracleHomeLibDir), 0, error);
-    dpiUtils__freeMemory(oracleHomeLibDir);
-    return status;
-}
-
-#endif
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__loadLibWithDir() [INTERNAL]
-//   Helper function for loading the OCI library. If a directory is specified,
-// that directory is searched; otherwise, an unqualfied search is performed
-// using the normal OS library loading rules.
-//-----------------------------------------------------------------------------
-static int dpiOci__loadLibWithDir(dpiOciLoadLibParams *loadParams,
-        const char *dirName, size_t dirNameLength, int scanAllNames,
-        dpiError *error)
-{
-    const char *searchName;
-    size_t nameLength;
-    int i;
-
-    // report attempt with directory, if applicable
-    if (dirName && dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
-        dpiDebug__print("load in dir %.*s\n", (int) dirNameLength, dirName);
-
-    // iterate over all possible options
-    for (i = 0; dpiOciLibNames[i]; i++) {
-
-        // determine name to search
-        if (!dirName) {
-            searchName = dpiOciLibNames[i];
-        } else {
-            nameLength = strlen(dpiOciLibNames[i]) + dirNameLength + 2;
-            if (dpiUtils__ensureBuffer(nameLength, "allocate name buffer",
-                    (void**) &loadParams->nameBuffer,
-                    &loadParams->nameBufferLength, error) < 0)
-                return DPI_FAILURE;
-            (void) sprintf(loadParams->nameBuffer, "%.*s/%s",
-                    (int) dirNameLength, dirName, dpiOciLibNames[i]);
-            searchName = loadParams->nameBuffer;
-        }
-
-        // attempt to load the library using the calculated name; failure here
-        // implies something other than a load failure and this error is
-        // reported immediately
-        if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
-            dpiDebug__print("load with name %s\n", searchName);
-        if (dpiOci__loadLibWithName(loadParams, searchName, error) < 0)
-            return DPI_FAILURE;
-
-        // success is also reported immediately
-        if (loadParams->handle) {
-            if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
-                dpiDebug__print("load by OS successful\n");
-            return DPI_SUCCESS;
-        }
-
-        // load failed; store the first failure that occurs which will be
-        // reported if no successful loads were made and no other errors took
-        // place
-        if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
-            dpiDebug__print("load by OS failure: %s\n",
-                    loadParams->errorBuffer);
-        if (i == 0) {
-            if (dpiUtils__ensureBuffer(loadParams->errorBufferLength,
-                    "allocate load error buffer",
-                    (void**) &loadParams->loadError,
-                    &loadParams->loadErrorLength, error) < 0)
-                return DPI_FAILURE;
-            strcpy(loadParams->loadError, loadParams->errorBuffer);
-            if (!scanAllNames)
-                break;
-        }
-
-    }
-
-    // no attempts were successful
-    return DPI_FAILURE;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__loadLib() [INTERNAL]
-//   Load the OCI library.
-//-----------------------------------------------------------------------------
-int dpiOci__loadLib(dpiContextCreateParams *params,
-        dpiVersionInfo *clientVersionInfo, dpiError *error)
-{
-    static const char *envNamesToCheck[] = {
-        "ORACLE_HOME",
-        "ORA_TZFILE",
-        "TNS_ADMIN",
-#ifdef _WIN32
-        "PATH",
-#else
-        "LD_LIBRARY_PATH",
-        "DYLD_LIBRARY_PATH",
-        "LIBPATH",
-        "SHLIB_PATH",
-#endif
-        NULL
-    };
-    dpiOciLoadLibParams loadLibParams;
-    const char *temp;
-    int status, i;
-
-    // log the directory parameter values and any environment variables that
-    // have an impact on loading the library
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB) {
-
-        // first log directory parameter values
-        dpiDebug__print("Context Parameters:\n");
-        if (params->oracleClientLibDir)
-            dpiDebug__print("    Oracle Client Lib Dir: %s\n",
-                    params->oracleClientLibDir);
-        if (params->oracleClientConfigDir)
-            dpiDebug__print("    Oracle Client Config Dir: %s\n",
-                    params->oracleClientConfigDir);
-
-        // now log environment variable values
-        dpiDebug__print("Environment Variables:\n");
-        for (i = 0; envNamesToCheck[i]; i++) {
-            temp = getenv(envNamesToCheck[i]);
-            if (temp)
-                dpiDebug__print("    %s => \"%s\"\n", envNamesToCheck[i],
-                        temp);
-        }
-
-    }
-
-    // if a config directory was specified in the create params, set the
-    // TNS_ADMIN environment variable
-    if (params->oracleClientConfigDir) {
-#ifdef _WIN32
-        if (!SetEnvironmentVariable("TNS_ADMIN",
-                    params->oracleClientConfigDir)) {
-#else
-        if (setenv("TNS_ADMIN", params->oracleClientConfigDir, 1) != 0) {
-#endif
-            return dpiError__setFromOS(error,
-                    "set TNS_ADMIN environment variable");
-        }
-    }
-
-    // initialize loading parameters; these are used to provide space for
-    // loading errors and the names that are being searched; memory is
-    // allocated dynamically in order to avoid potential issues with long paths
-    // on some platforms
-    memset(&loadLibParams, 0, sizeof(loadLibParams));
-
-    // if a lib directory was specified in the create params, look for the OCI
-    // library in that location only
-    if (params->oracleClientLibDir) {
-        if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
-            dpiDebug__print("load in parameter directory\n");
-        status = dpiOci__loadLibWithDir(&loadLibParams,
-                params->oracleClientLibDir, strlen(params->oracleClientLibDir),
-                1, error);
-
-    // otherwise, use the normal loading mechanism
-    } else {
-
-        // first try the directory in which the ODPI-C library itself is found
-        if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
-            dpiDebug__print("check module directory\n");
-        status = dpiOci__loadLibInModuleDir(&loadLibParams, error);
-
-        // if that fails, try the default OS library loading mechanism
-        if (status < 0) {
-            if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
-                dpiDebug__print("load with OS search heuristics\n");
-            status = dpiOci__loadLibWithDir(&loadLibParams, NULL, 0, 1, error);
-        }
-
-#ifndef _WIN32
-        // if that fails, on platforms other than Windows, attempt to load
-        // from $ORACLE_HOME/lib
-        if (status < 0) {
-            if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
-                dpiDebug__print("check ORACLE_HOME\n");
-            status = dpiOci__loadLibWithOracleHome(&loadLibParams, error);
-        }
-#endif
-
-    }
-
-    // if no attempts succeeded and no other error was reported, craft the
-    // error message that will be returned
-    if (status < 0 && (int) error->buffer->errorNum == 0) {
-        const char *bits = (sizeof(void*) == 8) ? "64" : "32";
-        dpiError__set(error, "load library", DPI_ERR_LOAD_LIBRARY,
-                bits, loadLibParams.loadError, params->loadErrorUrl);
-    }
-
-    // free any memory that was allocated
-    if (loadLibParams.nameBuffer)
-        dpiUtils__freeMemory(loadLibParams.nameBuffer);
-    if (loadLibParams.moduleNameBuffer)
-        dpiUtils__freeMemory(loadLibParams.moduleNameBuffer);
-    if (loadLibParams.loadError)
-        dpiUtils__freeMemory(loadLibParams.loadError);
-    if (loadLibParams.errorBuffer)
-        dpiUtils__freeMemory(loadLibParams.errorBuffer);
-
-    // if no attempts, succeeded, return an error
-    if (status < 0)
-        return DPI_FAILURE;
-
-    // validate library
-    dpiOciLibHandle = loadLibParams.handle;
-    if (dpiOci__loadLibValidate(clientVersionInfo, error) < 0) {
-#ifdef _WIN32
-        FreeLibrary(dpiOciLibHandle);
-#else
-        dlclose(dpiOciLibHandle);
-#endif
-        dpiOciLibHandle = NULL;
-        memset(&dpiOciSymbols, 0, sizeof(dpiOciSymbols));
-        return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__loadLibValidate() [INTERNAL]
-//   Validate the OCI library after loading.
-//-----------------------------------------------------------------------------
-static int dpiOci__loadLibValidate(dpiVersionInfo *clientVersionInfo,
-        dpiError *error)
-{
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
-        dpiDebug__print("validating loaded library\n");
-
-    // determine the OCI client version information
-    if (dpiOci__loadSymbol("OCIClientVersion",
-            (void**) &dpiOciSymbols.fnClientVersion, NULL) < 0)
-        return dpiError__set(error, "load symbol OCIClientVersion",
-                DPI_ERR_ORACLE_CLIENT_UNSUPPORTED);
-    memset(clientVersionInfo, 0, sizeof(*clientVersionInfo));
-    (*dpiOciSymbols.fnClientVersion)(&clientVersionInfo->versionNum,
-            &clientVersionInfo->releaseNum,
-            &clientVersionInfo->updateNum,
-            &clientVersionInfo->portReleaseNum,
-            &clientVersionInfo->portUpdateNum);
-    if (clientVersionInfo->versionNum == 0)
-        return dpiError__set(error, "get OCI client version",
-                DPI_ERR_ORACLE_CLIENT_UNSUPPORTED);
-    clientVersionInfo->fullVersionNum = (uint32_t)
-            DPI_ORACLE_VERSION_TO_NUMBER(clientVersionInfo->versionNum,
-                    clientVersionInfo->releaseNum,
-                    clientVersionInfo->updateNum,
-                    clientVersionInfo->portReleaseNum,
-                    clientVersionInfo->portUpdateNum);
-
-    // OCI version must be a minimum of 11.2
-    if (dpiUtils__checkClientVersion(clientVersionInfo, 11, 2, error) < 0)
-        return DPI_FAILURE;
-
-    // initialize threading capability in the OCI library
-    // this must be run prior to any other OCI threading calls
-    DPI_OCI_LOAD_SYMBOL("OCIThreadProcessInit",
-            dpiOciSymbols.fnThreadProcessInit)
-    (*dpiOciSymbols.fnThreadProcessInit)();
-
-    // load symbols for key functions which are called many times
-    // this list should be kept as small as possible in order to avoid
-    // overhead in looking up symbols at startup
-    DPI_OCI_LOAD_SYMBOL("OCIAttrGet", dpiOciSymbols.fnAttrGet)
-    DPI_OCI_LOAD_SYMBOL("OCIAttrSet", dpiOciSymbols.fnAttrSet)
-    DPI_OCI_LOAD_SYMBOL("OCIThreadKeyGet", dpiOciSymbols.fnThreadKeyGet)
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__loadSymbol() [INTERNAL]
-//   Return the symbol for the function that is to be called. The symbol table
-// is first consulted. If the symbol is not found there, it is looked up and
-// then stored there so the next invocation does not have to perform the
-// lookup.
-//-----------------------------------------------------------------------------
-static int dpiOci__loadSymbol(const char *symbolName, void **symbol,
-        dpiError *error)
-{
-#ifdef _WIN32
-    *symbol = GetProcAddress(dpiOciLibHandle, symbolName);
-#else
-    *symbol = dlsym(dpiOciLibHandle, symbolName);
-#endif
-    if (!*symbol)
-        return dpiError__set(error, "get symbol", DPI_ERR_LOAD_SYMBOL,
-                symbolName);
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobClose() [INTERNAL]
-//   Wrapper for OCILobClose().
-//-----------------------------------------------------------------------------
-int dpiOci__lobClose(dpiLob *lob, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCILobClose", dpiOciSymbols.fnLobClose)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnLobClose)(lob->conn->handle, error->handle,
-            lob->locator);
-    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "close LOB");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobCreateTemporary() [INTERNAL]
-//   Wrapper for OCILobCreateTemporary().
-//-----------------------------------------------------------------------------
-int dpiOci__lobCreateTemporary(dpiLob *lob, dpiError *error)
-{
-    uint8_t lobType;
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCILobCreateTemporary",
-            dpiOciSymbols.fnLobCreateTemporary)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    if (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_BLOB)
-        lobType = DPI_OCI_TEMP_BLOB;
-    else lobType = DPI_OCI_TEMP_CLOB;
-    status = (*dpiOciSymbols.fnLobCreateTemporary)(lob->conn->handle,
-            error->handle, lob->locator, DPI_OCI_DEFAULT,
-            lob->type->charsetForm, lobType, 1, DPI_OCI_DURATION_SESSION);
-    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "create temporary LOB");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobFileExists() [INTERNAL]
-//   Wrapper for OCILobFileExists().
-//-----------------------------------------------------------------------------
-int dpiOci__lobFileExists(dpiLob *lob, int *exists, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCILobFileExists", dpiOciSymbols.fnLobFileExists)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnLobFileExists)(lob->conn->handle, error->handle,
-            lob->locator, exists);
-    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "get file exists");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobFileGetName() [INTERNAL]
-//   Wrapper for OCILobFileGetName().
-//-----------------------------------------------------------------------------
-int dpiOci__lobFileGetName(dpiLob *lob, char *dirAlias,
-        uint16_t *dirAliasLength, char *name, uint16_t *nameLength,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCILobFileGetName", dpiOciSymbols.fnLobFileGetName)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnLobFileGetName)(lob->env->handle, error->handle,
-            lob->locator, dirAlias, dirAliasLength, name, nameLength);
-    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "get LOB file name");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobFileSetName() [INTERNAL]
-//   Wrapper for OCILobFileSetName().
-//-----------------------------------------------------------------------------
-int dpiOci__lobFileSetName(dpiLob *lob, const char *dirAlias,
-        uint16_t dirAliasLength, const char *name, uint16_t nameLength,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCILobFileSetName", dpiOciSymbols.fnLobFileSetName)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnLobFileSetName)(lob->env->handle, error->handle,
-            &lob->locator, dirAlias, dirAliasLength, name, nameLength);
-    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "set LOB file name");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobFreeTemporary() [INTERNAL]
-//   Wrapper for OCILobFreeTemporary().
-//-----------------------------------------------------------------------------
-int dpiOci__lobFreeTemporary(dpiConn *conn, void *lobLocator, int checkError,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCILobFreeTemporary",
-            dpiOciSymbols.fnLobFreeTemporary)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnLobFreeTemporary)(conn->handle,
-            error->handle, lobLocator);
-    if (!checkError)
-        return DPI_SUCCESS;
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "free temporary LOB");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobGetChunkSize() [INTERNAL]
-//   Wrapper for OCILobGetChunkSize().
-//-----------------------------------------------------------------------------
-int dpiOci__lobGetChunkSize(dpiLob *lob, uint32_t *size, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCILobGetChunkSize", dpiOciSymbols.fnLobGetChunkSize)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnLobGetChunkSize)(lob->conn->handle,
-            error->handle, lob->locator, size);
-    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "get chunk size");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobGetLength2() [INTERNAL]
-//   Wrapper for OCILobGetLength2().
-//-----------------------------------------------------------------------------
-int dpiOci__lobGetLength2(dpiLob *lob, uint64_t *size, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCILobGetLength2", dpiOciSymbols.fnLobGetLength2)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnLobGetLength2)(lob->conn->handle, error->handle,
-            lob->locator, size);
-    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "get length");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobIsOpen() [INTERNAL]
-//   Wrapper for OCILobIsOpen().
-//-----------------------------------------------------------------------------
-int dpiOci__lobIsOpen(dpiLob *lob, int *isOpen, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCILobIsOpen", dpiOciSymbols.fnLobIsOpen)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnLobIsOpen)(lob->conn->handle, error->handle,
-            lob->locator, isOpen);
-    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "check is open");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobIsTemporary() [INTERNAL]
-//   Wrapper for OCILobIsTemporary().
-//-----------------------------------------------------------------------------
-int dpiOci__lobIsTemporary(dpiLob *lob, int *isTemporary, int checkError,
-        dpiError *error)
-{
-    int status;
-
-    *isTemporary = 0;
-    DPI_OCI_LOAD_SYMBOL("OCILobIsTemporary", dpiOciSymbols.fnLobIsTemporary)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnLobIsTemporary)(lob->env->handle, error->handle,
-            lob->locator, isTemporary);
-    if (!checkError)
-        return DPI_SUCCESS;
-    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "check is temporary");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobLocatorAssign() [INTERNAL]
-//   Wrapper for OCILobLocatorAssign().
-//-----------------------------------------------------------------------------
-int dpiOci__lobLocatorAssign(dpiLob *lob, void **copiedHandle, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCILobLocatorAssign",
-            dpiOciSymbols.fnLobLocatorAssign)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnLobLocatorAssign)(lob->conn->handle,
-            error->handle, lob->locator, copiedHandle);
-    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "assign locator");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobOpen() [INTERNAL]
-//   Wrapper for OCILobOpen().
-//-----------------------------------------------------------------------------
-int dpiOci__lobOpen(dpiLob *lob, dpiError *error)
-{
-    uint8_t mode;
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCILobOpen", dpiOciSymbols.fnLobOpen)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    mode = (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_BFILE) ?
-            DPI_OCI_LOB_READONLY : DPI_OCI_LOB_READWRITE;
-    status = (*dpiOciSymbols.fnLobOpen)(lob->conn->handle, error->handle,
-            lob->locator, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "close LOB");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobRead2() [INTERNAL]
-//   Wrapper for OCILobRead2().
-//-----------------------------------------------------------------------------
-int dpiOci__lobRead2(dpiLob *lob, uint64_t offset, uint64_t *amountInBytes,
-        uint64_t *amountInChars, char *buffer, uint64_t bufferLength,
-        dpiError *error)
-{
-    uint16_t charsetId;
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCILobRead2", dpiOciSymbols.fnLobRead2)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    charsetId = (lob->type->charsetForm == DPI_SQLCS_NCHAR) ?
-            lob->env->ncharsetId : lob->env->charsetId;
-    status = (*dpiOciSymbols.fnLobRead2)(lob->conn->handle, error->handle,
-            lob->locator, amountInBytes, amountInChars, offset, buffer,
-            bufferLength, DPI_OCI_ONE_PIECE, NULL, NULL, charsetId,
-            lob->type->charsetForm);
-    if (status == DPI_OCI_NEED_DATA) {
-        *amountInChars = 0;
-        *amountInBytes = 0;
-        return DPI_SUCCESS;
-    }
-    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "read from LOB");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobTrim2() [INTERNAL]
-//   Wrapper for OCILobTrim2().
-//-----------------------------------------------------------------------------
-int dpiOci__lobTrim2(dpiLob *lob, uint64_t newLength, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCILobTrim2", dpiOciSymbols.fnLobTrim2)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnLobTrim2)(lob->conn->handle, error->handle,
-            lob->locator, newLength);
-    if (status == DPI_OCI_INVALID_HANDLE)
-        return dpiOci__lobCreateTemporary(lob, error);
-    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "trim LOB");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__lobWrite2() [INTERNAL]
-//   Wrapper for OCILobWrite2().
-//-----------------------------------------------------------------------------
-int dpiOci__lobWrite2(dpiLob *lob, uint64_t offset, const char *value,
-        uint64_t valueLength, dpiError *error)
-{
-    uint64_t lengthInBytes = valueLength, lengthInChars = 0;
-    uint16_t charsetId;
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCILobWrite2", dpiOciSymbols.fnLobWrite2)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    charsetId = (lob->type->charsetForm == DPI_SQLCS_NCHAR) ?
-            lob->env->ncharsetId : lob->env->charsetId;
-    status = (*dpiOciSymbols.fnLobWrite2)(lob->conn->handle, error->handle,
-            lob->locator, &lengthInBytes, &lengthInChars, offset, (void*) value,
-            valueLength, DPI_OCI_ONE_PIECE, NULL, NULL, charsetId,
-            lob->type->charsetForm);
-    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "write to LOB");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__memoryAlloc() [INTERNAL]
-//   Wrapper for OCIMemoryAlloc().
-//-----------------------------------------------------------------------------
-int dpiOci__memoryAlloc(dpiConn *conn, void **ptr, uint32_t size,
-        int checkError, dpiError *error)
-{
-    int status;
-
-    *ptr = NULL;
-    DPI_OCI_LOAD_SYMBOL("OCIMemoryAlloc", dpiOciSymbols.fnMemoryAlloc)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnMemoryAlloc)(conn->sessionHandle, error->handle,
-            ptr, DPI_OCI_DURATION_SESSION, size, DPI_OCI_MEMORY_CLEARED);
-    if (!checkError)
-        return DPI_SUCCESS;
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "allocate memory");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__memoryFree() [INTERNAL]
-//   Wrapper for OCIMemoryFree().
-//-----------------------------------------------------------------------------
-int dpiOci__memoryFree(dpiConn *conn, void *ptr, dpiError *error)
-{
-    DPI_OCI_LOAD_SYMBOL("OCIMemoryFree", dpiOciSymbols.fnMemoryFree)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    (*dpiOciSymbols.fnMemoryFree)(conn->sessionHandle, error->handle, ptr);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__nlsCharSetConvert() [INTERNAL]
-//   Wrapper for OCINlsCharSetConvert().
-//-----------------------------------------------------------------------------
-int dpiOci__nlsCharSetConvert(void *envHandle, uint16_t destCharsetId,
-        char *dest, size_t destLength, uint16_t sourceCharsetId,
-        const char *source, size_t sourceLength, size_t *resultSize,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCINlsCharSetConvert",
-            dpiOciSymbols.fnNlsCharSetConvert)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnNlsCharSetConvert)(envHandle, error->handle,
-            destCharsetId, dest, destLength, sourceCharsetId, source,
-            sourceLength, resultSize);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "convert text");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__nlsCharSetIdToName() [INTERNAL]
-//   Wrapper for OCINlsCharSetIdToName().
-//-----------------------------------------------------------------------------
-int dpiOci__nlsCharSetIdToName(void *envHandle, char *buf, size_t bufLength,
-        uint16_t charsetId, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCINlsCharSetIdToName",
-            dpiOciSymbols.fnNlsCharSetIdToName)
-    status = (*dpiOciSymbols.fnNlsCharSetIdToName)(envHandle, buf, bufLength,
-            charsetId);
-    return (status == DPI_OCI_SUCCESS) ? DPI_SUCCESS : DPI_FAILURE;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__nlsCharSetNameToId() [INTERNAL]
-//   Wrapper for OCINlsCharSetNameToId().
-//-----------------------------------------------------------------------------
-int dpiOci__nlsCharSetNameToId(void *envHandle, const char *name,
-        uint16_t *charsetId, dpiError *error)
-{
-    DPI_OCI_LOAD_SYMBOL("OCINlsCharSetNameToId",
-            dpiOciSymbols.fnNlsCharSetNameToId)
-    *charsetId = (*dpiOciSymbols.fnNlsCharSetNameToId)(envHandle, name);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__nlsEnvironmentVariableGet() [INTERNAL]
-//   Wrapper for OCIEnvironmentVariableGet().
-//-----------------------------------------------------------------------------
-int dpiOci__nlsEnvironmentVariableGet(uint16_t item, void *value,
-        dpiError *error)
-{
-    size_t ignored;
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCINlsEnvironmentVariableGet",
-            dpiOciSymbols.fnNlsEnvironmentVariableGet)
-    status = (*dpiOciSymbols.fnNlsEnvironmentVariableGet)(value, 0, item, 0,
-            &ignored);
-    if (status != DPI_OCI_SUCCESS)
-        return dpiError__set(error, "get NLS environment variable",
-                DPI_ERR_NLS_ENV_VAR_GET);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__nlsNameMap() [INTERNAL]
-//   Wrapper for OCINlsNameMap().
-//-----------------------------------------------------------------------------
-int dpiOci__nlsNameMap(void *envHandle, char *buf, size_t bufLength,
-        const char *source, uint32_t flag, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCINlsNameMap", dpiOciSymbols.fnNlsNameMap)
-    status = (*dpiOciSymbols.fnNlsNameMap)(envHandle, buf, bufLength, source,
-            flag);
-    return (status == DPI_OCI_SUCCESS) ? DPI_SUCCESS : DPI_FAILURE;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__nlsNumericInfoGet() [INTERNAL]
-//   Wrapper for OCINlsNumericInfoGet().
-//-----------------------------------------------------------------------------
-int dpiOci__nlsNumericInfoGet(void *envHandle, int32_t *value, uint16_t item,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCINlsNumericInfoGet",
-            dpiOciSymbols.fnNlsNumericInfoGet)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnNlsNumericInfoGet)(envHandle, error->handle,
-            value, item);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get NLS info");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__numberFromInt() [INTERNAL]
-//   Wrapper for OCINumberFromInt().
-//-----------------------------------------------------------------------------
-int dpiOci__numberFromInt(const void *value, unsigned int valueLength,
-        unsigned int flags, void *number, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCINumberFromInt", dpiOciSymbols.fnNumberFromInt)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnNumberFromInt)(error->handle, value,
-            valueLength, flags, number);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "number from integer");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__numberFromReal() [INTERNAL]
-//   Wrapper for OCINumberFromReal().
-//-----------------------------------------------------------------------------
-int dpiOci__numberFromReal(const double value, void *number, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCINumberFromReal", dpiOciSymbols.fnNumberFromReal)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnNumberFromReal)(error->handle, &value,
-            sizeof(double), number);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "number from real");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__numberToInt() [INTERNAL]
-//   Wrapper for OCINumberToInt().
-//-----------------------------------------------------------------------------
-int dpiOci__numberToInt(void *number, void *value, unsigned int valueLength,
-        unsigned int flags, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCINumberToInt", dpiOciSymbols.fnNumberToInt)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnNumberToInt)(error->handle, number, valueLength,
-            flags, value);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "number to integer");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__numberToReal() [INTERNAL]
-//   Wrapper for OCINumberToReal().
-//-----------------------------------------------------------------------------
-int dpiOci__numberToReal(double *value, void *number, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCINumberToReal", dpiOciSymbols.fnNumberToReal)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnNumberToReal)(error->handle, number,
-            sizeof(double), value);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "number to real");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__objectCopy() [INTERNAL]
-//   Wrapper for OCIObjectCopy().
-//-----------------------------------------------------------------------------
-int dpiOci__objectCopy(dpiObject *obj, void *sourceInstance,
-        void *sourceIndicator, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIObjectCopy", dpiOciSymbols.fnObjectCopy)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnObjectCopy)(obj->env->handle, error->handle,
-            obj->type->conn->handle, sourceInstance, sourceIndicator,
-            obj->instance, obj->indicator, obj->type->tdo,
-            DPI_OCI_DURATION_SESSION, DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "copy object");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__objectFree() [INTERNAL]
-//   Wrapper for OCIObjectFree().
-//-----------------------------------------------------------------------------
-int dpiOci__objectFree(void *envHandle, void *data, int checkError,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIObjectFree", dpiOciSymbols.fnObjectFree)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnObjectFree)(envHandle, error->handle, data,
-            DPI_OCI_DEFAULT);
-    if (checkError && DPI_OCI_ERROR_OCCURRED(status)) {
-        dpiError__setFromOCI(error, status, NULL, "free instance");
-
-        // during the attempt to free, PL/SQL records fail with error
-        // "ORA-21602: operation does not support the specified typecode", but
-        // a subsequent attempt will yield error "OCI-21500: internal error
-        // code" and crash the process, so pretend like the free was
-        // successful!
-        if (error->buffer->code == 21602)
-            return DPI_SUCCESS;
-        return DPI_FAILURE;
-    }
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__objectGetAttr() [INTERNAL]
-//   Wrapper for OCIObjectGetAttr().
-//-----------------------------------------------------------------------------
-int dpiOci__objectGetAttr(dpiObject *obj, dpiObjectAttr *attr,
-        int16_t *scalarValueIndicator, void **valueIndicator, void **value,
-        void **tdo, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIObjectGetAttr", dpiOciSymbols.fnObjectGetAttr)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnObjectGetAttr)(obj->env->handle, error->handle,
-            obj->instance, obj->indicator, obj->type->tdo, &attr->name,
-            &attr->nameLength, 1, 0, 0, scalarValueIndicator, valueIndicator,
-            value, tdo);
-    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "get attribute");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__objectGetInd() [INTERNAL]
-//   Wrapper for OCIObjectGetInd().
-//-----------------------------------------------------------------------------
-int dpiOci__objectGetInd(dpiObject *obj, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIObjectGetInd", dpiOciSymbols.fnObjectGetInd)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnObjectGetInd)(obj->env->handle, error->handle,
-            obj->instance, &obj->indicator);
-    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "get indicator");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__objectNew() [INTERNAL]
-//   Wrapper for OCIObjectNew().
-//-----------------------------------------------------------------------------
-int dpiOci__objectNew(dpiObject *obj, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIObjectNew", dpiOciSymbols.fnObjectNew)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnObjectNew)(obj->env->handle, error->handle,
-            obj->type->conn->handle, obj->type->typeCode, obj->type->tdo, NULL,
-            DPI_OCI_DURATION_SESSION, 1, &obj->instance);
-    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "create object");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__objectPin() [INTERNAL]
-//   Wrapper for OCIObjectPin().
-//-----------------------------------------------------------------------------
-int dpiOci__objectPin(void *envHandle, void *objRef, void **obj,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIObjectPin", dpiOciSymbols.fnObjectPin)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnObjectPin)(envHandle, error->handle, objRef,
-            NULL, DPI_OCI_PIN_ANY, DPI_OCI_DURATION_SESSION, DPI_OCI_LOCK_NONE,
-            obj);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "pin reference");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__objectSetAttr() [INTERNAL]
-//   Wrapper for OCIObjectSetAttr().
-//-----------------------------------------------------------------------------
-int dpiOci__objectSetAttr(dpiObject *obj, dpiObjectAttr *attr,
-        int16_t scalarValueIndicator, void *valueIndicator, const void *value,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIObjectSetAttr", dpiOciSymbols.fnObjectSetAttr)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnObjectSetAttr)(obj->env->handle, error->handle,
-            obj->instance, obj->indicator, obj->type->tdo, &attr->name,
-            &attr->nameLength, 1, NULL, 0, scalarValueIndicator,
-            valueIndicator, value);
-    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "set attribute");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__passwordChange() [INTERNAL]
-//   Wrapper for OCIPasswordChange().
-//-----------------------------------------------------------------------------
-int dpiOci__passwordChange(dpiConn *conn, const char *userName,
-        uint32_t userNameLength, const char *oldPassword,
-        uint32_t oldPasswordLength, const char *newPassword,
-        uint32_t newPasswordLength, uint32_t mode, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIPasswordChange", dpiOciSymbols.fnPasswordChange)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnPasswordChange)(conn->handle, error->handle,
-            userName, userNameLength, oldPassword, oldPasswordLength,
-            newPassword, newPasswordLength, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "change password");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__paramGet() [INTERNAL]
-//   Wrapper for OCIParamGet().
-//-----------------------------------------------------------------------------
-int dpiOci__paramGet(const void *handle, uint32_t handleType, void **parameter,
-        uint32_t pos, const char *action, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIParamGet", dpiOciSymbols.fnParamGet)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnParamGet)(handle, handleType, error->handle,
-            parameter, pos);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, action);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__ping() [INTERNAL]
-//   Wrapper for OCIPing().
-//-----------------------------------------------------------------------------
-int dpiOci__ping(dpiConn *conn, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIPing", dpiOciSymbols.fnPing)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnPing)(conn->handle, error->handle,
-            DPI_OCI_DEFAULT);
-    if (DPI_OCI_ERROR_OCCURRED(status)) {
-        dpiError__setFromOCI(error, status, conn, "ping");
-
-        // attempting to ping a database earlier than 10g will result in error
-        // ORA-1010: invalid OCI operation, but that implies a successful ping
-        // so ignore that error and treat it as a successful operation
-        if (error->buffer->code == 1010)
-            return DPI_SUCCESS;
-        return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__rawAssignBytes() [INTERNAL]
-//   Wrapper for OCIRawAssignBytes().
-//-----------------------------------------------------------------------------
-int dpiOci__rawAssignBytes(void *envHandle, const char *value,
-        uint32_t valueLength, void **handle, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIRawAssignBytes", dpiOciSymbols.fnRawAssignBytes)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnRawAssignBytes)(envHandle, error->handle, value,
-            valueLength, handle);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "assign bytes to raw");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__rawPtr() [INTERNAL]
-//   Wrapper for OCIRawPtr().
-//-----------------------------------------------------------------------------
-int dpiOci__rawPtr(void *envHandle, void *handle, void **ptr)
-{
-    dpiError *error = NULL;
-
-    DPI_OCI_LOAD_SYMBOL("OCIRawPtr", dpiOciSymbols.fnRawPtr)
-    *ptr = (*dpiOciSymbols.fnRawPtr)(envHandle, handle);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__rawResize() [INTERNAL]
-//   Wrapper for OCIRawResize().
-//-----------------------------------------------------------------------------
-int dpiOci__rawResize(void *envHandle, void **handle, uint32_t newSize,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIRawResize", dpiOciSymbols.fnRawResize)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnRawResize)(envHandle, error->handle, newSize,
-            handle);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "resize raw");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__rawSize() [INTERNAL]
-//   Wrapper for OCIRawSize().
-//-----------------------------------------------------------------------------
-int dpiOci__rawSize(void *envHandle, void *handle, uint32_t *size)
-{
-    dpiError *error = NULL;
-
-    DPI_OCI_LOAD_SYMBOL("OCIRawSize", dpiOciSymbols.fnRawSize)
-    *size = (*dpiOciSymbols.fnRawSize)(envHandle, handle);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__reallocMem() [INTERNAL]
-//   Wrapper for OCI allocation of memory, only used when debugging memory
-// allocation.
-//-----------------------------------------------------------------------------
-static void *dpiOci__reallocMem(UNUSED void *unused, void *ptr, size_t newSize)
-{
-    char message[80];
-    void *newPtr;
-
-    (void) sprintf(message, "OCI reallocated ptr at %p", ptr);
-    newPtr = realloc(ptr, newSize);
-    dpiDebug__print("%s to %u bytes at %p\n", message, newSize, newPtr);
-    return newPtr;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__rowidToChar() [INTERNAL]
-//   Wrapper for OCIRowidToChar().
-//-----------------------------------------------------------------------------
-int dpiOci__rowidToChar(dpiRowid *rowid, char *buffer, uint16_t *bufferSize,
-        dpiError *error)
-{
-    uint16_t origSize;
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIRowidToChar", dpiOciSymbols.fnRowidToChar)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    origSize = *bufferSize;
-    status = (*dpiOciSymbols.fnRowidToChar)(rowid->handle, buffer, bufferSize,
-            error->handle);
-    if (origSize == 0)
-        return DPI_SUCCESS;
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get rowid as string");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__serverAttach() [INTERNAL]
-//   Wrapper for OCIServerAttach().
-//-----------------------------------------------------------------------------
-int dpiOci__serverAttach(dpiConn *conn, const char *connectString,
-        uint32_t connectStringLength, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIServerAttach", dpiOciSymbols.fnServerAttach)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnServerAttach)(conn->serverHandle, error->handle,
-            connectString, (int32_t) connectStringLength, DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "server attach");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__serverDetach() [INTERNAL]
-//   Wrapper for OCIServerDetach().
-//-----------------------------------------------------------------------------
-int dpiOci__serverDetach(dpiConn *conn, int checkError, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIServerDetach", dpiOciSymbols.fnServerDetach)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnServerDetach)(conn->serverHandle, error->handle,
-            DPI_OCI_DEFAULT);
-    if (!checkError)
-        return DPI_SUCCESS;
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "detatch from server");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__serverRelease() [INTERNAL]
-//   Wrapper for OCIServerRelease().
-//-----------------------------------------------------------------------------
-int dpiOci__serverRelease(dpiConn *conn, char *buffer, uint32_t bufferSize,
-        uint32_t *version, uint32_t mode, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    if (conn->env->versionInfo->versionNum < 18) {
-        DPI_OCI_LOAD_SYMBOL("OCIServerRelease", dpiOciSymbols.fnServerRelease)
-        status = (*dpiOciSymbols.fnServerRelease)(conn->handle, error->handle,
-                buffer, bufferSize, DPI_OCI_HTYPE_SVCCTX, version);
-    } else {
-        DPI_OCI_LOAD_SYMBOL("OCIServerRelease2",
-                dpiOciSymbols.fnServerRelease2)
-        status = (*dpiOciSymbols.fnServerRelease2)(conn->handle, error->handle,
-                buffer, bufferSize, DPI_OCI_HTYPE_SVCCTX, version, mode);
-    }
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "get server version");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sessionBegin() [INTERNAL]
-//   Wrapper for OCISessionBegin().
-//-----------------------------------------------------------------------------
-int dpiOci__sessionBegin(dpiConn *conn, uint32_t credentialType,
-        uint32_t mode, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISessionBegin", dpiOciSymbols.fnSessionBegin)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSessionBegin)(conn->handle, error->handle,
-            conn->sessionHandle, credentialType, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "begin session");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sessionEnd() [INTERNAL]
-//   Wrapper for OCISessionEnd().
-//-----------------------------------------------------------------------------
-int dpiOci__sessionEnd(dpiConn *conn, int checkError, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISessionEnd", dpiOciSymbols.fnSessionEnd)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSessionEnd)(conn->handle, error->handle,
-            conn->sessionHandle, DPI_OCI_DEFAULT);
-    if (!checkError)
-        return DPI_SUCCESS;
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "end session");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sessionGet() [INTERNAL]
-//   Wrapper for OCISessionGet().
-//-----------------------------------------------------------------------------
-int dpiOci__sessionGet(void *envHandle, void **handle, void *authInfo,
-        const char *connectString, uint32_t connectStringLength,
-        const char *tag, uint32_t tagLength, const char **outTag,
-        uint32_t *outTagLength, int *found, uint32_t mode, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISessionGet", dpiOciSymbols.fnSessionGet)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSessionGet)(envHandle, error->handle, handle,
-            authInfo, connectString, connectStringLength, tag, tagLength,
-            outTag, outTagLength, found, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get session");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sessionPoolCreate() [INTERNAL]
-//   Wrapper for OCISessionPoolCreate().
-//-----------------------------------------------------------------------------
-int dpiOci__sessionPoolCreate(dpiPool *pool, const char *connectString,
-        uint32_t connectStringLength, uint32_t minSessions,
-        uint32_t maxSessions, uint32_t sessionIncrement, const char *userName,
-        uint32_t userNameLength, const char *password, uint32_t passwordLength,
-        uint32_t mode, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISessionPoolCreate",
-            dpiOciSymbols.fnSessionPoolCreate)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSessionPoolCreate)(pool->env->handle,
-            error->handle, pool->handle, (char**) &pool->name,
-            &pool->nameLength, connectString, connectStringLength, minSessions,
-            maxSessions, sessionIncrement, userName, userNameLength, password,
-            passwordLength, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "create pool");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sessionPoolDestroy() [INTERNAL]
-//   Wrapper for OCISessionPoolDestroy().
-//-----------------------------------------------------------------------------
-int dpiOci__sessionPoolDestroy(dpiPool *pool, uint32_t mode, int checkError,
-        dpiError *error)
-{
-    void *handle;
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISessionPoolDestroy",
-            dpiOciSymbols.fnSessionPoolDestroy)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-
-    // clear the pool handle immediately so that no further attempts are made
-    // to use the pool while the pool is being closed; if the pool close fails,
-    // restore the pool handle afterwards
-    handle = pool->handle;
-    pool->handle = NULL;
-    status = (*dpiOciSymbols.fnSessionPoolDestroy)(handle, error->handle,
-            mode);
-    if (checkError && DPI_OCI_ERROR_OCCURRED(status)) {
-        pool->handle = handle;
-        return dpiError__setFromOCI(error, status, NULL, "destroy pool");
-    }
-    dpiOci__handleFree(handle, DPI_OCI_HTYPE_SPOOL);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sessionRelease() [INTERNAL]
-//   Wrapper for OCISessionRelease().
-//-----------------------------------------------------------------------------
-int dpiOci__sessionRelease(dpiConn *conn, const char *tag, uint32_t tagLength,
-        uint32_t mode, int checkError, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISessionRelease", dpiOciSymbols.fnSessionRelease)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSessionRelease)(conn->handle, error->handle,
-            tag, tagLength, mode);
-    if (!checkError)
-        return DPI_SUCCESS;
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "release session");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__shardingKeyColumnAdd() [INTERNAL]
-//   Wrapper for OCIshardingKeyColumnAdd().
-//-----------------------------------------------------------------------------
-int dpiOci__shardingKeyColumnAdd(void *shardingKey, void *col, uint32_t colLen,
-        uint16_t colType, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIShardingKeyColumnAdd",
-            dpiOciSymbols.fnShardingKeyColumnAdd)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnShardingKeyColumnAdd)(shardingKey,
-            error->handle, col, colLen, colType, DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "add sharding column");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaBulkInsert() [INTERNAL]
-//   Wrapper for OCISodaBulkInsert().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaBulkInsert(dpiSodaColl *coll, void **documents,
-        uint32_t numDocuments, void *outputOptions, uint32_t mode,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaBulkInsert", dpiOciSymbols.fnSodaBulkInsert)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaBulkInsert)(coll->db->conn->handle,
-            coll->handle, documents, numDocuments, outputOptions,
-            error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "insert multiple documents");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaBulkInsertAndGet() [INTERNAL]
-//   Wrapper for OCISodaBulkInsertAndGet().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaBulkInsertAndGet(dpiSodaColl *coll, void **documents,
-        uint32_t numDocuments, void *outputOptions, uint32_t mode,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaBulkInsertAndGet",
-            dpiOciSymbols.fnSodaBulkInsertAndGet)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaBulkInsertAndGet)(coll->db->conn->handle,
-            coll->handle, documents, numDocuments, outputOptions,
-            error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "insert (and get) multiple documents");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaBulkInsertAndGetWithOpts() [INTERNAL]
-//   Wrapper for OCISodaBulkInsertAndGetWithOpts().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaBulkInsertAndGetWithOpts(dpiSodaColl *coll, void **documents,
-        uint32_t numDocuments, void *operOptions, void *outputOptions,
-        uint32_t mode, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaBulkInsertAndGetWithOpts",
-            dpiOciSymbols.fnSodaBulkInsertAndGetWithOpts)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaBulkInsertAndGetWithOpts)
-            (coll->db->conn->handle, coll->handle, documents, numDocuments,
-             operOptions, outputOptions, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "insert (and get) multiple documents with options");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaCollCreateWithMetadata() [INTERNAL]
-//   Wrapper for OCISodaCollCreateWithMetadata().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaCollCreateWithMetadata(dpiSodaDb *db, const char *name,
-        uint32_t nameLength, const char *metadata, uint32_t metadataLength,
-        uint32_t mode, void **handle, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaCollCreateWithMetadata",
-            dpiOciSymbols.fnSodaCollCreateWithMetadata)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaCollCreateWithMetadata)(db->conn->handle,
-            name, nameLength, metadata, metadataLength, handle, error->handle,
-            mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, db->conn,
-            "create SODA collection");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaCollDrop() [INTERNAL]
-//   Wrapper for OCISodaCollDrop().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaCollDrop(dpiSodaColl *coll, int *isDropped, uint32_t mode,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaCollDrop", dpiOciSymbols.fnSodaCollDrop)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaCollDrop)(coll->db->conn->handle,
-            coll->handle, isDropped, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "drop SODA collection");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaCollGetNext() [INTERNAL]
-//   Wrapper for OCISodaCollGetNext().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaCollGetNext(dpiConn *conn, void *cursorHandle,
-        void **collectionHandle, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaCollGetNext", dpiOciSymbols.fnSodaCollGetNext)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaCollGetNext)(conn->handle, cursorHandle,
-            collectionHandle, error->handle, DPI_OCI_DEFAULT);
-    if (status == DPI_OCI_NO_DATA) {
-        *collectionHandle = NULL;
-        return DPI_SUCCESS;
-    }
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "get next collection");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaCollList() [INTERNAL]
-//   Wrapper for OCISodaCollList().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaCollList(dpiSodaDb *db, const char *startingName,
-        uint32_t startingNameLength, void **handle, uint32_t mode,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaCollList", dpiOciSymbols.fnSodaCollList)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaCollList)(db->conn->handle, startingName,
-            startingNameLength, handle, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, db->conn,
-            "get SODA collection cursor");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaCollOpen() [INTERNAL]
-//   Wrapper for OCISodaCollOpen().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaCollOpen(dpiSodaDb *db, const char *name, uint32_t nameLength,
-        uint32_t mode, void **handle, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaCollOpen", dpiOciSymbols.fnSodaCollOpen)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaCollOpen)(db->conn->handle, name,
-            nameLength, handle, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, db->conn, "open SODA collection");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaCollTruncate() [INTERNAL]
-//   Wrapper for OCISodaCollTruncate().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaCollTruncate(dpiSodaColl *coll, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaCollTruncate",
-            dpiOciSymbols.fnSodaCollTruncate)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaCollTruncate)(coll->db->conn->handle,
-            coll->handle, error->handle, DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "truncate SODA collection");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaDataGuideGet() [INTERNAL]
-//   Wrapper for OCISodaDataGuideGet().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaDataGuideGet(dpiSodaColl *coll, void **handle, uint32_t mode,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaDataGuideGet",
-            dpiOciSymbols.fnSodaDataGuideGet)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaDataGuideGet)(coll->db->conn->handle,
-            coll->handle, DPI_OCI_SODA_AS_AL32UTF8, handle, error->handle,
-            mode);
-    if (DPI_OCI_ERROR_OCCURRED(status)) {
-        dpiError__setFromOCI(error, status, coll->db->conn, "get data guide");
-        if (error->buffer->code != 24801)
-            return DPI_FAILURE;
-        *handle = NULL;
-    }
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaDocCount() [INTERNAL]
-//   Wrapper for OCISodaDocCount().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaDocCount(dpiSodaColl *coll, void *options, uint32_t mode,
-        uint64_t *count, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaDocCount", dpiOciSymbols.fnSodaDocCount)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaDocCount)(coll->db->conn->handle,
-            coll->handle, options, count, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "get document count");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaDocGetNext() [INTERNAL]
-//   Wrapper for OCISodaDocGetNext().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaDocGetNext(dpiSodaDocCursor *cursor, void **handle,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaDocGetNext", dpiOciSymbols.fnSodaDocGetNext)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaDocGetNext)(cursor->coll->db->conn->handle,
-            cursor->handle, handle, error->handle, DPI_OCI_DEFAULT);
-    if (status == DPI_OCI_NO_DATA) {
-        *handle = NULL;
-        return DPI_SUCCESS;
-    }
-    DPI_OCI_CHECK_AND_RETURN(error, status, cursor->coll->db->conn,
-            "get next document");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaFind() [INTERNAL]
-//   Wrapper for OCISodaFind().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaFind(dpiSodaColl *coll, const void *options, uint32_t flags,
-        uint32_t mode, void **handle, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaFind", dpiOciSymbols.fnSodaFind)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaFind)(coll->db->conn->handle,
-            coll->handle, options, flags, handle, error->handle, mode);
-    if (status == DPI_OCI_NO_DATA) {
-        *handle = NULL;
-        return DPI_SUCCESS;
-    }
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "find SODA documents");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaFindOne() [INTERNAL]
-//   Wrapper for OCISodaFindOne().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaFindOne(dpiSodaColl *coll, const void *options, uint32_t flags,
-        uint32_t mode, void **handle, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaFindOne", dpiOciSymbols.fnSodaFindOne)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaFindOne)(coll->db->conn->handle,
-            coll->handle, options, flags, handle, error->handle, mode);
-    if (status == DPI_OCI_NO_DATA) {
-        *handle = NULL;
-        return DPI_SUCCESS;
-    }
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "get SODA document");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaIndexCreate() [INTERNAL]
-//   Wrapper for OCISodaIndexCreate().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaIndexCreate(dpiSodaColl *coll, const char *indexSpec,
-        uint32_t indexSpecLength, uint32_t mode, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaIndexCreate", dpiOciSymbols.fnSodaIndexCreate)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaIndexCreate)(coll->db->conn->handle,
-            coll->handle, indexSpec, indexSpecLength, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn, "create index");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaIndexDrop() [INTERNAL]
-//   Wrapper for OCISodaIndexDrop().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaIndexDrop(dpiSodaColl *coll, const char *name,
-        uint32_t nameLength, uint32_t mode, int *isDropped, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaIndexDrop", dpiOciSymbols.fnSodaIndexDrop)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaIndexDrop)(coll->db->conn->handle, name,
-            nameLength, isDropped, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn, "drop index");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaInsert() [INTERNAL]
-//   Wrapper for OCISodaInsert().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaInsert(dpiSodaColl *coll, void *handle, uint32_t mode,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaInsert", dpiOciSymbols.fnSodaInsert)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaInsert)(coll->db->conn->handle,
-            coll->handle, handle, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "insert SODA document");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaInsertAndGet() [INTERNAL]
-//   Wrapper for OCISodaInsertAndGet().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaInsertAndGet(dpiSodaColl *coll, void **handle, uint32_t mode,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaInsertAndGet",
-            dpiOciSymbols.fnSodaInsertAndGet)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaInsertAndGet)(coll->db->conn->handle,
-            coll->handle, handle, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "insert and get SODA document");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaInsertAndGetWithOpts() [INTERNAL]
-//   Wrapper for OCISodaInsertAndGetWithOpts().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaInsertAndGetWithOpts(dpiSodaColl *coll, void **handle,
-        void *operOptions, uint32_t mode, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaInsertAndGetWithOpts",
-            dpiOciSymbols.fnSodaInsertAndGetWithOpts)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaInsertAndGetWithOpts)
-            (coll->db->conn->handle, coll->handle, handle, operOptions,
-             error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "insert and get SODA document with options");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaOperKeysSet() [INTERNAL]
-//   Wrapper for OCISodaOperKeysSet().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaOperKeysSet(const dpiSodaOperOptions *options, void *handle,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaOperKeysSet", dpiOciSymbols.fnSodaOperKeysSet)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaOperKeysSet)(handle, options->keys,
-            options->keyLengths, options->numKeys, error->handle,
-            DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL,
-            "set operation options keys");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaRemove() [INTERNAL]
-//   Wrapper for OCISodaRemove().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaRemove(dpiSodaColl *coll, void *options, uint32_t mode,
-        uint64_t *count, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaRemove", dpiOciSymbols.fnSodaRemove)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaRemove)(coll->db->conn->handle,
-            coll->handle, options, count, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "remove documents from SODA collection");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaReplOne() [INTERNAL]
-//   Wrapper for OCISodaReplOne().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaReplOne(dpiSodaColl *coll, const void *options, void *handle,
-        uint32_t mode, int *isReplaced, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaReplOne", dpiOciSymbols.fnSodaReplOne)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaReplOne)(coll->db->conn->handle,
-            coll->handle, options, handle, isReplaced, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "replace SODA document");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaReplOneAndGet() [INTERNAL]
-//   Wrapper for OCISodaReplOneAndGet().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaReplOneAndGet(dpiSodaColl *coll, const void *options,
-        void **handle, uint32_t mode, int *isReplaced, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaReplOneAndGet",
-            dpiOciSymbols.fnSodaReplOneAndGet)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaReplOneAndGet)(coll->db->conn->handle,
-            coll->handle, options, handle, isReplaced, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "replace and get SODA document");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaSave() [INTERNAL]
-//   Wrapper for OCISodaSave().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaSave(dpiSodaColl *coll, void *handle, uint32_t mode,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaSave", dpiOciSymbols.fnSodaSave)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaSave)(coll->db->conn->handle,
-            coll->handle, handle, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "save SODA document");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaSaveAndGet() [INTERNAL]
-//   Wrapper for OCISodaSaveAndGet().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaSaveAndGet(dpiSodaColl *coll, void **handle, uint32_t mode,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaSaveAndGet", dpiOciSymbols.fnSodaSaveAndGet)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaSaveAndGet)(coll->db->conn->handle,
-            coll->handle, handle, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "save and get SODA document");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__sodaSaveAndGetWithOpts() [INTERNAL]
-//   Wrapper for OCISodaSaveAndGetWithOpts().
-//-----------------------------------------------------------------------------
-int dpiOci__sodaSaveAndGetWithOpts(dpiSodaColl *coll, void **handle,
-        void *operOptions, uint32_t mode, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISodaSaveAndGetWithOpts",
-            dpiOciSymbols.fnSodaSaveAndGetWithOpts)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSodaSaveAndGetWithOpts)(coll->db->conn->handle,
-            coll->handle, handle, operOptions, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
-            "save and get SODA document");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__stmtExecute() [INTERNAL]
-//   Wrapper for OCIStmtExecute().
-//-----------------------------------------------------------------------------
-int dpiOci__stmtExecute(dpiStmt *stmt, uint32_t numIters, uint32_t mode,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIStmtExecute", dpiOciSymbols.fnStmtExecute)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnStmtExecute)(stmt->conn->handle, stmt->handle,
-            error->handle, numIters, 0, 0, 0, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "execute");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__stmtFetch2() [INTERNAL]
-//   Wrapper for OCIStmtFetch2().
-//-----------------------------------------------------------------------------
-int dpiOci__stmtFetch2(dpiStmt *stmt, uint32_t numRows, uint16_t fetchMode,
-        int32_t offset, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIStmtFetch2", dpiOciSymbols.fnStmtFetch2)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnStmtFetch2)(stmt->handle, error->handle,
-            numRows, fetchMode, offset, DPI_OCI_DEFAULT);
-    if (status == DPI_OCI_NO_DATA || fetchMode == DPI_MODE_FETCH_LAST) {
-        stmt->hasRowsToFetch = 0;
-    } else if (DPI_OCI_ERROR_OCCURRED(status)) {
-        return dpiError__setFromOCI(error, status, stmt->conn, "fetch");
-    } else {
-        stmt->hasRowsToFetch = 1;
-    }
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__stmtGetBindInfo() [INTERNAL]
-//   Wrapper for OCIStmtGetBindInfo().
-//-----------------------------------------------------------------------------
-int dpiOci__stmtGetBindInfo(dpiStmt *stmt, uint32_t size, uint32_t startLoc,
-        int32_t *numFound, char *names[], uint8_t nameLengths[],
-        char *indNames[], uint8_t indNameLengths[], uint8_t isDuplicate[],
-        void *bindHandles[], dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIStmtGetBindInfo", dpiOciSymbols.fnStmtGetBindInfo)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnStmtGetBindInfo)(stmt->handle, error->handle,
-            size, startLoc, numFound, names, nameLengths, indNames,
-            indNameLengths, isDuplicate, bindHandles);
-    if (status == DPI_OCI_NO_DATA) {
-        *numFound = 0;
-        return DPI_SUCCESS;
-    }
-    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "get bind info");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__stmtGetNextResult() [INTERNAL]
-//   Wrapper for OCIStmtGetNextResult().
-//-----------------------------------------------------------------------------
-int dpiOci__stmtGetNextResult(dpiStmt *stmt, void **handle, dpiError *error)
-{
-    uint32_t returnType;
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIStmtGetNextResult",
-            dpiOciSymbols.fnStmtGetNextResult)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnStmtGetNextResult)(stmt->handle, error->handle,
-            handle, &returnType, DPI_OCI_DEFAULT);
-    if (status == DPI_OCI_NO_DATA) {
-        *handle = NULL;
-        return DPI_SUCCESS;
-    }
-    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "get next result");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__stmtPrepare2() [INTERNAL]
-//   Wrapper for OCIStmtPrepare2().
-//-----------------------------------------------------------------------------
-int dpiOci__stmtPrepare2(dpiStmt *stmt, const char *sql, uint32_t sqlLength,
-        const char *tag, uint32_t tagLength, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIStmtPrepare2", dpiOciSymbols.fnStmtPrepare2)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnStmtPrepare2)(stmt->conn->handle, &stmt->handle,
-            error->handle, sql, sqlLength, tag, tagLength, DPI_OCI_NTV_SYNTAX,
-            DPI_OCI_DEFAULT);
-    if (DPI_OCI_ERROR_OCCURRED(status)) {
-        stmt->handle = NULL;
-        return dpiError__setFromOCI(error, status, stmt->conn, "prepare SQL");
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__stmtRelease() [INTERNAL]
-//   Wrapper for OCIStmtRelease().
-//-----------------------------------------------------------------------------
-int dpiOci__stmtRelease(dpiStmt *stmt, const char *tag, uint32_t tagLength,
-        int checkError, dpiError *error)
-{
-    uint32_t mode = DPI_OCI_DEFAULT;
-    uint32_t cacheSize = 0;
-    int status;
-
-    // if the statement should be deleted from the cache, first check to see
-    // that there actually is a cache currently being used; otherwise, the
-    // error "ORA-24300: bad value for mode" will be raised
-    if (stmt->deleteFromCache) {
-        dpiOci__attrGet(stmt->conn->handle, DPI_OCI_HTYPE_SVCCTX,
-                &cacheSize, NULL, DPI_OCI_ATTR_STMTCACHESIZE, NULL, error);
-        if (cacheSize > 0)
-            mode |= DPI_OCI_STRLS_CACHE_DELETE;
-    }
-
-    DPI_OCI_LOAD_SYMBOL("OCIStmtRelease", dpiOciSymbols.fnStmtRelease)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnStmtRelease)(stmt->handle, error->handle, tag,
-            tagLength, mode);
-    if (!checkError)
-        return DPI_SUCCESS;
-    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "release statement");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__stringAssignText() [INTERNAL]
-//   Wrapper for OCIStringAssignText().
-//-----------------------------------------------------------------------------
-int dpiOci__stringAssignText(void *envHandle, const char *value,
-        uint32_t valueLength, void **handle, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIStringAssignText",
-            dpiOciSymbols.fnStringAssignText)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnStringAssignText)(envHandle, error->handle,
-            value, valueLength, handle);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "assign to string");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__stringPtr() [INTERNAL]
-//   Wrapper for OCIStringPtr().
-//-----------------------------------------------------------------------------
-int dpiOci__stringPtr(void *envHandle, void *handle, char **ptr)
-{
-    dpiError *error = NULL;
-
-    DPI_OCI_LOAD_SYMBOL("OCIStringPtr", dpiOciSymbols.fnStringPtr)
-    *ptr = (*dpiOciSymbols.fnStringPtr)(envHandle, handle);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__stringResize() [INTERNAL]
-//   Wrapper for OCIStringResize().
-//-----------------------------------------------------------------------------
-int dpiOci__stringResize(void *envHandle, void **handle, uint32_t newSize,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIStringResize", dpiOciSymbols.fnStringResize)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnStringResize)(envHandle, error->handle, newSize,
-            handle);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "resize string");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__stringSize() [INTERNAL]
-//   Wrapper for OCIStringSize().
-//-----------------------------------------------------------------------------
-int dpiOci__stringSize(void *envHandle, void *handle, uint32_t *size)
-{
-    dpiError *error = NULL;
-
-    DPI_OCI_LOAD_SYMBOL("OCIStringSize", dpiOciSymbols.fnStringSize)
-    *size = (*dpiOciSymbols.fnStringSize)(envHandle, handle);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__subscriptionRegister() [INTERNAL]
-//   Wrapper for OCISubscriptionRegister().
-//-----------------------------------------------------------------------------
-int dpiOci__subscriptionRegister(dpiConn *conn, void **handle, uint32_t mode,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISubscriptionRegister",
-            dpiOciSymbols.fnSubscriptionRegister)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnSubscriptionRegister)(conn->handle, handle, 1,
-            error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "register");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__subscriptionUnRegister() [INTERNAL]
-//   Wrapper for OCISubscriptionUnRegister().
-//-----------------------------------------------------------------------------
-int dpiOci__subscriptionUnRegister(dpiConn *conn, dpiSubscr *subscr,
-        dpiError *error)
-{
-    uint32_t mode;
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCISubscriptionUnRegister",
-            dpiOciSymbols.fnSubscriptionUnRegister)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    mode = (subscr->clientInitiated) ? DPI_OCI_SECURE_NOTIFICATION :
-            DPI_OCI_DEFAULT;
-    status = (*dpiOciSymbols.fnSubscriptionUnRegister)(conn->handle,
-            subscr->handle, error->handle, mode);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "unregister");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__tableDelete() [INTERNAL]
-//   Wrapper for OCITableDelete().
-//-----------------------------------------------------------------------------
-int dpiOci__tableDelete(dpiObject *obj, int32_t index, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITableDelete", dpiOciSymbols.fnTableDelete)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTableDelete)(obj->env->handle, error->handle,
-            index, obj->instance);
-    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "delete element");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__tableExists() [INTERNAL]
-//   Wrapper for OCITableExists().
-//-----------------------------------------------------------------------------
-int dpiOci__tableExists(dpiObject *obj, int32_t index, int *exists,
-        dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITableExists", dpiOciSymbols.fnTableExists)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTableExists)(obj->env->handle, error->handle,
-            obj->instance, index, exists);
-    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn,
-            "get index exists");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__tableFirst() [INTERNAL]
-//   Wrapper for OCITableFirst().
-//-----------------------------------------------------------------------------
-int dpiOci__tableFirst(dpiObject *obj, int32_t *index, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITableFirst", dpiOciSymbols.fnTableFirst)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTableFirst)(obj->env->handle, error->handle,
-            obj->instance, index);
-    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn,
-            "get first index");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__tableLast() [INTERNAL]
-//   Wrapper for OCITableLast().
-//-----------------------------------------------------------------------------
-int dpiOci__tableLast(dpiObject *obj, int32_t *index, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITableLast", dpiOciSymbols.fnTableLast)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTableLast)(obj->env->handle, error->handle,
-            obj->instance, index);
-    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "get last index");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__tableNext() [INTERNAL]
-//   Wrapper for OCITableNext().
-//-----------------------------------------------------------------------------
-int dpiOci__tableNext(dpiObject *obj, int32_t index, int32_t *nextIndex,
-        int *exists, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITableNext", dpiOciSymbols.fnTableNext)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTableNext)(obj->env->handle, error->handle,
-            index, obj->instance, nextIndex, exists);
-    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "get next index");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__tablePrev() [INTERNAL]
-//   Wrapper for OCITablePrev().
-//-----------------------------------------------------------------------------
-int dpiOci__tablePrev(dpiObject *obj, int32_t index, int32_t *prevIndex,
-        int *exists, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITablePrev", dpiOciSymbols.fnTablePrev)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTablePrev)(obj->env->handle, error->handle,
-            index, obj->instance, prevIndex, exists);
-    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "get prev index");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__tableSize() [INTERNAL]
-//   Wrapper for OCITableSize().
-//-----------------------------------------------------------------------------
-int dpiOci__tableSize(dpiObject *obj, int32_t *size, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITableSize", dpiOciSymbols.fnTableSize)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTableSize)(obj->env->handle, error->handle,
-            obj->instance, size);
-    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "get size");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__threadKeyDestroy() [INTERNAL]
-//   Wrapper for OCIThreadKeyDestroy().
-//-----------------------------------------------------------------------------
-int dpiOci__threadKeyDestroy(void *envHandle, void *errorHandle, void **key,
-        dpiError *error)
-{
-    DPI_OCI_LOAD_SYMBOL("OCIThreadKeyDestroy",
-            dpiOciSymbols.fnThreadKeyDestroy)
-    (*dpiOciSymbols.fnThreadKeyDestroy)(envHandle, errorHandle, key);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__threadKeyGet() [INTERNAL]
-//   Wrapper for OCIThreadKeyGet().
-//-----------------------------------------------------------------------------
-int dpiOci__threadKeyGet(void *envHandle, void *errorHandle, void *key,
-        void **value, dpiError *error)
-{
-    int status;
-
-    status = (*dpiOciSymbols.fnThreadKeyGet)(envHandle, errorHandle, key,
-            value);
-    if (status != DPI_OCI_SUCCESS)
-        return dpiError__set(error, "get TLS error", DPI_ERR_TLS_ERROR);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__threadKeyInit() [INTERNAL]
-//   Wrapper for OCIThreadKeyInit().
-//-----------------------------------------------------------------------------
-int dpiOci__threadKeyInit(void *envHandle, void *errorHandle, void **key,
-        void *destroyFunc, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIThreadKeyInit", dpiOciSymbols.fnThreadKeyInit)
-    status = (*dpiOciSymbols.fnThreadKeyInit)(envHandle, errorHandle, key,
-            destroyFunc);
-    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "initialize thread key");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__threadKeySet() [INTERNAL]
-//   Wrapper for OCIThreadKeySet().
-//-----------------------------------------------------------------------------
-int dpiOci__threadKeySet(void *envHandle, void *errorHandle, void *key,
-        void *value, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCIThreadKeySet", dpiOciSymbols.fnThreadKeySet)
-    status = (*dpiOciSymbols.fnThreadKeySet)(envHandle, errorHandle, key,
-            value);
-    if (status != DPI_OCI_SUCCESS)
-        return dpiError__set(error, "set TLS error", DPI_ERR_TLS_ERROR);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__transCommit() [INTERNAL]
-//   Wrapper for OCITransCommit().
-//-----------------------------------------------------------------------------
-int dpiOci__transCommit(dpiConn *conn, uint32_t flags, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITransCommit", dpiOciSymbols.fnTransCommit)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTransCommit)(conn->handle, error->handle,
-            flags);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "commit");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__transDetach() [INTERNAL]
-//   Wrapper for OCITransDetach().
-//-----------------------------------------------------------------------------
-int dpiOci__transDetach(dpiConn *conn, uint32_t flags, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITransDetach", dpiOciSymbols.fnTransDetach)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTransDetach)(conn->handle, error->handle,
-            flags);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "detach TPC transaction");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__transForget() [INTERNAL]
-//   Wrapper for OCITransForget().
-//-----------------------------------------------------------------------------
-int dpiOci__transForget(dpiConn *conn, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITransForget", dpiOciSymbols.fnTransForget)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTransForget)(conn->handle, error->handle,
-            DPI_OCI_DEFAULT);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "forget TPC transaction");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__transPrepare() [INTERNAL]
-//   Wrapper for OCITransPrepare().
-//-----------------------------------------------------------------------------
-int dpiOci__transPrepare(dpiConn *conn, int *commitNeeded, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITransPrepare", dpiOciSymbols.fnTransPrepare)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTransPrepare)(conn->handle, error->handle,
-            DPI_OCI_DEFAULT);
-    *commitNeeded = (status == DPI_OCI_SUCCESS);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "prepare transaction");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__transRollback() [INTERNAL]
-//   Wrapper for OCITransRollback().
-//-----------------------------------------------------------------------------
-int dpiOci__transRollback(dpiConn *conn, int checkError, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITransRollback", dpiOciSymbols.fnTransRollback)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTransRollback)(conn->handle, error->handle,
-            DPI_OCI_DEFAULT);
-    if (!checkError)
-        return DPI_SUCCESS;
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "rollback");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__transStart() [INTERNAL]
-//   Wrapper for OCITransStart().
-//-----------------------------------------------------------------------------
-int dpiOci__transStart(dpiConn *conn, uint32_t transactionTimeout,
-        uint32_t flags, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITransStart", dpiOciSymbols.fnTransStart)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTransStart)(conn->handle, error->handle,
-            transactionTimeout, flags);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "start transaction");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__typeByName() [INTERNAL]
-//   Wrapper for OCITypeByName().
-//-----------------------------------------------------------------------------
-int dpiOci__typeByName(dpiConn *conn, const char *schema,
-        uint32_t schemaLength, const char *name, uint32_t nameLength,
-        void **tdo, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITypeByName", dpiOciSymbols.fnTypeByName)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTypeByName)(conn->env->handle, error->handle,
-            conn->handle, schema, schemaLength, name, nameLength, NULL, 0,
-            DPI_OCI_DURATION_SESSION, DPI_OCI_TYPEGET_ALL, tdo);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "get type by name");
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOci__typeByFullName() [INTERNAL]
-//   Wrapper for OCITypeByFullName().
-//-----------------------------------------------------------------------------
-int dpiOci__typeByFullName(dpiConn *conn, const char *name,
-        uint32_t nameLength, void **tdo, dpiError *error)
-{
-    int status;
-
-    DPI_OCI_LOAD_SYMBOL("OCITypeByFullName", dpiOciSymbols.fnTypeByFullName)
-    DPI_OCI_ENSURE_ERROR_HANDLE(error)
-    status = (*dpiOciSymbols.fnTypeByFullName)(conn->env->handle,
-            error->handle, conn->handle, name, nameLength, NULL, 0,
-            DPI_OCI_DURATION_SESSION, DPI_OCI_TYPEGET_ALL, tdo);
-    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "get type by full name");
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiOci.h ./odpi/src/dpiOci.h
--- patched-godror/odpi/src/dpiOci.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiOci.h	2024-05-14 14:55:13
@@ -0,0 +1,4311 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2017, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiOci.c
+//   Link to OCI using dynamic linking. The OCI library (11.2+) is loaded
+// dynamically and a function table kept for the functions that are used by
+// DPI. This function table is populated as functions are used and permits use
+// of all versions of OCI from one driver.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+// define structure used for loading the OCI library
+typedef struct {
+    void *handle;
+    char *nameBuffer;
+    size_t nameBufferLength;
+    char *moduleNameBuffer;
+    size_t moduleNameBufferLength;
+    char *loadError;
+    size_t loadErrorLength;
+    char *errorBuffer;
+    size_t errorBufferLength;
+} dpiOciLoadLibParams;
+
+
+// forward declarations of internal functions only used in this file
+static void *dpiOci__allocateMem(void *unused, size_t size);
+static void dpiOci__freeMem(void *unused, void *ptr);
+static int dpiOci__loadLibValidate(dpiVersionInfo *versionInfo,
+        dpiError *error);
+static int dpiOci__loadLibWithDir(dpiOciLoadLibParams *loadParams,
+        const char *dirName, size_t dirNameLength, int scanAllNames,
+        dpiError *error);
+static int dpiOci__loadLibWithName(dpiOciLoadLibParams *loadParams,
+        const char *libName, dpiError *error);
+static int dpiOci__loadSymbol(const char *symbolName, void **symbol,
+        dpiError *error);
+static void *dpiOci__reallocMem(void *unused, void *ptr, size_t newSize);
+
+
+// macro to simplify code for loading each symbol
+#define DPI_OCI_LOAD_SYMBOL(symbolName, symbol) \
+    if (!symbol && dpiOci__loadSymbol(symbolName, (void**) &symbol, \
+            error) < 0) \
+        return DPI_FAILURE;
+
+// macro to ensure that an error handle is available
+#define DPI_OCI_ENSURE_ERROR_HANDLE(error) \
+    if (!error->handle && dpiError__initHandle(error) < 0) \
+        return DPI_FAILURE;
+
+// macros to simplify code for checking results of OCI calls
+#define DPI_OCI_ERROR_OCCURRED(status) \
+    (status != DPI_OCI_SUCCESS && status != DPI_OCI_SUCCESS_WITH_INFO)
+#define DPI_OCI_CHECK_AND_RETURN(error, status, conn, action) \
+    if (status != DPI_OCI_SUCCESS) \
+        return dpiError__setFromOCI(error, status, conn, action); \
+    return DPI_SUCCESS;
+
+
+// typedefs for all OCI functions used by ODPI-C
+typedef int (*dpiOciFnType__aqDeq)(void *svchp, void *errhp,
+        const char *queue_name, void *deqopt, void *msgprop, void *payload_tdo,
+        void **payload, void **payload_ind, void **msgid, uint32_t flags);
+typedef int (*dpiOciFnType__aqDeqArray)(void *svchp, void *errhp,
+        const char *queue_name, void *deqopt, uint32_t *iters, void **msgprop,
+        void *payload_tdo, void **payload, void **payload_ind, void **msgid,
+        void *ctxp, void *deqcbfp, uint32_t flags);
+typedef int (*dpiOciFnType__aqEnq)(void *svchp, void *errhp,
+        const char *queue_name, void *enqopt, void *msgprop, void *payload_tdo,
+        void **payload, void **payload_ind, void **msgid, uint32_t flags);
+typedef int (*dpiOciFnType__aqEnqArray)(void *svchp, void *errhp,
+        const char *queue_name, void *enqopt, uint32_t *iters, void **msgprop,
+        void *payload_tdo, void **payload, void **payload_ind, void **msgid,
+        void *ctxp, void *enqcbfp, uint32_t flags);
+typedef int (*dpiOciFnType__arrayDescriptorAlloc)(const void *parenth,
+        void **descpp, const uint32_t type, uint32_t array_size,
+        const size_t xtramem_sz, void **usrmempp);
+typedef int (*dpiOciFnType__arrayDescriptorFree)(void **descp,
+        const uint32_t type);
+typedef int (*dpiOciFnType__attrGet)(const void  *trgthndlp,
+        uint32_t trghndltyp, void *attributep, uint32_t *sizep,
+        uint32_t attrtype, void *errhp);
+typedef int (*dpiOciFnType__attrSet)(void *trgthndlp, uint32_t trghndltyp,
+        void *attributep, uint32_t size, uint32_t attrtype, void *errhp);
+typedef int (*dpiOciFnType__bindByName)(void *stmtp, void **bindp, void *errhp,
+        const char *placeholder, int32_t placeh_len, void *valuep,
+        int32_t value_sz, uint16_t dty, void *indp, uint16_t *alenp,
+        uint16_t *rcodep, uint32_t maxarr_len, uint32_t *curelep,
+        uint32_t mode);
+typedef int (*dpiOciFnType__bindByName2)(void *stmtp, void **bindp,
+        void *errhp, const char *placeholder, int32_t placeh_len, void *valuep,
+        int64_t value_sz, uint16_t dty, void *indp, uint32_t *alenp,
+        uint16_t *rcodep, uint32_t maxarr_len, uint32_t *curelep,
+        uint32_t mode);
+typedef int (*dpiOciFnType__bindByPos)(void *stmtp, void **bindp, void *errhp,
+        uint32_t position, void *valuep, int32_t value_sz, uint16_t dty,
+        void *indp, uint16_t *alenp, uint16_t *rcodep, uint32_t maxarr_len,
+        uint32_t *curelep, uint32_t mode);
+typedef int (*dpiOciFnType__bindByPos2)(void *stmtp, void **bindp, void *errhp,
+        uint32_t position, void *valuep, int64_t value_sz, uint16_t dty,
+        void *indp, uint32_t *alenp, uint16_t *rcodep, uint32_t maxarr_len,
+        uint32_t *curelep, uint32_t mode);
+typedef int (*dpiOciFnType__bindDynamic)(void *bindp, void *errhp, void *ictxp,
+        void *icbfp, void *octxp, void *ocbfp);
+typedef int (*dpiOciFnType__bindObject)(void *bindp, void *errhp,
+        const void *type, void **pgvpp, uint32_t *pvszsp, void **indpp,
+        uint32_t *indszp);
+typedef int (*dpiOciFnType__break)(void *hndlp, void *errhp);
+typedef void (*dpiOciFnType__clientVersion)(int *major_version,
+        int *minor_version, int *update_num, int *patch_num,
+        int *port_update_num);
+typedef int (*dpiOciFnType__collAppend)(void *env, void *err, const void *elem,
+        const void *elemind, void *coll);
+typedef int (*dpiOciFnType__collAssignElem)(void *env, void *err,
+        int32_t index, const void *elem, const void *elemind, void *coll);
+typedef int (*dpiOciFnType__collGetElem)(void *env, void *err,
+        const void *coll, int32_t index, int *exists, void **elem,
+        void **elemind);
+typedef int (*dpiOciFnType__collSize)(void *env, void *err, const void *coll,
+        int32_t *size);
+typedef int (*dpiOciFnType__collTrim)(void *env, void *err, int32_t trim_num,
+        void *coll);
+typedef int (*dpiOciFnType__contextGetValue)(void *hdl, void *err,
+        const char *key, uint8_t keylen, void **ctx_value);
+typedef int (*dpiOciFnType__contextSetValue)(void *hdl, void *err,
+        uint16_t duration, const char *key, uint8_t keylen, void *ctx_value);
+typedef int (*dpiOciFnType__dateTimeConstruct)(void *hndl, void *err,
+        void *datetime, int16_t yr, uint8_t mnth, uint8_t dy, uint8_t hr,
+        uint8_t mm, uint8_t ss, uint32_t fsec, const char *tz,
+        size_t tzLength);
+typedef int (*dpiOciFnType__dateTimeConvert)(void *hndl, void *err,
+        void *indate, void *outdate);
+typedef int (*dpiOciFnType__dateTimeGetDate)(void *hndl, void *err,
+        const void *date, int16_t *yr, uint8_t *mnth, uint8_t *dy);
+typedef int (*dpiOciFnType__dateTimeGetTime)(void *hndl, void *err,
+        void *datetime, uint8_t *hr, uint8_t *mm, uint8_t *ss, uint32_t *fsec);
+typedef int (*dpiOciFnType__dateTimeGetTimeZoneOffset)(void *hndl, void *err,
+        const void *datetime, int8_t *hr, int8_t *mm);
+typedef int (*dpiOciFnType__dateTimeIntervalAdd)(void *hndl, void *err,
+        void *datetime, void *inter, void *outdatetime);
+typedef int (*dpiOciFnType__dateTimeSubtract)(void *hndl, void *err,
+        void *indate1, void *indate2, void *inter);
+typedef int (*dpiOciFnType__dbShutdown)(void *svchp, void *errhp, void *admhp,
+        uint32_t mode);
+typedef int (*dpiOciFnType__dbStartup)(void *svchp, void *errhp, void *admhp,
+        uint32_t mode, uint32_t flags);
+typedef int (*dpiOciFnType__defineByPos)(void *stmtp, void **defnp,
+        void *errhp, uint32_t position, void *valuep, int32_t value_sz,
+        uint16_t dty, void *indp, uint16_t *rlenp, uint16_t *rcodep,
+        uint32_t mode);
+typedef int (*dpiOciFnType__defineByPos2)(void *stmtp, void **defnp,
+        void *errhp, uint32_t position, void *valuep, uint64_t value_sz,
+        uint16_t dty, void *indp, uint32_t *rlenp, uint16_t *rcodep,
+        uint32_t mode);
+typedef int (*dpiOciFnType__defineDynamic)(void *defnp, void *errhp,
+        void *octxp, void *ocbfp);
+typedef int (*dpiOciFnType__defineObject)(void *defnp, void *errhp,
+        const void *type, void **pgvpp, uint32_t *pvszsp, void **indpp,
+        uint32_t *indszp);
+typedef int (*dpiOciFnType__describeAny)(void *svchp, void *errhp,
+        void *objptr, uint32_t objnm_len, uint8_t objptr_typ,
+        uint8_t info_level, uint8_t objtyp, void *dschp);
+typedef int (*dpiOciFnType__descriptorAlloc)(const void *parenth,
+        void **descpp, const uint32_t type, const size_t xtramem_sz,
+        void **usrmempp);
+typedef int (*dpiOciFnType__descriptorFree)(void *descp, const uint32_t type);
+typedef int (*dpiOciFnType__envNlsCreate)(void **envp, uint32_t mode,
+        void *ctxp, void *malocfp, void *ralocfp, void *mfreefp,
+        size_t xtramem_sz, void **usrmempp, uint16_t charset,
+        uint16_t ncharset);
+typedef int (*dpiOciFnType__errorGet)(void *hndlp, uint32_t recordno,
+        char *sqlstate, int32_t *errcodep, char *bufp, uint32_t bufsiz,
+        uint32_t type);
+typedef int (*dpiOciFnType__handleAlloc)(const void *parenth, void **hndlpp,
+        const uint32_t type, const size_t xtramem_sz, void **usrmempp);
+typedef int (*dpiOciFnType__handleFree)(void *hndlp, const uint32_t type);
+typedef int (*dpiOciFnType__intervalGetDaySecond)(void *hndl, void *err,
+        int32_t *dy, int32_t *hr, int32_t *mm, int32_t *ss, int32_t *fsec,
+        const void *result);
+typedef int (*dpiOciFnType__intervalGetYearMonth)(void *hndl, void *err,
+        int32_t *yr, int32_t *mnth, const void *result);
+typedef int (*dpiOciFnType__intervalSetDaySecond)(void *hndl, void *err,
+        int32_t dy, int32_t hr, int32_t mm, int32_t ss, int32_t fsec,
+        void *result);
+typedef int (*dpiOciFnType__intervalSetYearMonth)(void *hndl, void *err,
+        int32_t yr, int32_t mnth, void *result);
+typedef int (*dpiOciFnType__jsonDomDocGet)(void *svchp, void *jsond,
+        dpiJznDomDoc **jDomDoc, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__jsonTextBufferParse)(void *hndlp, void *jsond,
+        void *bufp, uint64_t buf_sz, uint32_t validation, uint16_t encoding,
+        void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__lobClose)(void *svchp, void *errhp, void *locp);
+typedef int (*dpiOciFnType__lobCreateTemporary)(void *svchp, void *errhp,
+        void *locp, uint16_t csid, uint8_t csfrm, uint8_t lobtype, int cache,
+        uint16_t duration);
+typedef int (*dpiOciFnType__lobFileExists)(void *svchp, void *errhp,
+        void *filep, int *flag);
+typedef int (*dpiOciFnType__lobFileGetName)(void *envhp, void *errhp,
+        const void *filep, char *dir_alias, uint16_t *d_length, char *filename,
+        uint16_t *f_length);
+typedef int (*dpiOciFnType__lobFileSetName)(void *envhp, void *errhp,
+        void **filepp, const char *dir_alias, uint16_t d_length,
+        const char *filename, uint16_t f_length);
+typedef int (*dpiOciFnType__lobFreeTemporary)(void *svchp, void *errhp,
+        void *locp);
+typedef int (*dpiOciFnType__lobGetChunkSize)(void *svchp, void *errhp,
+        void *locp, uint32_t *chunksizep);
+typedef int (*dpiOciFnType__lobGetLength2)(void *svchp, void *errhp,
+        void *locp, uint64_t *lenp);
+typedef int (*dpiOciFnType__lobIsOpen)(void *svchp, void *errhp, void *locp,
+        int *flag);
+typedef int (*dpiOciFnType__lobIsTemporary)(void *envp, void *errhp,
+        void *locp, int *is_temporary);
+typedef int (*dpiOciFnType__lobLocatorAssign)(void *svchp, void *errhp,
+        const void *src_locp, void **dst_locpp);
+typedef int (*dpiOciFnType__lobOpen)(void *svchp, void *errhp, void *locp,
+        uint8_t mode);
+typedef int (*dpiOciFnType__lobRead2)(void *svchp, void *errhp, void *locp,
+        uint64_t *byte_amtp, uint64_t *char_amtp, uint64_t offset, void *bufp,
+        uint64_t bufl, uint8_t piece, void *ctxp, void *cbfp, uint16_t csid,
+        uint8_t csfrm);
+typedef int (*dpiOciFnType__lobTrim2)(void *svchp, void *errhp, void *locp,
+        uint64_t newlen);
+typedef int (*dpiOciFnType__lobWrite2)(void *svchp, void *errhp, void *locp,
+        uint64_t *byte_amtp, uint64_t *char_amtp, uint64_t offset, void *bufp,
+        uint64_t buflen, uint8_t piece, void *ctxp, void *cbfp, uint16_t csid,
+        uint8_t csfrm);
+typedef int (*dpiOciFnType__memoryAlloc)(void *hdl, void *err, void **mem,
+        uint16_t dur, uint32_t size, uint32_t flags);
+typedef int (*dpiOciFnType__memoryFree)(void *hdl, void *err, void *mem);
+typedef int (*dpiOciFnType__nlsCharSetConvert)(void *envhp, void *errhp,
+        uint16_t dstid, void  *dstp, size_t dstlen, uint16_t srcid,
+        const void *srcp, size_t srclen, size_t *rsize);
+typedef int (*dpiOciFnType__nlsCharSetIdToName)(void *envhp, char *buf,
+        size_t buflen, uint16_t id);
+typedef uint16_t (*dpiOciFnType__nlsCharSetNameToId)(void *envhp,
+        const char *name);
+typedef int (*dpiOciFnType__nlsEnvironmentVariableGet)(void *val, size_t size,
+        uint16_t item, uint16_t charset, size_t *rsize);
+typedef int (*dpiOciFnType__nlsNameMap)(void *envhp, char *buf, size_t buflen,
+        const char *srcbuf, uint32_t flag);
+typedef int (*dpiOciFnType__nlsNumericInfoGet)(void *envhp, void *errhp,
+        int32_t *val, uint16_t item);
+typedef int (*dpiOciFnType__numberFromInt)(void *err, const void *inum,
+        unsigned int inum_length, unsigned int inum_s_flag, void *number);
+typedef int (*dpiOciFnType__numberFromReal)(void *err, const void *number,
+        unsigned int rsl_length, void *rsl);
+typedef int (*dpiOciFnType__numberToInt)(void *err, const void *number,
+        unsigned int rsl_length, unsigned int rsl_flag, void *rsl);
+typedef int (*dpiOciFnType__numberToReal)(void *err, const void *number,
+        unsigned int rsl_length, void *rsl);
+typedef int (*dpiOciFnType__objectCopy)(void *env, void *err, const void *svc,
+        void *source, void *null_source, void *target, void *null_target,
+        void *tdo, uint16_t duration, uint8_t option);
+typedef int (*dpiOciFnType__objectFree)(void *env, void *err, void *instance,
+        uint16_t flags);
+typedef int (*dpiOciFnType__objectGetAttr)(void *env, void *err,
+        void *instance, void *null_struct, void *tdo, const char **names,
+        const uint32_t *lengths, const uint32_t name_count,
+        const uint32_t *indexes, const uint32_t index_count,
+        int16_t *attr_null_status, void **attr_null_struct, void **attr_value,
+        void **attr_tdo);
+typedef int (*dpiOciFnType__objectGetInd)(void *env, void *err, void *instance,
+        void **null_struct);
+typedef int (*dpiOciFnType__objectNew)(void *env, void *err, const void *svc,
+        uint16_t typecode, void *tdo, void *table, uint16_t duration,
+        int value, void **instance);
+typedef int (*dpiOciFnType__objectPin)(void *env, void *err, void *object_ref,
+        void *corhdl, int pin_option, uint16_t pin_duration, int lock_option,
+        void **object);
+typedef int (*dpiOciFnType__objectSetAttr)(void *env, void *err,
+        void *instance, void *null_struct, void *tdo, const char **names,
+        const uint32_t *lengths, const uint32_t name_count,
+        const uint32_t *indexes, const uint32_t index_count,
+        const int16_t null_status, const void *attr_null_struct,
+        const void *attr_value);
+typedef int (*dpiOciFnType__paramGet)(const void *hndlp, uint32_t htype,
+        void *errhp, void **parmdpp, uint32_t pos);
+typedef int (*dpiOciFnType__passwordChange)(void *svchp, void *errhp,
+        const char *user_name, uint32_t usernm_len, const char *opasswd,
+        uint32_t opasswd_len, const char *npasswd, uint32_t npasswd_len,
+        uint32_t mode);
+typedef int (*dpiOciFnType__ping)(void *svchp, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__rawAssignBytes)(void *env, void *err,
+        const char *rhs, uint32_t rhs_len, void **lhs);
+typedef void *(*dpiOciFnType__rawPtr)(void *env, const void *raw);
+typedef int (*dpiOciFnType__rawResize)(void *env, void *err, uint32_t new_size,
+        void **raw);
+typedef uint32_t (*dpiOciFnType__rawSize)(void * env, const void *raw);
+typedef int (*dpiOciFnType__rowidToChar)(void *rowidDesc, char *outbfp,
+        uint16_t *outbflp, void *errhp);
+typedef int (*dpiOciFnType__serverAttach)(void *srvhp, void *errhp,
+        const char *dblink, int32_t dblink_len, uint32_t mode);
+typedef int (*dpiOciFnType__serverDetach)(void *srvhp, void *errhp,
+        uint32_t mode);
+typedef int (*dpiOciFnType__serverRelease)(void *hndlp, void *errhp,
+        char *bufp, uint32_t bufsz, uint8_t hndltype, uint32_t *version);
+typedef int (*dpiOciFnType__serverRelease2)(void *hndlp, void *errhp,
+        char *bufp, uint32_t bufsz, uint8_t hndltype, uint32_t *version,
+        uint32_t mode);
+typedef int (*dpiOciFnType__sessionBegin)(void *svchp, void *errhp,
+        void *usrhp, uint32_t credt, uint32_t mode);
+typedef int (*dpiOciFnType__sessionEnd)(void *svchp, void *errhp, void *usrhp,
+        uint32_t mode);
+typedef int (*dpiOciFnType__sessionGet)(void *envhp, void *errhp, void **svchp,
+        void *authhp, const char *poolName, uint32_t poolName_len,
+        const char *tagInfo, uint32_t tagInfo_len, const char **retTagInfo,
+        uint32_t *retTagInfo_len, int *found, uint32_t mode);
+typedef int (*dpiOciFnType__sessionPoolCreate)(void *envhp, void *errhp,
+        void *spoolhp, char **poolName, uint32_t *poolNameLen,
+        const char *connStr, uint32_t connStrLen, uint32_t sessMin,
+        uint32_t sessMax, uint32_t sessIncr, const char *userid,
+        uint32_t useridLen, const char *password, uint32_t passwordLen,
+        uint32_t mode);
+typedef int (*dpiOciFnType__sessionPoolDestroy)(void *spoolhp, void *errhp,
+        uint32_t mode);
+typedef int (*dpiOciFnType__sessionRelease)(void *svchp, void *errhp,
+        const char *tag, uint32_t tag_len, uint32_t mode);
+typedef int (*dpiOciFnType__shardingKeyColumnAdd)(void *shardingKey,
+        void *errhp, void *col, uint32_t colLen, uint16_t colType,
+        uint32_t mode);
+typedef int (*dpiOciFnType__sodaBulkInsert)(void *svchp,
+        void *collection, void **documentarray, uint32_t arraylen,
+        void *opoptns, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaBulkInsertAndGet)(void *svchp,
+        void *collection, void **documentarray, uint32_t arraylen,
+        void *opoptns, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaBulkInsertAndGetWithOpts)(void *svchp,
+        void *collection, void **documentarray, uint32_t arraylen,
+        void *oproptns, void *opoptns, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaCollCreateWithMetadata)(void *svchp,
+        const char *collname, uint32_t collnamelen, const char *metadata,
+        uint32_t metadatalen, void **collection, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaCollDrop)(void *svchp, void *coll,
+        int *isDropped, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaCollGetNext)(void *svchp, const void *cur,
+        void **coll, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaCollList)(void *svchp, const char *startname,
+        uint32_t stnamelen, void **cur, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaCollOpen)(void *svchp, const char *collname,
+        uint32_t collnamelen, void **coll, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaCollTruncate)(void *svchp, void *collection,
+        void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaDataGuideGet)(void *svchp,
+        const void *collection, uint32_t docFlags, void **doc, void *errhp,
+        uint32_t mode);
+typedef int (*dpiOciFnType__sodaDocCount)(void *svchp, const void *coll,
+        const void *optns, uint64_t *numdocs, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaDocGetNext)(void *svchp, const void *cur,
+        void **doc, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaFind)(void *svchp, const void *coll,
+        const void *findOptions, uint32_t docFlags, void **cursor,
+        void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaFindOne)(void *svchp, const void *coll,
+        const void *findOptions, uint32_t docFlags, void **doc, void *errhp,
+        uint32_t mode);
+typedef int (*dpiOciFnType__sodaIndexCreate)(void *svchp, const void *coll,
+        const char *indexspec, uint32_t speclen, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaIndexDrop)(void *svchp, const char *indexname,
+        uint32_t indexnamelen, int *isDropped, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaInsert)(void *svchp, void *collection,
+        void *document, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaInsertAndGet)(void *svchp, void *collection,
+        void **document, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaInsertAndGetWithOpts)(void *svchp,
+        void *collection, void **document, void *oproptns, void *errhp,
+        uint32_t mode);
+typedef int (*dpiOciFnType__sodaOperKeysSet)(const void *operhp,
+        const char **keysArray, uint32_t *lengthsArray, uint32_t count,
+        void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaRemove)(void *svchp, const void *coll,
+        const void *optns, uint64_t *removeCount, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaReplOne)(void *svchp, const void *coll,
+        const void *optns, void *document, int *isReplaced, void *errhp,
+        uint32_t mode);
+typedef int (*dpiOciFnType__sodaReplOneAndGet)(void *svchp, const void *coll,
+        const void *optns, void **document, int *isReplaced, void *errhp,
+        uint32_t mode);
+typedef int (*dpiOciFnType__sodaSave)(void *svchp, void *collection,
+        void *document, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaSaveAndGet)(void *svchp, void *collection,
+        void **document, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__sodaSaveAndGetWithOpts)(void *svchp,
+        void *collection, void **document, void *oproptns, void *errhp,
+        uint32_t mode);
+typedef int (*dpiOciFnType__stmtExecute)(void *svchp, void *stmtp, void *errhp,
+        uint32_t iters, uint32_t rowoff, const void *snap_in, void *snap_out,
+        uint32_t mode);
+typedef int (*dpiOciFnType__stmtFetch2)(void *stmtp, void *errhp,
+        uint32_t nrows, uint16_t orientation, int32_t scrollOffset,
+        uint32_t mode);
+typedef int (*dpiOciFnType__stmtGetBindInfo)(void *stmtp, void *errhp,
+        uint32_t size, uint32_t startloc, int32_t *found, char *bvnp[],
+        uint8_t bvnl[], char *invp[], uint8_t inpl[], uint8_t dupl[],
+        void **hndl);
+typedef int (*dpiOciFnType__stmtGetNextResult)(void *stmthp, void *errhp,
+        void **result, uint32_t *rtype, uint32_t mode);
+typedef int (*dpiOciFnType__stmtPrepare2)(void *svchp, void **stmtp,
+        void *errhp, const char *stmt, uint32_t stmt_len, const char *key,
+        uint32_t key_len, uint32_t language, uint32_t mode);
+typedef int (*dpiOciFnType__stmtRelease)(void *stmtp, void *errhp,
+        const char *key, uint32_t key_len, uint32_t mode);
+typedef int (*dpiOciFnType__stringAssignText)(void *env, void *err,
+        const char *rhs, uint32_t rhs_len, void **lhs);
+typedef char *(*dpiOciFnType__stringPtr)(void *env, const void *vs);
+typedef int (*dpiOciFnType__stringResize)(void *env, void *err,
+        uint32_t new_size, void **str);
+typedef uint32_t (*dpiOciFnType__stringSize)(void *env, const void *vs);
+typedef int (*dpiOciFnType__subscriptionRegister)(void *svchp,
+        void **subscrhpp, uint16_t count, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__subscriptionUnRegister)(void *svchp,
+        void *subscrhp, void *errhp, uint32_t mode);
+typedef int (*dpiOciFnType__tableDelete)(void *env, void *err, int32_t index,
+        void *tbl);
+typedef int (*dpiOciFnType__tableExists)(void *env, void *err, const void *tbl,
+        int32_t index, int *exists);
+typedef int (*dpiOciFnType__tableFirst)(void *env, void *err, const void *tbl,
+        int32_t *index);
+typedef int (*dpiOciFnType__tableLast)(void *env, void *err, const void *tbl,
+        int32_t *index);
+typedef int (*dpiOciFnType__tableNext)(void *env, void *err, int32_t index,
+        const void *tbl, int32_t *next_index, int *exists);
+typedef int (*dpiOciFnType__tablePrev)(void *env, void *err, int32_t index,
+        const void *tbl, int32_t *prev_index, int *exists);
+typedef int (*dpiOciFnType__tableSize)(void *env, void *err, const void *tbl,
+        int32_t *size);
+typedef int (*dpiOciFnType__threadKeyDestroy)(void *hndl, void *err,
+        void **key);
+typedef int (*dpiOciFnType__threadKeyGet)(void *hndl, void *err, void *key,
+        void **pValue);
+typedef int (*dpiOciFnType__threadKeyInit)(void *hndl, void *err, void **key,
+        void *destFn);
+typedef int (*dpiOciFnType__threadKeySet)(void *hndl, void *err, void *key,
+        void *value);
+typedef void (*dpiOciFnType__threadProcessInit)(void);
+typedef int (*dpiOciFnType__transCommit)(void *svchp, void *errhp,
+        uint32_t flags);
+typedef int (*dpiOciFnType__transDetach)(void *svchp, void *errhp,
+        uint32_t flags);
+typedef int (*dpiOciFnType__transForget)(void *svchp, void *errhp,
+        uint32_t flags);
+typedef int (*dpiOciFnType__transPrepare)(void *svchp, void *errhp,
+        uint32_t flags);
+typedef int (*dpiOciFnType__transRollback)(void *svchp, void *errhp,
+        uint32_t flags);
+typedef int (*dpiOciFnType__transStart)(void *svchp, void *errhp,
+        unsigned int timeout, uint32_t flags);
+typedef int (*dpiOciFnType__typeByFullName)(void *env, void *err,
+        const void *svc, const char *full_type_name,
+        uint32_t full_type_name_length, const char *version_name,
+        uint32_t version_name_length, uint16_t pin_duration, int get_option,
+        void **tdo);
+typedef int (*dpiOciFnType__typeByName)(void *env, void *err, const void *svc,
+        const char *schema_name, uint32_t s_length, const char *type_name,
+        uint32_t t_length, const char *version_name, uint32_t v_length,
+        uint16_t pin_duration, int get_option, void **tdo);
+
+
+// library handle for dynamically loaded OCI library
+static void *dpiOciLibHandle = NULL;
+
+// library names to search
+static const char *dpiOciLibNames[] = {
+#if defined _WIN32 || defined __CYGWIN__
+    "oci.dll",
+#elif __APPLE__
+    "libclntsh.dylib",
+    "libclntsh.dylib.19.1",
+    "libclntsh.dylib.18.1",
+    "libclntsh.dylib.12.1",
+    "libclntsh.dylib.11.1",
+    "libclntsh.dylib.20.1",
+    "libclntsh.dylib.21.1",
+#else
+    "libclntsh.so",
+    "libclntsh.so.19.1",
+    "libclntsh.so.18.1",
+    "libclntsh.so.12.1",
+    "libclntsh.so.11.1",
+    "libclntsh.so.20.1",
+    "libclntsh.so.21.1",
+#endif
+    NULL
+};
+
+// all OCI symbols used by ODPI-C
+static struct {
+    dpiOciFnType__aqDeq fnAqDeq;
+    dpiOciFnType__aqDeqArray fnAqDeqArray;
+    dpiOciFnType__aqEnq fnAqEnq;
+    dpiOciFnType__aqEnqArray fnAqEnqArray;
+    dpiOciFnType__arrayDescriptorAlloc fnArrayDescriptorAlloc;
+    dpiOciFnType__arrayDescriptorFree fnArrayDescriptorFree;
+    dpiOciFnType__attrGet fnAttrGet;
+    dpiOciFnType__attrSet fnAttrSet;
+    dpiOciFnType__bindByName fnBindByName;
+    dpiOciFnType__bindByName2 fnBindByName2;
+    dpiOciFnType__bindByPos fnBindByPos;
+    dpiOciFnType__bindByPos2 fnBindByPos2;
+    dpiOciFnType__bindDynamic fnBindDynamic;
+    dpiOciFnType__bindObject fnBindObject;
+    dpiOciFnType__break fnBreak;
+    dpiOciFnType__clientVersion fnClientVersion;
+    dpiOciFnType__collAppend fnCollAppend;
+    dpiOciFnType__collAssignElem fnCollAssignElem;
+    dpiOciFnType__collGetElem fnCollGetElem;
+    dpiOciFnType__collSize fnCollSize;
+    dpiOciFnType__collTrim fnCollTrim;
+    dpiOciFnType__contextGetValue fnContextGetValue;
+    dpiOciFnType__contextSetValue fnContextSetValue;
+    dpiOciFnType__dateTimeConstruct fnDateTimeConstruct;
+    dpiOciFnType__dateTimeConvert fnDateTimeConvert;
+    dpiOciFnType__dateTimeGetDate fnDateTimeGetDate;
+    dpiOciFnType__dateTimeGetTime fnDateTimeGetTime;
+    dpiOciFnType__dateTimeGetTimeZoneOffset fnDateTimeGetTimeZoneOffset;
+    dpiOciFnType__dateTimeIntervalAdd fnDateTimeIntervalAdd;
+    dpiOciFnType__dateTimeSubtract fnDateTimeSubtract;
+    dpiOciFnType__dbShutdown fnDbShutdown;
+    dpiOciFnType__dbStartup fnDbStartup;
+    dpiOciFnType__defineByPos fnDefineByPos;
+    dpiOciFnType__defineByPos2 fnDefineByPos2;
+    dpiOciFnType__defineDynamic fnDefineDynamic;
+    dpiOciFnType__defineObject fnDefineObject;
+    dpiOciFnType__describeAny fnDescribeAny;
+    dpiOciFnType__descriptorAlloc fnDescriptorAlloc;
+    dpiOciFnType__descriptorFree fnDescriptorFree;
+    dpiOciFnType__envNlsCreate fnEnvNlsCreate;
+    dpiOciFnType__errorGet fnErrorGet;
+    dpiOciFnType__handleAlloc fnHandleAlloc;
+    dpiOciFnType__handleFree fnHandleFree;
+    dpiOciFnType__intervalGetDaySecond fnIntervalGetDaySecond;
+    dpiOciFnType__intervalGetYearMonth fnIntervalGetYearMonth;
+    dpiOciFnType__intervalSetDaySecond fnIntervalSetDaySecond;
+    dpiOciFnType__intervalSetYearMonth fnIntervalSetYearMonth;
+    dpiOciFnType__jsonDomDocGet fnJsonDomDocGet;
+    dpiOciFnType__jsonTextBufferParse fnJsonTextBufferParse;
+    dpiOciFnType__lobClose fnLobClose;
+    dpiOciFnType__lobCreateTemporary fnLobCreateTemporary;
+    dpiOciFnType__lobFileExists fnLobFileExists;
+    dpiOciFnType__lobFileGetName fnLobFileGetName;
+    dpiOciFnType__lobFileSetName fnLobFileSetName;
+    dpiOciFnType__lobFreeTemporary fnLobFreeTemporary;
+    dpiOciFnType__lobGetChunkSize fnLobGetChunkSize;
+    dpiOciFnType__lobGetLength2 fnLobGetLength2;
+    dpiOciFnType__lobIsOpen fnLobIsOpen;
+    dpiOciFnType__lobIsTemporary fnLobIsTemporary;
+    dpiOciFnType__lobLocatorAssign fnLobLocatorAssign;
+    dpiOciFnType__lobOpen fnLobOpen;
+    dpiOciFnType__lobRead2 fnLobRead2;
+    dpiOciFnType__lobTrim2 fnLobTrim2;
+    dpiOciFnType__lobWrite2 fnLobWrite2;
+    dpiOciFnType__memoryAlloc fnMemoryAlloc;
+    dpiOciFnType__memoryFree fnMemoryFree;
+    dpiOciFnType__nlsCharSetConvert fnNlsCharSetConvert;
+    dpiOciFnType__nlsCharSetIdToName fnNlsCharSetIdToName;
+    dpiOciFnType__nlsCharSetNameToId fnNlsCharSetNameToId;
+    dpiOciFnType__nlsEnvironmentVariableGet fnNlsEnvironmentVariableGet;
+    dpiOciFnType__nlsNameMap fnNlsNameMap;
+    dpiOciFnType__nlsNumericInfoGet fnNlsNumericInfoGet;
+    dpiOciFnType__numberFromInt fnNumberFromInt;
+    dpiOciFnType__numberFromReal fnNumberFromReal;
+    dpiOciFnType__numberToInt fnNumberToInt;
+    dpiOciFnType__numberToReal fnNumberToReal;
+    dpiOciFnType__objectCopy fnObjectCopy;
+    dpiOciFnType__objectFree fnObjectFree;
+    dpiOciFnType__objectGetAttr fnObjectGetAttr;
+    dpiOciFnType__objectGetInd fnObjectGetInd;
+    dpiOciFnType__objectNew fnObjectNew;
+    dpiOciFnType__objectPin fnObjectPin;
+    dpiOciFnType__objectSetAttr fnObjectSetAttr;
+    dpiOciFnType__paramGet fnParamGet;
+    dpiOciFnType__passwordChange fnPasswordChange;
+    dpiOciFnType__ping fnPing;
+    dpiOciFnType__rawAssignBytes fnRawAssignBytes;
+    dpiOciFnType__rawPtr fnRawPtr;
+    dpiOciFnType__rawResize fnRawResize;
+    dpiOciFnType__rawSize fnRawSize;
+    dpiOciFnType__rowidToChar fnRowidToChar;
+    dpiOciFnType__serverAttach fnServerAttach;
+    dpiOciFnType__serverDetach fnServerDetach;
+    dpiOciFnType__serverRelease fnServerRelease;
+    dpiOciFnType__serverRelease2 fnServerRelease2;
+    dpiOciFnType__sessionBegin fnSessionBegin;
+    dpiOciFnType__sessionEnd fnSessionEnd;
+    dpiOciFnType__sessionGet fnSessionGet;
+    dpiOciFnType__sessionPoolCreate fnSessionPoolCreate;
+    dpiOciFnType__sessionPoolDestroy fnSessionPoolDestroy;
+    dpiOciFnType__sessionRelease fnSessionRelease;
+    dpiOciFnType__shardingKeyColumnAdd fnShardingKeyColumnAdd;
+    dpiOciFnType__stmtExecute fnStmtExecute;
+    dpiOciFnType__sodaBulkInsert fnSodaBulkInsert;
+    dpiOciFnType__sodaBulkInsertAndGet fnSodaBulkInsertAndGet;
+    dpiOciFnType__sodaBulkInsertAndGetWithOpts fnSodaBulkInsertAndGetWithOpts;
+    dpiOciFnType__sodaCollCreateWithMetadata fnSodaCollCreateWithMetadata;
+    dpiOciFnType__sodaCollDrop fnSodaCollDrop;
+    dpiOciFnType__sodaCollGetNext fnSodaCollGetNext;
+    dpiOciFnType__sodaCollList fnSodaCollList;
+    dpiOciFnType__sodaCollOpen fnSodaCollOpen;
+    dpiOciFnType__sodaCollTruncate fnSodaCollTruncate;
+    dpiOciFnType__sodaDataGuideGet fnSodaDataGuideGet;
+    dpiOciFnType__sodaDocCount fnSodaDocCount;
+    dpiOciFnType__sodaDocGetNext fnSodaDocGetNext;
+    dpiOciFnType__sodaFind fnSodaFind;
+    dpiOciFnType__sodaFindOne fnSodaFindOne;
+    dpiOciFnType__sodaIndexCreate fnSodaIndexCreate;
+    dpiOciFnType__sodaIndexDrop fnSodaIndexDrop;
+    dpiOciFnType__sodaInsert fnSodaInsert;
+    dpiOciFnType__sodaInsertAndGet fnSodaInsertAndGet;
+    dpiOciFnType__sodaInsertAndGetWithOpts fnSodaInsertAndGetWithOpts;
+    dpiOciFnType__sodaOperKeysSet fnSodaOperKeysSet;
+    dpiOciFnType__sodaRemove fnSodaRemove;
+    dpiOciFnType__sodaReplOne fnSodaReplOne;
+    dpiOciFnType__sodaReplOneAndGet fnSodaReplOneAndGet;
+    dpiOciFnType__sodaSave fnSodaSave;
+    dpiOciFnType__sodaSaveAndGet fnSodaSaveAndGet;
+    dpiOciFnType__sodaSaveAndGetWithOpts fnSodaSaveAndGetWithOpts;
+    dpiOciFnType__stmtFetch2 fnStmtFetch2;
+    dpiOciFnType__stmtGetBindInfo fnStmtGetBindInfo;
+    dpiOciFnType__stmtGetNextResult fnStmtGetNextResult;
+    dpiOciFnType__stmtPrepare2 fnStmtPrepare2;
+    dpiOciFnType__stmtRelease fnStmtRelease;
+    dpiOciFnType__stringAssignText fnStringAssignText;
+    dpiOciFnType__stringPtr fnStringPtr;
+    dpiOciFnType__stringResize fnStringResize;
+    dpiOciFnType__stringSize fnStringSize;
+    dpiOciFnType__subscriptionRegister fnSubscriptionRegister;
+    dpiOciFnType__subscriptionUnRegister fnSubscriptionUnRegister;
+    dpiOciFnType__tableDelete fnTableDelete;
+    dpiOciFnType__tableExists fnTableExists;
+    dpiOciFnType__tableFirst fnTableFirst;
+    dpiOciFnType__tableLast fnTableLast;
+    dpiOciFnType__tableNext fnTableNext;
+    dpiOciFnType__tablePrev fnTablePrev;
+    dpiOciFnType__tableSize fnTableSize;
+    dpiOciFnType__threadKeyDestroy fnThreadKeyDestroy;
+    dpiOciFnType__threadKeyGet fnThreadKeyGet;
+    dpiOciFnType__threadKeyInit fnThreadKeyInit;
+    dpiOciFnType__threadKeySet fnThreadKeySet;
+    dpiOciFnType__threadProcessInit fnThreadProcessInit;
+    dpiOciFnType__transCommit fnTransCommit;
+    dpiOciFnType__transDetach fnTransDetach;
+    dpiOciFnType__transForget fnTransForget;
+    dpiOciFnType__transPrepare fnTransPrepare;
+    dpiOciFnType__transRollback fnTransRollback;
+    dpiOciFnType__transStart fnTransStart;
+    dpiOciFnType__typeByFullName fnTypeByFullName;
+    dpiOciFnType__typeByName fnTypeByName;
+} dpiOciSymbols;
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__allocateMem() [INTERNAL]
+//   Wrapper for OCI allocation of memory, only used when debugging memory
+// allocation.
+//-----------------------------------------------------------------------------
+static void *dpiOci__allocateMem(UNUSED void *unused, size_t size)
+{
+    void *ptr;
+
+    ptr = malloc(size);
+    dpiDebug__print("OCI allocated %u bytes at %p\n", size, ptr);
+    return ptr;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__aqDeq() [INTERNAL]
+//   Wrapper for OCIAQDeq().
+//-----------------------------------------------------------------------------
+int dpiOci__aqDeq(dpiConn *conn, const char *queueName, void *options,
+        void *msgProps, void *payloadType, void **payload, void **payloadInd,
+        void **msgId, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIAQDeq", dpiOciSymbols.fnAqDeq)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnAqDeq)(conn->handle, error->handle, queueName,
+            options, msgProps, payloadType, payload, payloadInd, msgId,
+            DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "dequeue message");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__aqDeqArray() [INTERNAL]
+//   Wrapper for OCIAQDeqArray().
+//-----------------------------------------------------------------------------
+int dpiOci__aqDeqArray(dpiConn *conn, const char *queueName, void *options,
+        uint32_t *numIters, void **msgProps, void *payloadType, void **payload,
+        void **payloadInd, void **msgId, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIAQDeqArray", dpiOciSymbols.fnAqDeqArray)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnAqDeqArray)(conn->handle, error->handle,
+            queueName, options, numIters, msgProps, payloadType, payload,
+            payloadInd, msgId, NULL, NULL, DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "dequeue messages");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__aqEnq() [INTERNAL]
+//   Wrapper for OCIAQEnq().
+//-----------------------------------------------------------------------------
+int dpiOci__aqEnq(dpiConn *conn, const char *queueName, void *options,
+        void *msgProps, void *payloadType, void **payload, void **payloadInd,
+        void **msgId, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIAQEnq", dpiOciSymbols.fnAqEnq)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnAqEnq)(conn->handle, error->handle, queueName,
+            options, msgProps, payloadType, payload, payloadInd, msgId,
+            DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "enqueue message");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__aqEnqArray() [INTERNAL]
+//   Wrapper for OCIAQEnqArray().
+//-----------------------------------------------------------------------------
+int dpiOci__aqEnqArray(dpiConn *conn, const char *queueName, void *options,
+        uint32_t *numIters, void **msgProps, void *payloadType, void **payload,
+        void **payloadInd, void **msgId, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIAQEnqArray", dpiOciSymbols.fnAqEnqArray)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnAqEnqArray)(conn->handle, error->handle,
+            queueName, options, numIters, msgProps, payloadType, payload,
+            payloadInd, msgId, NULL, NULL, DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "enqueue messages");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__arrayDescriptorAlloc() [INTERNAL]
+//   Wrapper for OCIArrayDescriptorAlloc().
+//-----------------------------------------------------------------------------
+int dpiOci__arrayDescriptorAlloc(void *envHandle, void **handle,
+        uint32_t handleType, uint32_t arraySize, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIArrayDescriptorAlloc",
+            dpiOciSymbols.fnArrayDescriptorAlloc)
+    status = (*dpiOciSymbols.fnArrayDescriptorAlloc)(envHandle, handle,
+            handleType, arraySize, 0, NULL);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "allocate descriptors");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__arrayDescriptorFree() [INTERNAL]
+//   Wrapper for OCIArrayDescriptorFree().
+//-----------------------------------------------------------------------------
+int dpiOci__arrayDescriptorFree(void **handle, uint32_t handleType)
+{
+    dpiError *error = NULL;
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIArrayDescriptorFree",
+            dpiOciSymbols.fnArrayDescriptorFree)
+    status = (*dpiOciSymbols.fnArrayDescriptorFree)(handle, handleType);
+    if (status != DPI_OCI_SUCCESS &&
+            dpiDebugLevel & DPI_DEBUG_LEVEL_UNREPORTED_ERRORS)
+        dpiDebug__print("free array descriptors %p, handleType %d failed\n",
+                handle, handleType);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__attrGet() [INTERNAL]
+//   Wrapper for OCIAttrGet().
+//-----------------------------------------------------------------------------
+int dpiOci__attrGet(const void *handle, uint32_t handleType, void *ptr,
+        uint32_t *size, uint32_t attribute, const char *action,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnAttrGet)(handle, handleType, ptr, size,
+            attribute, error->handle);
+    if (status == DPI_OCI_NO_DATA && size) {
+        *size = 0;
+        return DPI_SUCCESS;
+    } else if (!action) {
+        return DPI_SUCCESS;
+    }
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, action);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__attrSet() [INTERNAL]
+//   Wrapper for OCIAttrSet().
+//-----------------------------------------------------------------------------
+int dpiOci__attrSet(void *handle, uint32_t handleType, void *ptr,
+        uint32_t size, uint32_t attribute, const char *action, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnAttrSet)(handle, handleType, ptr, size,
+            attribute, error->handle);
+    if (!action)
+        return DPI_SUCCESS;
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, action);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__bindByName() [INTERNAL]
+//   Wrapper for OCIBindByName().
+//-----------------------------------------------------------------------------
+int dpiOci__bindByName(dpiStmt *stmt, void **bindHandle, const char *name,
+        int32_t nameLength, int dynamicBind, dpiVar *var, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIBindByName", dpiOciSymbols.fnBindByName)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnBindByName)(stmt->handle, bindHandle,
+            error->handle, name, nameLength,
+            (dynamicBind) ? NULL : var->buffer.data.asRaw,
+            (var->isDynamic) ? INT_MAX : (int32_t) var->sizeInBytes,
+            var->type->oracleType, (dynamicBind) ? NULL :
+                    var->buffer.indicator,
+            (dynamicBind || var->type->sizeInBytes) ? NULL :
+                    var->buffer.actualLength16,
+            (dynamicBind) ? NULL : var->buffer.returnCode,
+            (var->isArray) ? var->buffer.maxArraySize : 0,
+            (var->isArray) ? &var->buffer.actualArraySize : NULL,
+            (dynamicBind) ? DPI_OCI_DATA_AT_EXEC : DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "bind by name");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__bindByName2() [INTERNAL]
+//   Wrapper for OCIBindByName2().
+//-----------------------------------------------------------------------------
+int dpiOci__bindByName2(dpiStmt *stmt, void **bindHandle, const char *name,
+        int32_t nameLength, int dynamicBind, dpiVar *var, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIBindByName2", dpiOciSymbols.fnBindByName2)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnBindByName2)(stmt->handle, bindHandle,
+            error->handle, name, nameLength,
+            (dynamicBind) ? NULL : var->buffer.data.asRaw,
+            (var->isDynamic) ? INT_MAX : var->sizeInBytes,
+            var->type->oracleType, (dynamicBind) ? NULL :
+                    var->buffer.indicator,
+            (dynamicBind || var->type->sizeInBytes) ? NULL :
+                    var->buffer.actualLength32,
+            (dynamicBind) ? NULL : var->buffer.returnCode,
+            (var->isArray) ? var->buffer.maxArraySize : 0,
+            (var->isArray) ? &var->buffer.actualArraySize : NULL,
+            (dynamicBind) ? DPI_OCI_DATA_AT_EXEC : DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "bind by name");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__bindByPos() [INTERNAL]
+//   Wrapper for OCIBindByPos().
+//-----------------------------------------------------------------------------
+int dpiOci__bindByPos(dpiStmt *stmt, void **bindHandle, uint32_t pos,
+        int dynamicBind, dpiVar *var, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIBindByPos", dpiOciSymbols.fnBindByPos)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnBindByPos)(stmt->handle, bindHandle,
+            error->handle, pos, (dynamicBind) ? NULL : var->buffer.data.asRaw,
+            (var->isDynamic) ? INT_MAX : (int32_t) var->sizeInBytes,
+            var->type->oracleType, (dynamicBind) ? NULL :
+                    var->buffer.indicator,
+            (dynamicBind || var->type->sizeInBytes) ? NULL :
+                    var->buffer.actualLength16,
+            (dynamicBind) ? NULL : var->buffer.returnCode,
+            (var->isArray) ? var->buffer.maxArraySize : 0,
+            (var->isArray) ? &var->buffer.actualArraySize : NULL,
+            (dynamicBind) ? DPI_OCI_DATA_AT_EXEC : DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "bind by position");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__bindByPos2() [INTERNAL]
+//   Wrapper for OCIBindByPos2().
+//-----------------------------------------------------------------------------
+int dpiOci__bindByPos2(dpiStmt *stmt, void **bindHandle, uint32_t pos,
+        int dynamicBind, dpiVar *var, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIBindByPos2", dpiOciSymbols.fnBindByPos2)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnBindByPos2)(stmt->handle, bindHandle,
+            error->handle, pos, (dynamicBind) ? NULL : var->buffer.data.asRaw,
+            (var->isDynamic) ? INT_MAX : var->sizeInBytes,
+            var->type->oracleType, (dynamicBind) ? NULL :
+                    var->buffer.indicator,
+            (dynamicBind || var->type->sizeInBytes) ? NULL :
+                    var->buffer.actualLength32,
+            (dynamicBind) ? NULL : var->buffer.returnCode,
+            (var->isArray) ? var->buffer.maxArraySize : 0,
+            (var->isArray) ? &var->buffer.actualArraySize : NULL,
+            (dynamicBind) ? DPI_OCI_DATA_AT_EXEC : DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "bind by position");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__bindDynamic() [INTERNAL]
+//   Wrapper for OCIBindDynamic().
+//-----------------------------------------------------------------------------
+int dpiOci__bindDynamic(dpiVar *var, void *bindHandle, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIBindDynamic", dpiOciSymbols.fnBindDynamic)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnBindDynamic)(bindHandle, error->handle, var,
+            (void*) dpiVar__inBindCallback, var,
+            (void*) dpiVar__outBindCallback);
+    DPI_OCI_CHECK_AND_RETURN(error, status, var->conn, "bind dynamic");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__bindObject() [INTERNAL]
+//   Wrapper for OCIBindObject().
+//-----------------------------------------------------------------------------
+int dpiOci__bindObject(dpiVar *var, void *bindHandle, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIBindObject", dpiOciSymbols.fnBindObject)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnBindObject)(bindHandle, error->handle,
+            var->objectType->tdo, (void**) var->buffer.data.asRaw, 0,
+            var->buffer.objectIndicator, 0);
+    DPI_OCI_CHECK_AND_RETURN(error, status, var->conn, "bind object");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__break() [INTERNAL]
+//   Wrapper for OCIBreak().
+//-----------------------------------------------------------------------------
+int dpiOci__break(dpiConn *conn, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIBreak", dpiOciSymbols.fnBreak)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnBreak)(conn->handle, error->handle);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "break execution");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__collAppend() [INTERNAL]
+//   Wrapper for OCICollAppend().
+//-----------------------------------------------------------------------------
+int dpiOci__collAppend(dpiConn *conn, const void *elem, const void *elemInd,
+        void *coll, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCICollAppend", dpiOciSymbols.fnCollAppend)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnCollAppend)(conn->env->handle, error->handle,
+            elem, elemInd, coll);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "append element");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__collAssignElem() [INTERNAL]
+//   Wrapper for OCICollAssignElem().
+//-----------------------------------------------------------------------------
+int dpiOci__collAssignElem(dpiConn *conn, int32_t index, const void *elem,
+        const void *elemInd, void *coll, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCICollAssignElem", dpiOciSymbols.fnCollAssignElem)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnCollAssignElem)(conn->env->handle,
+            error->handle, index, elem, elemInd, coll);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "assign element");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__collGetElem() [INTERNAL]
+//   Wrapper for OCICollGetElem().
+//-----------------------------------------------------------------------------
+int dpiOci__collGetElem(dpiConn *conn, void *coll, int32_t index, int *exists,
+        void **elem, void **elemInd, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCICollGetElem", dpiOciSymbols.fnCollGetElem)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnCollGetElem)(conn->env->handle, error->handle,
+            coll, index, exists, elem, elemInd);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "get element");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__collSize() [INTERNAL]
+//   Wrapper for OCICollSize().
+//-----------------------------------------------------------------------------
+int dpiOci__collSize(dpiConn *conn, void *coll, int32_t *size, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCICollSize", dpiOciSymbols.fnCollSize)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnCollSize)(conn->env->handle, error->handle,
+            coll, size);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "get size");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__collTrim() [INTERNAL]
+//   Wrapper for OCICollTrim().
+//-----------------------------------------------------------------------------
+int dpiOci__collTrim(dpiConn *conn, uint32_t numToTrim, void *coll,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCICollTrim", dpiOciSymbols.fnCollTrim)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnCollTrim)(conn->env->handle, error->handle,
+            (int32_t) numToTrim, coll);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "trim");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__contextGetValue() [INTERNAL]
+//   Wrapper for OCIContextGetValue().
+//-----------------------------------------------------------------------------
+int dpiOci__contextGetValue(dpiConn *conn, const char *key, uint32_t keyLength,
+        void **value, int checkError, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIContextGetValue", dpiOciSymbols.fnContextGetValue)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnContextGetValue)(conn->sessionHandle,
+            error->handle, key, (uint8_t) keyLength, value);
+    if (!checkError)
+        return DPI_SUCCESS;
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "get context value");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__contextSetValue() [INTERNAL]
+//   Wrapper for OCIContextSetValue().
+//-----------------------------------------------------------------------------
+int dpiOci__contextSetValue(dpiConn *conn, const char *key, uint32_t keyLength,
+        void *value, int checkError, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIContextSetValue", dpiOciSymbols.fnContextSetValue)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnContextSetValue)(conn->sessionHandle,
+            error->handle, DPI_OCI_DURATION_SESSION, key, (uint8_t) keyLength,
+            value);
+    if (!checkError)
+        return DPI_SUCCESS;
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "set context value");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__dateTimeConstruct() [INTERNAL]
+//   Wrapper for OCIDateTimeConstruct().
+//-----------------------------------------------------------------------------
+int dpiOci__dateTimeConstruct(void *envHandle, void *handle, int16_t year,
+        uint8_t month, uint8_t day, uint8_t hour, uint8_t minute,
+        uint8_t second, uint32_t fsecond, const char *tz, size_t tzLength,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDateTimeConstruct",
+            dpiOciSymbols.fnDateTimeConstruct)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnDateTimeConstruct)(envHandle, error->handle,
+            handle, year, month, day, hour, minute, second, fsecond, tz,
+            tzLength);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "construct date");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__dateTimeConvert() [INTERNAL]
+//   Wrapper for OCIDateTimeConvert().
+//-----------------------------------------------------------------------------
+int dpiOci__dateTimeConvert(void *envHandle, void *inDate, void *outDate,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDateTimeConvert", dpiOciSymbols.fnDateTimeConvert)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnDateTimeConvert)(envHandle, error->handle,
+            inDate, outDate);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "convert date");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__dateTimeGetDate() [INTERNAL]
+//   Wrapper for OCIDateTimeGetDate().
+//-----------------------------------------------------------------------------
+int dpiOci__dateTimeGetDate(void *envHandle, void *handle, int16_t *year,
+        uint8_t *month, uint8_t *day, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDateTimeGetDate", dpiOciSymbols.fnDateTimeGetDate)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnDateTimeGetDate)(envHandle, error->handle,
+            handle, year, month, day);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get date portion");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__dateTimeGetTime() [INTERNAL]
+//   Wrapper for OCIDateTimeGetTime().
+//-----------------------------------------------------------------------------
+int dpiOci__dateTimeGetTime(void *envHandle, void *handle, uint8_t *hour,
+        uint8_t *minute, uint8_t *second, uint32_t *fsecond, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDateTimeGetTime", dpiOciSymbols.fnDateTimeGetTime)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnDateTimeGetTime)(envHandle, error->handle,
+            handle, hour, minute, second, fsecond);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get time portion");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__dateTimeGetTimeZoneOffset() [INTERNAL]
+//   Wrapper for OCIDateTimeGetTimeZoneOffset().
+//-----------------------------------------------------------------------------
+int dpiOci__dateTimeGetTimeZoneOffset(void *envHandle, void *handle,
+        int8_t *tzHourOffset, int8_t *tzMinuteOffset, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDateTimeGetTimeZoneOffset",
+            dpiOciSymbols.fnDateTimeGetTimeZoneOffset)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnDateTimeGetTimeZoneOffset)(envHandle,
+            error->handle, handle, tzHourOffset, tzMinuteOffset);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get time zone portion");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__dateTimeIntervalAdd() [INTERNAL]
+//   Wrapper for OCIDateTimeIntervalAdd().
+//-----------------------------------------------------------------------------
+int dpiOci__dateTimeIntervalAdd(void *envHandle, void *handle, void *interval,
+        void *outHandle, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDateTimeIntervalAdd",
+            dpiOciSymbols.fnDateTimeIntervalAdd)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnDateTimeIntervalAdd)(envHandle, error->handle,
+            handle, interval, outHandle);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "add interval to date");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__dateTimeSubtract() [INTERNAL]
+//   Wrapper for OCIDateTimeSubtract().
+//-----------------------------------------------------------------------------
+int dpiOci__dateTimeSubtract(void *envHandle, void *handle1, void *handle2,
+        void *interval, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDateTimeSubtract",
+            dpiOciSymbols.fnDateTimeSubtract)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnDateTimeSubtract)(envHandle, error->handle,
+            handle1, handle2, interval);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "subtract date");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__dbShutdown() [INTERNAL]
+//   Wrapper for OCIDBShutdown().
+//-----------------------------------------------------------------------------
+int dpiOci__dbShutdown(dpiConn *conn, uint32_t mode, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDBShutdown", dpiOciSymbols.fnDbShutdown)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnDbShutdown)(conn->handle, error->handle, NULL,
+            mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "shutdown database");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__dbStartup() [INTERNAL]
+//   Wrapper for OCIDBStartup().
+//-----------------------------------------------------------------------------
+int dpiOci__dbStartup(dpiConn *conn, void *adminHandle, uint32_t mode,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDBStartup", dpiOciSymbols.fnDbStartup)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnDbStartup)(conn->handle, error->handle,
+            adminHandle, DPI_OCI_DEFAULT, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "startup database");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__defineByPos() [INTERNAL]
+//   Wrapper for OCIDefineByPos().
+//-----------------------------------------------------------------------------
+int dpiOci__defineByPos(dpiStmt *stmt, void **defineHandle, uint32_t pos,
+        dpiVar *var, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDefineByPos", dpiOciSymbols.fnDefineByPos)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnDefineByPos)(stmt->handle, defineHandle,
+            error->handle, pos, (var->isDynamic) ? NULL :
+                    var->buffer.data.asRaw,
+            (var->isDynamic) ? INT_MAX : (int32_t) var->sizeInBytes,
+            var->type->oracleType, (var->isDynamic) ? NULL :
+                    var->buffer.indicator,
+            (var->isDynamic) ? NULL : var->buffer.actualLength16,
+            (var->isDynamic) ? NULL : var->buffer.returnCode,
+            (var->isDynamic) ? DPI_OCI_DYNAMIC_FETCH : DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "define");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__defineByPos2() [INTERNAL]
+//   Wrapper for OCIDefineByPos2().
+//-----------------------------------------------------------------------------
+int dpiOci__defineByPos2(dpiStmt *stmt, void **defineHandle, uint32_t pos,
+        dpiVar *var, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDefineByPos2", dpiOciSymbols.fnDefineByPos2)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnDefineByPos2)(stmt->handle, defineHandle,
+            error->handle, pos, (var->isDynamic) ? NULL :
+                    var->buffer.data.asRaw,
+            (var->isDynamic) ? INT_MAX : var->sizeInBytes,
+            var->type->oracleType, (var->isDynamic) ? NULL :
+                    var->buffer.indicator,
+            (var->isDynamic) ? NULL : var->buffer.actualLength32,
+            (var->isDynamic) ? NULL : var->buffer.returnCode,
+            (var->isDynamic) ? DPI_OCI_DYNAMIC_FETCH : DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "define");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__defineDynamic() [INTERNAL]
+//   Wrapper for OCIDefineDynamic().
+//-----------------------------------------------------------------------------
+int dpiOci__defineDynamic(dpiVar *var, void *defineHandle, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDefineDynamic", dpiOciSymbols.fnDefineDynamic)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnDefineDynamic)(defineHandle, error->handle, var,
+            (void*) dpiVar__defineCallback);
+    DPI_OCI_CHECK_AND_RETURN(error, status, var->conn, "define dynamic");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__defineObject() [INTERNAL]
+//   Wrapper for OCIDefineObject().
+//-----------------------------------------------------------------------------
+int dpiOci__defineObject(dpiVar *var, void *defineHandle, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDefineObject", dpiOciSymbols.fnDefineObject)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnDefineObject)(defineHandle, error->handle,
+            var->objectType->tdo, (void**) var->buffer.data.asRaw, 0,
+            var->buffer.objectIndicator, 0);
+    DPI_OCI_CHECK_AND_RETURN(error, status, var->conn, "define object");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__describeAny() [INTERNAL]
+//   Wrapper for OCIDescribeAny().
+//-----------------------------------------------------------------------------
+int dpiOci__describeAny(dpiConn *conn, void *obj, uint32_t objLength,
+        uint8_t objType, void *describeHandle, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDescribeAny", dpiOciSymbols.fnDescribeAny)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnDescribeAny)(conn->handle, error->handle, obj,
+            objLength, objType, 0, DPI_OCI_PTYPE_TYPE, describeHandle);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "describe type");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__descriptorAlloc() [INTERNAL]
+//   Wrapper for OCIDescriptorAlloc().
+//-----------------------------------------------------------------------------
+int dpiOci__descriptorAlloc(void *envHandle, void **handle,
+        const uint32_t handleType, const char *action, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDescriptorAlloc", dpiOciSymbols.fnDescriptorAlloc)
+    status = (*dpiOciSymbols.fnDescriptorAlloc)(envHandle, handle, handleType,
+            0, NULL);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, action);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__descriptorFree() [INTERNAL]
+//   Wrapper for OCIDescriptorFree().
+//-----------------------------------------------------------------------------
+int dpiOci__descriptorFree(void *handle, uint32_t handleType)
+{
+    dpiError *error = NULL;
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIDescriptorFree", dpiOciSymbols.fnDescriptorFree)
+    status = (*dpiOciSymbols.fnDescriptorFree)(handle, handleType);
+    if (status != DPI_OCI_SUCCESS &&
+            dpiDebugLevel & DPI_DEBUG_LEVEL_UNREPORTED_ERRORS)
+        dpiDebug__print("free descriptor %p, type %d failed\n", handle,
+                handleType);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__envNlsCreate() [INTERNAL]
+//   Wrapper for OCIEnvNlsCreate().
+//-----------------------------------------------------------------------------
+int dpiOci__envNlsCreate(void **envHandle, uint32_t mode, uint16_t charsetId,
+        uint16_t ncharsetId, dpiError *error)
+{
+    void *mallocFn = NULL, *reallocFn = NULL, *freeFn = NULL;
+    int status;
+
+    *envHandle = NULL;
+    DPI_OCI_LOAD_SYMBOL("OCIEnvNlsCreate", dpiOciSymbols.fnEnvNlsCreate)
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_MEM) {
+        mallocFn = (void*) dpiOci__allocateMem;
+        reallocFn = (void*) dpiOci__reallocMem;
+        freeFn = (void*) dpiOci__freeMem;
+    }
+    status = (*dpiOciSymbols.fnEnvNlsCreate)(envHandle, mode, NULL, mallocFn,
+            reallocFn, freeFn, 0, NULL, charsetId, ncharsetId);
+    if (*envHandle) {
+        if (status == DPI_OCI_SUCCESS || status == DPI_OCI_SUCCESS_WITH_INFO)
+            return DPI_SUCCESS;
+        if (dpiOci__errorGet(*envHandle, DPI_OCI_HTYPE_ENV, charsetId,
+                "create env", error) == 0)
+            return DPI_FAILURE;
+    }
+    return dpiError__set(error, "create env", DPI_ERR_CREATE_ENV);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__errorGet() [INTERNAL]
+//   Wrapper for OCIErrorGet().
+//-----------------------------------------------------------------------------
+int dpiOci__errorGet(void *handle, uint32_t handleType, uint16_t charsetId,
+        const char *action, dpiError *error)
+{
+    uint32_t i, numChars, bufferChars;
+    uint16_t *utf16chars;
+    int status;
+    char *ptr;
+
+    DPI_OCI_LOAD_SYMBOL("OCIErrorGet", dpiOciSymbols.fnErrorGet)
+    status = (*dpiOciSymbols.fnErrorGet)(handle, 1, NULL, &error->buffer->code,
+            error->buffer->message, sizeof(error->buffer->message),
+            handleType);
+    if (status != DPI_OCI_SUCCESS)
+        return dpiError__set(error, action, DPI_ERR_GET_FAILED);
+    error->buffer->action = action;
+
+    // determine length of message since OCI does not provide this information;
+    // all encodings except UTF-16 can use normal string processing; cannot use
+    // type whar_t for processing UTF-16, though, as its size may be 4 on some
+    // platforms, not 2; also strip trailing whitespace from error messages
+    if (charsetId == DPI_CHARSET_ID_UTF16) {
+        numChars = 0;
+        utf16chars = (uint16_t*) error->buffer->message;
+        bufferChars = sizeof(error->buffer->message) / 2;
+        for (i = 0; i < bufferChars; i++) {
+            if (utf16chars[i] == 0)
+                break;
+            if (utf16chars[i] > 127 || !isspace(utf16chars[i]))
+                numChars = i + 1;
+        }
+        error->buffer->messageLength = numChars * 2;
+    } else {
+        error->buffer->messageLength =
+                (uint32_t) strlen(error->buffer->message);
+        ptr = error->buffer->message + error->buffer->messageLength - 1;
+        while (ptr > error->buffer->message && isspace((uint8_t) *ptr--))
+            error->buffer->messageLength--;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__freeMem() [INTERNAL]
+//   Wrapper for OCI allocation of memory, only used when debugging memory
+// allocation.
+//-----------------------------------------------------------------------------
+static void dpiOci__freeMem(UNUSED void *unused, void *ptr)
+{
+    char message[40];
+
+    (void) sprintf(message, "OCI freed ptr at %p", ptr);
+    free(ptr);
+    dpiDebug__print("%s\n", message);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__handleAlloc() [INTERNAL]
+//   Wrapper for OCIHandleAlloc().
+//-----------------------------------------------------------------------------
+int dpiOci__handleAlloc(void *envHandle, void **handle, uint32_t handleType,
+        const char *action, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIHandleAlloc", dpiOciSymbols.fnHandleAlloc)
+    status = (*dpiOciSymbols.fnHandleAlloc)(envHandle, handle, handleType, 0,
+            NULL);
+    if (handleType == DPI_OCI_HTYPE_ERROR && status != DPI_OCI_SUCCESS)
+        return dpiError__set(error, action, DPI_ERR_NO_MEMORY);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, action);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__handleFree() [INTERNAL]
+//   Wrapper for OCIHandleFree().
+//-----------------------------------------------------------------------------
+int dpiOci__handleFree(void *handle, uint32_t handleType)
+{
+    dpiError *error = NULL;
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIHandleFree", dpiOciSymbols.fnHandleFree)
+    status = (*dpiOciSymbols.fnHandleFree)(handle, handleType);
+    if (status != DPI_OCI_SUCCESS &&
+            dpiDebugLevel & DPI_DEBUG_LEVEL_UNREPORTED_ERRORS)
+        dpiDebug__print("free handle %p, handleType %d failed\n", handle,
+                handleType);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__intervalGetDaySecond() [INTERNAL]
+//   Wrapper for OCIIntervalGetDaySecond().
+//-----------------------------------------------------------------------------
+int dpiOci__intervalGetDaySecond(void *envHandle, int32_t *day, int32_t *hour,
+        int32_t *minute, int32_t *second, int32_t *fsecond,
+        const void *interval, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIIntervalGetDaySecond",
+            dpiOciSymbols.fnIntervalGetDaySecond)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnIntervalGetDaySecond)(envHandle,
+            error->handle, day, hour, minute, second, fsecond, interval);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get interval components");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__intervalGetYearMonth() [INTERNAL]
+//   Wrapper for OCIIntervalGetYearMonth().
+//-----------------------------------------------------------------------------
+int dpiOci__intervalGetYearMonth(void *envHandle, int32_t *year,
+        int32_t *month, const void *interval, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIIntervalGetYearMonth",
+            dpiOciSymbols.fnIntervalGetYearMonth)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnIntervalGetYearMonth)(envHandle, error->handle,
+            year, month, interval);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get interval components");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__intervalSetDaySecond() [INTERNAL]
+//   Wrapper for OCIIntervalSetDaySecond().
+//-----------------------------------------------------------------------------
+int dpiOci__intervalSetDaySecond(void *envHandle, int32_t day, int32_t hour,
+        int32_t minute, int32_t second, int32_t fsecond, void *interval,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIIntervalSetDaySecond",
+            dpiOciSymbols.fnIntervalSetDaySecond)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnIntervalSetDaySecond)(envHandle, error->handle,
+            day, hour, minute, second, fsecond, interval);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "set interval components");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__intervalSetYearMonth() [INTERNAL]
+//   Wrapper for OCIIntervalSetYearMonth().
+//-----------------------------------------------------------------------------
+int dpiOci__intervalSetYearMonth(void *envHandle, int32_t year, int32_t month,
+        void *interval, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIIntervalSetYearMonth",
+            dpiOciSymbols.fnIntervalSetYearMonth)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnIntervalSetYearMonth)(envHandle, error->handle,
+            year, month, interval);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "set interval components");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__jsonDomDocGet() [INTERNAL]
+//   Wrapper for OCIJsonDomDocGet().
+//-----------------------------------------------------------------------------
+int dpiOci__jsonDomDocGet(dpiJson *json, dpiJznDomDoc **domDoc,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIJsonDomDocGet", dpiOciSymbols.fnJsonDomDocGet)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnJsonDomDocGet)(json->conn->handle, json->handle,
+            domDoc, error->handle, DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, json->conn, "get JSON DOM doc");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__jsonTextBufferParse() [INTERNAL]
+//   Wrapper for OCIJsonTextBufferParse().
+//-----------------------------------------------------------------------------
+int dpiOci__jsonTextBufferParse(dpiJson *json, const char *value,
+        uint64_t valueLength, uint32_t flags, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIJsonTextBufferParse",
+            dpiOciSymbols.fnJsonTextBufferParse)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnJsonTextBufferParse)(json->conn->handle,
+            json->handle, (void*) value, valueLength,
+            (DPI_JZN_ALLOW_SCALAR_DOCUMENTS | flags), DPI_JZN_INPUT_UTF8,
+            error->handle, DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, json->conn, "parse JSON text");
+}
+
+
+#ifdef _WIN32
+
+//-----------------------------------------------------------------------------
+// dpiOci__checkDllArchitecture() [INTERNAL]
+//   Check the architecture of the specified DLL name and check if it
+// matches the expected architecture. If it does not, the load error is
+// modified and DPI_SUCCESS is returned; otherwise, DPI_FAILURE is returned.
+//-----------------------------------------------------------------------------
+static int dpiOci__checkDllArchitecture(dpiOciLoadLibParams *loadParams,
+        const char *name, dpiError *error)
+{
+    const char *errorFormat = "%s is not the correct architecture";
+    IMAGE_DOS_HEADER dosHeader;
+    IMAGE_NT_HEADERS ntHeaders;
+    FILE *fp;
+
+    // check DLL architecture
+    fp = fopen(name, "rb");
+    if (!fp)
+        return DPI_FAILURE;
+    fread(&dosHeader, sizeof(dosHeader), 1, fp);
+    if (dosHeader.e_magic != IMAGE_DOS_SIGNATURE) {
+        fclose(fp);
+        return DPI_FAILURE;
+    }
+    fseek(fp, dosHeader.e_lfanew, SEEK_SET);
+    fread(&ntHeaders, sizeof(ntHeaders), 1, fp);
+    fclose(fp);
+    if (ntHeaders.Signature != IMAGE_NT_SIGNATURE)
+        return DPI_FAILURE;
+
+#if defined _M_AMD64
+    if (ntHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64)
+        return DPI_FAILURE;
+#elif defined _M_IX86
+    if (ntHeaders.FileHeader.Machine == IMAGE_FILE_MACHINE_I386)
+        return DPI_FAILURE;
+#else
+    return DPI_FAILURE;
+#endif
+
+    // store a modified error in the error buffer
+    if (dpiUtils__ensureBuffer(strlen(errorFormat) + strlen(name) + 1,
+            "allocate wrong architecture load error buffer",
+            (void**) &loadParams->errorBuffer,
+            &loadParams->errorBufferLength, error) < 0)
+        return DPI_FAILURE;
+    sprintf(loadParams->errorBuffer, errorFormat, name);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__findAndCheckDllArchitecture() [INTERNAL]
+//   Attempt to find the specified DLL name using the standard search path and
+// if the DLL can be found but is of the wrong architecture, include the full
+// name of the DLL in the load error. Return DPI_SUCCESS if such a DLL was
+// found and was of the wrong architecture (in which case the load error has
+// been set); otherwise, return DPI_FAILURE so that the normal load error can
+// be determined.
+//-----------------------------------------------------------------------------
+static int dpiOci__findAndCheckDllArchitecture(dpiOciLoadLibParams *loadParams,
+        const char *name, dpiError *error)
+{
+    DWORD bufferLength;
+    char *temp, *path;
+    size_t length;
+    int status;
+
+    // if the name of the DLL is an absolute path, check it directly
+    temp = strchr(name, '\\');
+    if (temp)
+        return dpiOci__checkDllArchitecture(loadParams, name, error);
+
+    // check current directory
+    bufferLength = GetCurrentDirectory(0, NULL);
+    if (bufferLength == 0)
+        return DPI_FAILURE;
+    if (dpiUtils__ensureBuffer(strlen(name) + 1 + bufferLength,
+            "allocate load params name buffer (current dir)",
+            (void**) &loadParams->nameBuffer,
+            &loadParams->nameBufferLength, error) < 0)
+        return DPI_FAILURE;
+    if (GetCurrentDirectory(bufferLength, loadParams->nameBuffer) == 0)
+        return DPI_FAILURE;
+    temp = loadParams->nameBuffer + strlen(loadParams->nameBuffer);
+    *temp++ = '\\';
+    strcpy(temp, name);
+    status = dpiOci__checkDllArchitecture(loadParams, loadParams->nameBuffer,
+            error);
+
+    // search PATH
+    path = getenv("PATH");
+    if (path) {
+        while (status < 0) {
+            temp = strchr(path, ';');
+            if (temp) {
+                length = temp - path;
+            } else {
+                length = strlen(path);
+            }
+            if (dpiUtils__ensureBuffer(strlen(name) + length + 2,
+                    "allocate load params name buffer (PATH)",
+                    (void**) &loadParams->nameBuffer,
+                    &loadParams->nameBufferLength, error) < 0)
+                return DPI_FAILURE;
+            (void) sprintf(loadParams->nameBuffer, "%.*s\\%s", (int) length,
+                    path, name);
+            status = dpiOci__checkDllArchitecture(loadParams,
+                    loadParams->nameBuffer, error);
+            if (!temp)
+                break;
+            path = temp + 1;
+        }
+    }
+
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__loadLibWithName() [INTERNAL]
+//   Platform specific method of loading the library with a specific name.
+// Load errors are stored in the temporary load error buffer and do not cause
+// the function to fail; other errors (such as memory allocation errors) will
+// result in failure.
+//-----------------------------------------------------------------------------
+static int dpiOci__loadLibWithName(dpiOciLoadLibParams *loadParams,
+        const char *name, dpiError *error)
+{
+    DWORD errorNum;
+
+    // attempt to load the library
+    loadParams->handle = LoadLibrary(name);
+    if (loadParams->handle)
+        return DPI_SUCCESS;
+
+    // if DLL is of the wrong architecture, attempt to locate the DLL that was
+    // loaded and use that information if it can be found
+    errorNum = GetLastError();
+    if (errorNum == ERROR_BAD_EXE_FORMAT &&
+            dpiOci__findAndCheckDllArchitecture(loadParams, name, error) == 0)
+        return DPI_SUCCESS;
+
+    // otherwise, attempt to get the error message
+    return dpiUtils__getWindowsError(errorNum, &loadParams->errorBuffer,
+            &loadParams->errorBufferLength, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__loadLibInModuleDir() [INTERNAL]
+//   Attempts to load the library from the directory in which the ODPI-C module
+// (or its containing module) is located. This is platform specific.
+//-----------------------------------------------------------------------------
+static int dpiOci__loadLibInModuleDir(dpiOciLoadLibParams *loadParams,
+        dpiError *error)
+{
+    HMODULE module = NULL;
+    DWORD result = 0;
+    char *temp;
+
+    // attempt to get the module handle from a known function pointer
+    if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS,
+            (LPCSTR) dpiContext_createWithParams, &module) == 0)
+        return DPI_FAILURE;
+
+    // attempt to get the module name from the module; the size of the buffer
+    // is increased as needed as there is no other known way to acquire the
+    // full name (MAX_PATH is no longer the maximum path length)
+    if (dpiUtils__ensureBuffer(MAX_PATH, "allocate module name",
+            (void**) &loadParams->moduleNameBuffer,
+            &loadParams->moduleNameBufferLength, error) < 0) {
+        FreeLibrary(module);
+        return DPI_FAILURE;
+    }
+    while (1) {
+        result = GetModuleFileName(module, loadParams->moduleNameBuffer,
+                loadParams->moduleNameBufferLength);
+        if (result < (DWORD) loadParams->moduleNameBufferLength)
+            break;
+        if (dpiUtils__ensureBuffer(loadParams->moduleNameBufferLength * 2,
+                "allocate module name", (void**) &loadParams->moduleNameBuffer,
+                &loadParams->moduleNameBufferLength, error) < 0) {
+            FreeLibrary(module);
+            return DPI_FAILURE;
+        }
+    }
+    FreeLibrary(module);
+    if (result == 0)
+        return DPI_FAILURE;
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
+        dpiDebug__print("module name is %s\n", loadParams->moduleNameBuffer);
+
+    // use the module name to determine the directory and attempt to load the
+    // Oracle client libraries from there
+    temp = strrchr(loadParams->moduleNameBuffer, '\\');
+    if (temp) {
+        *temp = '\0';
+        return dpiOci__loadLibWithDir(loadParams, loadParams->moduleNameBuffer,
+                strlen(loadParams->moduleNameBuffer), 0, error);
+    }
+
+    return DPI_FAILURE;
+}
+
+
+// for platforms other than Windows
+#else
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__loadLibInModuleDir() [INTERNAL]
+//   Attempts to load the library from the directory in which the ODPI-C module
+// (or its containing module) is located. This is platform specific.
+//-----------------------------------------------------------------------------
+static int dpiOci__loadLibInModuleDir(dpiOciLoadLibParams *loadParams,
+        dpiError *error)
+{
+#ifndef _AIX
+    char *dirName;
+    Dl_info info;
+
+    if (dladdr(dpiContext_createWithParams, &info) != 0) {
+        if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
+            dpiDebug__print("module name is %s\n", info.dli_fname);
+        dirName = strrchr(info.dli_fname, '/');
+        if (dirName)
+            return dpiOci__loadLibWithDir(loadParams, info.dli_fname,
+                    (size_t) (dirName - info.dli_fname), 0, error);
+    }
+#endif
+
+    return DPI_FAILURE;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__loadLibWithName() [INTERNAL]
+//   Platform specific method of loading the library with a specific name.
+// Load errors are stored in the temporary load error buffer and do not cause
+// the function to fail; other errors (such as memory allocation errors) will
+// result in failure.
+//-----------------------------------------------------------------------------
+static int dpiOci__loadLibWithName(dpiOciLoadLibParams *loadParams,
+        const char *libName, dpiError *error)
+{
+    char *osError;
+
+    loadParams->handle = dlopen(libName, RTLD_LAZY);
+    if (!loadParams->handle) {
+        osError = dlerror();
+        if (dpiUtils__ensureBuffer(strlen(osError) + 1,
+                "allocate load error buffer",
+                (void**) &loadParams->errorBuffer,
+                &loadParams->errorBufferLength, error) < 0)
+            return DPI_FAILURE;
+        strcpy(loadParams->errorBuffer, osError);
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__loadLibWithOracleHome() [INTERNAL]
+//   Attempts to load the library from the lib subdirectory of an Oracle home
+// pointed to by the environemnt variable ORACLE_HOME.
+//-----------------------------------------------------------------------------
+static int dpiOci__loadLibWithOracleHome(dpiOciLoadLibParams *loadParams,
+        dpiError *error)
+{
+    char *oracleHome, *oracleHomeLibDir;
+    size_t oracleHomeLength;
+    int status;
+
+    // check environment variable; if not set, attempt cannot proceed
+    oracleHome = getenv("ORACLE_HOME");
+    if (!oracleHome)
+        return DPI_FAILURE;
+
+    // a zero-length directory is ignored
+    oracleHomeLength = strlen(oracleHome);
+    if (oracleHomeLength == 0)
+        return DPI_FAILURE;
+
+    // craft directory to search
+    if (dpiUtils__allocateMemory(1, oracleHomeLength + 5, 0,
+            "allocate ORACLE_HOME dir name", (void**) &oracleHomeLibDir,
+            error) < 0)
+        return DPI_FAILURE;
+    (void) sprintf(oracleHomeLibDir, "%s/lib", oracleHome);
+
+    // perform search
+    status = dpiOci__loadLibWithDir(loadParams, oracleHomeLibDir,
+           strlen(oracleHomeLibDir), 0, error);
+    dpiUtils__freeMemory(oracleHomeLibDir);
+    return status;
+}
+
+#endif
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__loadLibWithDir() [INTERNAL]
+//   Helper function for loading the OCI library. If a directory is specified,
+// that directory is searched; otherwise, an unqualfied search is performed
+// using the normal OS library loading rules.
+//-----------------------------------------------------------------------------
+static int dpiOci__loadLibWithDir(dpiOciLoadLibParams *loadParams,
+        const char *dirName, size_t dirNameLength, int scanAllNames,
+        dpiError *error)
+{
+    const char *searchName;
+    size_t nameLength;
+    int i;
+
+    // report attempt with directory, if applicable
+    if (dirName && dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
+        dpiDebug__print("load in dir %.*s\n", (int) dirNameLength, dirName);
+
+    // iterate over all possible options
+    for (i = 0; dpiOciLibNames[i]; i++) {
+
+        // determine name to search
+        if (!dirName) {
+            searchName = dpiOciLibNames[i];
+        } else {
+            nameLength = strlen(dpiOciLibNames[i]) + dirNameLength + 2;
+            if (dpiUtils__ensureBuffer(nameLength, "allocate name buffer",
+                    (void**) &loadParams->nameBuffer,
+                    &loadParams->nameBufferLength, error) < 0)
+                return DPI_FAILURE;
+            (void) sprintf(loadParams->nameBuffer, "%.*s/%s",
+                    (int) dirNameLength, dirName, dpiOciLibNames[i]);
+            searchName = loadParams->nameBuffer;
+        }
+
+        // attempt to load the library using the calculated name; failure here
+        // implies something other than a load failure and this error is
+        // reported immediately
+        if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
+            dpiDebug__print("load with name %s\n", searchName);
+        if (dpiOci__loadLibWithName(loadParams, searchName, error) < 0)
+            return DPI_FAILURE;
+
+        // success is also reported immediately
+        if (loadParams->handle) {
+            if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
+                dpiDebug__print("load by OS successful\n");
+            return DPI_SUCCESS;
+        }
+
+        // load failed; store the first failure that occurs which will be
+        // reported if no successful loads were made and no other errors took
+        // place
+        if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
+            dpiDebug__print("load by OS failure: %s\n",
+                    loadParams->errorBuffer);
+        if (i == 0) {
+            if (dpiUtils__ensureBuffer(loadParams->errorBufferLength,
+                    "allocate load error buffer",
+                    (void**) &loadParams->loadError,
+                    &loadParams->loadErrorLength, error) < 0)
+                return DPI_FAILURE;
+            strcpy(loadParams->loadError, loadParams->errorBuffer);
+            if (!scanAllNames)
+                break;
+        }
+
+    }
+
+    // no attempts were successful
+    return DPI_FAILURE;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__loadLib() [INTERNAL]
+//   Load the OCI library.
+//-----------------------------------------------------------------------------
+int dpiOci__loadLib(dpiContextCreateParams *params,
+        dpiVersionInfo *clientVersionInfo, dpiError *error)
+{
+    static const char *envNamesToCheck[] = {
+        "ORACLE_HOME",
+        "ORA_TZFILE",
+        "TNS_ADMIN",
+#ifdef _WIN32
+        "PATH",
+#else
+        "LD_LIBRARY_PATH",
+        "DYLD_LIBRARY_PATH",
+        "LIBPATH",
+        "SHLIB_PATH",
+#endif
+        NULL
+    };
+    dpiOciLoadLibParams loadLibParams;
+    const char *temp;
+    int status, i;
+
+    // log the directory parameter values and any environment variables that
+    // have an impact on loading the library
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB) {
+
+        // first log directory parameter values
+        dpiDebug__print("Context Parameters:\n");
+        if (params->oracleClientLibDir)
+            dpiDebug__print("    Oracle Client Lib Dir: %s\n",
+                    params->oracleClientLibDir);
+        if (params->oracleClientConfigDir)
+            dpiDebug__print("    Oracle Client Config Dir: %s\n",
+                    params->oracleClientConfigDir);
+
+        // now log environment variable values
+        dpiDebug__print("Environment Variables:\n");
+        for (i = 0; envNamesToCheck[i]; i++) {
+            temp = getenv(envNamesToCheck[i]);
+            if (temp)
+                dpiDebug__print("    %s => \"%s\"\n", envNamesToCheck[i],
+                        temp);
+        }
+
+    }
+
+    // if a config directory was specified in the create params, set the
+    // TNS_ADMIN environment variable
+    if (params->oracleClientConfigDir) {
+#ifdef _WIN32
+        if (!SetEnvironmentVariable("TNS_ADMIN",
+                    params->oracleClientConfigDir)) {
+#else
+        if (setenv("TNS_ADMIN", params->oracleClientConfigDir, 1) != 0) {
+#endif
+            return dpiError__setFromOS(error,
+                    "set TNS_ADMIN environment variable");
+        }
+    }
+
+    // initialize loading parameters; these are used to provide space for
+    // loading errors and the names that are being searched; memory is
+    // allocated dynamically in order to avoid potential issues with long paths
+    // on some platforms
+    memset(&loadLibParams, 0, sizeof(loadLibParams));
+
+    // if a lib directory was specified in the create params, look for the OCI
+    // library in that location only
+    if (params->oracleClientLibDir) {
+        if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
+            dpiDebug__print("load in parameter directory\n");
+        status = dpiOci__loadLibWithDir(&loadLibParams,
+                params->oracleClientLibDir, strlen(params->oracleClientLibDir),
+                1, error);
+
+    // otherwise, use the normal loading mechanism
+    } else {
+
+        // first try the directory in which the ODPI-C library itself is found
+        if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
+            dpiDebug__print("check module directory\n");
+        status = dpiOci__loadLibInModuleDir(&loadLibParams, error);
+
+        // if that fails, try the default OS library loading mechanism
+        if (status < 0) {
+            if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
+                dpiDebug__print("load with OS search heuristics\n");
+            status = dpiOci__loadLibWithDir(&loadLibParams, NULL, 0, 1, error);
+        }
+
+#ifndef _WIN32
+        // if that fails, on platforms other than Windows, attempt to load
+        // from $ORACLE_HOME/lib
+        if (status < 0) {
+            if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
+                dpiDebug__print("check ORACLE_HOME\n");
+            status = dpiOci__loadLibWithOracleHome(&loadLibParams, error);
+        }
+#endif
+
+    }
+
+    // if no attempts succeeded and no other error was reported, craft the
+    // error message that will be returned
+    if (status < 0 && (int) error->buffer->errorNum == 0) {
+        const char *bits = (sizeof(void*) == 8) ? "64" : "32";
+        dpiError__set(error, "load library", DPI_ERR_LOAD_LIBRARY,
+                bits, loadLibParams.loadError, params->loadErrorUrl);
+    }
+
+    // free any memory that was allocated
+    if (loadLibParams.nameBuffer)
+        dpiUtils__freeMemory(loadLibParams.nameBuffer);
+    if (loadLibParams.moduleNameBuffer)
+        dpiUtils__freeMemory(loadLibParams.moduleNameBuffer);
+    if (loadLibParams.loadError)
+        dpiUtils__freeMemory(loadLibParams.loadError);
+    if (loadLibParams.errorBuffer)
+        dpiUtils__freeMemory(loadLibParams.errorBuffer);
+
+    // if no attempts, succeeded, return an error
+    if (status < 0)
+        return DPI_FAILURE;
+
+    // validate library
+    dpiOciLibHandle = loadLibParams.handle;
+    if (dpiOci__loadLibValidate(clientVersionInfo, error) < 0) {
+#ifdef _WIN32
+        FreeLibrary(dpiOciLibHandle);
+#else
+        dlclose(dpiOciLibHandle);
+#endif
+        dpiOciLibHandle = NULL;
+        memset(&dpiOciSymbols, 0, sizeof(dpiOciSymbols));
+        return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__loadLibValidate() [INTERNAL]
+//   Validate the OCI library after loading.
+//-----------------------------------------------------------------------------
+static int dpiOci__loadLibValidate(dpiVersionInfo *clientVersionInfo,
+        dpiError *error)
+{
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_LOAD_LIB)
+        dpiDebug__print("validating loaded library\n");
+
+    // determine the OCI client version information
+    if (dpiOci__loadSymbol("OCIClientVersion",
+            (void**) &dpiOciSymbols.fnClientVersion, NULL) < 0)
+        return dpiError__set(error, "load symbol OCIClientVersion",
+                DPI_ERR_ORACLE_CLIENT_UNSUPPORTED);
+    memset(clientVersionInfo, 0, sizeof(*clientVersionInfo));
+    (*dpiOciSymbols.fnClientVersion)(&clientVersionInfo->versionNum,
+            &clientVersionInfo->releaseNum,
+            &clientVersionInfo->updateNum,
+            &clientVersionInfo->portReleaseNum,
+            &clientVersionInfo->portUpdateNum);
+    if (clientVersionInfo->versionNum == 0)
+        return dpiError__set(error, "get OCI client version",
+                DPI_ERR_ORACLE_CLIENT_UNSUPPORTED);
+    clientVersionInfo->fullVersionNum = (uint32_t)
+            DPI_ORACLE_VERSION_TO_NUMBER(clientVersionInfo->versionNum,
+                    clientVersionInfo->releaseNum,
+                    clientVersionInfo->updateNum,
+                    clientVersionInfo->portReleaseNum,
+                    clientVersionInfo->portUpdateNum);
+
+    // OCI version must be a minimum of 11.2
+    if (dpiUtils__checkClientVersion(clientVersionInfo, 11, 2, error) < 0)
+        return DPI_FAILURE;
+
+    // initialize threading capability in the OCI library
+    // this must be run prior to any other OCI threading calls
+    DPI_OCI_LOAD_SYMBOL("OCIThreadProcessInit",
+            dpiOciSymbols.fnThreadProcessInit)
+    (*dpiOciSymbols.fnThreadProcessInit)();
+
+    // load symbols for key functions which are called many times
+    // this list should be kept as small as possible in order to avoid
+    // overhead in looking up symbols at startup
+    DPI_OCI_LOAD_SYMBOL("OCIAttrGet", dpiOciSymbols.fnAttrGet)
+    DPI_OCI_LOAD_SYMBOL("OCIAttrSet", dpiOciSymbols.fnAttrSet)
+    DPI_OCI_LOAD_SYMBOL("OCIThreadKeyGet", dpiOciSymbols.fnThreadKeyGet)
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__loadSymbol() [INTERNAL]
+//   Return the symbol for the function that is to be called. The symbol table
+// is first consulted. If the symbol is not found there, it is looked up and
+// then stored there so the next invocation does not have to perform the
+// lookup.
+//-----------------------------------------------------------------------------
+static int dpiOci__loadSymbol(const char *symbolName, void **symbol,
+        dpiError *error)
+{
+#ifdef _WIN32
+    *symbol = GetProcAddress(dpiOciLibHandle, symbolName);
+#else
+    *symbol = dlsym(dpiOciLibHandle, symbolName);
+#endif
+    if (!*symbol)
+        return dpiError__set(error, "get symbol", DPI_ERR_LOAD_SYMBOL,
+                symbolName);
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobClose() [INTERNAL]
+//   Wrapper for OCILobClose().
+//-----------------------------------------------------------------------------
+int dpiOci__lobClose(dpiLob *lob, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCILobClose", dpiOciSymbols.fnLobClose)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnLobClose)(lob->conn->handle, error->handle,
+            lob->locator);
+    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "close LOB");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobCreateTemporary() [INTERNAL]
+//   Wrapper for OCILobCreateTemporary().
+//-----------------------------------------------------------------------------
+int dpiOci__lobCreateTemporary(dpiLob *lob, dpiError *error)
+{
+    uint8_t lobType;
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCILobCreateTemporary",
+            dpiOciSymbols.fnLobCreateTemporary)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    if (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_BLOB)
+        lobType = DPI_OCI_TEMP_BLOB;
+    else lobType = DPI_OCI_TEMP_CLOB;
+    status = (*dpiOciSymbols.fnLobCreateTemporary)(lob->conn->handle,
+            error->handle, lob->locator, DPI_OCI_DEFAULT,
+            lob->type->charsetForm, lobType, 1, DPI_OCI_DURATION_SESSION);
+    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "create temporary LOB");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobFileExists() [INTERNAL]
+//   Wrapper for OCILobFileExists().
+//-----------------------------------------------------------------------------
+int dpiOci__lobFileExists(dpiLob *lob, int *exists, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCILobFileExists", dpiOciSymbols.fnLobFileExists)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnLobFileExists)(lob->conn->handle, error->handle,
+            lob->locator, exists);
+    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "get file exists");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobFileGetName() [INTERNAL]
+//   Wrapper for OCILobFileGetName().
+//-----------------------------------------------------------------------------
+int dpiOci__lobFileGetName(dpiLob *lob, char *dirAlias,
+        uint16_t *dirAliasLength, char *name, uint16_t *nameLength,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCILobFileGetName", dpiOciSymbols.fnLobFileGetName)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnLobFileGetName)(lob->env->handle, error->handle,
+            lob->locator, dirAlias, dirAliasLength, name, nameLength);
+    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "get LOB file name");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobFileSetName() [INTERNAL]
+//   Wrapper for OCILobFileSetName().
+//-----------------------------------------------------------------------------
+int dpiOci__lobFileSetName(dpiLob *lob, const char *dirAlias,
+        uint16_t dirAliasLength, const char *name, uint16_t nameLength,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCILobFileSetName", dpiOciSymbols.fnLobFileSetName)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnLobFileSetName)(lob->env->handle, error->handle,
+            &lob->locator, dirAlias, dirAliasLength, name, nameLength);
+    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "set LOB file name");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobFreeTemporary() [INTERNAL]
+//   Wrapper for OCILobFreeTemporary().
+//-----------------------------------------------------------------------------
+int dpiOci__lobFreeTemporary(dpiConn *conn, void *lobLocator, int checkError,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCILobFreeTemporary",
+            dpiOciSymbols.fnLobFreeTemporary)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnLobFreeTemporary)(conn->handle,
+            error->handle, lobLocator);
+    if (!checkError)
+        return DPI_SUCCESS;
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "free temporary LOB");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobGetChunkSize() [INTERNAL]
+//   Wrapper for OCILobGetChunkSize().
+//-----------------------------------------------------------------------------
+int dpiOci__lobGetChunkSize(dpiLob *lob, uint32_t *size, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCILobGetChunkSize", dpiOciSymbols.fnLobGetChunkSize)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnLobGetChunkSize)(lob->conn->handle,
+            error->handle, lob->locator, size);
+    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "get chunk size");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobGetLength2() [INTERNAL]
+//   Wrapper for OCILobGetLength2().
+//-----------------------------------------------------------------------------
+int dpiOci__lobGetLength2(dpiLob *lob, uint64_t *size, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCILobGetLength2", dpiOciSymbols.fnLobGetLength2)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnLobGetLength2)(lob->conn->handle, error->handle,
+            lob->locator, size);
+    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "get length");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobIsOpen() [INTERNAL]
+//   Wrapper for OCILobIsOpen().
+//-----------------------------------------------------------------------------
+int dpiOci__lobIsOpen(dpiLob *lob, int *isOpen, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCILobIsOpen", dpiOciSymbols.fnLobIsOpen)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnLobIsOpen)(lob->conn->handle, error->handle,
+            lob->locator, isOpen);
+    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "check is open");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobIsTemporary() [INTERNAL]
+//   Wrapper for OCILobIsTemporary().
+//-----------------------------------------------------------------------------
+int dpiOci__lobIsTemporary(dpiLob *lob, int *isTemporary, int checkError,
+        dpiError *error)
+{
+    int status;
+
+    *isTemporary = 0;
+    DPI_OCI_LOAD_SYMBOL("OCILobIsTemporary", dpiOciSymbols.fnLobIsTemporary)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnLobIsTemporary)(lob->env->handle, error->handle,
+            lob->locator, isTemporary);
+    if (!checkError)
+        return DPI_SUCCESS;
+    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "check is temporary");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobLocatorAssign() [INTERNAL]
+//   Wrapper for OCILobLocatorAssign().
+//-----------------------------------------------------------------------------
+int dpiOci__lobLocatorAssign(dpiLob *lob, void **copiedHandle, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCILobLocatorAssign",
+            dpiOciSymbols.fnLobLocatorAssign)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnLobLocatorAssign)(lob->conn->handle,
+            error->handle, lob->locator, copiedHandle);
+    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "assign locator");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobOpen() [INTERNAL]
+//   Wrapper for OCILobOpen().
+//-----------------------------------------------------------------------------
+int dpiOci__lobOpen(dpiLob *lob, dpiError *error)
+{
+    uint8_t mode;
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCILobOpen", dpiOciSymbols.fnLobOpen)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    mode = (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_BFILE) ?
+            DPI_OCI_LOB_READONLY : DPI_OCI_LOB_READWRITE;
+    status = (*dpiOciSymbols.fnLobOpen)(lob->conn->handle, error->handle,
+            lob->locator, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "close LOB");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobRead2() [INTERNAL]
+//   Wrapper for OCILobRead2().
+//-----------------------------------------------------------------------------
+int dpiOci__lobRead2(dpiLob *lob, uint64_t offset, uint64_t *amountInBytes,
+        uint64_t *amountInChars, char *buffer, uint64_t bufferLength,
+        dpiError *error)
+{
+    uint16_t charsetId;
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCILobRead2", dpiOciSymbols.fnLobRead2)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    charsetId = (lob->type->charsetForm == DPI_SQLCS_NCHAR) ?
+            lob->env->ncharsetId : lob->env->charsetId;
+    status = (*dpiOciSymbols.fnLobRead2)(lob->conn->handle, error->handle,
+            lob->locator, amountInBytes, amountInChars, offset, buffer,
+            bufferLength, DPI_OCI_ONE_PIECE, NULL, NULL, charsetId,
+            lob->type->charsetForm);
+    if (status == DPI_OCI_NEED_DATA) {
+        *amountInChars = 0;
+        *amountInBytes = 0;
+        return DPI_SUCCESS;
+    }
+    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "read from LOB");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobTrim2() [INTERNAL]
+//   Wrapper for OCILobTrim2().
+//-----------------------------------------------------------------------------
+int dpiOci__lobTrim2(dpiLob *lob, uint64_t newLength, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCILobTrim2", dpiOciSymbols.fnLobTrim2)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnLobTrim2)(lob->conn->handle, error->handle,
+            lob->locator, newLength);
+    if (status == DPI_OCI_INVALID_HANDLE)
+        return dpiOci__lobCreateTemporary(lob, error);
+    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "trim LOB");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__lobWrite2() [INTERNAL]
+//   Wrapper for OCILobWrite2().
+//-----------------------------------------------------------------------------
+int dpiOci__lobWrite2(dpiLob *lob, uint64_t offset, const char *value,
+        uint64_t valueLength, dpiError *error)
+{
+    uint64_t lengthInBytes = valueLength, lengthInChars = 0;
+    uint16_t charsetId;
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCILobWrite2", dpiOciSymbols.fnLobWrite2)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    charsetId = (lob->type->charsetForm == DPI_SQLCS_NCHAR) ?
+            lob->env->ncharsetId : lob->env->charsetId;
+    status = (*dpiOciSymbols.fnLobWrite2)(lob->conn->handle, error->handle,
+            lob->locator, &lengthInBytes, &lengthInChars, offset, (void*) value,
+            valueLength, DPI_OCI_ONE_PIECE, NULL, NULL, charsetId,
+            lob->type->charsetForm);
+    DPI_OCI_CHECK_AND_RETURN(error, status, lob->conn, "write to LOB");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__memoryAlloc() [INTERNAL]
+//   Wrapper for OCIMemoryAlloc().
+//-----------------------------------------------------------------------------
+int dpiOci__memoryAlloc(dpiConn *conn, void **ptr, uint32_t size,
+        int checkError, dpiError *error)
+{
+    int status;
+
+    *ptr = NULL;
+    DPI_OCI_LOAD_SYMBOL("OCIMemoryAlloc", dpiOciSymbols.fnMemoryAlloc)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnMemoryAlloc)(conn->sessionHandle, error->handle,
+            ptr, DPI_OCI_DURATION_SESSION, size, DPI_OCI_MEMORY_CLEARED);
+    if (!checkError)
+        return DPI_SUCCESS;
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "allocate memory");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__memoryFree() [INTERNAL]
+//   Wrapper for OCIMemoryFree().
+//-----------------------------------------------------------------------------
+int dpiOci__memoryFree(dpiConn *conn, void *ptr, dpiError *error)
+{
+    DPI_OCI_LOAD_SYMBOL("OCIMemoryFree", dpiOciSymbols.fnMemoryFree)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    (*dpiOciSymbols.fnMemoryFree)(conn->sessionHandle, error->handle, ptr);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__nlsCharSetConvert() [INTERNAL]
+//   Wrapper for OCINlsCharSetConvert().
+//-----------------------------------------------------------------------------
+int dpiOci__nlsCharSetConvert(void *envHandle, uint16_t destCharsetId,
+        char *dest, size_t destLength, uint16_t sourceCharsetId,
+        const char *source, size_t sourceLength, size_t *resultSize,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCINlsCharSetConvert",
+            dpiOciSymbols.fnNlsCharSetConvert)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnNlsCharSetConvert)(envHandle, error->handle,
+            destCharsetId, dest, destLength, sourceCharsetId, source,
+            sourceLength, resultSize);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "convert text");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__nlsCharSetIdToName() [INTERNAL]
+//   Wrapper for OCINlsCharSetIdToName().
+//-----------------------------------------------------------------------------
+int dpiOci__nlsCharSetIdToName(void *envHandle, char *buf, size_t bufLength,
+        uint16_t charsetId, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCINlsCharSetIdToName",
+            dpiOciSymbols.fnNlsCharSetIdToName)
+    status = (*dpiOciSymbols.fnNlsCharSetIdToName)(envHandle, buf, bufLength,
+            charsetId);
+    return (status == DPI_OCI_SUCCESS) ? DPI_SUCCESS : DPI_FAILURE;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__nlsCharSetNameToId() [INTERNAL]
+//   Wrapper for OCINlsCharSetNameToId().
+//-----------------------------------------------------------------------------
+int dpiOci__nlsCharSetNameToId(void *envHandle, const char *name,
+        uint16_t *charsetId, dpiError *error)
+{
+    DPI_OCI_LOAD_SYMBOL("OCINlsCharSetNameToId",
+            dpiOciSymbols.fnNlsCharSetNameToId)
+    *charsetId = (*dpiOciSymbols.fnNlsCharSetNameToId)(envHandle, name);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__nlsEnvironmentVariableGet() [INTERNAL]
+//   Wrapper for OCIEnvironmentVariableGet().
+//-----------------------------------------------------------------------------
+int dpiOci__nlsEnvironmentVariableGet(uint16_t item, void *value,
+        dpiError *error)
+{
+    size_t ignored;
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCINlsEnvironmentVariableGet",
+            dpiOciSymbols.fnNlsEnvironmentVariableGet)
+    status = (*dpiOciSymbols.fnNlsEnvironmentVariableGet)(value, 0, item, 0,
+            &ignored);
+    if (status != DPI_OCI_SUCCESS)
+        return dpiError__set(error, "get NLS environment variable",
+                DPI_ERR_NLS_ENV_VAR_GET);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__nlsNameMap() [INTERNAL]
+//   Wrapper for OCINlsNameMap().
+//-----------------------------------------------------------------------------
+int dpiOci__nlsNameMap(void *envHandle, char *buf, size_t bufLength,
+        const char *source, uint32_t flag, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCINlsNameMap", dpiOciSymbols.fnNlsNameMap)
+    status = (*dpiOciSymbols.fnNlsNameMap)(envHandle, buf, bufLength, source,
+            flag);
+    return (status == DPI_OCI_SUCCESS) ? DPI_SUCCESS : DPI_FAILURE;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__nlsNumericInfoGet() [INTERNAL]
+//   Wrapper for OCINlsNumericInfoGet().
+//-----------------------------------------------------------------------------
+int dpiOci__nlsNumericInfoGet(void *envHandle, int32_t *value, uint16_t item,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCINlsNumericInfoGet",
+            dpiOciSymbols.fnNlsNumericInfoGet)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnNlsNumericInfoGet)(envHandle, error->handle,
+            value, item);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get NLS info");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__numberFromInt() [INTERNAL]
+//   Wrapper for OCINumberFromInt().
+//-----------------------------------------------------------------------------
+int dpiOci__numberFromInt(const void *value, unsigned int valueLength,
+        unsigned int flags, void *number, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCINumberFromInt", dpiOciSymbols.fnNumberFromInt)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnNumberFromInt)(error->handle, value,
+            valueLength, flags, number);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "number from integer");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__numberFromReal() [INTERNAL]
+//   Wrapper for OCINumberFromReal().
+//-----------------------------------------------------------------------------
+int dpiOci__numberFromReal(const double value, void *number, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCINumberFromReal", dpiOciSymbols.fnNumberFromReal)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnNumberFromReal)(error->handle, &value,
+            sizeof(double), number);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "number from real");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__numberToInt() [INTERNAL]
+//   Wrapper for OCINumberToInt().
+//-----------------------------------------------------------------------------
+int dpiOci__numberToInt(void *number, void *value, unsigned int valueLength,
+        unsigned int flags, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCINumberToInt", dpiOciSymbols.fnNumberToInt)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnNumberToInt)(error->handle, number, valueLength,
+            flags, value);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "number to integer");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__numberToReal() [INTERNAL]
+//   Wrapper for OCINumberToReal().
+//-----------------------------------------------------------------------------
+int dpiOci__numberToReal(double *value, void *number, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCINumberToReal", dpiOciSymbols.fnNumberToReal)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnNumberToReal)(error->handle, number,
+            sizeof(double), value);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "number to real");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__objectCopy() [INTERNAL]
+//   Wrapper for OCIObjectCopy().
+//-----------------------------------------------------------------------------
+int dpiOci__objectCopy(dpiObject *obj, void *sourceInstance,
+        void *sourceIndicator, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIObjectCopy", dpiOciSymbols.fnObjectCopy)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnObjectCopy)(obj->env->handle, error->handle,
+            obj->type->conn->handle, sourceInstance, sourceIndicator,
+            obj->instance, obj->indicator, obj->type->tdo,
+            DPI_OCI_DURATION_SESSION, DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "copy object");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__objectFree() [INTERNAL]
+//   Wrapper for OCIObjectFree().
+//-----------------------------------------------------------------------------
+int dpiOci__objectFree(void *envHandle, void *data, int checkError,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIObjectFree", dpiOciSymbols.fnObjectFree)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnObjectFree)(envHandle, error->handle, data,
+            DPI_OCI_DEFAULT);
+    if (checkError && DPI_OCI_ERROR_OCCURRED(status)) {
+        dpiError__setFromOCI(error, status, NULL, "free instance");
+
+        // during the attempt to free, PL/SQL records fail with error
+        // "ORA-21602: operation does not support the specified typecode", but
+        // a subsequent attempt will yield error "OCI-21500: internal error
+        // code" and crash the process, so pretend like the free was
+        // successful!
+        if (error->buffer->code == 21602)
+            return DPI_SUCCESS;
+        return DPI_FAILURE;
+    }
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__objectGetAttr() [INTERNAL]
+//   Wrapper for OCIObjectGetAttr().
+//-----------------------------------------------------------------------------
+int dpiOci__objectGetAttr(dpiObject *obj, dpiObjectAttr *attr,
+        int16_t *scalarValueIndicator, void **valueIndicator, void **value,
+        void **tdo, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIObjectGetAttr", dpiOciSymbols.fnObjectGetAttr)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnObjectGetAttr)(obj->env->handle, error->handle,
+            obj->instance, obj->indicator, obj->type->tdo, &attr->name,
+            &attr->nameLength, 1, 0, 0, scalarValueIndicator, valueIndicator,
+            value, tdo);
+    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "get attribute");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__objectGetInd() [INTERNAL]
+//   Wrapper for OCIObjectGetInd().
+//-----------------------------------------------------------------------------
+int dpiOci__objectGetInd(dpiObject *obj, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIObjectGetInd", dpiOciSymbols.fnObjectGetInd)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnObjectGetInd)(obj->env->handle, error->handle,
+            obj->instance, &obj->indicator);
+    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "get indicator");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__objectNew() [INTERNAL]
+//   Wrapper for OCIObjectNew().
+//-----------------------------------------------------------------------------
+int dpiOci__objectNew(dpiObject *obj, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIObjectNew", dpiOciSymbols.fnObjectNew)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnObjectNew)(obj->env->handle, error->handle,
+            obj->type->conn->handle, obj->type->typeCode, obj->type->tdo, NULL,
+            DPI_OCI_DURATION_SESSION, 1, &obj->instance);
+    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "create object");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__objectPin() [INTERNAL]
+//   Wrapper for OCIObjectPin().
+//-----------------------------------------------------------------------------
+int dpiOci__objectPin(void *envHandle, void *objRef, void **obj,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIObjectPin", dpiOciSymbols.fnObjectPin)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnObjectPin)(envHandle, error->handle, objRef,
+            NULL, DPI_OCI_PIN_ANY, DPI_OCI_DURATION_SESSION, DPI_OCI_LOCK_NONE,
+            obj);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "pin reference");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__objectSetAttr() [INTERNAL]
+//   Wrapper for OCIObjectSetAttr().
+//-----------------------------------------------------------------------------
+int dpiOci__objectSetAttr(dpiObject *obj, dpiObjectAttr *attr,
+        int16_t scalarValueIndicator, void *valueIndicator, const void *value,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIObjectSetAttr", dpiOciSymbols.fnObjectSetAttr)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnObjectSetAttr)(obj->env->handle, error->handle,
+            obj->instance, obj->indicator, obj->type->tdo, &attr->name,
+            &attr->nameLength, 1, NULL, 0, scalarValueIndicator,
+            valueIndicator, value);
+    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "set attribute");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__passwordChange() [INTERNAL]
+//   Wrapper for OCIPasswordChange().
+//-----------------------------------------------------------------------------
+int dpiOci__passwordChange(dpiConn *conn, const char *userName,
+        uint32_t userNameLength, const char *oldPassword,
+        uint32_t oldPasswordLength, const char *newPassword,
+        uint32_t newPasswordLength, uint32_t mode, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIPasswordChange", dpiOciSymbols.fnPasswordChange)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnPasswordChange)(conn->handle, error->handle,
+            userName, userNameLength, oldPassword, oldPasswordLength,
+            newPassword, newPasswordLength, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "change password");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__paramGet() [INTERNAL]
+//   Wrapper for OCIParamGet().
+//-----------------------------------------------------------------------------
+int dpiOci__paramGet(const void *handle, uint32_t handleType, void **parameter,
+        uint32_t pos, const char *action, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIParamGet", dpiOciSymbols.fnParamGet)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnParamGet)(handle, handleType, error->handle,
+            parameter, pos);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, action);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__ping() [INTERNAL]
+//   Wrapper for OCIPing().
+//-----------------------------------------------------------------------------
+int dpiOci__ping(dpiConn *conn, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIPing", dpiOciSymbols.fnPing)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnPing)(conn->handle, error->handle,
+            DPI_OCI_DEFAULT);
+    if (DPI_OCI_ERROR_OCCURRED(status)) {
+        dpiError__setFromOCI(error, status, conn, "ping");
+
+        // attempting to ping a database earlier than 10g will result in error
+        // ORA-1010: invalid OCI operation, but that implies a successful ping
+        // so ignore that error and treat it as a successful operation
+        if (error->buffer->code == 1010)
+            return DPI_SUCCESS;
+        return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__rawAssignBytes() [INTERNAL]
+//   Wrapper for OCIRawAssignBytes().
+//-----------------------------------------------------------------------------
+int dpiOci__rawAssignBytes(void *envHandle, const char *value,
+        uint32_t valueLength, void **handle, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIRawAssignBytes", dpiOciSymbols.fnRawAssignBytes)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnRawAssignBytes)(envHandle, error->handle, value,
+            valueLength, handle);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "assign bytes to raw");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__rawPtr() [INTERNAL]
+//   Wrapper for OCIRawPtr().
+//-----------------------------------------------------------------------------
+int dpiOci__rawPtr(void *envHandle, void *handle, void **ptr)
+{
+    dpiError *error = NULL;
+
+    DPI_OCI_LOAD_SYMBOL("OCIRawPtr", dpiOciSymbols.fnRawPtr)
+    *ptr = (*dpiOciSymbols.fnRawPtr)(envHandle, handle);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__rawResize() [INTERNAL]
+//   Wrapper for OCIRawResize().
+//-----------------------------------------------------------------------------
+int dpiOci__rawResize(void *envHandle, void **handle, uint32_t newSize,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIRawResize", dpiOciSymbols.fnRawResize)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnRawResize)(envHandle, error->handle, newSize,
+            handle);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "resize raw");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__rawSize() [INTERNAL]
+//   Wrapper for OCIRawSize().
+//-----------------------------------------------------------------------------
+int dpiOci__rawSize(void *envHandle, void *handle, uint32_t *size)
+{
+    dpiError *error = NULL;
+
+    DPI_OCI_LOAD_SYMBOL("OCIRawSize", dpiOciSymbols.fnRawSize)
+    *size = (*dpiOciSymbols.fnRawSize)(envHandle, handle);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__reallocMem() [INTERNAL]
+//   Wrapper for OCI allocation of memory, only used when debugging memory
+// allocation.
+//-----------------------------------------------------------------------------
+static void *dpiOci__reallocMem(UNUSED void *unused, void *ptr, size_t newSize)
+{
+    char message[80];
+    void *newPtr;
+
+    (void) sprintf(message, "OCI reallocated ptr at %p", ptr);
+    newPtr = realloc(ptr, newSize);
+    dpiDebug__print("%s to %u bytes at %p\n", message, newSize, newPtr);
+    return newPtr;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__rowidToChar() [INTERNAL]
+//   Wrapper for OCIRowidToChar().
+//-----------------------------------------------------------------------------
+int dpiOci__rowidToChar(dpiRowid *rowid, char *buffer, uint16_t *bufferSize,
+        dpiError *error)
+{
+    uint16_t origSize;
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIRowidToChar", dpiOciSymbols.fnRowidToChar)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    origSize = *bufferSize;
+    status = (*dpiOciSymbols.fnRowidToChar)(rowid->handle, buffer, bufferSize,
+            error->handle);
+    if (origSize == 0)
+        return DPI_SUCCESS;
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get rowid as string");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__serverAttach() [INTERNAL]
+//   Wrapper for OCIServerAttach().
+//-----------------------------------------------------------------------------
+int dpiOci__serverAttach(dpiConn *conn, const char *connectString,
+        uint32_t connectStringLength, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIServerAttach", dpiOciSymbols.fnServerAttach)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnServerAttach)(conn->serverHandle, error->handle,
+            connectString, (int32_t) connectStringLength, DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "server attach");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__serverDetach() [INTERNAL]
+//   Wrapper for OCIServerDetach().
+//-----------------------------------------------------------------------------
+int dpiOci__serverDetach(dpiConn *conn, int checkError, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIServerDetach", dpiOciSymbols.fnServerDetach)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnServerDetach)(conn->serverHandle, error->handle,
+            DPI_OCI_DEFAULT);
+    if (!checkError)
+        return DPI_SUCCESS;
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "detatch from server");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__serverRelease() [INTERNAL]
+//   Wrapper for OCIServerRelease().
+//-----------------------------------------------------------------------------
+int dpiOci__serverRelease(dpiConn *conn, char *buffer, uint32_t bufferSize,
+        uint32_t *version, uint32_t mode, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    if (conn->env->versionInfo->versionNum < 18) {
+        DPI_OCI_LOAD_SYMBOL("OCIServerRelease", dpiOciSymbols.fnServerRelease)
+        status = (*dpiOciSymbols.fnServerRelease)(conn->handle, error->handle,
+                buffer, bufferSize, DPI_OCI_HTYPE_SVCCTX, version);
+    } else {
+        DPI_OCI_LOAD_SYMBOL("OCIServerRelease2",
+                dpiOciSymbols.fnServerRelease2)
+        status = (*dpiOciSymbols.fnServerRelease2)(conn->handle, error->handle,
+                buffer, bufferSize, DPI_OCI_HTYPE_SVCCTX, version, mode);
+    }
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "get server version");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sessionBegin() [INTERNAL]
+//   Wrapper for OCISessionBegin().
+//-----------------------------------------------------------------------------
+int dpiOci__sessionBegin(dpiConn *conn, uint32_t credentialType,
+        uint32_t mode, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISessionBegin", dpiOciSymbols.fnSessionBegin)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSessionBegin)(conn->handle, error->handle,
+            conn->sessionHandle, credentialType, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "begin session");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sessionEnd() [INTERNAL]
+//   Wrapper for OCISessionEnd().
+//-----------------------------------------------------------------------------
+int dpiOci__sessionEnd(dpiConn *conn, int checkError, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISessionEnd", dpiOciSymbols.fnSessionEnd)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSessionEnd)(conn->handle, error->handle,
+            conn->sessionHandle, DPI_OCI_DEFAULT);
+    if (!checkError)
+        return DPI_SUCCESS;
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "end session");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sessionGet() [INTERNAL]
+//   Wrapper for OCISessionGet().
+//-----------------------------------------------------------------------------
+int dpiOci__sessionGet(void *envHandle, void **handle, void *authInfo,
+        const char *connectString, uint32_t connectStringLength,
+        const char *tag, uint32_t tagLength, const char **outTag,
+        uint32_t *outTagLength, int *found, uint32_t mode, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISessionGet", dpiOciSymbols.fnSessionGet)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSessionGet)(envHandle, error->handle, handle,
+            authInfo, connectString, connectStringLength, tag, tagLength,
+            outTag, outTagLength, found, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "get session");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sessionPoolCreate() [INTERNAL]
+//   Wrapper for OCISessionPoolCreate().
+//-----------------------------------------------------------------------------
+int dpiOci__sessionPoolCreate(dpiPool *pool, const char *connectString,
+        uint32_t connectStringLength, uint32_t minSessions,
+        uint32_t maxSessions, uint32_t sessionIncrement, const char *userName,
+        uint32_t userNameLength, const char *password, uint32_t passwordLength,
+        uint32_t mode, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISessionPoolCreate",
+            dpiOciSymbols.fnSessionPoolCreate)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSessionPoolCreate)(pool->env->handle,
+            error->handle, pool->handle, (char**) &pool->name,
+            &pool->nameLength, connectString, connectStringLength, minSessions,
+            maxSessions, sessionIncrement, userName, userNameLength, password,
+            passwordLength, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "create pool");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sessionPoolDestroy() [INTERNAL]
+//   Wrapper for OCISessionPoolDestroy().
+//-----------------------------------------------------------------------------
+int dpiOci__sessionPoolDestroy(dpiPool *pool, uint32_t mode, int checkError,
+        dpiError *error)
+{
+    void *handle;
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISessionPoolDestroy",
+            dpiOciSymbols.fnSessionPoolDestroy)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+
+    // clear the pool handle immediately so that no further attempts are made
+    // to use the pool while the pool is being closed; if the pool close fails,
+    // restore the pool handle afterwards
+    handle = pool->handle;
+    pool->handle = NULL;
+    status = (*dpiOciSymbols.fnSessionPoolDestroy)(handle, error->handle,
+            mode);
+    if (checkError && DPI_OCI_ERROR_OCCURRED(status)) {
+        pool->handle = handle;
+        return dpiError__setFromOCI(error, status, NULL, "destroy pool");
+    }
+    dpiOci__handleFree(handle, DPI_OCI_HTYPE_SPOOL);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sessionRelease() [INTERNAL]
+//   Wrapper for OCISessionRelease().
+//-----------------------------------------------------------------------------
+int dpiOci__sessionRelease(dpiConn *conn, const char *tag, uint32_t tagLength,
+        uint32_t mode, int checkError, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISessionRelease", dpiOciSymbols.fnSessionRelease)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSessionRelease)(conn->handle, error->handle,
+            tag, tagLength, mode);
+    if (!checkError)
+        return DPI_SUCCESS;
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "release session");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__shardingKeyColumnAdd() [INTERNAL]
+//   Wrapper for OCIshardingKeyColumnAdd().
+//-----------------------------------------------------------------------------
+int dpiOci__shardingKeyColumnAdd(void *shardingKey, void *col, uint32_t colLen,
+        uint16_t colType, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIShardingKeyColumnAdd",
+            dpiOciSymbols.fnShardingKeyColumnAdd)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnShardingKeyColumnAdd)(shardingKey,
+            error->handle, col, colLen, colType, DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "add sharding column");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaBulkInsert() [INTERNAL]
+//   Wrapper for OCISodaBulkInsert().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaBulkInsert(dpiSodaColl *coll, void **documents,
+        uint32_t numDocuments, void *outputOptions, uint32_t mode,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaBulkInsert", dpiOciSymbols.fnSodaBulkInsert)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaBulkInsert)(coll->db->conn->handle,
+            coll->handle, documents, numDocuments, outputOptions,
+            error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "insert multiple documents");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaBulkInsertAndGet() [INTERNAL]
+//   Wrapper for OCISodaBulkInsertAndGet().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaBulkInsertAndGet(dpiSodaColl *coll, void **documents,
+        uint32_t numDocuments, void *outputOptions, uint32_t mode,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaBulkInsertAndGet",
+            dpiOciSymbols.fnSodaBulkInsertAndGet)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaBulkInsertAndGet)(coll->db->conn->handle,
+            coll->handle, documents, numDocuments, outputOptions,
+            error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "insert (and get) multiple documents");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaBulkInsertAndGetWithOpts() [INTERNAL]
+//   Wrapper for OCISodaBulkInsertAndGetWithOpts().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaBulkInsertAndGetWithOpts(dpiSodaColl *coll, void **documents,
+        uint32_t numDocuments, void *operOptions, void *outputOptions,
+        uint32_t mode, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaBulkInsertAndGetWithOpts",
+            dpiOciSymbols.fnSodaBulkInsertAndGetWithOpts)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaBulkInsertAndGetWithOpts)
+            (coll->db->conn->handle, coll->handle, documents, numDocuments,
+             operOptions, outputOptions, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "insert (and get) multiple documents with options");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaCollCreateWithMetadata() [INTERNAL]
+//   Wrapper for OCISodaCollCreateWithMetadata().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaCollCreateWithMetadata(dpiSodaDb *db, const char *name,
+        uint32_t nameLength, const char *metadata, uint32_t metadataLength,
+        uint32_t mode, void **handle, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaCollCreateWithMetadata",
+            dpiOciSymbols.fnSodaCollCreateWithMetadata)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaCollCreateWithMetadata)(db->conn->handle,
+            name, nameLength, metadata, metadataLength, handle, error->handle,
+            mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, db->conn,
+            "create SODA collection");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaCollDrop() [INTERNAL]
+//   Wrapper for OCISodaCollDrop().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaCollDrop(dpiSodaColl *coll, int *isDropped, uint32_t mode,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaCollDrop", dpiOciSymbols.fnSodaCollDrop)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaCollDrop)(coll->db->conn->handle,
+            coll->handle, isDropped, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "drop SODA collection");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaCollGetNext() [INTERNAL]
+//   Wrapper for OCISodaCollGetNext().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaCollGetNext(dpiConn *conn, void *cursorHandle,
+        void **collectionHandle, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaCollGetNext", dpiOciSymbols.fnSodaCollGetNext)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaCollGetNext)(conn->handle, cursorHandle,
+            collectionHandle, error->handle, DPI_OCI_DEFAULT);
+    if (status == DPI_OCI_NO_DATA) {
+        *collectionHandle = NULL;
+        return DPI_SUCCESS;
+    }
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "get next collection");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaCollList() [INTERNAL]
+//   Wrapper for OCISodaCollList().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaCollList(dpiSodaDb *db, const char *startingName,
+        uint32_t startingNameLength, void **handle, uint32_t mode,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaCollList", dpiOciSymbols.fnSodaCollList)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaCollList)(db->conn->handle, startingName,
+            startingNameLength, handle, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, db->conn,
+            "get SODA collection cursor");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaCollOpen() [INTERNAL]
+//   Wrapper for OCISodaCollOpen().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaCollOpen(dpiSodaDb *db, const char *name, uint32_t nameLength,
+        uint32_t mode, void **handle, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaCollOpen", dpiOciSymbols.fnSodaCollOpen)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaCollOpen)(db->conn->handle, name,
+            nameLength, handle, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, db->conn, "open SODA collection");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaCollTruncate() [INTERNAL]
+//   Wrapper for OCISodaCollTruncate().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaCollTruncate(dpiSodaColl *coll, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaCollTruncate",
+            dpiOciSymbols.fnSodaCollTruncate)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaCollTruncate)(coll->db->conn->handle,
+            coll->handle, error->handle, DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "truncate SODA collection");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaDataGuideGet() [INTERNAL]
+//   Wrapper for OCISodaDataGuideGet().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaDataGuideGet(dpiSodaColl *coll, void **handle, uint32_t mode,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaDataGuideGet",
+            dpiOciSymbols.fnSodaDataGuideGet)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaDataGuideGet)(coll->db->conn->handle,
+            coll->handle, DPI_OCI_SODA_AS_AL32UTF8, handle, error->handle,
+            mode);
+    if (DPI_OCI_ERROR_OCCURRED(status)) {
+        dpiError__setFromOCI(error, status, coll->db->conn, "get data guide");
+        if (error->buffer->code != 24801)
+            return DPI_FAILURE;
+        *handle = NULL;
+    }
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaDocCount() [INTERNAL]
+//   Wrapper for OCISodaDocCount().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaDocCount(dpiSodaColl *coll, void *options, uint32_t mode,
+        uint64_t *count, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaDocCount", dpiOciSymbols.fnSodaDocCount)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaDocCount)(coll->db->conn->handle,
+            coll->handle, options, count, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "get document count");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaDocGetNext() [INTERNAL]
+//   Wrapper for OCISodaDocGetNext().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaDocGetNext(dpiSodaDocCursor *cursor, void **handle,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaDocGetNext", dpiOciSymbols.fnSodaDocGetNext)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaDocGetNext)(cursor->coll->db->conn->handle,
+            cursor->handle, handle, error->handle, DPI_OCI_DEFAULT);
+    if (status == DPI_OCI_NO_DATA) {
+        *handle = NULL;
+        return DPI_SUCCESS;
+    }
+    DPI_OCI_CHECK_AND_RETURN(error, status, cursor->coll->db->conn,
+            "get next document");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaFind() [INTERNAL]
+//   Wrapper for OCISodaFind().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaFind(dpiSodaColl *coll, const void *options, uint32_t flags,
+        uint32_t mode, void **handle, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaFind", dpiOciSymbols.fnSodaFind)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaFind)(coll->db->conn->handle,
+            coll->handle, options, flags, handle, error->handle, mode);
+    if (status == DPI_OCI_NO_DATA) {
+        *handle = NULL;
+        return DPI_SUCCESS;
+    }
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "find SODA documents");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaFindOne() [INTERNAL]
+//   Wrapper for OCISodaFindOne().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaFindOne(dpiSodaColl *coll, const void *options, uint32_t flags,
+        uint32_t mode, void **handle, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaFindOne", dpiOciSymbols.fnSodaFindOne)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaFindOne)(coll->db->conn->handle,
+            coll->handle, options, flags, handle, error->handle, mode);
+    if (status == DPI_OCI_NO_DATA) {
+        *handle = NULL;
+        return DPI_SUCCESS;
+    }
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "get SODA document");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaIndexCreate() [INTERNAL]
+//   Wrapper for OCISodaIndexCreate().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaIndexCreate(dpiSodaColl *coll, const char *indexSpec,
+        uint32_t indexSpecLength, uint32_t mode, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaIndexCreate", dpiOciSymbols.fnSodaIndexCreate)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaIndexCreate)(coll->db->conn->handle,
+            coll->handle, indexSpec, indexSpecLength, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn, "create index");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaIndexDrop() [INTERNAL]
+//   Wrapper for OCISodaIndexDrop().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaIndexDrop(dpiSodaColl *coll, const char *name,
+        uint32_t nameLength, uint32_t mode, int *isDropped, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaIndexDrop", dpiOciSymbols.fnSodaIndexDrop)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaIndexDrop)(coll->db->conn->handle, name,
+            nameLength, isDropped, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn, "drop index");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaInsert() [INTERNAL]
+//   Wrapper for OCISodaInsert().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaInsert(dpiSodaColl *coll, void *handle, uint32_t mode,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaInsert", dpiOciSymbols.fnSodaInsert)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaInsert)(coll->db->conn->handle,
+            coll->handle, handle, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "insert SODA document");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaInsertAndGet() [INTERNAL]
+//   Wrapper for OCISodaInsertAndGet().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaInsertAndGet(dpiSodaColl *coll, void **handle, uint32_t mode,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaInsertAndGet",
+            dpiOciSymbols.fnSodaInsertAndGet)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaInsertAndGet)(coll->db->conn->handle,
+            coll->handle, handle, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "insert and get SODA document");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaInsertAndGetWithOpts() [INTERNAL]
+//   Wrapper for OCISodaInsertAndGetWithOpts().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaInsertAndGetWithOpts(dpiSodaColl *coll, void **handle,
+        void *operOptions, uint32_t mode, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaInsertAndGetWithOpts",
+            dpiOciSymbols.fnSodaInsertAndGetWithOpts)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaInsertAndGetWithOpts)
+            (coll->db->conn->handle, coll->handle, handle, operOptions,
+             error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "insert and get SODA document with options");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaOperKeysSet() [INTERNAL]
+//   Wrapper for OCISodaOperKeysSet().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaOperKeysSet(const dpiSodaOperOptions *options, void *handle,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaOperKeysSet", dpiOciSymbols.fnSodaOperKeysSet)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaOperKeysSet)(handle, options->keys,
+            options->keyLengths, options->numKeys, error->handle,
+            DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL,
+            "set operation options keys");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaRemove() [INTERNAL]
+//   Wrapper for OCISodaRemove().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaRemove(dpiSodaColl *coll, void *options, uint32_t mode,
+        uint64_t *count, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaRemove", dpiOciSymbols.fnSodaRemove)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaRemove)(coll->db->conn->handle,
+            coll->handle, options, count, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "remove documents from SODA collection");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaReplOne() [INTERNAL]
+//   Wrapper for OCISodaReplOne().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaReplOne(dpiSodaColl *coll, const void *options, void *handle,
+        uint32_t mode, int *isReplaced, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaReplOne", dpiOciSymbols.fnSodaReplOne)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaReplOne)(coll->db->conn->handle,
+            coll->handle, options, handle, isReplaced, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "replace SODA document");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaReplOneAndGet() [INTERNAL]
+//   Wrapper for OCISodaReplOneAndGet().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaReplOneAndGet(dpiSodaColl *coll, const void *options,
+        void **handle, uint32_t mode, int *isReplaced, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaReplOneAndGet",
+            dpiOciSymbols.fnSodaReplOneAndGet)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaReplOneAndGet)(coll->db->conn->handle,
+            coll->handle, options, handle, isReplaced, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "replace and get SODA document");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaSave() [INTERNAL]
+//   Wrapper for OCISodaSave().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaSave(dpiSodaColl *coll, void *handle, uint32_t mode,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaSave", dpiOciSymbols.fnSodaSave)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaSave)(coll->db->conn->handle,
+            coll->handle, handle, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "save SODA document");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaSaveAndGet() [INTERNAL]
+//   Wrapper for OCISodaSaveAndGet().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaSaveAndGet(dpiSodaColl *coll, void **handle, uint32_t mode,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaSaveAndGet", dpiOciSymbols.fnSodaSaveAndGet)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaSaveAndGet)(coll->db->conn->handle,
+            coll->handle, handle, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "save and get SODA document");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__sodaSaveAndGetWithOpts() [INTERNAL]
+//   Wrapper for OCISodaSaveAndGetWithOpts().
+//-----------------------------------------------------------------------------
+int dpiOci__sodaSaveAndGetWithOpts(dpiSodaColl *coll, void **handle,
+        void *operOptions, uint32_t mode, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISodaSaveAndGetWithOpts",
+            dpiOciSymbols.fnSodaSaveAndGetWithOpts)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSodaSaveAndGetWithOpts)(coll->db->conn->handle,
+            coll->handle, handle, operOptions, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, coll->db->conn,
+            "save and get SODA document");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__stmtExecute() [INTERNAL]
+//   Wrapper for OCIStmtExecute().
+//-----------------------------------------------------------------------------
+int dpiOci__stmtExecute(dpiStmt *stmt, uint32_t numIters, uint32_t mode,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIStmtExecute", dpiOciSymbols.fnStmtExecute)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnStmtExecute)(stmt->conn->handle, stmt->handle,
+            error->handle, numIters, 0, 0, 0, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "execute");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__stmtFetch2() [INTERNAL]
+//   Wrapper for OCIStmtFetch2().
+//-----------------------------------------------------------------------------
+int dpiOci__stmtFetch2(dpiStmt *stmt, uint32_t numRows, uint16_t fetchMode,
+        int32_t offset, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIStmtFetch2", dpiOciSymbols.fnStmtFetch2)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnStmtFetch2)(stmt->handle, error->handle,
+            numRows, fetchMode, offset, DPI_OCI_DEFAULT);
+    if (status == DPI_OCI_NO_DATA || fetchMode == DPI_MODE_FETCH_LAST) {
+        stmt->hasRowsToFetch = 0;
+    } else if (DPI_OCI_ERROR_OCCURRED(status)) {
+        return dpiError__setFromOCI(error, status, stmt->conn, "fetch");
+    } else {
+        stmt->hasRowsToFetch = 1;
+    }
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__stmtGetBindInfo() [INTERNAL]
+//   Wrapper for OCIStmtGetBindInfo().
+//-----------------------------------------------------------------------------
+int dpiOci__stmtGetBindInfo(dpiStmt *stmt, uint32_t size, uint32_t startLoc,
+        int32_t *numFound, char *names[], uint8_t nameLengths[],
+        char *indNames[], uint8_t indNameLengths[], uint8_t isDuplicate[],
+        void *bindHandles[], dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIStmtGetBindInfo", dpiOciSymbols.fnStmtGetBindInfo)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnStmtGetBindInfo)(stmt->handle, error->handle,
+            size, startLoc, numFound, names, nameLengths, indNames,
+            indNameLengths, isDuplicate, bindHandles);
+    if (status == DPI_OCI_NO_DATA) {
+        *numFound = 0;
+        return DPI_SUCCESS;
+    }
+    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "get bind info");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__stmtGetNextResult() [INTERNAL]
+//   Wrapper for OCIStmtGetNextResult().
+//-----------------------------------------------------------------------------
+int dpiOci__stmtGetNextResult(dpiStmt *stmt, void **handle, dpiError *error)
+{
+    uint32_t returnType;
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIStmtGetNextResult",
+            dpiOciSymbols.fnStmtGetNextResult)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnStmtGetNextResult)(stmt->handle, error->handle,
+            handle, &returnType, DPI_OCI_DEFAULT);
+    if (status == DPI_OCI_NO_DATA) {
+        *handle = NULL;
+        return DPI_SUCCESS;
+    }
+    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "get next result");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__stmtPrepare2() [INTERNAL]
+//   Wrapper for OCIStmtPrepare2().
+//-----------------------------------------------------------------------------
+int dpiOci__stmtPrepare2(dpiStmt *stmt, const char *sql, uint32_t sqlLength,
+        const char *tag, uint32_t tagLength, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIStmtPrepare2", dpiOciSymbols.fnStmtPrepare2)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnStmtPrepare2)(stmt->conn->handle, &stmt->handle,
+            error->handle, sql, sqlLength, tag, tagLength, DPI_OCI_NTV_SYNTAX,
+            DPI_OCI_DEFAULT);
+    if (DPI_OCI_ERROR_OCCURRED(status)) {
+        stmt->handle = NULL;
+        return dpiError__setFromOCI(error, status, stmt->conn, "prepare SQL");
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__stmtRelease() [INTERNAL]
+//   Wrapper for OCIStmtRelease().
+//-----------------------------------------------------------------------------
+int dpiOci__stmtRelease(dpiStmt *stmt, const char *tag, uint32_t tagLength,
+        int checkError, dpiError *error)
+{
+    uint32_t mode = DPI_OCI_DEFAULT;
+    uint32_t cacheSize = 0;
+    int status;
+
+    // if the statement should be deleted from the cache, first check to see
+    // that there actually is a cache currently being used; otherwise, the
+    // error "ORA-24300: bad value for mode" will be raised
+    if (stmt->deleteFromCache) {
+        dpiOci__attrGet(stmt->conn->handle, DPI_OCI_HTYPE_SVCCTX,
+                &cacheSize, NULL, DPI_OCI_ATTR_STMTCACHESIZE, NULL, error);
+        if (cacheSize > 0)
+            mode |= DPI_OCI_STRLS_CACHE_DELETE;
+    }
+
+    DPI_OCI_LOAD_SYMBOL("OCIStmtRelease", dpiOciSymbols.fnStmtRelease)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnStmtRelease)(stmt->handle, error->handle, tag,
+            tagLength, mode);
+    if (!checkError)
+        return DPI_SUCCESS;
+    DPI_OCI_CHECK_AND_RETURN(error, status, stmt->conn, "release statement");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__stringAssignText() [INTERNAL]
+//   Wrapper for OCIStringAssignText().
+//-----------------------------------------------------------------------------
+int dpiOci__stringAssignText(void *envHandle, const char *value,
+        uint32_t valueLength, void **handle, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIStringAssignText",
+            dpiOciSymbols.fnStringAssignText)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnStringAssignText)(envHandle, error->handle,
+            value, valueLength, handle);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "assign to string");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__stringPtr() [INTERNAL]
+//   Wrapper for OCIStringPtr().
+//-----------------------------------------------------------------------------
+int dpiOci__stringPtr(void *envHandle, void *handle, char **ptr)
+{
+    dpiError *error = NULL;
+
+    DPI_OCI_LOAD_SYMBOL("OCIStringPtr", dpiOciSymbols.fnStringPtr)
+    *ptr = (*dpiOciSymbols.fnStringPtr)(envHandle, handle);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__stringResize() [INTERNAL]
+//   Wrapper for OCIStringResize().
+//-----------------------------------------------------------------------------
+int dpiOci__stringResize(void *envHandle, void **handle, uint32_t newSize,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIStringResize", dpiOciSymbols.fnStringResize)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnStringResize)(envHandle, error->handle, newSize,
+            handle);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "resize string");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__stringSize() [INTERNAL]
+//   Wrapper for OCIStringSize().
+//-----------------------------------------------------------------------------
+int dpiOci__stringSize(void *envHandle, void *handle, uint32_t *size)
+{
+    dpiError *error = NULL;
+
+    DPI_OCI_LOAD_SYMBOL("OCIStringSize", dpiOciSymbols.fnStringSize)
+    *size = (*dpiOciSymbols.fnStringSize)(envHandle, handle);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__subscriptionRegister() [INTERNAL]
+//   Wrapper for OCISubscriptionRegister().
+//-----------------------------------------------------------------------------
+int dpiOci__subscriptionRegister(dpiConn *conn, void **handle, uint32_t mode,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISubscriptionRegister",
+            dpiOciSymbols.fnSubscriptionRegister)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnSubscriptionRegister)(conn->handle, handle, 1,
+            error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "register");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__subscriptionUnRegister() [INTERNAL]
+//   Wrapper for OCISubscriptionUnRegister().
+//-----------------------------------------------------------------------------
+int dpiOci__subscriptionUnRegister(dpiConn *conn, dpiSubscr *subscr,
+        dpiError *error)
+{
+    uint32_t mode;
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCISubscriptionUnRegister",
+            dpiOciSymbols.fnSubscriptionUnRegister)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    mode = (subscr->clientInitiated) ? DPI_OCI_SECURE_NOTIFICATION :
+            DPI_OCI_DEFAULT;
+    status = (*dpiOciSymbols.fnSubscriptionUnRegister)(conn->handle,
+            subscr->handle, error->handle, mode);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "unregister");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__tableDelete() [INTERNAL]
+//   Wrapper for OCITableDelete().
+//-----------------------------------------------------------------------------
+int dpiOci__tableDelete(dpiObject *obj, int32_t index, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITableDelete", dpiOciSymbols.fnTableDelete)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTableDelete)(obj->env->handle, error->handle,
+            index, obj->instance);
+    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "delete element");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__tableExists() [INTERNAL]
+//   Wrapper for OCITableExists().
+//-----------------------------------------------------------------------------
+int dpiOci__tableExists(dpiObject *obj, int32_t index, int *exists,
+        dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITableExists", dpiOciSymbols.fnTableExists)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTableExists)(obj->env->handle, error->handle,
+            obj->instance, index, exists);
+    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn,
+            "get index exists");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__tableFirst() [INTERNAL]
+//   Wrapper for OCITableFirst().
+//-----------------------------------------------------------------------------
+int dpiOci__tableFirst(dpiObject *obj, int32_t *index, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITableFirst", dpiOciSymbols.fnTableFirst)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTableFirst)(obj->env->handle, error->handle,
+            obj->instance, index);
+    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn,
+            "get first index");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__tableLast() [INTERNAL]
+//   Wrapper for OCITableLast().
+//-----------------------------------------------------------------------------
+int dpiOci__tableLast(dpiObject *obj, int32_t *index, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITableLast", dpiOciSymbols.fnTableLast)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTableLast)(obj->env->handle, error->handle,
+            obj->instance, index);
+    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "get last index");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__tableNext() [INTERNAL]
+//   Wrapper for OCITableNext().
+//-----------------------------------------------------------------------------
+int dpiOci__tableNext(dpiObject *obj, int32_t index, int32_t *nextIndex,
+        int *exists, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITableNext", dpiOciSymbols.fnTableNext)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTableNext)(obj->env->handle, error->handle,
+            index, obj->instance, nextIndex, exists);
+    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "get next index");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__tablePrev() [INTERNAL]
+//   Wrapper for OCITablePrev().
+//-----------------------------------------------------------------------------
+int dpiOci__tablePrev(dpiObject *obj, int32_t index, int32_t *prevIndex,
+        int *exists, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITablePrev", dpiOciSymbols.fnTablePrev)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTablePrev)(obj->env->handle, error->handle,
+            index, obj->instance, prevIndex, exists);
+    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "get prev index");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__tableSize() [INTERNAL]
+//   Wrapper for OCITableSize().
+//-----------------------------------------------------------------------------
+int dpiOci__tableSize(dpiObject *obj, int32_t *size, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITableSize", dpiOciSymbols.fnTableSize)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTableSize)(obj->env->handle, error->handle,
+            obj->instance, size);
+    DPI_OCI_CHECK_AND_RETURN(error, status, obj->type->conn, "get size");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__threadKeyDestroy() [INTERNAL]
+//   Wrapper for OCIThreadKeyDestroy().
+//-----------------------------------------------------------------------------
+int dpiOci__threadKeyDestroy(void *envHandle, void *errorHandle, void **key,
+        dpiError *error)
+{
+    DPI_OCI_LOAD_SYMBOL("OCIThreadKeyDestroy",
+            dpiOciSymbols.fnThreadKeyDestroy)
+    (*dpiOciSymbols.fnThreadKeyDestroy)(envHandle, errorHandle, key);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__threadKeyGet() [INTERNAL]
+//   Wrapper for OCIThreadKeyGet().
+//-----------------------------------------------------------------------------
+int dpiOci__threadKeyGet(void *envHandle, void *errorHandle, void *key,
+        void **value, dpiError *error)
+{
+    int status;
+
+    status = (*dpiOciSymbols.fnThreadKeyGet)(envHandle, errorHandle, key,
+            value);
+    if (status != DPI_OCI_SUCCESS)
+        return dpiError__set(error, "get TLS error", DPI_ERR_TLS_ERROR);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__threadKeyInit() [INTERNAL]
+//   Wrapper for OCIThreadKeyInit().
+//-----------------------------------------------------------------------------
+int dpiOci__threadKeyInit(void *envHandle, void *errorHandle, void **key,
+        void *destroyFunc, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIThreadKeyInit", dpiOciSymbols.fnThreadKeyInit)
+    status = (*dpiOciSymbols.fnThreadKeyInit)(envHandle, errorHandle, key,
+            destroyFunc);
+    DPI_OCI_CHECK_AND_RETURN(error, status, NULL, "initialize thread key");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__threadKeySet() [INTERNAL]
+//   Wrapper for OCIThreadKeySet().
+//-----------------------------------------------------------------------------
+int dpiOci__threadKeySet(void *envHandle, void *errorHandle, void *key,
+        void *value, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCIThreadKeySet", dpiOciSymbols.fnThreadKeySet)
+    status = (*dpiOciSymbols.fnThreadKeySet)(envHandle, errorHandle, key,
+            value);
+    if (status != DPI_OCI_SUCCESS)
+        return dpiError__set(error, "set TLS error", DPI_ERR_TLS_ERROR);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__transCommit() [INTERNAL]
+//   Wrapper for OCITransCommit().
+//-----------------------------------------------------------------------------
+int dpiOci__transCommit(dpiConn *conn, uint32_t flags, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITransCommit", dpiOciSymbols.fnTransCommit)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTransCommit)(conn->handle, error->handle,
+            flags);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "commit");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__transDetach() [INTERNAL]
+//   Wrapper for OCITransDetach().
+//-----------------------------------------------------------------------------
+int dpiOci__transDetach(dpiConn *conn, uint32_t flags, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITransDetach", dpiOciSymbols.fnTransDetach)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTransDetach)(conn->handle, error->handle,
+            flags);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "detach TPC transaction");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__transForget() [INTERNAL]
+//   Wrapper for OCITransForget().
+//-----------------------------------------------------------------------------
+int dpiOci__transForget(dpiConn *conn, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITransForget", dpiOciSymbols.fnTransForget)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTransForget)(conn->handle, error->handle,
+            DPI_OCI_DEFAULT);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "forget TPC transaction");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__transPrepare() [INTERNAL]
+//   Wrapper for OCITransPrepare().
+//-----------------------------------------------------------------------------
+int dpiOci__transPrepare(dpiConn *conn, int *commitNeeded, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITransPrepare", dpiOciSymbols.fnTransPrepare)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTransPrepare)(conn->handle, error->handle,
+            DPI_OCI_DEFAULT);
+    *commitNeeded = (status == DPI_OCI_SUCCESS);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "prepare transaction");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__transRollback() [INTERNAL]
+//   Wrapper for OCITransRollback().
+//-----------------------------------------------------------------------------
+int dpiOci__transRollback(dpiConn *conn, int checkError, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITransRollback", dpiOciSymbols.fnTransRollback)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTransRollback)(conn->handle, error->handle,
+            DPI_OCI_DEFAULT);
+    if (!checkError)
+        return DPI_SUCCESS;
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "rollback");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__transStart() [INTERNAL]
+//   Wrapper for OCITransStart().
+//-----------------------------------------------------------------------------
+int dpiOci__transStart(dpiConn *conn, uint32_t transactionTimeout,
+        uint32_t flags, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITransStart", dpiOciSymbols.fnTransStart)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTransStart)(conn->handle, error->handle,
+            transactionTimeout, flags);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "start transaction");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__typeByName() [INTERNAL]
+//   Wrapper for OCITypeByName().
+//-----------------------------------------------------------------------------
+int dpiOci__typeByName(dpiConn *conn, const char *schema,
+        uint32_t schemaLength, const char *name, uint32_t nameLength,
+        void **tdo, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITypeByName", dpiOciSymbols.fnTypeByName)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTypeByName)(conn->env->handle, error->handle,
+            conn->handle, schema, schemaLength, name, nameLength, NULL, 0,
+            DPI_OCI_DURATION_SESSION, DPI_OCI_TYPEGET_ALL, tdo);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "get type by name");
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOci__typeByFullName() [INTERNAL]
+//   Wrapper for OCITypeByFullName().
+//-----------------------------------------------------------------------------
+int dpiOci__typeByFullName(dpiConn *conn, const char *name,
+        uint32_t nameLength, void **tdo, dpiError *error)
+{
+    int status;
+
+    DPI_OCI_LOAD_SYMBOL("OCITypeByFullName", dpiOciSymbols.fnTypeByFullName)
+    DPI_OCI_ENSURE_ERROR_HANDLE(error)
+    status = (*dpiOciSymbols.fnTypeByFullName)(conn->env->handle,
+            error->handle, conn->handle, name, nameLength, NULL, 0,
+            DPI_OCI_DURATION_SESSION, DPI_OCI_TYPEGET_ALL, tdo);
+    DPI_OCI_CHECK_AND_RETURN(error, status, conn, "get type by full name");
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiOracleType.c ./odpi/src/dpiOracleType.c
--- patched-godror/odpi/src/dpiOracleType.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiOracleType.c	1970-01-01 01:00:00
@@ -1,569 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiOracleType.c
-//   Implementation of variable types.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// definition of Oracle types (MUST be in same order as enumeration)
-//-----------------------------------------------------------------------------
-static const dpiOracleType
-        dpiAllOracleTypes[DPI_ORACLE_TYPE_MAX - DPI_ORACLE_TYPE_NONE - 1] = {
-    {
-        DPI_ORACLE_TYPE_VARCHAR,            // public Oracle type
-        DPI_NATIVE_TYPE_BYTES,              // default native type
-        DPI_SQLT_CHR,                       // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        0,                                  // buffer size
-        1,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_NVARCHAR,           // public Oracle type
-        DPI_NATIVE_TYPE_BYTES,              // default native type
-        DPI_SQLT_CHR,                       // internal Oracle type
-        DPI_SQLCS_NCHAR,                    // charset form
-        0,                                  // buffer size
-        1,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_CHAR,               // public Oracle type
-        DPI_NATIVE_TYPE_BYTES,              // default native type
-        DPI_SQLT_AFC,                       // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        0,                                  // buffer size
-        1,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_NCHAR,              // public Oracle type
-        DPI_NATIVE_TYPE_BYTES,              // default native type
-        DPI_SQLT_AFC,                       // internal Oracle type
-        DPI_SQLCS_NCHAR,                    // charset form
-        0,                                  // buffer size
-        1,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_ROWID,              // public Oracle type
-        DPI_NATIVE_TYPE_ROWID,              // default native type
-        DPI_SQLT_RDD,                       // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(void*),                      // buffer size
-        1,                                  // is character data
-        1,                                  // can be in array
-        1                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_RAW,                // public Oracle type
-        DPI_NATIVE_TYPE_BYTES,              // default native type
-        DPI_SQLT_BIN,                       // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        0,                                  // buffer size
-        0,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_NATIVE_FLOAT,       // public Oracle type
-        DPI_NATIVE_TYPE_FLOAT,              // default native type
-        DPI_SQLT_BFLOAT,                    // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(float),                      // buffer size
-        0,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_NATIVE_DOUBLE,      // public Oracle type
-        DPI_NATIVE_TYPE_DOUBLE,             // default native type
-        DPI_SQLT_BDOUBLE,                   // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(double),                     // buffer size
-        0,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_NATIVE_INT,         // public Oracle type
-        DPI_NATIVE_TYPE_INT64,              // default native type
-        DPI_SQLT_INT,                       // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(int64_t),                    // buffer size
-        0,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_NUMBER,             // public Oracle type
-        DPI_NATIVE_TYPE_DOUBLE,             // default native type
-        DPI_SQLT_VNU,                       // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        DPI_OCI_NUMBER_SIZE,                // buffer size
-        0,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_DATE,               // public Oracle type
-        DPI_NATIVE_TYPE_TIMESTAMP,          // default native type
-        DPI_SQLT_ODT,                       // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(dpiOciDate),                 // buffer size
-        0,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_TIMESTAMP,          // public Oracle type
-        DPI_NATIVE_TYPE_TIMESTAMP,          // default native type
-        DPI_SQLT_TIMESTAMP,                 // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(void*),                      // buffer size
-        0,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_TIMESTAMP_TZ,       // public Oracle type
-        DPI_NATIVE_TYPE_TIMESTAMP,          // default native type
-        DPI_SQLT_TIMESTAMP_TZ,              // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(void*),                      // buffer size
-        0,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_TIMESTAMP_LTZ,      // public Oracle type
-        DPI_NATIVE_TYPE_TIMESTAMP,          // default native type
-        DPI_SQLT_TIMESTAMP_LTZ,             // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(void*),                      // buffer size
-        0,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_INTERVAL_DS,        // public Oracle type
-        DPI_NATIVE_TYPE_INTERVAL_DS,        // default native type
-        DPI_SQLT_INTERVAL_DS,               // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(void*),                      // buffer size
-        0,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_INTERVAL_YM,        // public Oracle type
-        DPI_NATIVE_TYPE_INTERVAL_YM,        // default native type
-        DPI_SQLT_INTERVAL_YM,               // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(void*),                      // buffer size
-        0,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_CLOB,               // public Oracle type
-        DPI_NATIVE_TYPE_LOB,                // default native type
-        DPI_SQLT_CLOB,                      // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(void*),                      // buffer size
-        1,                                  // is character data
-        0,                                  // can be in array
-        1                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_NCLOB,              // public Oracle type
-        DPI_NATIVE_TYPE_LOB,                // default native type
-        DPI_SQLT_CLOB,                      // internal Oracle type
-        DPI_SQLCS_NCHAR,                    // charset form
-        sizeof(void*),                      // buffer size
-        1,                                  // is character data
-        0,                                  // can be in array
-        1                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_BLOB,               // public Oracle type
-        DPI_NATIVE_TYPE_LOB,                // default native type
-        DPI_SQLT_BLOB,                      // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(void*),                      // buffer size
-        0,                                  // is character data
-        0,                                  // can be in array
-        1                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_BFILE,              // public Oracle type
-        DPI_NATIVE_TYPE_LOB,                // default native type
-        DPI_SQLT_BFILE,                     // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(void*),                      // buffer size
-        0,                                  // is character data
-        0,                                  // can be in array
-        1                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_STMT,               // public Oracle type
-        DPI_NATIVE_TYPE_STMT,               // default native type
-        DPI_SQLT_RSET,                      // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(void*),                      // buffer size
-        0,                                  // is character data
-        0,                                  // can be in array
-        1                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_BOOLEAN,            // public Oracle type
-        DPI_NATIVE_TYPE_BOOLEAN,            // default native type
-        DPI_SQLT_BOL,                       // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(int),                        // buffer size
-        0,                                  // is character data
-        0,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_OBJECT,             // public Oracle type
-        DPI_NATIVE_TYPE_OBJECT,             // default native type
-        DPI_SQLT_NTY,                       // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(void*),                      // buffer size
-        0,                                  // is character data
-        0,                                  // can be in array
-        1                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_LONG_VARCHAR,       // public Oracle type
-        DPI_NATIVE_TYPE_BYTES,              // default native type
-        DPI_SQLT_CHR,                       // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        DPI_MAX_BASIC_BUFFER_SIZE + 1,      // buffer size
-        1,                                  // is character data
-        0,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_LONG_RAW,           // public Oracle type
-        DPI_NATIVE_TYPE_BYTES,              // default native type
-        DPI_SQLT_BIN,                       // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        DPI_MAX_BASIC_BUFFER_SIZE + 1,      // buffer size
-        0,                                  // is character data
-        0,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_NATIVE_UINT,        // public Oracle type
-        DPI_NATIVE_TYPE_UINT64,             // default native type
-        DPI_SQLT_UIN,                       // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(uint64_t),                   // buffer size
-        0,                                  // is character data
-        1,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_JSON,               // public Oracle type
-        DPI_NATIVE_TYPE_JSON,               // default native type
-        DPI_SQLT_JSON,                      // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(void*),                      // buffer size
-        0,                                  // is character data
-        0,                                  // can be in array
-        1                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_JSON_OBJECT,        // public Oracle type
-        DPI_NATIVE_TYPE_JSON_OBJECT,        // default native type
-        0,                                  // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(dpiJsonObject),              // buffer size
-        0,                                  // is character data
-        0,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_JSON_ARRAY,         // public Oracle type
-        DPI_NATIVE_TYPE_JSON_ARRAY,         // default native type
-        0,                                  // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(dpiJsonArray),               // buffer size
-        0,                                  // is character data
-        0,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_UROWID,             // public Oracle type
-        DPI_NATIVE_TYPE_ROWID,              // default native type
-        DPI_SQLT_RDD,                       // internal Oracle type
-        DPI_SQLCS_IMPLICIT,                 // charset form
-        sizeof(void*),                      // buffer size
-        1,                                  // is character data
-        1,                                  // can be in array
-        1                                   // requires pre-fetch
-    },
-    {
-        DPI_ORACLE_TYPE_LONG_NVARCHAR,      // public Oracle type
-        DPI_NATIVE_TYPE_BYTES,              // default native type
-        DPI_SQLT_CHR,                       // internal Oracle type
-        DPI_SQLCS_NCHAR,                    // charset form
-        DPI_MAX_BASIC_BUFFER_SIZE + 1,      // buffer size
-        1,                                  // is character data
-        0,                                  // can be in array
-        0                                   // requires pre-fetch
-    },
-};
-
-
-//-----------------------------------------------------------------------------
-// dpiOracleType__convertFromOracle() [INTERNAL]
-//   Return a value from the dpiOracleTypeNum enumeration for the OCI data type
-// and charset form. If the OCI data type is not supported, 0 is returned.
-//-----------------------------------------------------------------------------
-static dpiOracleTypeNum dpiOracleType__convertFromOracle(uint16_t typeCode,
-        uint8_t charsetForm)
-{
-    switch(typeCode) {
-        case DPI_SQLT_CHR:
-        case DPI_SQLT_VCS:
-            if (charsetForm == DPI_SQLCS_NCHAR)
-                return DPI_ORACLE_TYPE_NVARCHAR;
-            return DPI_ORACLE_TYPE_VARCHAR;
-        case DPI_SQLT_INT:
-        case DPI_SQLT_FLT:
-        case DPI_SQLT_NUM:
-        case DPI_SQLT_PDN:
-        case DPI_SQLT_VNU:
-        case DPI_SQLT_BFLOAT:
-        case DPI_SQLT_BDOUBLE:
-        case DPI_OCI_TYPECODE_SMALLINT:
-            return DPI_ORACLE_TYPE_NUMBER;
-        case DPI_SQLT_DAT:
-        case DPI_SQLT_ODT:
-            return DPI_ORACLE_TYPE_DATE;
-        case DPI_SQLT_BIN:
-        case DPI_SQLT_LVB:
-            return DPI_ORACLE_TYPE_RAW;
-        case DPI_SQLT_AFC:
-            if (charsetForm == DPI_SQLCS_NCHAR)
-                return DPI_ORACLE_TYPE_NCHAR;
-            return DPI_ORACLE_TYPE_CHAR;
-        case DPI_OCI_TYPECODE_BINARY_INTEGER:
-        case DPI_OCI_TYPECODE_PLS_INTEGER:
-            return DPI_ORACLE_TYPE_NATIVE_INT;
-        case DPI_SQLT_IBFLOAT:
-            return DPI_ORACLE_TYPE_NATIVE_FLOAT;
-        case DPI_SQLT_IBDOUBLE:
-            return DPI_ORACLE_TYPE_NATIVE_DOUBLE;
-        case DPI_SQLT_DATE:
-        case DPI_SQLT_TIMESTAMP:
-            return DPI_ORACLE_TYPE_TIMESTAMP;
-        case DPI_SQLT_TIMESTAMP_TZ:
-            return DPI_ORACLE_TYPE_TIMESTAMP_TZ;
-        case DPI_SQLT_TIMESTAMP_LTZ:
-            return DPI_ORACLE_TYPE_TIMESTAMP_LTZ;
-        case DPI_SQLT_NTY:
-        case DPI_SQLT_REC:
-        case DPI_SQLT_NCO:
-            return DPI_ORACLE_TYPE_OBJECT;
-        case DPI_SQLT_BOL:
-            return DPI_ORACLE_TYPE_BOOLEAN;
-        case DPI_SQLT_CLOB:
-            if (charsetForm == DPI_SQLCS_NCHAR)
-                return DPI_ORACLE_TYPE_NCLOB;
-            return DPI_ORACLE_TYPE_CLOB;
-        case DPI_SQLT_BLOB:
-            return DPI_ORACLE_TYPE_BLOB;
-        case DPI_SQLT_BFILE:
-            return DPI_ORACLE_TYPE_BFILE;
-        case DPI_SQLT_RDD:
-        case DPI_OCI_TYPECODE_ROWID:
-            return DPI_ORACLE_TYPE_ROWID;
-        case DPI_SQLT_RSET:
-            return DPI_ORACLE_TYPE_STMT;
-        case DPI_SQLT_INTERVAL_DS:
-            return DPI_ORACLE_TYPE_INTERVAL_DS;
-        case DPI_SQLT_INTERVAL_YM:
-            return DPI_ORACLE_TYPE_INTERVAL_YM;
-        case DPI_SQLT_LNG:
-        case DPI_OCI_TYPECODE_LONG:
-            return DPI_ORACLE_TYPE_LONG_VARCHAR;
-        case DPI_SQLT_LBI:
-        case DPI_OCI_TYPECODE_LONG_RAW:
-            return DPI_ORACLE_TYPE_LONG_RAW;
-        case DPI_SQLT_JSON:
-            return DPI_ORACLE_TYPE_JSON;
-    }
-    return (dpiOracleTypeNum) 0;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOracleType__getFromNum() [INTERNAL]
-//   Return the type associated with the type number.
-//-----------------------------------------------------------------------------
-const dpiOracleType *dpiOracleType__getFromNum(dpiOracleTypeNum typeNum,
-        dpiError *error)
-{
-    if (typeNum > DPI_ORACLE_TYPE_NONE && typeNum < DPI_ORACLE_TYPE_MAX)
-        return &dpiAllOracleTypes[typeNum - DPI_ORACLE_TYPE_NONE - 1];
-    dpiError__set(error, "check type", DPI_ERR_INVALID_ORACLE_TYPE, typeNum);
-    return NULL;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiOracleType__populateTypeInfo() [INTERNAL]
-//   Populate dpiDataTypeInfo structure given an Oracle descriptor. Note that
-// no error is raised by this function if the data type is not supported. This
-// method is called for both implicit and explicit describes (which behave
-// slightly differently).
-//-----------------------------------------------------------------------------
-int dpiOracleType__populateTypeInfo(dpiConn *conn, void *handle,
-        uint32_t handleType, dpiDataTypeInfo *info, dpiError *error)
-{
-    const dpiOracleType *oracleType = NULL;
-    dpiNativeTypeNum nativeTypeNum;
-    uint32_t dataTypeAttribute;
-    uint8_t charsetForm;
-    uint16_t ociSize;
-
-    // acquire data type
-    if (handleType == DPI_OCI_DTYPE_PARAM)
-        dataTypeAttribute = DPI_OCI_ATTR_TYPECODE;
-    else dataTypeAttribute = DPI_OCI_ATTR_DATA_TYPE;
-    if (dpiOci__attrGet(handle, handleType, (void*) &info->ociTypeCode, 0,
-            dataTypeAttribute, "get data type", error) < 0)
-        return DPI_FAILURE;
-
-    // acquire character set form
-    if (info->ociTypeCode != DPI_SQLT_CHR &&
-            info->ociTypeCode != DPI_SQLT_AFC &&
-            info->ociTypeCode != DPI_SQLT_VCS &&
-            info->ociTypeCode != DPI_SQLT_CLOB)
-        charsetForm = DPI_SQLCS_IMPLICIT;
-    else if (dpiOci__attrGet(handle, handleType, (void*) &charsetForm, 0,
-            DPI_OCI_ATTR_CHARSET_FORM, "get charset form", error) < 0)
-        return DPI_FAILURE;
-
-    // convert Oracle type to ODPI-C enumerations, if possible
-    info->oracleTypeNum = dpiOracleType__convertFromOracle(info->ociTypeCode,
-            charsetForm);
-    if (!info->oracleTypeNum)
-        info->defaultNativeTypeNum = (dpiNativeTypeNum) 0;
-    else {
-        oracleType = dpiOracleType__getFromNum(info->oracleTypeNum, error);
-        if (!oracleType)
-            return DPI_FAILURE;
-        info->defaultNativeTypeNum = oracleType->defaultNativeTypeNum;
-    }
-
-    // determine precision/scale
-    nativeTypeNum = info->defaultNativeTypeNum;
-    switch (nativeTypeNum) {
-        case DPI_NATIVE_TYPE_DOUBLE:
-        case DPI_NATIVE_TYPE_FLOAT:
-        case DPI_NATIVE_TYPE_INT64:
-        case DPI_NATIVE_TYPE_TIMESTAMP:
-        case DPI_NATIVE_TYPE_INTERVAL_YM:
-        case DPI_NATIVE_TYPE_INTERVAL_DS:
-            if (dpiOci__attrGet(handle, handleType, (void*) &info->scale, 0,
-                    DPI_OCI_ATTR_SCALE, "get scale", error) < 0)
-                return DPI_FAILURE;
-            if (dpiOci__attrGet(handle, handleType, (void*) &info->precision,
-                    0, DPI_OCI_ATTR_PRECISION, "get precision", error) < 0)
-                return DPI_FAILURE;
-            if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP ||
-                    nativeTypeNum == DPI_NATIVE_TYPE_INTERVAL_DS) {
-                info->fsPrecision = (uint8_t) info->scale;
-                info->scale = 0;
-            }
-            break;
-        default:
-            info->precision = 0;
-            info->fsPrecision = 0;
-            info->scale = 0;
-            break;
-    }
-
-    // change default type to integer if precision/scale supports it
-    if (info->oracleTypeNum == DPI_ORACLE_TYPE_NUMBER && info->scale == 0 &&
-            info->precision > 0 && info->precision <= DPI_MAX_INT64_PRECISION)
-        info->defaultNativeTypeNum = DPI_NATIVE_TYPE_INT64;
-
-    // acquire size (in bytes) of item
-    info->sizeInChars = 0;
-    if (oracleType && oracleType->sizeInBytes == 0) {
-        if (dpiOci__attrGet(handle, handleType, (void*) &ociSize, 0,
-                DPI_OCI_ATTR_DATA_SIZE, "get size (bytes)", error) < 0)
-            return DPI_FAILURE;
-        info->dbSizeInBytes = ociSize;
-        info->clientSizeInBytes = ociSize;
-    } else {
-        info->dbSizeInBytes = 0;
-        info->clientSizeInBytes = 0;
-    }
-
-    // acquire size (in characters) of item, if applicable
-    if (oracleType && oracleType->isCharacterData &&
-            oracleType->sizeInBytes == 0) {
-        if (dpiOci__attrGet(handle, handleType, (void*) &ociSize, 0,
-                DPI_OCI_ATTR_CHAR_SIZE, "get size (chars)", error) < 0)
-            return DPI_FAILURE;
-        info->sizeInChars = ociSize;
-        if (charsetForm == DPI_SQLCS_NCHAR)
-            info->clientSizeInBytes = info->sizeInChars *
-                    conn->env->nmaxBytesPerCharacter;
-        else if (conn->charsetId != conn->env->charsetId)
-            info->clientSizeInBytes = info->sizeInChars *
-                    conn->env->maxBytesPerCharacter;
-    }
-
-    // acquire object type, if applicable
-    if (info->oracleTypeNum == DPI_ORACLE_TYPE_OBJECT) {
-        if (dpiObjectType__allocate(conn, handle, handleType,
-                &info->objectType, error) < 0)
-            return DPI_FAILURE;
-        if (dpiObjectType__isXmlType(info->objectType)) {
-            dpiObjectType__free(info->objectType, error);
-            info->objectType = NULL;
-            info->ociTypeCode = DPI_SQLT_CHR;
-            info->oracleTypeNum = DPI_ORACLE_TYPE_LONG_VARCHAR;
-            info->defaultNativeTypeNum = DPI_NATIVE_TYPE_BYTES;
-        }
-    }
-
-    return DPI_SUCCESS;
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiOracleType.h ./odpi/src/dpiOracleType.h
--- patched-godror/odpi/src/dpiOracleType.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiOracleType.h	2024-05-14 14:55:13
@@ -0,0 +1,569 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiOracleType.c
+//   Implementation of variable types.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// definition of Oracle types (MUST be in same order as enumeration)
+//-----------------------------------------------------------------------------
+static const dpiOracleType
+        dpiAllOracleTypes[DPI_ORACLE_TYPE_MAX - DPI_ORACLE_TYPE_NONE - 1] = {
+    {
+        DPI_ORACLE_TYPE_VARCHAR,            // public Oracle type
+        DPI_NATIVE_TYPE_BYTES,              // default native type
+        DPI_SQLT_CHR,                       // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        0,                                  // buffer size
+        1,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_NVARCHAR,           // public Oracle type
+        DPI_NATIVE_TYPE_BYTES,              // default native type
+        DPI_SQLT_CHR,                       // internal Oracle type
+        DPI_SQLCS_NCHAR,                    // charset form
+        0,                                  // buffer size
+        1,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_CHAR,               // public Oracle type
+        DPI_NATIVE_TYPE_BYTES,              // default native type
+        DPI_SQLT_AFC,                       // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        0,                                  // buffer size
+        1,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_NCHAR,              // public Oracle type
+        DPI_NATIVE_TYPE_BYTES,              // default native type
+        DPI_SQLT_AFC,                       // internal Oracle type
+        DPI_SQLCS_NCHAR,                    // charset form
+        0,                                  // buffer size
+        1,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_ROWID,              // public Oracle type
+        DPI_NATIVE_TYPE_ROWID,              // default native type
+        DPI_SQLT_RDD,                       // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(void*),                      // buffer size
+        1,                                  // is character data
+        1,                                  // can be in array
+        1                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_RAW,                // public Oracle type
+        DPI_NATIVE_TYPE_BYTES,              // default native type
+        DPI_SQLT_BIN,                       // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        0,                                  // buffer size
+        0,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_NATIVE_FLOAT,       // public Oracle type
+        DPI_NATIVE_TYPE_FLOAT,              // default native type
+        DPI_SQLT_BFLOAT,                    // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(float),                      // buffer size
+        0,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_NATIVE_DOUBLE,      // public Oracle type
+        DPI_NATIVE_TYPE_DOUBLE,             // default native type
+        DPI_SQLT_BDOUBLE,                   // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(double),                     // buffer size
+        0,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_NATIVE_INT,         // public Oracle type
+        DPI_NATIVE_TYPE_INT64,              // default native type
+        DPI_SQLT_INT,                       // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(int64_t),                    // buffer size
+        0,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_NUMBER,             // public Oracle type
+        DPI_NATIVE_TYPE_DOUBLE,             // default native type
+        DPI_SQLT_VNU,                       // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        DPI_OCI_NUMBER_SIZE,                // buffer size
+        0,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_DATE,               // public Oracle type
+        DPI_NATIVE_TYPE_TIMESTAMP,          // default native type
+        DPI_SQLT_ODT,                       // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(dpiOciDate),                 // buffer size
+        0,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_TIMESTAMP,          // public Oracle type
+        DPI_NATIVE_TYPE_TIMESTAMP,          // default native type
+        DPI_SQLT_TIMESTAMP,                 // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(void*),                      // buffer size
+        0,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_TIMESTAMP_TZ,       // public Oracle type
+        DPI_NATIVE_TYPE_TIMESTAMP,          // default native type
+        DPI_SQLT_TIMESTAMP_TZ,              // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(void*),                      // buffer size
+        0,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_TIMESTAMP_LTZ,      // public Oracle type
+        DPI_NATIVE_TYPE_TIMESTAMP,          // default native type
+        DPI_SQLT_TIMESTAMP_LTZ,             // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(void*),                      // buffer size
+        0,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_INTERVAL_DS,        // public Oracle type
+        DPI_NATIVE_TYPE_INTERVAL_DS,        // default native type
+        DPI_SQLT_INTERVAL_DS,               // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(void*),                      // buffer size
+        0,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_INTERVAL_YM,        // public Oracle type
+        DPI_NATIVE_TYPE_INTERVAL_YM,        // default native type
+        DPI_SQLT_INTERVAL_YM,               // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(void*),                      // buffer size
+        0,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_CLOB,               // public Oracle type
+        DPI_NATIVE_TYPE_LOB,                // default native type
+        DPI_SQLT_CLOB,                      // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(void*),                      // buffer size
+        1,                                  // is character data
+        0,                                  // can be in array
+        1                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_NCLOB,              // public Oracle type
+        DPI_NATIVE_TYPE_LOB,                // default native type
+        DPI_SQLT_CLOB,                      // internal Oracle type
+        DPI_SQLCS_NCHAR,                    // charset form
+        sizeof(void*),                      // buffer size
+        1,                                  // is character data
+        0,                                  // can be in array
+        1                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_BLOB,               // public Oracle type
+        DPI_NATIVE_TYPE_LOB,                // default native type
+        DPI_SQLT_BLOB,                      // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(void*),                      // buffer size
+        0,                                  // is character data
+        0,                                  // can be in array
+        1                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_BFILE,              // public Oracle type
+        DPI_NATIVE_TYPE_LOB,                // default native type
+        DPI_SQLT_BFILE,                     // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(void*),                      // buffer size
+        0,                                  // is character data
+        0,                                  // can be in array
+        1                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_STMT,               // public Oracle type
+        DPI_NATIVE_TYPE_STMT,               // default native type
+        DPI_SQLT_RSET,                      // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(void*),                      // buffer size
+        0,                                  // is character data
+        0,                                  // can be in array
+        1                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_BOOLEAN,            // public Oracle type
+        DPI_NATIVE_TYPE_BOOLEAN,            // default native type
+        DPI_SQLT_BOL,                       // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(int),                        // buffer size
+        0,                                  // is character data
+        0,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_OBJECT,             // public Oracle type
+        DPI_NATIVE_TYPE_OBJECT,             // default native type
+        DPI_SQLT_NTY,                       // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(void*),                      // buffer size
+        0,                                  // is character data
+        0,                                  // can be in array
+        1                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_LONG_VARCHAR,       // public Oracle type
+        DPI_NATIVE_TYPE_BYTES,              // default native type
+        DPI_SQLT_CHR,                       // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        DPI_MAX_BASIC_BUFFER_SIZE + 1,      // buffer size
+        1,                                  // is character data
+        0,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_LONG_RAW,           // public Oracle type
+        DPI_NATIVE_TYPE_BYTES,              // default native type
+        DPI_SQLT_BIN,                       // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        DPI_MAX_BASIC_BUFFER_SIZE + 1,      // buffer size
+        0,                                  // is character data
+        0,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_NATIVE_UINT,        // public Oracle type
+        DPI_NATIVE_TYPE_UINT64,             // default native type
+        DPI_SQLT_UIN,                       // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(uint64_t),                   // buffer size
+        0,                                  // is character data
+        1,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_JSON,               // public Oracle type
+        DPI_NATIVE_TYPE_JSON,               // default native type
+        DPI_SQLT_JSON,                      // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(void*),                      // buffer size
+        0,                                  // is character data
+        0,                                  // can be in array
+        1                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_JSON_OBJECT,        // public Oracle type
+        DPI_NATIVE_TYPE_JSON_OBJECT,        // default native type
+        0,                                  // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(dpiJsonObject),              // buffer size
+        0,                                  // is character data
+        0,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_JSON_ARRAY,         // public Oracle type
+        DPI_NATIVE_TYPE_JSON_ARRAY,         // default native type
+        0,                                  // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(dpiJsonArray),               // buffer size
+        0,                                  // is character data
+        0,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_UROWID,             // public Oracle type
+        DPI_NATIVE_TYPE_ROWID,              // default native type
+        DPI_SQLT_RDD,                       // internal Oracle type
+        DPI_SQLCS_IMPLICIT,                 // charset form
+        sizeof(void*),                      // buffer size
+        1,                                  // is character data
+        1,                                  // can be in array
+        1                                   // requires pre-fetch
+    },
+    {
+        DPI_ORACLE_TYPE_LONG_NVARCHAR,      // public Oracle type
+        DPI_NATIVE_TYPE_BYTES,              // default native type
+        DPI_SQLT_CHR,                       // internal Oracle type
+        DPI_SQLCS_NCHAR,                    // charset form
+        DPI_MAX_BASIC_BUFFER_SIZE + 1,      // buffer size
+        1,                                  // is character data
+        0,                                  // can be in array
+        0                                   // requires pre-fetch
+    },
+};
+
+
+//-----------------------------------------------------------------------------
+// dpiOracleType__convertFromOracle() [INTERNAL]
+//   Return a value from the dpiOracleTypeNum enumeration for the OCI data type
+// and charset form. If the OCI data type is not supported, 0 is returned.
+//-----------------------------------------------------------------------------
+static dpiOracleTypeNum dpiOracleType__convertFromOracle(uint16_t typeCode,
+        uint8_t charsetForm)
+{
+    switch(typeCode) {
+        case DPI_SQLT_CHR:
+        case DPI_SQLT_VCS:
+            if (charsetForm == DPI_SQLCS_NCHAR)
+                return DPI_ORACLE_TYPE_NVARCHAR;
+            return DPI_ORACLE_TYPE_VARCHAR;
+        case DPI_SQLT_INT:
+        case DPI_SQLT_FLT:
+        case DPI_SQLT_NUM:
+        case DPI_SQLT_PDN:
+        case DPI_SQLT_VNU:
+        case DPI_SQLT_BFLOAT:
+        case DPI_SQLT_BDOUBLE:
+        case DPI_OCI_TYPECODE_SMALLINT:
+            return DPI_ORACLE_TYPE_NUMBER;
+        case DPI_SQLT_DAT:
+        case DPI_SQLT_ODT:
+            return DPI_ORACLE_TYPE_DATE;
+        case DPI_SQLT_BIN:
+        case DPI_SQLT_LVB:
+            return DPI_ORACLE_TYPE_RAW;
+        case DPI_SQLT_AFC:
+            if (charsetForm == DPI_SQLCS_NCHAR)
+                return DPI_ORACLE_TYPE_NCHAR;
+            return DPI_ORACLE_TYPE_CHAR;
+        case DPI_OCI_TYPECODE_BINARY_INTEGER:
+        case DPI_OCI_TYPECODE_PLS_INTEGER:
+            return DPI_ORACLE_TYPE_NATIVE_INT;
+        case DPI_SQLT_IBFLOAT:
+            return DPI_ORACLE_TYPE_NATIVE_FLOAT;
+        case DPI_SQLT_IBDOUBLE:
+            return DPI_ORACLE_TYPE_NATIVE_DOUBLE;
+        case DPI_SQLT_DATE:
+        case DPI_SQLT_TIMESTAMP:
+            return DPI_ORACLE_TYPE_TIMESTAMP;
+        case DPI_SQLT_TIMESTAMP_TZ:
+            return DPI_ORACLE_TYPE_TIMESTAMP_TZ;
+        case DPI_SQLT_TIMESTAMP_LTZ:
+            return DPI_ORACLE_TYPE_TIMESTAMP_LTZ;
+        case DPI_SQLT_NTY:
+        case DPI_SQLT_REC:
+        case DPI_SQLT_NCO:
+            return DPI_ORACLE_TYPE_OBJECT;
+        case DPI_SQLT_BOL:
+            return DPI_ORACLE_TYPE_BOOLEAN;
+        case DPI_SQLT_CLOB:
+            if (charsetForm == DPI_SQLCS_NCHAR)
+                return DPI_ORACLE_TYPE_NCLOB;
+            return DPI_ORACLE_TYPE_CLOB;
+        case DPI_SQLT_BLOB:
+            return DPI_ORACLE_TYPE_BLOB;
+        case DPI_SQLT_BFILE:
+            return DPI_ORACLE_TYPE_BFILE;
+        case DPI_SQLT_RDD:
+        case DPI_OCI_TYPECODE_ROWID:
+            return DPI_ORACLE_TYPE_ROWID;
+        case DPI_SQLT_RSET:
+            return DPI_ORACLE_TYPE_STMT;
+        case DPI_SQLT_INTERVAL_DS:
+            return DPI_ORACLE_TYPE_INTERVAL_DS;
+        case DPI_SQLT_INTERVAL_YM:
+            return DPI_ORACLE_TYPE_INTERVAL_YM;
+        case DPI_SQLT_LNG:
+        case DPI_OCI_TYPECODE_LONG:
+            return DPI_ORACLE_TYPE_LONG_VARCHAR;
+        case DPI_SQLT_LBI:
+        case DPI_OCI_TYPECODE_LONG_RAW:
+            return DPI_ORACLE_TYPE_LONG_RAW;
+        case DPI_SQLT_JSON:
+            return DPI_ORACLE_TYPE_JSON;
+    }
+    return (dpiOracleTypeNum) 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOracleType__getFromNum() [INTERNAL]
+//   Return the type associated with the type number.
+//-----------------------------------------------------------------------------
+const dpiOracleType *dpiOracleType__getFromNum(dpiOracleTypeNum typeNum,
+        dpiError *error)
+{
+    if (typeNum > DPI_ORACLE_TYPE_NONE && typeNum < DPI_ORACLE_TYPE_MAX)
+        return &dpiAllOracleTypes[typeNum - DPI_ORACLE_TYPE_NONE - 1];
+    dpiError__set(error, "check type", DPI_ERR_INVALID_ORACLE_TYPE, typeNum);
+    return NULL;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiOracleType__populateTypeInfo() [INTERNAL]
+//   Populate dpiDataTypeInfo structure given an Oracle descriptor. Note that
+// no error is raised by this function if the data type is not supported. This
+// method is called for both implicit and explicit describes (which behave
+// slightly differently).
+//-----------------------------------------------------------------------------
+int dpiOracleType__populateTypeInfo(dpiConn *conn, void *handle,
+        uint32_t handleType, dpiDataTypeInfo *info, dpiError *error)
+{
+    const dpiOracleType *oracleType = NULL;
+    dpiNativeTypeNum nativeTypeNum;
+    uint32_t dataTypeAttribute;
+    uint8_t charsetForm;
+    uint16_t ociSize;
+
+    // acquire data type
+    if (handleType == DPI_OCI_DTYPE_PARAM)
+        dataTypeAttribute = DPI_OCI_ATTR_TYPECODE;
+    else dataTypeAttribute = DPI_OCI_ATTR_DATA_TYPE;
+    if (dpiOci__attrGet(handle, handleType, (void*) &info->ociTypeCode, 0,
+            dataTypeAttribute, "get data type", error) < 0)
+        return DPI_FAILURE;
+
+    // acquire character set form
+    if (info->ociTypeCode != DPI_SQLT_CHR &&
+            info->ociTypeCode != DPI_SQLT_AFC &&
+            info->ociTypeCode != DPI_SQLT_VCS &&
+            info->ociTypeCode != DPI_SQLT_CLOB)
+        charsetForm = DPI_SQLCS_IMPLICIT;
+    else if (dpiOci__attrGet(handle, handleType, (void*) &charsetForm, 0,
+            DPI_OCI_ATTR_CHARSET_FORM, "get charset form", error) < 0)
+        return DPI_FAILURE;
+
+    // convert Oracle type to ODPI-C enumerations, if possible
+    info->oracleTypeNum = dpiOracleType__convertFromOracle(info->ociTypeCode,
+            charsetForm);
+    if (!info->oracleTypeNum)
+        info->defaultNativeTypeNum = (dpiNativeTypeNum) 0;
+    else {
+        oracleType = dpiOracleType__getFromNum(info->oracleTypeNum, error);
+        if (!oracleType)
+            return DPI_FAILURE;
+        info->defaultNativeTypeNum = oracleType->defaultNativeTypeNum;
+    }
+
+    // determine precision/scale
+    nativeTypeNum = info->defaultNativeTypeNum;
+    switch (nativeTypeNum) {
+        case DPI_NATIVE_TYPE_DOUBLE:
+        case DPI_NATIVE_TYPE_FLOAT:
+        case DPI_NATIVE_TYPE_INT64:
+        case DPI_NATIVE_TYPE_TIMESTAMP:
+        case DPI_NATIVE_TYPE_INTERVAL_YM:
+        case DPI_NATIVE_TYPE_INTERVAL_DS:
+            if (dpiOci__attrGet(handle, handleType, (void*) &info->scale, 0,
+                    DPI_OCI_ATTR_SCALE, "get scale", error) < 0)
+                return DPI_FAILURE;
+            if (dpiOci__attrGet(handle, handleType, (void*) &info->precision,
+                    0, DPI_OCI_ATTR_PRECISION, "get precision", error) < 0)
+                return DPI_FAILURE;
+            if (nativeTypeNum == DPI_NATIVE_TYPE_TIMESTAMP ||
+                    nativeTypeNum == DPI_NATIVE_TYPE_INTERVAL_DS) {
+                info->fsPrecision = (uint8_t) info->scale;
+                info->scale = 0;
+            }
+            break;
+        default:
+            info->precision = 0;
+            info->fsPrecision = 0;
+            info->scale = 0;
+            break;
+    }
+
+    // change default type to integer if precision/scale supports it
+    if (info->oracleTypeNum == DPI_ORACLE_TYPE_NUMBER && info->scale == 0 &&
+            info->precision > 0 && info->precision <= DPI_MAX_INT64_PRECISION)
+        info->defaultNativeTypeNum = DPI_NATIVE_TYPE_INT64;
+
+    // acquire size (in bytes) of item
+    info->sizeInChars = 0;
+    if (oracleType && oracleType->sizeInBytes == 0) {
+        if (dpiOci__attrGet(handle, handleType, (void*) &ociSize, 0,
+                DPI_OCI_ATTR_DATA_SIZE, "get size (bytes)", error) < 0)
+            return DPI_FAILURE;
+        info->dbSizeInBytes = ociSize;
+        info->clientSizeInBytes = ociSize;
+    } else {
+        info->dbSizeInBytes = 0;
+        info->clientSizeInBytes = 0;
+    }
+
+    // acquire size (in characters) of item, if applicable
+    if (oracleType && oracleType->isCharacterData &&
+            oracleType->sizeInBytes == 0) {
+        if (dpiOci__attrGet(handle, handleType, (void*) &ociSize, 0,
+                DPI_OCI_ATTR_CHAR_SIZE, "get size (chars)", error) < 0)
+            return DPI_FAILURE;
+        info->sizeInChars = ociSize;
+        if (charsetForm == DPI_SQLCS_NCHAR)
+            info->clientSizeInBytes = info->sizeInChars *
+                    conn->env->nmaxBytesPerCharacter;
+        else if (conn->charsetId != conn->env->charsetId)
+            info->clientSizeInBytes = info->sizeInChars *
+                    conn->env->maxBytesPerCharacter;
+    }
+
+    // acquire object type, if applicable
+    if (info->oracleTypeNum == DPI_ORACLE_TYPE_OBJECT) {
+        if (dpiObjectType__allocate(conn, handle, handleType,
+                &info->objectType, error) < 0)
+            return DPI_FAILURE;
+        if (dpiObjectType__isXmlType(info->objectType)) {
+            dpiObjectType__free(info->objectType, error);
+            info->objectType = NULL;
+            info->ociTypeCode = DPI_SQLT_CHR;
+            info->oracleTypeNum = DPI_ORACLE_TYPE_LONG_VARCHAR;
+            info->defaultNativeTypeNum = DPI_NATIVE_TYPE_BYTES;
+        }
+    }
+
+    return DPI_SUCCESS;
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiPool.c ./odpi/src/dpiPool.c
--- patched-godror/odpi/src/dpiPool.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiPool.c	1970-01-01 01:00:00
@@ -1,820 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiPool.c
-//   Implementation of session pools.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiPool__acquireConnection() [INTERNAL]
-//   Internal method used for acquiring a connection from a pool.
-//-----------------------------------------------------------------------------
-int dpiPool__acquireConnection(dpiPool *pool, const char *userName,
-        uint32_t userNameLength, const char *password, uint32_t passwordLength,
-        dpiConnCreateParams *params, dpiConn **conn, dpiError *error)
-{
-    dpiConn *tempConn;
-
-    // allocate new connection
-    if (dpiGen__allocate(DPI_HTYPE_CONN, pool->env, (void**) &tempConn,
-            error) < 0)
-        return DPI_FAILURE;
-    error->env = pool->env;
-
-    // create the connection
-    if (dpiConn__create(tempConn, pool->env->context, userName, userNameLength,
-            password, passwordLength, pool->name, pool->nameLength, pool,
-            NULL, params, error) < 0) {
-        dpiConn__free(tempConn, error);
-        return DPI_FAILURE;
-    }
-
-    *conn = tempConn;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool__checkConnected() [INTERNAL]
-//   Determine if the session pool is connected to the database. If not, an
-// error is raised.
-//-----------------------------------------------------------------------------
-static int dpiPool__checkConnected(dpiPool *pool, const char *fnName,
-        dpiError *error)
-{
-    if (dpiGen__startPublicFn(pool, DPI_HTYPE_POOL, fnName, error) < 0)
-        return DPI_FAILURE;
-    if (!pool->handle)
-        return dpiError__set(error, "check pool", DPI_ERR_NOT_CONNECTED);
-    return DPI_SUCCESS;
-}
-
-
-//----------------------------------------------------------------------------
-// dpiPool__accessTokenCallback() [INTERNAL]
-//   Callback used to execute the registered callback when the authentication
-// token expires and the connection pool needs to create a new connection.
-// -----------------------------------------------------------------------------
-int dpiPool__accessTokenCallback(dpiPool *pool, void *authInfo,
-        UNUSED uint32_t mode)
-{
-    dpiAccessToken accessToken;
-    dpiError error;
-
-    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-
-    memset(&accessToken, 0, sizeof(dpiAccessToken));
-
-    if ((*pool->accessTokenCallback)(pool->accessTokenCallbackContext,
-            &accessToken) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-
-    if (dpiUtils__setAccessTokenAttributes(authInfo, &accessToken,
-               pool->env->versionInfo, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-
-    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool__create() [INTERNAL]
-//   Internal method for creating a session pool.
-//-----------------------------------------------------------------------------
-static int dpiPool__create(dpiPool *pool, const char *userName,
-        uint32_t userNameLength, const char *password, uint32_t passwordLength,
-        const char *connectString, uint32_t connectStringLength,
-        const dpiCommonCreateParams *commonParams,
-        dpiPoolCreateParams *createParams, dpiError *error)
-{
-    uint32_t poolMode;
-    uint8_t getMode;
-    void *authInfo;
-
-    // validate parameters
-    if (createParams->externalAuth &&
-            ((userName && userNameLength > 0) ||
-             (password && passwordLength > 0)))
-        return dpiError__set(error, "check mixed credentials",
-                DPI_ERR_EXT_AUTH_WITH_CREDENTIALS);
-
-    // create the session pool handle
-    if (dpiOci__handleAlloc(pool->env->handle, &pool->handle,
-            DPI_OCI_HTYPE_SPOOL, "allocate pool handle", error) < 0)
-        return DPI_FAILURE;
-
-    // prepare pool mode
-    poolMode = DPI_OCI_SPC_STMTCACHE;
-    if (createParams->homogeneous)
-        poolMode |= DPI_OCI_SPC_HOMOGENEOUS;
-
-    // create authorization handle
-    if (dpiOci__handleAlloc(pool->env->handle, &authInfo,
-            DPI_OCI_HTYPE_AUTHINFO, "allocate authinfo handle", error) < 0)
-        return DPI_FAILURE;
-
-    // set context attributes
-    if (dpiUtils__setAttributesFromCommonCreateParams(authInfo,
-            DPI_OCI_HTYPE_AUTHINFO, commonParams, error) < 0)
-        return DPI_FAILURE;
-
-    // set token based authentication attributes
-    if (commonParams->accessToken) {
-
-        // homogeneous must be set to true for token based authentication
-        if (!createParams->homogeneous || !createParams->externalAuth)
-            return dpiError__set(error, "check homogeneous and externalAuth",
-                    DPI_ERR_POOL_TOKEN_BASED_AUTH);
-
-        if (dpiUtils__setAccessTokenAttributes(authInfo,
-                commonParams->accessToken, pool->env->versionInfo, error) < 0)
-            return DPI_FAILURE;
-
-        if (createParams->accessTokenCallback) {
-            // set token based auth context callback on session handle
-            if (dpiOci__attrSet(authInfo, DPI_OCI_HTYPE_SESSION,
-                    (void*) pool, 0, DPI_OCI_ATTR_TOKEN_CBKCTX,
-                    "set token callback context", error) < 0)
-                return DPI_FAILURE;
-
-            // set token based auth callback on session handle
-            if (dpiOci__attrSet(authInfo, DPI_OCI_HTYPE_SESSION,
-                    (void*) dpiPool__accessTokenCallback, 0,
-                    DPI_OCI_ATTR_TOKEN_CBK, "set token callback", error) < 0)
-                return DPI_FAILURE;
-        }
-    }
-
-    // set PL/SQL session state fixup callback, if applicable
-    if (createParams->plsqlFixupCallback &&
-            createParams->plsqlFixupCallbackLength > 0) {
-        if (dpiUtils__checkClientVersion(pool->env->versionInfo, 12, 2,
-                error) < 0)
-            return DPI_FAILURE;
-        if (dpiOci__attrSet(authInfo, DPI_OCI_HTYPE_AUTHINFO,
-                    (void*) createParams->plsqlFixupCallback,
-                    createParams->plsqlFixupCallbackLength,
-                    DPI_OCI_ATTR_FIXUP_CALLBACK,
-                    "set PL/SQL session state fixup callback", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set authorization info on session pool
-    if (dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL, (void*) authInfo, 0,
-            DPI_OCI_ATTR_SPOOL_AUTH, "set auth info", error) < 0)
-        return DPI_FAILURE;
-
-    // set the get mode on the pool
-    getMode = (uint8_t) createParams->getMode;
-    if (dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL, (void*) &getMode, 0,
-            DPI_OCI_ATTR_SPOOL_GETMODE, "set get mode", error) < 0)
-        return DPI_FAILURE;
-
-    // set the session timeout on the pool
-    if (dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL, (void*)
-            &createParams->timeout, 0, DPI_OCI_ATTR_SPOOL_TIMEOUT,
-            "set timeout", error) < 0)
-        return DPI_FAILURE;
-
-    // set the wait timeout on the pool (valid in 12.2 and higher)
-    if (pool->env->versionInfo->versionNum > 12 ||
-            (pool->env->versionInfo->versionNum == 12 &&
-             pool->env->versionInfo->releaseNum >= 2)) {
-        if (dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL, (void*)
-                &createParams->waitTimeout, 0, DPI_OCI_ATTR_SPOOL_WAIT_TIMEOUT,
-                "set wait timeout", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set the maximum lifetime session on the pool (valid in 12.1 and higher)
-    if (pool->env->versionInfo->versionNum >= 12) {
-        if (dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL, (void*)
-                &createParams->maxLifetimeSession, 0,
-                DPI_OCI_ATTR_SPOOL_MAX_LIFETIME_SESSION,
-                "set max lifetime session", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set the maximum number of sessions per shard (valid in 18.3 and higher)
-    if (pool->env->versionInfo->versionNum > 18 ||
-            (pool->env->versionInfo->versionNum == 18 &&
-             pool->env->versionInfo->releaseNum >= 3)) {
-        if (dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL, (void*)
-                &createParams->maxSessionsPerShard, 0,
-                DPI_OCI_ATTR_SPOOL_MAX_PER_SHARD,
-                "set max sessions per shard", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // create pool
-    if (dpiOci__sessionPoolCreate(pool, connectString, connectStringLength,
-            createParams->minSessions, createParams->maxSessions,
-            createParams->sessionIncrement, userName, userNameLength, password,
-            passwordLength, poolMode, error) < 0)
-        return DPI_FAILURE;
-
-    // set the statement cache size
-    if (dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL,
-            (void*) &commonParams->stmtCacheSize, 0,
-            DPI_OCI_ATTR_SPOOL_STMTCACHESIZE, "set stmt cache size",
-            error) < 0)
-        return DPI_FAILURE;
-
-    // set remaining attributes directly
-    pool->homogeneous = createParams->homogeneous;
-    pool->externalAuth = createParams->externalAuth;
-    pool->pingInterval = createParams->pingInterval;
-    pool->pingTimeout = createParams->pingTimeout;
-    pool->stmtCacheSize = commonParams->stmtCacheSize;
-
-    if (commonParams->accessToken) {
-        pool->accessTokenCallback = createParams->accessTokenCallback;
-        pool->accessTokenCallbackContext =
-                createParams->accessTokenCallbackContext;
-        // force externalAuth to false for token based authentication
-        pool->externalAuth = 0;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool__free() [INTERNAL]
-//   Free any memory associated with the pool.
-//-----------------------------------------------------------------------------
-void dpiPool__free(dpiPool *pool, dpiError *error)
-{
-    if (pool->handle) {
-        dpiOci__sessionPoolDestroy(pool, DPI_OCI_SPD_FORCE, 0, error);
-        pool->handle = NULL;
-    }
-    if (pool->env) {
-        dpiEnv__free(pool->env, error);
-        pool->env = NULL;
-    }
-    dpiUtils__freeMemory(pool);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool__getAttributeUint() [INTERNAL]
-//   Return the value of the attribute as an unsigned integer.
-//-----------------------------------------------------------------------------
-static int dpiPool__getAttributeUint(dpiPool *pool, uint32_t attribute,
-        uint32_t *value, const char *fnName)
-{
-    dpiError error;
-    int status;
-
-    if (dpiPool__checkConnected(pool, fnName, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(pool, value)
-    switch (attribute) {
-        case DPI_OCI_ATTR_SPOOL_MAX_LIFETIME_SESSION:
-            if (dpiUtils__checkClientVersion(pool->env->versionInfo, 12, 1,
-                    &error) < 0)
-                return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-            break;
-        case DPI_OCI_ATTR_SPOOL_WAIT_TIMEOUT:
-            if (dpiUtils__checkClientVersion(pool->env->versionInfo, 12, 2,
-                    &error) < 0)
-                return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-            break;
-        case DPI_OCI_ATTR_SPOOL_BUSY_COUNT:
-        case DPI_OCI_ATTR_SPOOL_OPEN_COUNT:
-        case DPI_OCI_ATTR_SPOOL_STMTCACHESIZE:
-        case DPI_OCI_ATTR_SPOOL_TIMEOUT:
-            break;
-        case DPI_OCI_ATTR_SPOOL_MAX_PER_SHARD:
-            if (dpiUtils__checkClientVersion(pool->env->versionInfo, 18, 3,
-                    &error) < 0)
-                return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-            break;
-        default:
-            dpiError__set(&error, "get attribute value",
-                    DPI_ERR_NOT_SUPPORTED);
-            return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    }
-    status = dpiOci__attrGet(pool->handle, DPI_OCI_HTYPE_SPOOL, value,
-            NULL, attribute, "get attribute value", &error);
-    return dpiGen__endPublicFn(pool, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool__setAttributeUint() [INTERNAL]
-//   Set the value of the OCI attribute as an unsigned integer.
-//-----------------------------------------------------------------------------
-static int dpiPool__setAttributeUint(dpiPool *pool, uint32_t attribute,
-        uint32_t value, const char *fnName)
-{
-    void *ociValue = &value;
-    uint8_t shortValue;
-    dpiError error;
-    int status;
-
-    // make sure session pool is connected
-    if (dpiPool__checkConnected(pool, fnName, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-
-    // determine pointer to pass (OCI uses different sizes)
-    switch (attribute) {
-        case DPI_OCI_ATTR_SPOOL_GETMODE:
-            shortValue = (uint8_t) value;
-            ociValue = &shortValue;
-            break;
-        case DPI_OCI_ATTR_SPOOL_MAX_LIFETIME_SESSION:
-            if (dpiUtils__checkClientVersion(pool->env->versionInfo, 12, 1,
-                    &error) < 0)
-                return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-            break;
-        case DPI_OCI_ATTR_SPOOL_WAIT_TIMEOUT:
-            if (dpiUtils__checkClientVersion(pool->env->versionInfo, 12, 2,
-                    &error) < 0)
-                return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-            break;
-        case DPI_OCI_ATTR_SPOOL_STMTCACHESIZE:
-        case DPI_OCI_ATTR_SPOOL_TIMEOUT:
-            break;
-        case DPI_OCI_ATTR_SPOOL_MAX_PER_SHARD:
-            if (dpiUtils__checkClientVersion(pool->env->versionInfo, 18, 3,
-                    &error) < 0)
-                return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-            break;
-        default:
-            dpiError__set(&error, "set attribute value",
-                    DPI_ERR_NOT_SUPPORTED);
-            return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    }
-
-    // set value in the OCI
-    status = dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL, ociValue, 0,
-            attribute, "set attribute value", &error);
-    return dpiGen__endPublicFn(pool, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_acquireConnection() [PUBLIC]
-//   Acquire a connection from the pool.
-//-----------------------------------------------------------------------------
-int dpiPool_acquireConnection(dpiPool *pool, const char *userName,
-        uint32_t userNameLength, const char *password, uint32_t passwordLength,
-        dpiConnCreateParams *params, dpiConn **conn)
-{
-    dpiConnCreateParams localParams;
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(pool, userName)
-    DPI_CHECK_PTR_AND_LENGTH(pool, password)
-    DPI_CHECK_PTR_NOT_NULL(pool, conn)
-
-    // use default parameters if none provided
-    if (!params) {
-        dpiContext__initConnCreateParams(&localParams);
-        params = &localParams;
-    }
-
-    // the username must be enclosed within [] if external authentication
-    // with proxy is desired
-    if (pool->externalAuth && userName && userNameLength > 0 &&
-            (userName[0] != '[' || userName[userNameLength - 1] != ']')) {
-        dpiError__set(&error, "verify proxy user name with external auth",
-                DPI_ERR_EXT_AUTH_INVALID_PROXY);
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error );
-    }
-
-    status = dpiPool__acquireConnection(pool, userName, userNameLength,
-            password, passwordLength, params, conn, &error);
-    return dpiGen__endPublicFn(pool, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_addRef() [PUBLIC]
-//   Add a reference to the pool.
-//-----------------------------------------------------------------------------
-int dpiPool_addRef(dpiPool *pool)
-{
-    return dpiGen__addRef(pool, DPI_HTYPE_POOL, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_close() [PUBLIC]
-//   Destroy the pool now, not when the reference count reaches zero.
-//-----------------------------------------------------------------------------
-int dpiPool_close(dpiPool *pool, dpiPoolCloseMode mode)
-{
-    dpiError error;
-
-    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    if (dpiOci__sessionPoolDestroy(pool, mode, 1, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_create() [PUBLIC]
-//   Create a new session pool and return it.
-//-----------------------------------------------------------------------------
-int dpiPool_create(const dpiContext *context, const char *userName,
-        uint32_t userNameLength, const char *password, uint32_t passwordLength,
-        const char *connectString, uint32_t connectStringLength,
-        const dpiCommonCreateParams *commonParams,
-        dpiPoolCreateParams *createParams, dpiPool **pool)
-{
-    dpiCommonCreateParams localCommonParams;
-    dpiPoolCreateParams localCreateParams;
-    dpiPool *tempPool;
-    dpiError error;
-
-    // validate parameters
-    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
-            &error) < 0)
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(context, userName)
-    DPI_CHECK_PTR_AND_LENGTH(context, password)
-    DPI_CHECK_PTR_AND_LENGTH(context, connectString)
-    DPI_CHECK_PTR_NOT_NULL(context, pool)
-
-    // use default parameters if none provided
-    if (!commonParams) {
-        dpiContext__initCommonCreateParams(context, &localCommonParams);
-        commonParams = &localCommonParams;
-    }
-    if (!createParams) {
-        dpiContext__initPoolCreateParams(&localCreateParams);
-        createParams = &localCreateParams;
-    }
-
-    // allocate memory for pool
-    if (dpiGen__allocate(DPI_HTYPE_POOL, NULL, (void**) &tempPool, &error) < 0)
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-
-    // initialize environment
-    if (dpiEnv__init(tempPool->env, context, commonParams, NULL,
-            commonParams->createMode | DPI_MODE_CREATE_THREADED, &error) < 0) {
-        dpiPool__free(tempPool, &error);
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    }
-
-    // perform remaining steps required to create pool
-    if (dpiPool__create(tempPool, userName, userNameLength, password,
-            passwordLength, connectString, connectStringLength, commonParams,
-            createParams, &error) < 0) {
-        dpiPool__free(tempPool, &error);
-        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
-    }
-
-    createParams->outPoolName = tempPool->name;
-    createParams->outPoolNameLength = tempPool->nameLength;
-    *pool = tempPool;
-    dpiHandlePool__release(tempPool->env->errorHandles, &error.handle);
-    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_getBusyCount() [PUBLIC]
-//   Return the pool's busy count.
-//-----------------------------------------------------------------------------
-int dpiPool_getBusyCount(dpiPool *pool, uint32_t *value)
-{
-    return dpiPool__getAttributeUint(pool, DPI_OCI_ATTR_SPOOL_BUSY_COUNT,
-            value, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_getEncodingInfo() [PUBLIC]
-//   Get the encoding information from the pool.
-//-----------------------------------------------------------------------------
-int dpiPool_getEncodingInfo(dpiPool *pool, dpiEncodingInfo *info)
-{
-    dpiError error;
-    int status;
-
-    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(pool, info)
-    status = dpiEnv__getEncodingInfo(pool->env, info);
-    return dpiGen__endPublicFn(pool, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_getGetMode() [PUBLIC]
-//   Return the pool's "get" mode.
-//-----------------------------------------------------------------------------
-int dpiPool_getGetMode(dpiPool *pool, dpiPoolGetMode *value)
-{
-    dpiError error;
-
-    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(pool, value)
-    if (dpiOci__attrGet(pool->handle, DPI_OCI_HTYPE_SPOOL, value, NULL,
-            DPI_OCI_ATTR_SPOOL_GETMODE, "get attribute value", &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_getMaxLifetimeSession() [PUBLIC]
-//   Return the pool's maximum lifetime session.
-//-----------------------------------------------------------------------------
-int dpiPool_getMaxLifetimeSession(dpiPool *pool, uint32_t *value)
-{
-    return dpiPool__getAttributeUint(pool,
-            DPI_OCI_ATTR_SPOOL_MAX_LIFETIME_SESSION, value, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_getMaxSessionsPerShard() [PUBLIC]
-//   Return the pool's maximum sessions per shard.
-//-----------------------------------------------------------------------------
-int dpiPool_getMaxSessionsPerShard(dpiPool *pool, uint32_t *value)
-{
-    return dpiPool__getAttributeUint(pool, DPI_OCI_ATTR_SPOOL_MAX_PER_SHARD,
-            value, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_getOpenCount() [PUBLIC]
-//   Return the pool's open count.
-//-----------------------------------------------------------------------------
-int dpiPool_getOpenCount(dpiPool *pool, uint32_t *value)
-{
-    return dpiPool__getAttributeUint(pool, DPI_OCI_ATTR_SPOOL_OPEN_COUNT,
-            value, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_getSodaMetadataCache() [PUBLIC]
-//   Return whether the SODA metadata cache is enabled or not.
-//-----------------------------------------------------------------------------
-int dpiPool_getSodaMetadataCache(dpiPool *pool, int *enabled)
-{
-    dpiError error;
-
-    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(pool, enabled)
-    if (dpiUtils__checkClientVersionMulti(pool->env->versionInfo, 19, 11, 21,
-            3, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    if (dpiOci__attrGet(pool->env->handle, DPI_OCI_HTYPE_ENV, enabled, NULL,
-            DPI_OCI_ATTR_SODA_METADATA_CACHE, "get SODA metadata cache",
-            &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-
-    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_getStmtCacheSize() [PUBLIC]
-//   Return the pool's default statement cache size.
-//-----------------------------------------------------------------------------
-int dpiPool_getStmtCacheSize(dpiPool *pool, uint32_t *value)
-{
-    return dpiPool__getAttributeUint(pool, DPI_OCI_ATTR_SPOOL_STMTCACHESIZE,
-            value, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_getTimeout() [PUBLIC]
-//   Return the pool's timeout value.
-//-----------------------------------------------------------------------------
-int dpiPool_getTimeout(dpiPool *pool, uint32_t *value)
-{
-    return dpiPool__getAttributeUint(pool, DPI_OCI_ATTR_SPOOL_TIMEOUT, value,
-            __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_getWaitTimeout() [PUBLIC]
-//   Return the pool's wait timeout value.
-//-----------------------------------------------------------------------------
-int dpiPool_getWaitTimeout(dpiPool *pool, uint32_t *value)
-{
-    return dpiPool__getAttributeUint(pool, DPI_OCI_ATTR_SPOOL_WAIT_TIMEOUT,
-            value, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_getPingInterval() [PUBLIC]
-//   Return the pool's ping-interval value.
-//-----------------------------------------------------------------------------
-int dpiPool_getPingInterval(dpiPool *pool, int *value)
-{
-    dpiError error;
-
-    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(pool, value);
-    *value = pool->pingInterval;
-    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_release() [PUBLIC]
-//   Release a reference to the pool.
-//-----------------------------------------------------------------------------
-int dpiPool_release(dpiPool *pool)
-{
-    return dpiGen__release(pool, DPI_HTYPE_POOL, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_reconfigure() [PUBLIC]
-//   Reconfigure the pool - OCI only allows poolMin, poolMax, poolIncr
-//   properties
-//-----------------------------------------------------------------------------
-int dpiPool_reconfigure(dpiPool *pool, uint32_t minSessions,
-        uint32_t maxSessions, uint32_t sessionIncrement)
-{
-    dpiError error;
-    uint32_t mode = DPI_OCI_SPC_REINITIALIZE;
-
-    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-
-    if (dpiOci__sessionPoolCreate(pool, NULL, 0, minSessions, maxSessions,
-            sessionIncrement, NULL, 0, NULL, 0, mode, &error) < 0)
-        return DPI_FAILURE;
-
-    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_setGetMode() [PUBLIC]
-//   Set the pool's "get" mode.
-//-----------------------------------------------------------------------------
-int dpiPool_setGetMode(dpiPool *pool, dpiPoolGetMode value)
-{
-    return dpiPool__setAttributeUint(pool, DPI_OCI_ATTR_SPOOL_GETMODE, value,
-            __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_setAccessToken() [PUBLIC]
-//   Sets the token and private key for token based authentication
-//-----------------------------------------------------------------------------
-int dpiPool_setAccessToken(dpiPool *pool, dpiAccessToken *accessToken)
-{
-    dpiError error;
-    void * authInfo;
-
-    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(pool, accessToken)
-
-    if (dpiOci__attrGet(pool->handle, DPI_OCI_HTYPE_SPOOL, (void *)&authInfo,
-            NULL, DPI_OCI_ATTR_SPOOL_AUTH,
-            "get attribute value", &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-
-    if (dpiUtils__setAccessTokenAttributes(authInfo, accessToken,
-            pool->env->versionInfo, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-
-    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_setMaxLifetimeSession() [PUBLIC]
-//   Set the pool's maximum lifetime session.
-//-----------------------------------------------------------------------------
-int dpiPool_setMaxLifetimeSession(dpiPool *pool, uint32_t value)
-{
-    return dpiPool__setAttributeUint(pool,
-            DPI_OCI_ATTR_SPOOL_MAX_LIFETIME_SESSION, value, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_setMaxSessionsPerShard() [PUBLIC]
-//   Set the pool's maximum sessions per shard.
-//-----------------------------------------------------------------------------
-int dpiPool_setMaxSessionsPerShard(dpiPool *pool, uint32_t value)
-{
-    return dpiPool__setAttributeUint(pool, DPI_OCI_ATTR_SPOOL_MAX_PER_SHARD,
-            value, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_setSodaMetadataCache() [PUBLIC]
-//   Set whether the SODA metadata cache is enabled or not.
-//-----------------------------------------------------------------------------
-int dpiPool_setSodaMetadataCache(dpiPool *pool, int enabled)
-{
-    dpiError error;
-
-    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    if (dpiUtils__checkClientVersionMulti(pool->env->versionInfo, 19, 11, 21,
-            3, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    if (dpiOci__attrSet(pool->env->handle, DPI_OCI_HTYPE_ENV, &enabled, 0,
-            DPI_OCI_ATTR_SODA_METADATA_CACHE, "set SODA metadata cache",
-            &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-
-    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_setStmtCacheSize() [PUBLIC]
-//   Set the pool's default statement cache size.
-//-----------------------------------------------------------------------------
-int dpiPool_setStmtCacheSize(dpiPool *pool, uint32_t value)
-{
-    pool->stmtCacheSize = value;
-    return dpiPool__setAttributeUint(pool, DPI_OCI_ATTR_SPOOL_STMTCACHESIZE,
-            value, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_setTimeout() [PUBLIC]
-//   Set the pool's timeout value.
-//-----------------------------------------------------------------------------
-int dpiPool_setTimeout(dpiPool *pool, uint32_t value)
-{
-    return dpiPool__setAttributeUint(pool, DPI_OCI_ATTR_SPOOL_TIMEOUT, value,
-            __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_setWaitTimeout() [PUBLIC]
-//   Set the pool's wait timeout value.
-//-----------------------------------------------------------------------------
-int dpiPool_setWaitTimeout(dpiPool *pool, uint32_t value)
-{
-    return dpiPool__setAttributeUint(pool, DPI_OCI_ATTR_SPOOL_WAIT_TIMEOUT,
-            value, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiPool_setPingInterval() [PUBLIC]
-//   Set the pool-ping-interval value.
-//-----------------------------------------------------------------------------
-int dpiPool_setPingInterval(dpiPool *pool, int value)
-{
-    dpiError error;
-
-    if(dpiPool__checkConnected(pool, __func__, &error) < 0)
-        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
-    pool->pingInterval = value;
-    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiPool.h ./odpi/src/dpiPool.h
--- patched-godror/odpi/src/dpiPool.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiPool.h	2024-05-14 14:55:13
@@ -0,0 +1,820 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiPool.c
+//   Implementation of session pools.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiPool__acquireConnection() [INTERNAL]
+//   Internal method used for acquiring a connection from a pool.
+//-----------------------------------------------------------------------------
+int dpiPool__acquireConnection(dpiPool *pool, const char *userName,
+        uint32_t userNameLength, const char *password, uint32_t passwordLength,
+        dpiConnCreateParams *params, dpiConn **conn, dpiError *error)
+{
+    dpiConn *tempConn;
+
+    // allocate new connection
+    if (dpiGen__allocate(DPI_HTYPE_CONN, pool->env, (void**) &tempConn,
+            error) < 0)
+        return DPI_FAILURE;
+    error->env = pool->env;
+
+    // create the connection
+    if (dpiConn__create(tempConn, pool->env->context, userName, userNameLength,
+            password, passwordLength, pool->name, pool->nameLength, pool,
+            NULL, params, error) < 0) {
+        dpiConn__free(tempConn, error);
+        return DPI_FAILURE;
+    }
+
+    *conn = tempConn;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool__checkConnected() [INTERNAL]
+//   Determine if the session pool is connected to the database. If not, an
+// error is raised.
+//-----------------------------------------------------------------------------
+static int dpiPool__checkConnected(dpiPool *pool, const char *fnName,
+        dpiError *error)
+{
+    if (dpiGen__startPublicFn(pool, DPI_HTYPE_POOL, fnName, error) < 0)
+        return DPI_FAILURE;
+    if (!pool->handle)
+        return dpiError__set(error, "check pool", DPI_ERR_NOT_CONNECTED);
+    return DPI_SUCCESS;
+}
+
+
+//----------------------------------------------------------------------------
+// dpiPool__accessTokenCallback() [INTERNAL]
+//   Callback used to execute the registered callback when the authentication
+// token expires and the connection pool needs to create a new connection.
+// -----------------------------------------------------------------------------
+int dpiPool__accessTokenCallback(dpiPool *pool, void *authInfo,
+        UNUSED uint32_t mode)
+{
+    dpiAccessToken accessToken;
+    dpiError error;
+
+    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+
+    memset(&accessToken, 0, sizeof(dpiAccessToken));
+
+    if ((*pool->accessTokenCallback)(pool->accessTokenCallbackContext,
+            &accessToken) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+
+    if (dpiUtils__setAccessTokenAttributes(authInfo, &accessToken,
+               pool->env->versionInfo, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+
+    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool__create() [INTERNAL]
+//   Internal method for creating a session pool.
+//-----------------------------------------------------------------------------
+static int dpiPool__create(dpiPool *pool, const char *userName,
+        uint32_t userNameLength, const char *password, uint32_t passwordLength,
+        const char *connectString, uint32_t connectStringLength,
+        const dpiCommonCreateParams *commonParams,
+        dpiPoolCreateParams *createParams, dpiError *error)
+{
+    uint32_t poolMode;
+    uint8_t getMode;
+    void *authInfo;
+
+    // validate parameters
+    if (createParams->externalAuth &&
+            ((userName && userNameLength > 0) ||
+             (password && passwordLength > 0)))
+        return dpiError__set(error, "check mixed credentials",
+                DPI_ERR_EXT_AUTH_WITH_CREDENTIALS);
+
+    // create the session pool handle
+    if (dpiOci__handleAlloc(pool->env->handle, &pool->handle,
+            DPI_OCI_HTYPE_SPOOL, "allocate pool handle", error) < 0)
+        return DPI_FAILURE;
+
+    // prepare pool mode
+    poolMode = DPI_OCI_SPC_STMTCACHE;
+    if (createParams->homogeneous)
+        poolMode |= DPI_OCI_SPC_HOMOGENEOUS;
+
+    // create authorization handle
+    if (dpiOci__handleAlloc(pool->env->handle, &authInfo,
+            DPI_OCI_HTYPE_AUTHINFO, "allocate authinfo handle", error) < 0)
+        return DPI_FAILURE;
+
+    // set context attributes
+    if (dpiUtils__setAttributesFromCommonCreateParams(authInfo,
+            DPI_OCI_HTYPE_AUTHINFO, commonParams, error) < 0)
+        return DPI_FAILURE;
+
+    // set token based authentication attributes
+    if (commonParams->accessToken) {
+
+        // homogeneous must be set to true for token based authentication
+        if (!createParams->homogeneous || !createParams->externalAuth)
+            return dpiError__set(error, "check homogeneous and externalAuth",
+                    DPI_ERR_POOL_TOKEN_BASED_AUTH);
+
+        if (dpiUtils__setAccessTokenAttributes(authInfo,
+                commonParams->accessToken, pool->env->versionInfo, error) < 0)
+            return DPI_FAILURE;
+
+        if (createParams->accessTokenCallback) {
+            // set token based auth context callback on session handle
+            if (dpiOci__attrSet(authInfo, DPI_OCI_HTYPE_SESSION,
+                    (void*) pool, 0, DPI_OCI_ATTR_TOKEN_CBKCTX,
+                    "set token callback context", error) < 0)
+                return DPI_FAILURE;
+
+            // set token based auth callback on session handle
+            if (dpiOci__attrSet(authInfo, DPI_OCI_HTYPE_SESSION,
+                    (void*) dpiPool__accessTokenCallback, 0,
+                    DPI_OCI_ATTR_TOKEN_CBK, "set token callback", error) < 0)
+                return DPI_FAILURE;
+        }
+    }
+
+    // set PL/SQL session state fixup callback, if applicable
+    if (createParams->plsqlFixupCallback &&
+            createParams->plsqlFixupCallbackLength > 0) {
+        if (dpiUtils__checkClientVersion(pool->env->versionInfo, 12, 2,
+                error) < 0)
+            return DPI_FAILURE;
+        if (dpiOci__attrSet(authInfo, DPI_OCI_HTYPE_AUTHINFO,
+                    (void*) createParams->plsqlFixupCallback,
+                    createParams->plsqlFixupCallbackLength,
+                    DPI_OCI_ATTR_FIXUP_CALLBACK,
+                    "set PL/SQL session state fixup callback", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set authorization info on session pool
+    if (dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL, (void*) authInfo, 0,
+            DPI_OCI_ATTR_SPOOL_AUTH, "set auth info", error) < 0)
+        return DPI_FAILURE;
+
+    // set the get mode on the pool
+    getMode = (uint8_t) createParams->getMode;
+    if (dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL, (void*) &getMode, 0,
+            DPI_OCI_ATTR_SPOOL_GETMODE, "set get mode", error) < 0)
+        return DPI_FAILURE;
+
+    // set the session timeout on the pool
+    if (dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL, (void*)
+            &createParams->timeout, 0, DPI_OCI_ATTR_SPOOL_TIMEOUT,
+            "set timeout", error) < 0)
+        return DPI_FAILURE;
+
+    // set the wait timeout on the pool (valid in 12.2 and higher)
+    if (pool->env->versionInfo->versionNum > 12 ||
+            (pool->env->versionInfo->versionNum == 12 &&
+             pool->env->versionInfo->releaseNum >= 2)) {
+        if (dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL, (void*)
+                &createParams->waitTimeout, 0, DPI_OCI_ATTR_SPOOL_WAIT_TIMEOUT,
+                "set wait timeout", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set the maximum lifetime session on the pool (valid in 12.1 and higher)
+    if (pool->env->versionInfo->versionNum >= 12) {
+        if (dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL, (void*)
+                &createParams->maxLifetimeSession, 0,
+                DPI_OCI_ATTR_SPOOL_MAX_LIFETIME_SESSION,
+                "set max lifetime session", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set the maximum number of sessions per shard (valid in 18.3 and higher)
+    if (pool->env->versionInfo->versionNum > 18 ||
+            (pool->env->versionInfo->versionNum == 18 &&
+             pool->env->versionInfo->releaseNum >= 3)) {
+        if (dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL, (void*)
+                &createParams->maxSessionsPerShard, 0,
+                DPI_OCI_ATTR_SPOOL_MAX_PER_SHARD,
+                "set max sessions per shard", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // create pool
+    if (dpiOci__sessionPoolCreate(pool, connectString, connectStringLength,
+            createParams->minSessions, createParams->maxSessions,
+            createParams->sessionIncrement, userName, userNameLength, password,
+            passwordLength, poolMode, error) < 0)
+        return DPI_FAILURE;
+
+    // set the statement cache size
+    if (dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL,
+            (void*) &commonParams->stmtCacheSize, 0,
+            DPI_OCI_ATTR_SPOOL_STMTCACHESIZE, "set stmt cache size",
+            error) < 0)
+        return DPI_FAILURE;
+
+    // set remaining attributes directly
+    pool->homogeneous = createParams->homogeneous;
+    pool->externalAuth = createParams->externalAuth;
+    pool->pingInterval = createParams->pingInterval;
+    pool->pingTimeout = createParams->pingTimeout;
+    pool->stmtCacheSize = commonParams->stmtCacheSize;
+
+    if (commonParams->accessToken) {
+        pool->accessTokenCallback = createParams->accessTokenCallback;
+        pool->accessTokenCallbackContext =
+                createParams->accessTokenCallbackContext;
+        // force externalAuth to false for token based authentication
+        pool->externalAuth = 0;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool__free() [INTERNAL]
+//   Free any memory associated with the pool.
+//-----------------------------------------------------------------------------
+void dpiPool__free(dpiPool *pool, dpiError *error)
+{
+    if (pool->handle) {
+        dpiOci__sessionPoolDestroy(pool, DPI_OCI_SPD_FORCE, 0, error);
+        pool->handle = NULL;
+    }
+    if (pool->env) {
+        dpiEnv__free(pool->env, error);
+        pool->env = NULL;
+    }
+    dpiUtils__freeMemory(pool);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool__getAttributeUint() [INTERNAL]
+//   Return the value of the attribute as an unsigned integer.
+//-----------------------------------------------------------------------------
+static int dpiPool__getAttributeUint(dpiPool *pool, uint32_t attribute,
+        uint32_t *value, const char *fnName)
+{
+    dpiError error;
+    int status;
+
+    if (dpiPool__checkConnected(pool, fnName, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(pool, value)
+    switch (attribute) {
+        case DPI_OCI_ATTR_SPOOL_MAX_LIFETIME_SESSION:
+            if (dpiUtils__checkClientVersion(pool->env->versionInfo, 12, 1,
+                    &error) < 0)
+                return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+            break;
+        case DPI_OCI_ATTR_SPOOL_WAIT_TIMEOUT:
+            if (dpiUtils__checkClientVersion(pool->env->versionInfo, 12, 2,
+                    &error) < 0)
+                return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+            break;
+        case DPI_OCI_ATTR_SPOOL_BUSY_COUNT:
+        case DPI_OCI_ATTR_SPOOL_OPEN_COUNT:
+        case DPI_OCI_ATTR_SPOOL_STMTCACHESIZE:
+        case DPI_OCI_ATTR_SPOOL_TIMEOUT:
+            break;
+        case DPI_OCI_ATTR_SPOOL_MAX_PER_SHARD:
+            if (dpiUtils__checkClientVersion(pool->env->versionInfo, 18, 3,
+                    &error) < 0)
+                return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+            break;
+        default:
+            dpiError__set(&error, "get attribute value",
+                    DPI_ERR_NOT_SUPPORTED);
+            return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    }
+    status = dpiOci__attrGet(pool->handle, DPI_OCI_HTYPE_SPOOL, value,
+            NULL, attribute, "get attribute value", &error);
+    return dpiGen__endPublicFn(pool, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool__setAttributeUint() [INTERNAL]
+//   Set the value of the OCI attribute as an unsigned integer.
+//-----------------------------------------------------------------------------
+static int dpiPool__setAttributeUint(dpiPool *pool, uint32_t attribute,
+        uint32_t value, const char *fnName)
+{
+    void *ociValue = &value;
+    uint8_t shortValue;
+    dpiError error;
+    int status;
+
+    // make sure session pool is connected
+    if (dpiPool__checkConnected(pool, fnName, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+
+    // determine pointer to pass (OCI uses different sizes)
+    switch (attribute) {
+        case DPI_OCI_ATTR_SPOOL_GETMODE:
+            shortValue = (uint8_t) value;
+            ociValue = &shortValue;
+            break;
+        case DPI_OCI_ATTR_SPOOL_MAX_LIFETIME_SESSION:
+            if (dpiUtils__checkClientVersion(pool->env->versionInfo, 12, 1,
+                    &error) < 0)
+                return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+            break;
+        case DPI_OCI_ATTR_SPOOL_WAIT_TIMEOUT:
+            if (dpiUtils__checkClientVersion(pool->env->versionInfo, 12, 2,
+                    &error) < 0)
+                return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+            break;
+        case DPI_OCI_ATTR_SPOOL_STMTCACHESIZE:
+        case DPI_OCI_ATTR_SPOOL_TIMEOUT:
+            break;
+        case DPI_OCI_ATTR_SPOOL_MAX_PER_SHARD:
+            if (dpiUtils__checkClientVersion(pool->env->versionInfo, 18, 3,
+                    &error) < 0)
+                return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+            break;
+        default:
+            dpiError__set(&error, "set attribute value",
+                    DPI_ERR_NOT_SUPPORTED);
+            return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    }
+
+    // set value in the OCI
+    status = dpiOci__attrSet(pool->handle, DPI_OCI_HTYPE_SPOOL, ociValue, 0,
+            attribute, "set attribute value", &error);
+    return dpiGen__endPublicFn(pool, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_acquireConnection() [PUBLIC]
+//   Acquire a connection from the pool.
+//-----------------------------------------------------------------------------
+int dpiPool_acquireConnection(dpiPool *pool, const char *userName,
+        uint32_t userNameLength, const char *password, uint32_t passwordLength,
+        dpiConnCreateParams *params, dpiConn **conn)
+{
+    dpiConnCreateParams localParams;
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(pool, userName)
+    DPI_CHECK_PTR_AND_LENGTH(pool, password)
+    DPI_CHECK_PTR_NOT_NULL(pool, conn)
+
+    // use default parameters if none provided
+    if (!params) {
+        dpiContext__initConnCreateParams(&localParams);
+        params = &localParams;
+    }
+
+    // the username must be enclosed within [] if external authentication
+    // with proxy is desired
+    if (pool->externalAuth && userName && userNameLength > 0 &&
+            (userName[0] != '[' || userName[userNameLength - 1] != ']')) {
+        dpiError__set(&error, "verify proxy user name with external auth",
+                DPI_ERR_EXT_AUTH_INVALID_PROXY);
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error );
+    }
+
+    status = dpiPool__acquireConnection(pool, userName, userNameLength,
+            password, passwordLength, params, conn, &error);
+    return dpiGen__endPublicFn(pool, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_addRef() [PUBLIC]
+//   Add a reference to the pool.
+//-----------------------------------------------------------------------------
+int dpiPool_addRef(dpiPool *pool)
+{
+    return dpiGen__addRef(pool, DPI_HTYPE_POOL, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_close() [PUBLIC]
+//   Destroy the pool now, not when the reference count reaches zero.
+//-----------------------------------------------------------------------------
+int dpiPool_close(dpiPool *pool, dpiPoolCloseMode mode)
+{
+    dpiError error;
+
+    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    if (dpiOci__sessionPoolDestroy(pool, mode, 1, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_create() [PUBLIC]
+//   Create a new session pool and return it.
+//-----------------------------------------------------------------------------
+int dpiPool_create(const dpiContext *context, const char *userName,
+        uint32_t userNameLength, const char *password, uint32_t passwordLength,
+        const char *connectString, uint32_t connectStringLength,
+        const dpiCommonCreateParams *commonParams,
+        dpiPoolCreateParams *createParams, dpiPool **pool)
+{
+    dpiCommonCreateParams localCommonParams;
+    dpiPoolCreateParams localCreateParams;
+    dpiPool *tempPool;
+    dpiError error;
+
+    // validate parameters
+    if (dpiGen__startPublicFn(context, DPI_HTYPE_CONTEXT, __func__,
+            &error) < 0)
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(context, userName)
+    DPI_CHECK_PTR_AND_LENGTH(context, password)
+    DPI_CHECK_PTR_AND_LENGTH(context, connectString)
+    DPI_CHECK_PTR_NOT_NULL(context, pool)
+
+    // use default parameters if none provided
+    if (!commonParams) {
+        dpiContext__initCommonCreateParams(context, &localCommonParams);
+        commonParams = &localCommonParams;
+    }
+    if (!createParams) {
+        dpiContext__initPoolCreateParams(&localCreateParams);
+        createParams = &localCreateParams;
+    }
+
+    // allocate memory for pool
+    if (dpiGen__allocate(DPI_HTYPE_POOL, NULL, (void**) &tempPool, &error) < 0)
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+
+    // initialize environment
+    if (dpiEnv__init(tempPool->env, context, commonParams, NULL,
+            commonParams->createMode | DPI_MODE_CREATE_THREADED, &error) < 0) {
+        dpiPool__free(tempPool, &error);
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    }
+
+    // perform remaining steps required to create pool
+    if (dpiPool__create(tempPool, userName, userNameLength, password,
+            passwordLength, connectString, connectStringLength, commonParams,
+            createParams, &error) < 0) {
+        dpiPool__free(tempPool, &error);
+        return dpiGen__endPublicFn(context, DPI_FAILURE, &error);
+    }
+
+    createParams->outPoolName = tempPool->name;
+    createParams->outPoolNameLength = tempPool->nameLength;
+    *pool = tempPool;
+    dpiHandlePool__release(tempPool->env->errorHandles, &error.handle);
+    return dpiGen__endPublicFn(context, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_getBusyCount() [PUBLIC]
+//   Return the pool's busy count.
+//-----------------------------------------------------------------------------
+int dpiPool_getBusyCount(dpiPool *pool, uint32_t *value)
+{
+    return dpiPool__getAttributeUint(pool, DPI_OCI_ATTR_SPOOL_BUSY_COUNT,
+            value, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_getEncodingInfo() [PUBLIC]
+//   Get the encoding information from the pool.
+//-----------------------------------------------------------------------------
+int dpiPool_getEncodingInfo(dpiPool *pool, dpiEncodingInfo *info)
+{
+    dpiError error;
+    int status;
+
+    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(pool, info)
+    status = dpiEnv__getEncodingInfo(pool->env, info);
+    return dpiGen__endPublicFn(pool, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_getGetMode() [PUBLIC]
+//   Return the pool's "get" mode.
+//-----------------------------------------------------------------------------
+int dpiPool_getGetMode(dpiPool *pool, dpiPoolGetMode *value)
+{
+    dpiError error;
+
+    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(pool, value)
+    if (dpiOci__attrGet(pool->handle, DPI_OCI_HTYPE_SPOOL, value, NULL,
+            DPI_OCI_ATTR_SPOOL_GETMODE, "get attribute value", &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_getMaxLifetimeSession() [PUBLIC]
+//   Return the pool's maximum lifetime session.
+//-----------------------------------------------------------------------------
+int dpiPool_getMaxLifetimeSession(dpiPool *pool, uint32_t *value)
+{
+    return dpiPool__getAttributeUint(pool,
+            DPI_OCI_ATTR_SPOOL_MAX_LIFETIME_SESSION, value, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_getMaxSessionsPerShard() [PUBLIC]
+//   Return the pool's maximum sessions per shard.
+//-----------------------------------------------------------------------------
+int dpiPool_getMaxSessionsPerShard(dpiPool *pool, uint32_t *value)
+{
+    return dpiPool__getAttributeUint(pool, DPI_OCI_ATTR_SPOOL_MAX_PER_SHARD,
+            value, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_getOpenCount() [PUBLIC]
+//   Return the pool's open count.
+//-----------------------------------------------------------------------------
+int dpiPool_getOpenCount(dpiPool *pool, uint32_t *value)
+{
+    return dpiPool__getAttributeUint(pool, DPI_OCI_ATTR_SPOOL_OPEN_COUNT,
+            value, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_getSodaMetadataCache() [PUBLIC]
+//   Return whether the SODA metadata cache is enabled or not.
+//-----------------------------------------------------------------------------
+int dpiPool_getSodaMetadataCache(dpiPool *pool, int *enabled)
+{
+    dpiError error;
+
+    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(pool, enabled)
+    if (dpiUtils__checkClientVersionMulti(pool->env->versionInfo, 19, 11, 21,
+            3, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    if (dpiOci__attrGet(pool->env->handle, DPI_OCI_HTYPE_ENV, enabled, NULL,
+            DPI_OCI_ATTR_SODA_METADATA_CACHE, "get SODA metadata cache",
+            &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+
+    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_getStmtCacheSize() [PUBLIC]
+//   Return the pool's default statement cache size.
+//-----------------------------------------------------------------------------
+int dpiPool_getStmtCacheSize(dpiPool *pool, uint32_t *value)
+{
+    return dpiPool__getAttributeUint(pool, DPI_OCI_ATTR_SPOOL_STMTCACHESIZE,
+            value, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_getTimeout() [PUBLIC]
+//   Return the pool's timeout value.
+//-----------------------------------------------------------------------------
+int dpiPool_getTimeout(dpiPool *pool, uint32_t *value)
+{
+    return dpiPool__getAttributeUint(pool, DPI_OCI_ATTR_SPOOL_TIMEOUT, value,
+            __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_getWaitTimeout() [PUBLIC]
+//   Return the pool's wait timeout value.
+//-----------------------------------------------------------------------------
+int dpiPool_getWaitTimeout(dpiPool *pool, uint32_t *value)
+{
+    return dpiPool__getAttributeUint(pool, DPI_OCI_ATTR_SPOOL_WAIT_TIMEOUT,
+            value, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_getPingInterval() [PUBLIC]
+//   Return the pool's ping-interval value.
+//-----------------------------------------------------------------------------
+int dpiPool_getPingInterval(dpiPool *pool, int *value)
+{
+    dpiError error;
+
+    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(pool, value);
+    *value = pool->pingInterval;
+    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_release() [PUBLIC]
+//   Release a reference to the pool.
+//-----------------------------------------------------------------------------
+int dpiPool_release(dpiPool *pool)
+{
+    return dpiGen__release(pool, DPI_HTYPE_POOL, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_reconfigure() [PUBLIC]
+//   Reconfigure the pool - OCI only allows poolMin, poolMax, poolIncr
+//   properties
+//-----------------------------------------------------------------------------
+int dpiPool_reconfigure(dpiPool *pool, uint32_t minSessions,
+        uint32_t maxSessions, uint32_t sessionIncrement)
+{
+    dpiError error;
+    uint32_t mode = DPI_OCI_SPC_REINITIALIZE;
+
+    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+
+    if (dpiOci__sessionPoolCreate(pool, NULL, 0, minSessions, maxSessions,
+            sessionIncrement, NULL, 0, NULL, 0, mode, &error) < 0)
+        return DPI_FAILURE;
+
+    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_setGetMode() [PUBLIC]
+//   Set the pool's "get" mode.
+//-----------------------------------------------------------------------------
+int dpiPool_setGetMode(dpiPool *pool, dpiPoolGetMode value)
+{
+    return dpiPool__setAttributeUint(pool, DPI_OCI_ATTR_SPOOL_GETMODE, value,
+            __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_setAccessToken() [PUBLIC]
+//   Sets the token and private key for token based authentication
+//-----------------------------------------------------------------------------
+int dpiPool_setAccessToken(dpiPool *pool, dpiAccessToken *accessToken)
+{
+    dpiError error;
+    void * authInfo;
+
+    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(pool, accessToken)
+
+    if (dpiOci__attrGet(pool->handle, DPI_OCI_HTYPE_SPOOL, (void *)&authInfo,
+            NULL, DPI_OCI_ATTR_SPOOL_AUTH,
+            "get attribute value", &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+
+    if (dpiUtils__setAccessTokenAttributes(authInfo, accessToken,
+            pool->env->versionInfo, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+
+    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_setMaxLifetimeSession() [PUBLIC]
+//   Set the pool's maximum lifetime session.
+//-----------------------------------------------------------------------------
+int dpiPool_setMaxLifetimeSession(dpiPool *pool, uint32_t value)
+{
+    return dpiPool__setAttributeUint(pool,
+            DPI_OCI_ATTR_SPOOL_MAX_LIFETIME_SESSION, value, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_setMaxSessionsPerShard() [PUBLIC]
+//   Set the pool's maximum sessions per shard.
+//-----------------------------------------------------------------------------
+int dpiPool_setMaxSessionsPerShard(dpiPool *pool, uint32_t value)
+{
+    return dpiPool__setAttributeUint(pool, DPI_OCI_ATTR_SPOOL_MAX_PER_SHARD,
+            value, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_setSodaMetadataCache() [PUBLIC]
+//   Set whether the SODA metadata cache is enabled or not.
+//-----------------------------------------------------------------------------
+int dpiPool_setSodaMetadataCache(dpiPool *pool, int enabled)
+{
+    dpiError error;
+
+    if (dpiPool__checkConnected(pool, __func__, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    if (dpiUtils__checkClientVersionMulti(pool->env->versionInfo, 19, 11, 21,
+            3, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    if (dpiOci__attrSet(pool->env->handle, DPI_OCI_HTYPE_ENV, &enabled, 0,
+            DPI_OCI_ATTR_SODA_METADATA_CACHE, "set SODA metadata cache",
+            &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+
+    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_setStmtCacheSize() [PUBLIC]
+//   Set the pool's default statement cache size.
+//-----------------------------------------------------------------------------
+int dpiPool_setStmtCacheSize(dpiPool *pool, uint32_t value)
+{
+    pool->stmtCacheSize = value;
+    return dpiPool__setAttributeUint(pool, DPI_OCI_ATTR_SPOOL_STMTCACHESIZE,
+            value, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_setTimeout() [PUBLIC]
+//   Set the pool's timeout value.
+//-----------------------------------------------------------------------------
+int dpiPool_setTimeout(dpiPool *pool, uint32_t value)
+{
+    return dpiPool__setAttributeUint(pool, DPI_OCI_ATTR_SPOOL_TIMEOUT, value,
+            __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_setWaitTimeout() [PUBLIC]
+//   Set the pool's wait timeout value.
+//-----------------------------------------------------------------------------
+int dpiPool_setWaitTimeout(dpiPool *pool, uint32_t value)
+{
+    return dpiPool__setAttributeUint(pool, DPI_OCI_ATTR_SPOOL_WAIT_TIMEOUT,
+            value, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiPool_setPingInterval() [PUBLIC]
+//   Set the pool-ping-interval value.
+//-----------------------------------------------------------------------------
+int dpiPool_setPingInterval(dpiPool *pool, int value)
+{
+    dpiError error;
+
+    if(dpiPool__checkConnected(pool, __func__, &error) < 0)
+        return dpiGen__endPublicFn(pool, DPI_FAILURE, &error);
+    pool->pingInterval = value;
+    return dpiGen__endPublicFn(pool, DPI_SUCCESS, &error);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiQueue.c ./odpi/src/dpiQueue.c
--- patched-godror/odpi/src/dpiQueue.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiQueue.c	1970-01-01 01:00:00
@@ -1,621 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2019, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiQueue.c
-//   Implementation of AQ queues.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-// forward declarations of internal functions only used in this file
-static int dpiQueue__allocateBuffer(dpiQueue *queue, uint32_t numElements,
-        dpiError *error);
-static int dpiQueue__deq(dpiQueue *queue, uint32_t *numProps,
-        dpiMsgProps **props, dpiError *error);
-static void dpiQueue__freeBuffer(dpiQueue *queue, dpiError *error);
-static int dpiQueue__getPayloadTDO(dpiQueue *queue, void **tdo,
-        dpiError *error);
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue__allocate() [INTERNAL]
-//   Allocate and initialize a queue.
-//-----------------------------------------------------------------------------
-int dpiQueue__allocate(dpiConn *conn, const char *name, uint32_t nameLength,
-        dpiObjectType *payloadType, dpiQueue **queue, int isJson,
-        dpiError *error)
-{
-    dpiQueue *tempQueue;
-    char *buffer;
-
-    // allocate handle; store reference to the connection that created it
-    if (dpiGen__allocate(DPI_HTYPE_QUEUE, conn->env, (void**) &tempQueue,
-            error) < 0)
-        return DPI_FAILURE;
-    dpiGen__setRefCount(conn, error, 1);
-    tempQueue->conn = conn;
-    tempQueue->isJson = isJson;
-
-    // store payload type, which is either an object type or NULL (meaning that
-    // RAW or JSON payloads are being enqueued and dequeued)
-    if (payloadType) {
-        dpiGen__setRefCount(payloadType, error, 1);
-        tempQueue->payloadType = payloadType;
-    }
-
-    // allocate space for the name of the queue; OCI requires a NULL-terminated
-    // string so allocate enough space to store the NULL terminator; UTF-16
-    // encoded strings are not currently supported
-    if (dpiUtils__allocateMemory(1, nameLength + 1, 0, "queue name",
-            (void**) &buffer, error) < 0) {
-        dpiQueue__free(tempQueue, error);
-        return DPI_FAILURE;
-    }
-    memcpy(buffer, name, nameLength);
-    buffer[nameLength] = '\0';
-    tempQueue->name = buffer;
-
-    *queue = tempQueue;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue__allocateBuffer() [INTERNAL]
-//   Ensure there is enough space in the buffer for the specified number of
-// elements.
-//-----------------------------------------------------------------------------
-static int dpiQueue__allocateBuffer(dpiQueue *queue, uint32_t numElements,
-        dpiError *error)
-{
-    dpiQueue__freeBuffer(queue, error);
-    queue->buffer.numElements = numElements;
-    if (dpiUtils__allocateMemory(numElements, sizeof(dpiMsgProps*), 1,
-            "allocate msg props array", (void**) &queue->buffer.props,
-            error) < 0)
-        return DPI_FAILURE;
-    if (dpiUtils__allocateMemory(numElements, sizeof(void*), 1,
-            "allocate OCI handles array", (void**) &queue->buffer.handles,
-            error) < 0)
-        return DPI_FAILURE;
-    if (dpiUtils__allocateMemory(numElements, sizeof(void*), 1,
-            "allocate OCI instances array", (void**) &queue->buffer.instances,
-            error) < 0)
-        return DPI_FAILURE;
-    if (dpiUtils__allocateMemory(numElements, sizeof(void*), 1,
-            "allocate OCI indicators array",
-            (void**) &queue->buffer.indicators, error) < 0)
-        return DPI_FAILURE;
-    if (!queue->payloadType) {
-        if (dpiUtils__allocateMemory(numElements, sizeof(int16_t), 1,
-                "allocate array of OCI scalar indicator buffers",
-                (void**) &queue->buffer.scalarIndicators, error) < 0)
-            return DPI_FAILURE;
-    }
-    if (dpiUtils__allocateMemory(numElements, sizeof(void*), 1,
-            "allocate message ids array", (void**) &queue->buffer.msgIds,
-            error) < 0)
-        return DPI_FAILURE;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue__check() [INTERNAL]
-//   Determine if the queue is available to use.
-//-----------------------------------------------------------------------------
-static int dpiQueue__check(dpiQueue *queue, const char *fnName,
-        dpiError *error)
-{
-    if (dpiGen__startPublicFn(queue, DPI_HTYPE_QUEUE, fnName, error) < 0)
-        return DPI_FAILURE;
-    if (!queue->conn->handle || queue->conn->closing)
-        return dpiError__set(error, "check connection", DPI_ERR_NOT_CONNECTED);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue__createDeqOptions() [INTERNAL]
-//   Create the dequeue options object that will be used for performing
-// dequeues against the queue.
-//-----------------------------------------------------------------------------
-static int dpiQueue__createDeqOptions(dpiQueue *queue, dpiError *error)
-{
-    dpiDeqOptions *tempOptions;
-
-    if (dpiGen__allocate(DPI_HTYPE_DEQ_OPTIONS, queue->env,
-            (void**) &tempOptions, error) < 0)
-        return DPI_FAILURE;
-    if (dpiDeqOptions__create(tempOptions, queue->conn, error) < 0) {
-        dpiDeqOptions__free(tempOptions, error);
-        return DPI_FAILURE;
-    }
-
-    queue->deqOptions = tempOptions;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue__createEnqOptions() [INTERNAL]
-//   Create the dequeue options object that will be used for performing
-// dequeues against the queue.
-//-----------------------------------------------------------------------------
-static int dpiQueue__createEnqOptions(dpiQueue *queue, dpiError *error)
-{
-    dpiEnqOptions *tempOptions;
-
-    if (dpiGen__allocate(DPI_HTYPE_ENQ_OPTIONS, queue->env,
-            (void**) &tempOptions, error) < 0)
-        return DPI_FAILURE;
-    if (dpiEnqOptions__create(tempOptions, queue->conn, error) < 0) {
-        dpiEnqOptions__free(tempOptions, error);
-        return DPI_FAILURE;
-    }
-
-    queue->enqOptions = tempOptions;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue__deq() [INTERNAL]
-//   Perform a dequeue of up to the specified number of properties.
-//-----------------------------------------------------------------------------
-static int dpiQueue__deq(dpiQueue *queue, uint32_t *numProps,
-        dpiMsgProps **props, dpiError *error)
-{
-    dpiMsgProps *prop;
-    void *payloadTDO;
-    uint32_t i;
-    int status;
-
-    // create dequeue options, if necessary
-    if (!queue->deqOptions && dpiQueue__createDeqOptions(queue, error) < 0)
-        return DPI_FAILURE;
-
-    // allocate buffer, if necessary
-    if (queue->buffer.numElements < *numProps &&
-            dpiQueue__allocateBuffer(queue, *numProps, error) < 0)
-        return DPI_FAILURE;
-
-    // populate buffer
-    for (i = 0; i < *numProps; i++) {
-        prop = queue->buffer.props[i];
-
-        // create new message properties, if applicable
-        if (!prop) {
-            if (dpiMsgProps__allocate(queue->conn, &prop, error) < 0)
-                return DPI_FAILURE;
-            queue->buffer.props[i] = prop;
-        }
-
-        // create payload object, if applicable
-        if (queue->payloadType && !prop->payloadObj &&
-                dpiObject__allocate(queue->payloadType, NULL, NULL, NULL,
-                &prop->payloadObj, error) < 0)
-            return DPI_FAILURE;
-
-        // create JSON payload object, if applicable
-        if (queue->isJson) {
-            if (dpiJson__allocate(queue->conn, &prop->payloadJson, error) < 0)
-                return DPI_FAILURE;
-        }
-
-        // set OCI arrays
-        queue->buffer.handles[i] = prop->handle;
-        if (queue->payloadType) {
-            queue->buffer.instances[i] = prop->payloadObj->instance;
-            queue->buffer.indicators[i] = prop->payloadObj->indicator;
-        } else if (queue->isJson) {
-            queue->buffer.instances[i] = prop->payloadJson->handle;
-            queue->buffer.indicators[i] = &queue->buffer.scalarIndicators[i];
-        } else {
-            queue->buffer.instances[i] = prop->payloadRaw;
-            queue->buffer.indicators[i] = &queue->buffer.scalarIndicators[i];
-        }
-        queue->buffer.msgIds[i] = prop->msgIdRaw;
-
-    }
-
-    // perform dequeue
-    if (dpiQueue__getPayloadTDO(queue, &payloadTDO, error) < 0)
-        return DPI_FAILURE;
-    if (*numProps == 1) {
-        status = dpiOci__aqDeq(queue->conn, queue->name,
-                queue->deqOptions->handle, queue->buffer.handles[0],
-                payloadTDO, queue->buffer.instances, queue->buffer.indicators,
-                queue->buffer.msgIds, error);
-        if (status < 0)
-            *numProps = 0;
-    } else if (queue->isJson) {
-        status = DPI_SUCCESS;
-        for (i = 0; i < *numProps; i++) {
-            status = dpiOci__aqDeq(queue->conn, queue->name,
-                    queue->deqOptions->handle, queue->buffer.handles[i],
-                    payloadTDO, &queue->buffer.instances[i],
-                    &queue->buffer.indicators[i],
-                    &queue->buffer.msgIds[i], error);
-            if (status < 0) {
-                *numProps = i;
-                break;
-            }
-        }
-    } else {
-        status = dpiOci__aqDeqArray(queue->conn, queue->name,
-                queue->deqOptions->handle, numProps, queue->buffer.handles,
-                payloadTDO, queue->buffer.instances, queue->buffer.indicators,
-                queue->buffer.msgIds, error);
-    }
-    if (status < 0 && error->buffer->code != 25228) {
-        error->buffer->offset = *numProps;
-        return DPI_FAILURE;
-    }
-
-    // transfer message properties to destination array
-    for (i = 0; i < *numProps; i++) {
-        props[i] = queue->buffer.props[i];
-        queue->buffer.props[i] = NULL;
-        if (queue->isJson) {
-            props[i]->payloadJson->handle = queue->buffer.instances[i];
-        } else if (!queue->payloadType) {
-            props[i]->payloadRaw = queue->buffer.instances[i];
-        }
-        props[i]->msgIdRaw = queue->buffer.msgIds[i];
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue__enq() [INTERNAL]
-//   Perform an enqueue of the specified properties.
-//-----------------------------------------------------------------------------
-static int dpiQueue__enq(dpiQueue *queue, uint32_t numProps,
-        dpiMsgProps **props, dpiError *error)
-{
-    void *payloadTDO;
-    uint32_t i;
-
-    // if no messages are being enqueued, nothing to do!
-    if (numProps == 0)
-        return DPI_SUCCESS;
-
-    // create enqueue options, if necessary
-    if (!queue->enqOptions && dpiQueue__createEnqOptions(queue, error) < 0)
-        return DPI_FAILURE;
-
-    // allocate buffer, if necessary
-    if (queue->buffer.numElements < numProps &&
-            dpiQueue__allocateBuffer(queue, numProps, error) < 0)
-        return DPI_FAILURE;
-
-    // populate buffer
-    for (i = 0; i < numProps; i++) {
-
-        // perform checks
-        if (!props[i]->payloadObj && !props[i]->payloadRaw &&
-                !props[i]->payloadJson)
-            return dpiError__set(error, "check payload",
-                    DPI_ERR_QUEUE_NO_PAYLOAD);
-        if ((queue->isJson && !props[i]->payloadJson) ||
-                (queue->payloadType && !props[i]->payloadObj) ||
-                (!queue->isJson && !queue->payloadType &&
-                        !props[i]->payloadRaw))
-            return dpiError__set(error, "check payload",
-                    DPI_ERR_QUEUE_WRONG_PAYLOAD_TYPE);
-        if (queue->payloadType && props[i]->payloadObj &&
-                queue->payloadType->tdo != props[i]->payloadObj->type->tdo)
-            return dpiError__set(error, "check payload",
-                    DPI_ERR_WRONG_TYPE,
-                    props[i]->payloadObj->type->schemaLength,
-                    props[i]->payloadObj->type->schema,
-                    props[i]->payloadObj->type->nameLength,
-                    props[i]->payloadObj->type->name,
-                    queue->payloadType->schemaLength,
-                    queue->payloadType->schema,
-                    queue->payloadType->nameLength,
-                    queue->payloadType->name);
-
-        // set OCI arrays
-        queue->buffer.handles[i] = props[i]->handle;
-        if (queue->payloadType) {
-            queue->buffer.instances[i] = props[i]->payloadObj->instance;
-            queue->buffer.indicators[i] = props[i]->payloadObj->indicator;
-        } else if (props[i]->payloadJson) {
-            queue->buffer.instances[i] = props[i]->payloadJson->handle;
-            queue->buffer.indicators[i] = &queue->buffer.scalarIndicators[i];
-        } else {
-            queue->buffer.instances[i] = props[i]->payloadRaw;
-            queue->buffer.indicators[i] = &queue->buffer.scalarIndicators[i];
-        }
-        queue->buffer.msgIds[i] = props[i]->msgIdRaw;
-
-    }
-
-    // perform enqueue
-    if (dpiQueue__getPayloadTDO(queue, &payloadTDO, error) < 0)
-        return DPI_FAILURE;
-    if (numProps == 1) {
-        if (dpiOci__aqEnq(queue->conn, queue->name, queue->enqOptions->handle,
-                queue->buffer.handles[0], payloadTDO, queue->buffer.instances,
-                queue->buffer.indicators, queue->buffer.msgIds, error) < 0)
-            return DPI_FAILURE;
-    } else {
-        if (dpiOci__aqEnqArray(queue->conn, queue->name,
-                queue->enqOptions->handle, &numProps, queue->buffer.handles,
-                payloadTDO, queue->buffer.instances, queue->buffer.indicators,
-                queue->buffer.msgIds, error) < 0) {
-            error->buffer->offset = numProps;
-            return DPI_FAILURE;
-        }
-    }
-
-    // transfer message ids back to message properties
-    for (i = 0; i < numProps; i++)
-        props[i]->msgIdRaw = queue->buffer.msgIds[i];
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue__free() [INTERNAL]
-//   Free the memory for a queue.
-//-----------------------------------------------------------------------------
-void dpiQueue__free(dpiQueue *queue, dpiError *error)
-{
-    if (queue->conn) {
-        dpiGen__setRefCount(queue->conn, error, -1);
-        queue->conn = NULL;
-    }
-    if (queue->payloadType) {
-        dpiGen__setRefCount(queue->payloadType, error, -1);
-        queue->payloadType = NULL;
-    }
-    if (queue->name) {
-        dpiUtils__freeMemory((void*) queue->name);
-        queue->name = NULL;
-    }
-    if (queue->deqOptions) {
-        dpiGen__setRefCount(queue->deqOptions, error, -1);
-        queue->deqOptions = NULL;
-    }
-    if (queue->enqOptions) {
-        dpiGen__setRefCount(queue->enqOptions, error, -1);
-        queue->enqOptions = NULL;
-    }
-    dpiQueue__freeBuffer(queue, error);
-    dpiUtils__freeMemory(queue);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue__freeBuffer() [INTERNAL]
-//   Free the memory areas in the queue buffer.
-//-----------------------------------------------------------------------------
-static void dpiQueue__freeBuffer(dpiQueue *queue, dpiError *error)
-{
-    dpiQueueBuffer *buffer = &queue->buffer;
-    uint32_t i;
-
-    if (buffer->props) {
-        for (i = 0; i < buffer->numElements; i++) {
-            if (buffer->props[i]) {
-                dpiGen__setRefCount(buffer->props[i], error, -1);
-                buffer->props[i] = NULL;
-            }
-        }
-        dpiUtils__freeMemory(buffer->props);
-        buffer->props = NULL;
-    }
-    if (buffer->handles) {
-        dpiUtils__freeMemory(buffer->handles);
-        buffer->handles = NULL;
-    }
-    if (buffer->instances) {
-        dpiUtils__freeMemory(buffer->instances);
-        buffer->instances = NULL;
-    }
-    if (buffer->indicators) {
-        dpiUtils__freeMemory(buffer->indicators);
-        buffer->indicators = NULL;
-    }
-    if (buffer->scalarIndicators) {
-        dpiUtils__freeMemory(buffer->scalarIndicators);
-        buffer->indicators = NULL;
-    }
-    if (buffer->msgIds) {
-        dpiUtils__freeMemory(buffer->msgIds);
-        buffer->msgIds = NULL;
-    }
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue__getPayloadTDO() [INTERNAL]
-//   Acquire the TDO to use for the payload. This will either be the TDO of the
-// object type (if one was specified when the queue was created), the RAW TDO
-// cached on the connection (for RAW queues) or the JSON TDO cached on the
-// connection (for JSON queues).
-//-----------------------------------------------------------------------------
-static int dpiQueue__getPayloadTDO(dpiQueue *queue, void **tdo,
-        dpiError *error)
-{
-    if (queue->payloadType) {
-        *tdo = queue->payloadType->tdo;
-    } else if (queue->isJson) {
-        if (dpiConn__getJsonTDO(queue->conn, error) < 0)
-            return DPI_FAILURE;
-        *tdo = queue->conn->jsonTDO;
-    } else {
-        if (dpiConn__getRawTDO(queue->conn, error) < 0)
-            return DPI_FAILURE;
-        *tdo = queue->conn->rawTDO;
-    }
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue_addRef() [PUBLIC]
-//   Add a reference to the queue.
-//-----------------------------------------------------------------------------
-int dpiQueue_addRef(dpiQueue *queue)
-{
-    return dpiGen__addRef(queue, DPI_HTYPE_QUEUE, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue_deqMany() [PUBLIC]
-//   Dequeue multiple messages from the queue.
-//-----------------------------------------------------------------------------
-int dpiQueue_deqMany(dpiQueue *queue, uint32_t *numProps, dpiMsgProps **props)
-{
-    dpiError error;
-    int status;
-
-    if (dpiQueue__check(queue, __func__, &error) < 0)
-        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(queue, numProps)
-    DPI_CHECK_PTR_NOT_NULL(queue, props)
-    status = dpiQueue__deq(queue, numProps, props, &error);
-    return dpiGen__endPublicFn(queue, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue_deqOne() [PUBLIC]
-//   Dequeue a single message from the queue.
-//-----------------------------------------------------------------------------
-int dpiQueue_deqOne(dpiQueue *queue, dpiMsgProps **props)
-{
-    uint32_t numProps = 1;
-    dpiError error;
-
-    if (dpiQueue__check(queue, __func__, &error) < 0)
-        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(queue, props)
-    if (dpiQueue__deq(queue, &numProps, props, &error) < 0)
-        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
-    if (numProps == 0)
-        *props = NULL;
-    return dpiGen__endPublicFn(queue, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue_enqMany() [PUBLIC]
-//   Enqueue multiple message to the queue.
-//-----------------------------------------------------------------------------
-int dpiQueue_enqMany(dpiQueue *queue, uint32_t numProps, dpiMsgProps **props)
-{
-    dpiError error;
-    uint32_t i;
-    int status;
-
-    // validate parameters
-    if (dpiQueue__check(queue, __func__, &error) < 0)
-        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(queue, props)
-    for (i = 0; i < numProps; i++) {
-        if (dpiGen__checkHandle(props[i], DPI_HTYPE_MSG_PROPS,
-                "check message properties", &error) < 0)
-            return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
-    }
-    status = dpiQueue__enq(queue, numProps, props, &error);
-    return dpiGen__endPublicFn(queue, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue_enqOne() [PUBLIC]
-//   Enqueue a single message to the queue.
-//-----------------------------------------------------------------------------
-int dpiQueue_enqOne(dpiQueue *queue, dpiMsgProps *props)
-{
-    dpiError error;
-    int status;
-
-    if (dpiQueue__check(queue, __func__, &error) < 0)
-        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(props, DPI_HTYPE_MSG_PROPS,
-            "check message properties", &error) < 0)
-        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
-    status = dpiQueue__enq(queue, 1, &props, &error);
-    return dpiGen__endPublicFn(queue, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue_getDeqOptions() [PUBLIC]
-//   Return the dequeue options associated with the queue. If no dequeue
-// options are currently associated with the queue, create them first.
-//-----------------------------------------------------------------------------
-int dpiQueue_getDeqOptions(dpiQueue *queue, dpiDeqOptions **options)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(queue, DPI_HTYPE_QUEUE, __func__, &error) < 0)
-        return DPI_FAILURE;
-    DPI_CHECK_PTR_NOT_NULL(queue, options)
-    if (!queue->deqOptions && dpiQueue__createDeqOptions(queue, &error) < 0)
-        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
-    *options = queue->deqOptions;
-    return dpiGen__endPublicFn(queue, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue_getEnqOptions() [PUBLIC]
-//   Return the enqueue options associated with the queue. If no enqueue
-// options are currently associated with the queue, create them first.
-//-----------------------------------------------------------------------------
-int dpiQueue_getEnqOptions(dpiQueue *queue, dpiEnqOptions **options)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(queue, DPI_HTYPE_QUEUE, __func__, &error) < 0)
-        return DPI_FAILURE;
-    DPI_CHECK_PTR_NOT_NULL(queue, options)
-    if (!queue->enqOptions && dpiQueue__createEnqOptions(queue, &error) < 0)
-        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
-    *options = queue->enqOptions;
-    return dpiGen__endPublicFn(queue, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiQueue_release() [PUBLIC]
-//   Release a reference to the queue.
-//-----------------------------------------------------------------------------
-int dpiQueue_release(dpiQueue *queue)
-{
-    return dpiGen__release(queue, DPI_HTYPE_QUEUE, __func__);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiQueue.h ./odpi/src/dpiQueue.h
--- patched-godror/odpi/src/dpiQueue.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiQueue.h	2024-05-14 14:55:13
@@ -0,0 +1,621 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2019, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiQueue.c
+//   Implementation of AQ queues.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+// forward declarations of internal functions only used in this file
+static int dpiQueue__allocateBuffer(dpiQueue *queue, uint32_t numElements,
+        dpiError *error);
+static int dpiQueue__deq(dpiQueue *queue, uint32_t *numProps,
+        dpiMsgProps **props, dpiError *error);
+static void dpiQueue__freeBuffer(dpiQueue *queue, dpiError *error);
+static int dpiQueue__getPayloadTDO(dpiQueue *queue, void **tdo,
+        dpiError *error);
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue__allocate() [INTERNAL]
+//   Allocate and initialize a queue.
+//-----------------------------------------------------------------------------
+int dpiQueue__allocate(dpiConn *conn, const char *name, uint32_t nameLength,
+        dpiObjectType *payloadType, dpiQueue **queue, int isJson,
+        dpiError *error)
+{
+    dpiQueue *tempQueue;
+    char *buffer;
+
+    // allocate handle; store reference to the connection that created it
+    if (dpiGen__allocate(DPI_HTYPE_QUEUE, conn->env, (void**) &tempQueue,
+            error) < 0)
+        return DPI_FAILURE;
+    dpiGen__setRefCount(conn, error, 1);
+    tempQueue->conn = conn;
+    tempQueue->isJson = isJson;
+
+    // store payload type, which is either an object type or NULL (meaning that
+    // RAW or JSON payloads are being enqueued and dequeued)
+    if (payloadType) {
+        dpiGen__setRefCount(payloadType, error, 1);
+        tempQueue->payloadType = payloadType;
+    }
+
+    // allocate space for the name of the queue; OCI requires a NULL-terminated
+    // string so allocate enough space to store the NULL terminator; UTF-16
+    // encoded strings are not currently supported
+    if (dpiUtils__allocateMemory(1, nameLength + 1, 0, "queue name",
+            (void**) &buffer, error) < 0) {
+        dpiQueue__free(tempQueue, error);
+        return DPI_FAILURE;
+    }
+    memcpy(buffer, name, nameLength);
+    buffer[nameLength] = '\0';
+    tempQueue->name = buffer;
+
+    *queue = tempQueue;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue__allocateBuffer() [INTERNAL]
+//   Ensure there is enough space in the buffer for the specified number of
+// elements.
+//-----------------------------------------------------------------------------
+static int dpiQueue__allocateBuffer(dpiQueue *queue, uint32_t numElements,
+        dpiError *error)
+{
+    dpiQueue__freeBuffer(queue, error);
+    queue->buffer.numElements = numElements;
+    if (dpiUtils__allocateMemory(numElements, sizeof(dpiMsgProps*), 1,
+            "allocate msg props array", (void**) &queue->buffer.props,
+            error) < 0)
+        return DPI_FAILURE;
+    if (dpiUtils__allocateMemory(numElements, sizeof(void*), 1,
+            "allocate OCI handles array", (void**) &queue->buffer.handles,
+            error) < 0)
+        return DPI_FAILURE;
+    if (dpiUtils__allocateMemory(numElements, sizeof(void*), 1,
+            "allocate OCI instances array", (void**) &queue->buffer.instances,
+            error) < 0)
+        return DPI_FAILURE;
+    if (dpiUtils__allocateMemory(numElements, sizeof(void*), 1,
+            "allocate OCI indicators array",
+            (void**) &queue->buffer.indicators, error) < 0)
+        return DPI_FAILURE;
+    if (!queue->payloadType) {
+        if (dpiUtils__allocateMemory(numElements, sizeof(int16_t), 1,
+                "allocate array of OCI scalar indicator buffers",
+                (void**) &queue->buffer.scalarIndicators, error) < 0)
+            return DPI_FAILURE;
+    }
+    if (dpiUtils__allocateMemory(numElements, sizeof(void*), 1,
+            "allocate message ids array", (void**) &queue->buffer.msgIds,
+            error) < 0)
+        return DPI_FAILURE;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue__check() [INTERNAL]
+//   Determine if the queue is available to use.
+//-----------------------------------------------------------------------------
+static int dpiQueue__check(dpiQueue *queue, const char *fnName,
+        dpiError *error)
+{
+    if (dpiGen__startPublicFn(queue, DPI_HTYPE_QUEUE, fnName, error) < 0)
+        return DPI_FAILURE;
+    if (!queue->conn->handle || queue->conn->closing)
+        return dpiError__set(error, "check connection", DPI_ERR_NOT_CONNECTED);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue__createDeqOptions() [INTERNAL]
+//   Create the dequeue options object that will be used for performing
+// dequeues against the queue.
+//-----------------------------------------------------------------------------
+static int dpiQueue__createDeqOptions(dpiQueue *queue, dpiError *error)
+{
+    dpiDeqOptions *tempOptions;
+
+    if (dpiGen__allocate(DPI_HTYPE_DEQ_OPTIONS, queue->env,
+            (void**) &tempOptions, error) < 0)
+        return DPI_FAILURE;
+    if (dpiDeqOptions__create(tempOptions, queue->conn, error) < 0) {
+        dpiDeqOptions__free(tempOptions, error);
+        return DPI_FAILURE;
+    }
+
+    queue->deqOptions = tempOptions;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue__createEnqOptions() [INTERNAL]
+//   Create the dequeue options object that will be used for performing
+// dequeues against the queue.
+//-----------------------------------------------------------------------------
+static int dpiQueue__createEnqOptions(dpiQueue *queue, dpiError *error)
+{
+    dpiEnqOptions *tempOptions;
+
+    if (dpiGen__allocate(DPI_HTYPE_ENQ_OPTIONS, queue->env,
+            (void**) &tempOptions, error) < 0)
+        return DPI_FAILURE;
+    if (dpiEnqOptions__create(tempOptions, queue->conn, error) < 0) {
+        dpiEnqOptions__free(tempOptions, error);
+        return DPI_FAILURE;
+    }
+
+    queue->enqOptions = tempOptions;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue__deq() [INTERNAL]
+//   Perform a dequeue of up to the specified number of properties.
+//-----------------------------------------------------------------------------
+static int dpiQueue__deq(dpiQueue *queue, uint32_t *numProps,
+        dpiMsgProps **props, dpiError *error)
+{
+    dpiMsgProps *prop;
+    void *payloadTDO;
+    uint32_t i;
+    int status;
+
+    // create dequeue options, if necessary
+    if (!queue->deqOptions && dpiQueue__createDeqOptions(queue, error) < 0)
+        return DPI_FAILURE;
+
+    // allocate buffer, if necessary
+    if (queue->buffer.numElements < *numProps &&
+            dpiQueue__allocateBuffer(queue, *numProps, error) < 0)
+        return DPI_FAILURE;
+
+    // populate buffer
+    for (i = 0; i < *numProps; i++) {
+        prop = queue->buffer.props[i];
+
+        // create new message properties, if applicable
+        if (!prop) {
+            if (dpiMsgProps__allocate(queue->conn, &prop, error) < 0)
+                return DPI_FAILURE;
+            queue->buffer.props[i] = prop;
+        }
+
+        // create payload object, if applicable
+        if (queue->payloadType && !prop->payloadObj &&
+                dpiObject__allocate(queue->payloadType, NULL, NULL, NULL,
+                &prop->payloadObj, error) < 0)
+            return DPI_FAILURE;
+
+        // create JSON payload object, if applicable
+        if (queue->isJson) {
+            if (dpiJson__allocate(queue->conn, &prop->payloadJson, error) < 0)
+                return DPI_FAILURE;
+        }
+
+        // set OCI arrays
+        queue->buffer.handles[i] = prop->handle;
+        if (queue->payloadType) {
+            queue->buffer.instances[i] = prop->payloadObj->instance;
+            queue->buffer.indicators[i] = prop->payloadObj->indicator;
+        } else if (queue->isJson) {
+            queue->buffer.instances[i] = prop->payloadJson->handle;
+            queue->buffer.indicators[i] = &queue->buffer.scalarIndicators[i];
+        } else {
+            queue->buffer.instances[i] = prop->payloadRaw;
+            queue->buffer.indicators[i] = &queue->buffer.scalarIndicators[i];
+        }
+        queue->buffer.msgIds[i] = prop->msgIdRaw;
+
+    }
+
+    // perform dequeue
+    if (dpiQueue__getPayloadTDO(queue, &payloadTDO, error) < 0)
+        return DPI_FAILURE;
+    if (*numProps == 1) {
+        status = dpiOci__aqDeq(queue->conn, queue->name,
+                queue->deqOptions->handle, queue->buffer.handles[0],
+                payloadTDO, queue->buffer.instances, queue->buffer.indicators,
+                queue->buffer.msgIds, error);
+        if (status < 0)
+            *numProps = 0;
+    } else if (queue->isJson) {
+        status = DPI_SUCCESS;
+        for (i = 0; i < *numProps; i++) {
+            status = dpiOci__aqDeq(queue->conn, queue->name,
+                    queue->deqOptions->handle, queue->buffer.handles[i],
+                    payloadTDO, &queue->buffer.instances[i],
+                    &queue->buffer.indicators[i],
+                    &queue->buffer.msgIds[i], error);
+            if (status < 0) {
+                *numProps = i;
+                break;
+            }
+        }
+    } else {
+        status = dpiOci__aqDeqArray(queue->conn, queue->name,
+                queue->deqOptions->handle, numProps, queue->buffer.handles,
+                payloadTDO, queue->buffer.instances, queue->buffer.indicators,
+                queue->buffer.msgIds, error);
+    }
+    if (status < 0 && error->buffer->code != 25228) {
+        error->buffer->offset = *numProps;
+        return DPI_FAILURE;
+    }
+
+    // transfer message properties to destination array
+    for (i = 0; i < *numProps; i++) {
+        props[i] = queue->buffer.props[i];
+        queue->buffer.props[i] = NULL;
+        if (queue->isJson) {
+            props[i]->payloadJson->handle = queue->buffer.instances[i];
+        } else if (!queue->payloadType) {
+            props[i]->payloadRaw = queue->buffer.instances[i];
+        }
+        props[i]->msgIdRaw = queue->buffer.msgIds[i];
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue__enq() [INTERNAL]
+//   Perform an enqueue of the specified properties.
+//-----------------------------------------------------------------------------
+static int dpiQueue__enq(dpiQueue *queue, uint32_t numProps,
+        dpiMsgProps **props, dpiError *error)
+{
+    void *payloadTDO;
+    uint32_t i;
+
+    // if no messages are being enqueued, nothing to do!
+    if (numProps == 0)
+        return DPI_SUCCESS;
+
+    // create enqueue options, if necessary
+    if (!queue->enqOptions && dpiQueue__createEnqOptions(queue, error) < 0)
+        return DPI_FAILURE;
+
+    // allocate buffer, if necessary
+    if (queue->buffer.numElements < numProps &&
+            dpiQueue__allocateBuffer(queue, numProps, error) < 0)
+        return DPI_FAILURE;
+
+    // populate buffer
+    for (i = 0; i < numProps; i++) {
+
+        // perform checks
+        if (!props[i]->payloadObj && !props[i]->payloadRaw &&
+                !props[i]->payloadJson)
+            return dpiError__set(error, "check payload",
+                    DPI_ERR_QUEUE_NO_PAYLOAD);
+        if ((queue->isJson && !props[i]->payloadJson) ||
+                (queue->payloadType && !props[i]->payloadObj) ||
+                (!queue->isJson && !queue->payloadType &&
+                        !props[i]->payloadRaw))
+            return dpiError__set(error, "check payload",
+                    DPI_ERR_QUEUE_WRONG_PAYLOAD_TYPE);
+        if (queue->payloadType && props[i]->payloadObj &&
+                queue->payloadType->tdo != props[i]->payloadObj->type->tdo)
+            return dpiError__set(error, "check payload",
+                    DPI_ERR_WRONG_TYPE,
+                    props[i]->payloadObj->type->schemaLength,
+                    props[i]->payloadObj->type->schema,
+                    props[i]->payloadObj->type->nameLength,
+                    props[i]->payloadObj->type->name,
+                    queue->payloadType->schemaLength,
+                    queue->payloadType->schema,
+                    queue->payloadType->nameLength,
+                    queue->payloadType->name);
+
+        // set OCI arrays
+        queue->buffer.handles[i] = props[i]->handle;
+        if (queue->payloadType) {
+            queue->buffer.instances[i] = props[i]->payloadObj->instance;
+            queue->buffer.indicators[i] = props[i]->payloadObj->indicator;
+        } else if (props[i]->payloadJson) {
+            queue->buffer.instances[i] = props[i]->payloadJson->handle;
+            queue->buffer.indicators[i] = &queue->buffer.scalarIndicators[i];
+        } else {
+            queue->buffer.instances[i] = props[i]->payloadRaw;
+            queue->buffer.indicators[i] = &queue->buffer.scalarIndicators[i];
+        }
+        queue->buffer.msgIds[i] = props[i]->msgIdRaw;
+
+    }
+
+    // perform enqueue
+    if (dpiQueue__getPayloadTDO(queue, &payloadTDO, error) < 0)
+        return DPI_FAILURE;
+    if (numProps == 1) {
+        if (dpiOci__aqEnq(queue->conn, queue->name, queue->enqOptions->handle,
+                queue->buffer.handles[0], payloadTDO, queue->buffer.instances,
+                queue->buffer.indicators, queue->buffer.msgIds, error) < 0)
+            return DPI_FAILURE;
+    } else {
+        if (dpiOci__aqEnqArray(queue->conn, queue->name,
+                queue->enqOptions->handle, &numProps, queue->buffer.handles,
+                payloadTDO, queue->buffer.instances, queue->buffer.indicators,
+                queue->buffer.msgIds, error) < 0) {
+            error->buffer->offset = numProps;
+            return DPI_FAILURE;
+        }
+    }
+
+    // transfer message ids back to message properties
+    for (i = 0; i < numProps; i++)
+        props[i]->msgIdRaw = queue->buffer.msgIds[i];
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue__free() [INTERNAL]
+//   Free the memory for a queue.
+//-----------------------------------------------------------------------------
+void dpiQueue__free(dpiQueue *queue, dpiError *error)
+{
+    if (queue->conn) {
+        dpiGen__setRefCount(queue->conn, error, -1);
+        queue->conn = NULL;
+    }
+    if (queue->payloadType) {
+        dpiGen__setRefCount(queue->payloadType, error, -1);
+        queue->payloadType = NULL;
+    }
+    if (queue->name) {
+        dpiUtils__freeMemory((void*) queue->name);
+        queue->name = NULL;
+    }
+    if (queue->deqOptions) {
+        dpiGen__setRefCount(queue->deqOptions, error, -1);
+        queue->deqOptions = NULL;
+    }
+    if (queue->enqOptions) {
+        dpiGen__setRefCount(queue->enqOptions, error, -1);
+        queue->enqOptions = NULL;
+    }
+    dpiQueue__freeBuffer(queue, error);
+    dpiUtils__freeMemory(queue);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue__freeBuffer() [INTERNAL]
+//   Free the memory areas in the queue buffer.
+//-----------------------------------------------------------------------------
+static void dpiQueue__freeBuffer(dpiQueue *queue, dpiError *error)
+{
+    dpiQueueBuffer *buffer = &queue->buffer;
+    uint32_t i;
+
+    if (buffer->props) {
+        for (i = 0; i < buffer->numElements; i++) {
+            if (buffer->props[i]) {
+                dpiGen__setRefCount(buffer->props[i], error, -1);
+                buffer->props[i] = NULL;
+            }
+        }
+        dpiUtils__freeMemory(buffer->props);
+        buffer->props = NULL;
+    }
+    if (buffer->handles) {
+        dpiUtils__freeMemory(buffer->handles);
+        buffer->handles = NULL;
+    }
+    if (buffer->instances) {
+        dpiUtils__freeMemory(buffer->instances);
+        buffer->instances = NULL;
+    }
+    if (buffer->indicators) {
+        dpiUtils__freeMemory(buffer->indicators);
+        buffer->indicators = NULL;
+    }
+    if (buffer->scalarIndicators) {
+        dpiUtils__freeMemory(buffer->scalarIndicators);
+        buffer->indicators = NULL;
+    }
+    if (buffer->msgIds) {
+        dpiUtils__freeMemory(buffer->msgIds);
+        buffer->msgIds = NULL;
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue__getPayloadTDO() [INTERNAL]
+//   Acquire the TDO to use for the payload. This will either be the TDO of the
+// object type (if one was specified when the queue was created), the RAW TDO
+// cached on the connection (for RAW queues) or the JSON TDO cached on the
+// connection (for JSON queues).
+//-----------------------------------------------------------------------------
+static int dpiQueue__getPayloadTDO(dpiQueue *queue, void **tdo,
+        dpiError *error)
+{
+    if (queue->payloadType) {
+        *tdo = queue->payloadType->tdo;
+    } else if (queue->isJson) {
+        if (dpiConn__getJsonTDO(queue->conn, error) < 0)
+            return DPI_FAILURE;
+        *tdo = queue->conn->jsonTDO;
+    } else {
+        if (dpiConn__getRawTDO(queue->conn, error) < 0)
+            return DPI_FAILURE;
+        *tdo = queue->conn->rawTDO;
+    }
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue_addRef() [PUBLIC]
+//   Add a reference to the queue.
+//-----------------------------------------------------------------------------
+int dpiQueue_addRef(dpiQueue *queue)
+{
+    return dpiGen__addRef(queue, DPI_HTYPE_QUEUE, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue_deqMany() [PUBLIC]
+//   Dequeue multiple messages from the queue.
+//-----------------------------------------------------------------------------
+int dpiQueue_deqMany(dpiQueue *queue, uint32_t *numProps, dpiMsgProps **props)
+{
+    dpiError error;
+    int status;
+
+    if (dpiQueue__check(queue, __func__, &error) < 0)
+        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(queue, numProps)
+    DPI_CHECK_PTR_NOT_NULL(queue, props)
+    status = dpiQueue__deq(queue, numProps, props, &error);
+    return dpiGen__endPublicFn(queue, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue_deqOne() [PUBLIC]
+//   Dequeue a single message from the queue.
+//-----------------------------------------------------------------------------
+int dpiQueue_deqOne(dpiQueue *queue, dpiMsgProps **props)
+{
+    uint32_t numProps = 1;
+    dpiError error;
+
+    if (dpiQueue__check(queue, __func__, &error) < 0)
+        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(queue, props)
+    if (dpiQueue__deq(queue, &numProps, props, &error) < 0)
+        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
+    if (numProps == 0)
+        *props = NULL;
+    return dpiGen__endPublicFn(queue, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue_enqMany() [PUBLIC]
+//   Enqueue multiple message to the queue.
+//-----------------------------------------------------------------------------
+int dpiQueue_enqMany(dpiQueue *queue, uint32_t numProps, dpiMsgProps **props)
+{
+    dpiError error;
+    uint32_t i;
+    int status;
+
+    // validate parameters
+    if (dpiQueue__check(queue, __func__, &error) < 0)
+        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(queue, props)
+    for (i = 0; i < numProps; i++) {
+        if (dpiGen__checkHandle(props[i], DPI_HTYPE_MSG_PROPS,
+                "check message properties", &error) < 0)
+            return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
+    }
+    status = dpiQueue__enq(queue, numProps, props, &error);
+    return dpiGen__endPublicFn(queue, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue_enqOne() [PUBLIC]
+//   Enqueue a single message to the queue.
+//-----------------------------------------------------------------------------
+int dpiQueue_enqOne(dpiQueue *queue, dpiMsgProps *props)
+{
+    dpiError error;
+    int status;
+
+    if (dpiQueue__check(queue, __func__, &error) < 0)
+        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(props, DPI_HTYPE_MSG_PROPS,
+            "check message properties", &error) < 0)
+        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
+    status = dpiQueue__enq(queue, 1, &props, &error);
+    return dpiGen__endPublicFn(queue, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue_getDeqOptions() [PUBLIC]
+//   Return the dequeue options associated with the queue. If no dequeue
+// options are currently associated with the queue, create them first.
+//-----------------------------------------------------------------------------
+int dpiQueue_getDeqOptions(dpiQueue *queue, dpiDeqOptions **options)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(queue, DPI_HTYPE_QUEUE, __func__, &error) < 0)
+        return DPI_FAILURE;
+    DPI_CHECK_PTR_NOT_NULL(queue, options)
+    if (!queue->deqOptions && dpiQueue__createDeqOptions(queue, &error) < 0)
+        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
+    *options = queue->deqOptions;
+    return dpiGen__endPublicFn(queue, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue_getEnqOptions() [PUBLIC]
+//   Return the enqueue options associated with the queue. If no enqueue
+// options are currently associated with the queue, create them first.
+//-----------------------------------------------------------------------------
+int dpiQueue_getEnqOptions(dpiQueue *queue, dpiEnqOptions **options)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(queue, DPI_HTYPE_QUEUE, __func__, &error) < 0)
+        return DPI_FAILURE;
+    DPI_CHECK_PTR_NOT_NULL(queue, options)
+    if (!queue->enqOptions && dpiQueue__createEnqOptions(queue, &error) < 0)
+        return dpiGen__endPublicFn(queue, DPI_FAILURE, &error);
+    *options = queue->enqOptions;
+    return dpiGen__endPublicFn(queue, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiQueue_release() [PUBLIC]
+//   Release a reference to the queue.
+//-----------------------------------------------------------------------------
+int dpiQueue_release(dpiQueue *queue)
+{
+    return dpiGen__release(queue, DPI_HTYPE_QUEUE, __func__);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiRowid.c ./odpi/src/dpiRowid.c
--- patched-godror/odpi/src/dpiRowid.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiRowid.c	1970-01-01 01:00:00
@@ -1,147 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiRowid.c
-//   Implementation of rowids.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiRowid__allocate() [INTERNAL]
-//   Allocate and initialize a rowid object.
-//-----------------------------------------------------------------------------
-int dpiRowid__allocate(dpiConn *conn, dpiRowid **rowid, dpiError *error)
-{
-    dpiRowid *tempRowid;
-
-    if (dpiGen__allocate(DPI_HTYPE_ROWID, conn->env, (void**) &tempRowid,
-            error) < 0)
-        return DPI_FAILURE;
-    if (dpiOci__descriptorAlloc(conn->env->handle, &tempRowid->handle,
-            DPI_OCI_DTYPE_ROWID, "allocate descriptor", error) < 0) {
-        dpiRowid__free(tempRowid, error);
-        return DPI_FAILURE;
-    }
-
-    *rowid = tempRowid;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiRowid__free() [INTERNAL]
-//   Free the memory for a rowid.
-//-----------------------------------------------------------------------------
-void dpiRowid__free(dpiRowid *rowid, UNUSED dpiError *error)
-{
-    if (rowid->handle) {
-        dpiOci__descriptorFree(rowid->handle, DPI_OCI_DTYPE_ROWID);
-        rowid->handle = NULL;
-    }
-    if (rowid->buffer) {
-        dpiUtils__freeMemory(rowid->buffer);
-        rowid->buffer = NULL;
-    }
-    dpiUtils__freeMemory(rowid);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiRowid_addRef() [PUBLIC]
-//   Add a reference to the rowid.
-//-----------------------------------------------------------------------------
-int dpiRowid_addRef(dpiRowid *rowid)
-{
-    return dpiGen__addRef(rowid, DPI_HTYPE_ROWID, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiRowid_getStringValue() [PUBLIC]
-//   Get the string representation of the rowid.
-//-----------------------------------------------------------------------------
-int dpiRowid_getStringValue(dpiRowid *rowid, const char **value,
-        uint32_t *valueLength)
-{
-    char temp, *adjustedBuffer, *sourcePtr;
-    uint16_t *targetPtr;
-    dpiError error;
-    uint16_t i;
-
-    if (dpiGen__startPublicFn(rowid, DPI_HTYPE_ROWID, __func__, &error) < 0)
-        return dpiGen__endPublicFn(rowid, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(rowid, value)
-    DPI_CHECK_PTR_NOT_NULL(rowid, valueLength)
-    if (!rowid->buffer) {
-
-        // determine length of rowid
-        rowid->bufferLength = 0;
-        dpiOci__rowidToChar(rowid, &temp, &rowid->bufferLength, &error);
-
-        // allocate and populate buffer containing string representation
-        if (dpiUtils__allocateMemory(1, rowid->bufferLength, 0,
-                "allocate rowid buffer", (void**) &rowid->buffer, &error) < 0)
-            return dpiGen__endPublicFn(rowid, DPI_FAILURE, &error);
-        if (dpiOci__rowidToChar(rowid, rowid->buffer, &rowid->bufferLength,
-                &error) < 0)
-            return dpiGen__endPublicFn(rowid, DPI_FAILURE, &error);
-
-        // UTF-16 is not handled properly (data is returned as ASCII instead)
-        // adjust the buffer to use the correct encoding
-        if (rowid->env->charsetId == DPI_CHARSET_ID_UTF16) {
-            if (dpiUtils__allocateMemory(2, rowid->bufferLength, 0,
-                    "allocate rowid buffer", (void**) &adjustedBuffer,
-                    &error) < 0) {
-                dpiUtils__freeMemory(rowid->buffer);
-                rowid->bufferLength = 0;
-                rowid->buffer = NULL;
-                return dpiGen__endPublicFn(rowid, DPI_FAILURE, &error);
-            }
-            sourcePtr = rowid->buffer;
-            targetPtr = (uint16_t*) adjustedBuffer;
-            for (i = 0; i < rowid->bufferLength; i++)
-                *targetPtr++ = (uint16_t) *sourcePtr++;
-            dpiUtils__freeMemory(rowid->buffer);
-            rowid->buffer = adjustedBuffer;
-            rowid->bufferLength *= 2;
-        }
-
-    }
-
-    *value = rowid->buffer;
-    *valueLength = rowid->bufferLength;
-    return dpiGen__endPublicFn(rowid, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiRowid_release() [PUBLIC]
-//   Release a reference to the rowid.
-//-----------------------------------------------------------------------------
-int dpiRowid_release(dpiRowid *rowid)
-{
-    return dpiGen__release(rowid, DPI_HTYPE_ROWID, __func__);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiRowid.h ./odpi/src/dpiRowid.h
--- patched-godror/odpi/src/dpiRowid.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiRowid.h	2024-05-14 14:55:13
@@ -0,0 +1,147 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiRowid.c
+//   Implementation of rowids.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiRowid__allocate() [INTERNAL]
+//   Allocate and initialize a rowid object.
+//-----------------------------------------------------------------------------
+int dpiRowid__allocate(dpiConn *conn, dpiRowid **rowid, dpiError *error)
+{
+    dpiRowid *tempRowid;
+
+    if (dpiGen__allocate(DPI_HTYPE_ROWID, conn->env, (void**) &tempRowid,
+            error) < 0)
+        return DPI_FAILURE;
+    if (dpiOci__descriptorAlloc(conn->env->handle, &tempRowid->handle,
+            DPI_OCI_DTYPE_ROWID, "allocate descriptor", error) < 0) {
+        dpiRowid__free(tempRowid, error);
+        return DPI_FAILURE;
+    }
+
+    *rowid = tempRowid;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiRowid__free() [INTERNAL]
+//   Free the memory for a rowid.
+//-----------------------------------------------------------------------------
+void dpiRowid__free(dpiRowid *rowid, UNUSED dpiError *error)
+{
+    if (rowid->handle) {
+        dpiOci__descriptorFree(rowid->handle, DPI_OCI_DTYPE_ROWID);
+        rowid->handle = NULL;
+    }
+    if (rowid->buffer) {
+        dpiUtils__freeMemory(rowid->buffer);
+        rowid->buffer = NULL;
+    }
+    dpiUtils__freeMemory(rowid);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiRowid_addRef() [PUBLIC]
+//   Add a reference to the rowid.
+//-----------------------------------------------------------------------------
+int dpiRowid_addRef(dpiRowid *rowid)
+{
+    return dpiGen__addRef(rowid, DPI_HTYPE_ROWID, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiRowid_getStringValue() [PUBLIC]
+//   Get the string representation of the rowid.
+//-----------------------------------------------------------------------------
+int dpiRowid_getStringValue(dpiRowid *rowid, const char **value,
+        uint32_t *valueLength)
+{
+    char temp, *adjustedBuffer, *sourcePtr;
+    uint16_t *targetPtr;
+    dpiError error;
+    uint16_t i;
+
+    if (dpiGen__startPublicFn(rowid, DPI_HTYPE_ROWID, __func__, &error) < 0)
+        return dpiGen__endPublicFn(rowid, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(rowid, value)
+    DPI_CHECK_PTR_NOT_NULL(rowid, valueLength)
+    if (!rowid->buffer) {
+
+        // determine length of rowid
+        rowid->bufferLength = 0;
+        dpiOci__rowidToChar(rowid, &temp, &rowid->bufferLength, &error);
+
+        // allocate and populate buffer containing string representation
+        if (dpiUtils__allocateMemory(1, rowid->bufferLength, 0,
+                "allocate rowid buffer", (void**) &rowid->buffer, &error) < 0)
+            return dpiGen__endPublicFn(rowid, DPI_FAILURE, &error);
+        if (dpiOci__rowidToChar(rowid, rowid->buffer, &rowid->bufferLength,
+                &error) < 0)
+            return dpiGen__endPublicFn(rowid, DPI_FAILURE, &error);
+
+        // UTF-16 is not handled properly (data is returned as ASCII instead)
+        // adjust the buffer to use the correct encoding
+        if (rowid->env->charsetId == DPI_CHARSET_ID_UTF16) {
+            if (dpiUtils__allocateMemory(2, rowid->bufferLength, 0,
+                    "allocate rowid buffer", (void**) &adjustedBuffer,
+                    &error) < 0) {
+                dpiUtils__freeMemory(rowid->buffer);
+                rowid->bufferLength = 0;
+                rowid->buffer = NULL;
+                return dpiGen__endPublicFn(rowid, DPI_FAILURE, &error);
+            }
+            sourcePtr = rowid->buffer;
+            targetPtr = (uint16_t*) adjustedBuffer;
+            for (i = 0; i < rowid->bufferLength; i++)
+                *targetPtr++ = (uint16_t) *sourcePtr++;
+            dpiUtils__freeMemory(rowid->buffer);
+            rowid->buffer = adjustedBuffer;
+            rowid->bufferLength *= 2;
+        }
+
+    }
+
+    *value = rowid->buffer;
+    *valueLength = rowid->bufferLength;
+    return dpiGen__endPublicFn(rowid, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiRowid_release() [PUBLIC]
+//   Release a reference to the rowid.
+//-----------------------------------------------------------------------------
+int dpiRowid_release(dpiRowid *rowid)
+{
+    return dpiGen__release(rowid, DPI_HTYPE_ROWID, __func__);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiSodaColl.c ./odpi/src/dpiSodaColl.c
--- patched-godror/odpi/src/dpiSodaColl.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiSodaColl.c	1970-01-01 01:00:00
@@ -1,1048 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2018, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl.c
-//   Implementation of SODA collections.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-// forward declarations of internal functions only used in this file
-static int dpiSodaColl__populateOperOptions(dpiSodaColl *coll,
-        const dpiSodaOperOptions *options, void *handle, dpiError *error);
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl__allocate() [INTERNAL]
-//   Allocate and initialize a SODA collection structure.
-//-----------------------------------------------------------------------------
-int dpiSodaColl__allocate(dpiSodaDb *db, void *handle, dpiSodaColl **coll,
-        dpiError *error)
-{
-    uint8_t sqlType, contentType;
-    dpiSodaColl *tempColl;
-
-    if (dpiOci__attrGet(handle, DPI_OCI_HTYPE_SODA_COLLECTION,
-            (void*) &sqlType, 0, DPI_OCI_ATTR_SODA_CTNT_SQL_TYPE,
-            "get content sql type", error) < 0)
-        return DPI_FAILURE;
-    if (dpiGen__allocate(DPI_HTYPE_SODA_COLL, db->env, (void**) &tempColl,
-            error) < 0)
-        return DPI_FAILURE;
-    dpiGen__setRefCount(db, error, 1);
-    tempColl->db = db;
-    tempColl->handle = handle;
-    if (sqlType == DPI_SQLT_BLOB) {
-        tempColl->binaryContent = 1;
-        contentType = 0;
-        dpiOci__attrGet(handle, DPI_OCI_HTYPE_SODA_COLLECTION,
-                (void*) &contentType, 0, DPI_OCI_ATTR_SODA_CTNT_FORMAT,
-                    NULL, error);
-        if (contentType == DPI_OCI_JSON_FORMAT_OSON)
-            tempColl->binaryContent = 0;
-    }
-    *coll = tempColl;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl__check() [INTERNAL]
-//   Determine if the SODA collection is available to use.
-//-----------------------------------------------------------------------------
-static int dpiSodaColl__check(dpiSodaColl *coll, const char *fnName,
-        dpiError *error)
-{
-    if (dpiGen__startPublicFn(coll, DPI_HTYPE_SODA_COLL, fnName, error) < 0)
-        return DPI_FAILURE;
-    if (!coll->db->conn->handle || coll->db->conn->closing)
-        return dpiError__set(error, "check connection", DPI_ERR_NOT_CONNECTED);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl__createOperOptions() [INTERNAL]
-//   Create a SODA operation options handle with the specified information.
-//-----------------------------------------------------------------------------
-static int dpiSodaColl__createOperOptions(dpiSodaColl *coll,
-        const dpiSodaOperOptions *options, void **handle, dpiError *error)
-{
-    dpiSodaOperOptions localOptions;
-
-    // if no options specified, use default values
-    if (!options) {
-        dpiContext__initSodaOperOptions(&localOptions);
-        options = &localOptions;
-
-    // size changed in version 4.2; this can be removed in version 5
-    } else if (coll->env->context->dpiMinorVersion < 2) {
-        dpiContext__initSodaOperOptions(&localOptions);
-        memcpy(&localOptions, options, sizeof(dpiSodaOperOptions__v41));
-        options = &localOptions;
-    }
-
-    // allocate new handle
-    if (dpiOci__handleAlloc(coll->env->handle, handle,
-            DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
-            "allocate SODA operation options handle", error) < 0)
-        return DPI_FAILURE;
-
-    // populate handle attributes
-    if (dpiSodaColl__populateOperOptions(coll, options, *handle, error) < 0) {
-        dpiOci__handleFree(*handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
-        return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl__find() [INTERNAL]
-//   Perform a find of SODA documents by creating an operation options handle
-// and populating it with the requested options. Once the find is complete,
-// return either a cursor or a document.
-//-----------------------------------------------------------------------------
-static int dpiSodaColl__find(dpiSodaColl *coll,
-        const dpiSodaOperOptions *options, uint32_t flags,
-        dpiSodaDocCursor **cursor, dpiSodaDoc **doc, dpiError *error)
-{
-    uint32_t ociMode, returnHandleType, ociFlags;
-    void *optionsHandle, *ociReturnHandle;
-    int status;
-
-    // determine OCI mode to pass
-    ociMode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        ociMode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-
-    // create new OCI operation options handle
-    if (dpiSodaColl__createOperOptions(coll, options, &optionsHandle,
-            error) < 0)
-        return DPI_FAILURE;
-
-    // determine OCI flags to use
-    ociFlags = (coll->binaryContent) ? DPI_OCI_SODA_AS_STORED :
-            DPI_OCI_SODA_AS_AL32UTF8;
-
-    // perform actual find
-    if (cursor) {
-        *cursor = NULL;
-        status = dpiOci__sodaFind(coll, optionsHandle, ociFlags, ociMode,
-                &ociReturnHandle, error);
-    } else {
-        *doc = NULL;
-        status = dpiOci__sodaFindOne(coll, optionsHandle, ociFlags, ociMode,
-                &ociReturnHandle, error);
-    }
-    dpiOci__handleFree(optionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
-    if (status < 0)
-        return DPI_FAILURE;
-
-    // return cursor or document, as appropriate
-    if (cursor) {
-        status = dpiSodaDocCursor__allocate(coll, ociReturnHandle, cursor,
-                error);
-        returnHandleType = DPI_OCI_HTYPE_SODA_DOC_CURSOR;
-    } else if (ociReturnHandle) {
-        status = dpiSodaDoc__allocate(coll->db, ociReturnHandle, doc, error);
-        returnHandleType = DPI_OCI_HTYPE_SODA_DOCUMENT;
-    }
-    if (status < 0)
-        dpiOci__handleFree(ociReturnHandle, returnHandleType);
-
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl__free() [INTERNAL]
-//   Free the memory for a SODA collection. Note that the reference to the
-// database must remain until after the handle is freed; otherwise, a segfault
-// can take place.
-//-----------------------------------------------------------------------------
-void dpiSodaColl__free(dpiSodaColl *coll, dpiError *error)
-{
-    if (coll->handle) {
-        dpiOci__handleFree(coll->handle, DPI_OCI_HTYPE_SODA_COLLECTION);
-        coll->handle = NULL;
-    }
-    if (coll->db) {
-        dpiGen__setRefCount(coll->db, error, -1);
-        coll->db = NULL;
-    }
-    dpiUtils__freeMemory(coll);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl__getDocCount() [INTERNAL]
-//   Internal method for getting document count.
-//-----------------------------------------------------------------------------
-static int dpiSodaColl__getDocCount(dpiSodaColl *coll,
-        const dpiSodaOperOptions *options, uint32_t flags, uint64_t *count,
-        dpiError *error)
-{
-    void *optionsHandle;
-    uint32_t ociMode;
-    int status;
-
-    // determine OCI mode to pass
-    ociMode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        ociMode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-
-    // create new OCI operation options handle
-    if (dpiSodaColl__createOperOptions(coll, options, &optionsHandle,
-            error) < 0)
-        return DPI_FAILURE;
-
-    // perform actual document count
-    status = dpiOci__sodaDocCount(coll, optionsHandle, ociMode, count, error);
-    dpiOci__handleFree(optionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl__insertMany() [INTERNAL]
-//   Insert multiple documents into the collection and return handles to the
-// newly created documents, if desired.
-//-----------------------------------------------------------------------------
-static int dpiSodaColl__insertMany(dpiSodaColl *coll, uint32_t numDocs,
-        void **docHandles, uint32_t flags, dpiSodaDoc **insertedDocs,
-        void *operOptionsHandle, dpiError *error)
-{
-    void *outputOptionsHandle;
-    uint32_t i, j, mode;
-    uint64_t docCount;
-    int status;
-
-    // create OCI output options handle
-    if (dpiOci__handleAlloc(coll->env->handle, &outputOptionsHandle,
-            DPI_OCI_HTYPE_SODA_OUTPUT_OPTIONS,
-            "allocate SODA output options handle", error) < 0)
-        return DPI_FAILURE;
-
-    // determine mode to pass
-    mode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-
-    // perform actual bulk insert
-    if (operOptionsHandle) {
-        status = dpiOci__sodaBulkInsertAndGetWithOpts(coll, docHandles,
-                numDocs, operOptionsHandle, outputOptionsHandle, mode, error);
-        dpiOci__handleFree(operOptionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
-    } else if (insertedDocs) {
-        status = dpiOci__sodaBulkInsertAndGet(coll, docHandles, numDocs,
-                outputOptionsHandle, mode, error);
-    } else {
-        status = dpiOci__sodaBulkInsert(coll, docHandles, numDocs,
-                outputOptionsHandle, mode, error);
-    }
-
-    // on failure, determine the number of documents that were successfully
-    // inserted and store that information in the error buffer
-    if (status < 0) {
-        dpiOci__attrGet(outputOptionsHandle, DPI_OCI_HTYPE_SODA_OUTPUT_OPTIONS,
-                (void*) &docCount, 0, DPI_OCI_ATTR_SODA_DOC_COUNT,
-                NULL, error);
-        error->buffer->offset = (uint32_t) docCount;
-    }
-    dpiOci__handleFree(outputOptionsHandle, DPI_OCI_HTYPE_SODA_OUTPUT_OPTIONS);
-
-    // on failure, if using the "AndGet" variant, any document handles that
-    // were created need to be freed
-    if (insertedDocs && status < 0) {
-        for (i = 0; i < numDocs; i++) {
-            if (docHandles[i]) {
-                dpiOci__handleFree(docHandles[i], DPI_OCI_HTYPE_SODA_DOCUMENT);
-                docHandles[i] = NULL;
-            }
-        }
-    }
-    if (status < 0)
-        return DPI_FAILURE;
-
-    // return document handles, if desired
-    if (insertedDocs) {
-        for (i = 0; i < numDocs; i++) {
-            if (dpiSodaDoc__allocate(coll->db, docHandles[i], &insertedDocs[i],
-                    error) < 0) {
-                for (j = 0; j < i; j++) {
-                    dpiSodaDoc__free(insertedDocs[j], error);
-                    insertedDocs[j] = NULL;
-                }
-                for (j = i; j < numDocs; j++) {
-                    dpiOci__handleFree(docHandles[i],
-                            DPI_OCI_HTYPE_SODA_DOCUMENT);
-                }
-                return DPI_FAILURE;
-            }
-        }
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl__populateOperOptions() [INTERNAL]
-//   Populate the SODA operation options handle with the information found in
-// the supplied structure.
-//-----------------------------------------------------------------------------
-static int dpiSodaColl__populateOperOptions(dpiSodaColl *coll,
-        const dpiSodaOperOptions *options, void *handle, dpiError *error)
-{
-    // set multiple keys, if applicable
-    if (options->numKeys > 0) {
-        if (dpiOci__sodaOperKeysSet(options, handle, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set single key, if applicable
-    if (options->keyLength > 0) {
-        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
-                (void*) options->key, options->keyLength,
-                DPI_OCI_ATTR_SODA_KEY, "set key", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set single version, if applicable
-    if (options->versionLength > 0) {
-        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
-                (void*) options->version, options->versionLength,
-                DPI_OCI_ATTR_SODA_VERSION, "set version", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set filter, if applicable
-    if (options->filterLength > 0) {
-        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
-                (void*) options->filter, options->filterLength,
-                DPI_OCI_ATTR_SODA_FILTER, "set filter", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set skip count, if applicable
-    if (options->skip > 0) {
-        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
-                (void*) &options->skip, 0, DPI_OCI_ATTR_SODA_SKIP,
-                "set skip count", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set limit, if applicable
-    if (options->limit > 0) {
-        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
-                (void*) &options->limit, 0, DPI_OCI_ATTR_SODA_LIMIT,
-                "set limit", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set fetch array size, if applicable (only available in 19.5+ client)
-    if (options->fetchArraySize > 0) {
-        if (dpiUtils__checkClientVersion(coll->env->versionInfo, 19, 5,
-                error) < 0)
-            return DPI_FAILURE;
-        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
-                (void*) &options->fetchArraySize, 0,
-                DPI_OCI_ATTR_SODA_FETCH_ARRAY_SIZE, "set fetch array size",
-                error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set hint, if applicable (only available in 19.11+/21.3+ client)
-    if (options->hintLength > 0) {
-        if (dpiUtils__checkClientVersionMulti(coll->env->versionInfo, 19, 11,
-                21, 3, error) < 0)
-            return DPI_FAILURE;
-        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
-                (void*) options->hint, options->hintLength,
-                DPI_OCI_ATTR_SODA_HINT, "set hint", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl__remove() [INTERNAL]
-//   Internal method for removing documents from a collection.
-//-----------------------------------------------------------------------------
-static int dpiSodaColl__remove(dpiSodaColl *coll,
-        const dpiSodaOperOptions *options, uint32_t flags, uint64_t *count,
-        dpiError *error)
-{
-    void *optionsHandle;
-    uint32_t mode;
-    int status;
-
-    // determine OCI mode to pass
-    mode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-
-    // create new OCI operation options handle
-    if (dpiSodaColl__createOperOptions(coll, options, &optionsHandle,
-            error) < 0)
-        return DPI_FAILURE;
-
-    // remove documents from collection
-    status = dpiOci__sodaRemove(coll, optionsHandle, mode, count, error);
-    dpiOci__handleFree(optionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl__replace() [INTERNAL]
-//   Internal method for replacing a document in the collection.
-//-----------------------------------------------------------------------------
-static int dpiSodaColl__replace(dpiSodaColl *coll,
-        const dpiSodaOperOptions *options, dpiSodaDoc *doc, uint32_t flags,
-        int *replaced, dpiSodaDoc **replacedDoc, dpiError *error)
-{
-    void *docHandle, *optionsHandle;
-    int status, dummyIsReplaced;
-    uint32_t mode;
-
-    // use dummy value if the replaced flag is not desired
-    if (!replaced)
-        replaced = &dummyIsReplaced;
-
-    // determine OCI mode to pass
-    mode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-
-    // create new OCI operation options handle
-    if (dpiSodaColl__createOperOptions(coll, options, &optionsHandle,
-            error) < 0)
-        return DPI_FAILURE;
-
-    // replace document in collection
-    // use "AndGet" variant if the replaced document is requested
-    docHandle = doc->handle;
-    if (!replacedDoc) {
-        status = dpiOci__sodaReplOne(coll, optionsHandle, docHandle, mode,
-                replaced, error);
-    } else {
-        *replacedDoc = NULL;
-        status = dpiOci__sodaReplOneAndGet(coll, optionsHandle, &docHandle,
-                mode, replaced, error);
-        if (status == 0 && docHandle) {
-            status = dpiSodaDoc__allocate(coll->db, docHandle, replacedDoc,
-                    error);
-            if (status < 0)
-                dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
-        }
-    }
-
-    dpiOci__handleFree(optionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl__save() [INTERNAL]
-//   Internal method for saving a document in the collection.
-//-----------------------------------------------------------------------------
-static int dpiSodaColl__save(dpiSodaColl *coll, dpiSodaDoc *doc,
-        uint32_t flags, dpiSodaDoc **savedDoc, void *optionsHandle,
-        dpiError *error)
-{
-    void *docHandle;
-    uint32_t mode;
-    int status;
-
-    // determine OCI mode to pass
-    mode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-
-    // save document in collection
-    // use "AndGet" variant if the saved document is requested
-    docHandle = doc->handle;
-    if (!savedDoc) {
-        status = dpiOci__sodaSave(coll, docHandle, mode, error);
-    } else {
-        *savedDoc = NULL;
-        if (optionsHandle) {
-            status = dpiOci__sodaSaveAndGetWithOpts(coll, &docHandle,
-                    optionsHandle, mode, error);
-            dpiOci__handleFree(optionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
-        } else {
-            status = dpiOci__sodaSaveAndGet(coll, &docHandle, mode, error);
-        }
-        if (status == 0 && docHandle) {
-            status = dpiSodaDoc__allocate(coll->db, docHandle, savedDoc,
-                    error);
-            if (status < 0)
-                dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
-        }
-    }
-
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_addRef() [PUBLIC]
-//   Add a reference to the SODA collection.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_addRef(dpiSodaColl *coll)
-{
-    return dpiGen__addRef(coll, DPI_HTYPE_SODA_COLL, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_createIndex() [PUBLIC]
-//   Create an index on the collection.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_createIndex(dpiSodaColl *coll, const char *indexSpec,
-        uint32_t indexSpecLength, uint32_t flags)
-{
-    dpiError error;
-    uint32_t mode;
-    int status;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(coll, indexSpec)
-
-    // determine mode to pass to OCI
-    mode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-
-    // create index
-    status = dpiOci__sodaIndexCreate(coll, indexSpec, indexSpecLength, mode,
-            &error);
-    return dpiGen__endPublicFn(coll, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_drop() [PUBLIC]
-//   Drop the collection.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_drop(dpiSodaColl *coll, uint32_t flags, int *isDropped)
-{
-    int status, dummyIsDropped;
-    dpiError error;
-    uint32_t mode;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-
-    // isDropped is not a mandatory parameter, but it is for OCI
-    if (!isDropped)
-        isDropped = &dummyIsDropped;
-
-    // determine mode to pass to OCI
-    mode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-
-    // drop collection
-    status = dpiOci__sodaCollDrop(coll, isDropped, mode, &error);
-    return dpiGen__endPublicFn(coll, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_dropIndex() [PUBLIC]
-//   Drop the index on the collection.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_dropIndex(dpiSodaColl *coll, const char *name,
-        uint32_t nameLength, uint32_t flags, int *isDropped)
-{
-    int status, dummyIsDropped;
-    dpiError error;
-    uint32_t mode;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(coll, name)
-
-    // isDropped is not a mandatory parameter, but it is for OCI
-    if (!isDropped)
-        isDropped = &dummyIsDropped;
-
-    // determine mode to pass to OCI
-    mode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-    if (flags & DPI_SODA_FLAGS_INDEX_DROP_FORCE)
-        mode |= DPI_OCI_SODA_INDEX_DROP_FORCE;
-
-    // drop index
-    status = dpiOci__sodaIndexDrop(coll, name, nameLength, mode, isDropped,
-            &error);
-    return dpiGen__endPublicFn(coll, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_find() [PUBLIC]
-//   Find documents in a collection and return a cursor.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_find(dpiSodaColl *coll, const dpiSodaOperOptions *options,
-        uint32_t flags, dpiSodaDocCursor **cursor)
-{
-    dpiError error;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(coll, cursor)
-
-    // perform find and return a cursor
-    if (dpiSodaColl__find(coll, options, flags, cursor, NULL, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-
-    return dpiGen__endPublicFn(coll, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_findOne() [PUBLIC]
-//   Find a single document in a collection and return it.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_findOne(dpiSodaColl *coll, const dpiSodaOperOptions *options,
-        uint32_t flags, dpiSodaDoc **doc)
-{
-    dpiError error;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(coll, doc)
-
-    // perform find and return a document
-    if (dpiSodaColl__find(coll, options, flags, NULL, doc, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-
-    return dpiGen__endPublicFn(coll, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_getDataGuide() [PUBLIC]
-//   Return the data guide document for the collection.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_getDataGuide(dpiSodaColl *coll, uint32_t flags,
-        dpiSodaDoc **doc)
-{
-    void *docHandle;
-    dpiError error;
-    uint32_t mode;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(coll, doc)
-
-    // determine mode to pass
-    mode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-
-    // get data guide
-    if (dpiOci__sodaDataGuideGet(coll, &docHandle, mode, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    if (!docHandle) {
-        *doc = NULL;
-    } else if (dpiSodaDoc__allocate(coll->db, docHandle, doc, &error) < 0) {
-        dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    }
-
-    return dpiGen__endPublicFn(coll, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_getDocCount() [PUBLIC]
-//   Return the number of documents in the collection that match the specified
-// criteria.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_getDocCount(dpiSodaColl *coll,
-        const dpiSodaOperOptions *options, uint32_t flags, uint64_t *count)
-{
-    dpiError error;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(coll, count)
-
-    // get document count
-    if (dpiSodaColl__getDocCount(coll, options, flags, count, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-
-    return dpiGen__endPublicFn(coll, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_getMetadata() [PUBLIC]
-//   Return the metadata for the collection.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_getMetadata(dpiSodaColl *coll, const char **value,
-        uint32_t *valueLength)
-{
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(coll, value)
-    DPI_CHECK_PTR_NOT_NULL(coll, valueLength)
-
-    // get attribute value
-    status = dpiOci__attrGet(coll->handle, DPI_OCI_HTYPE_SODA_COLLECTION,
-            (void*) value, valueLength, DPI_OCI_ATTR_SODA_COLL_DESCRIPTOR,
-            "get value", &error);
-    return dpiGen__endPublicFn(coll, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_getName() [PUBLIC]
-//   Return the name of the collection.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_getName(dpiSodaColl *coll, const char **value,
-        uint32_t *valueLength)
-{
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(coll, value)
-    DPI_CHECK_PTR_NOT_NULL(coll, valueLength)
-
-    // get attribute value
-    status = dpiOci__attrGet(coll->handle, DPI_OCI_HTYPE_SODA_COLLECTION,
-            (void*) value, valueLength, DPI_OCI_ATTR_SODA_COLL_NAME,
-            "get value", &error);
-    return dpiGen__endPublicFn(coll, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_insertMany() [PUBLIC]
-//   Similar to dpiSodaColl_insertManyWithOptions() but passing NULL options.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_insertMany(dpiSodaColl *coll, uint32_t numDocs,
-        dpiSodaDoc **docs, uint32_t flags, dpiSodaDoc **insertedDocs)
-{
-    return dpiSodaColl_insertManyWithOptions(coll, numDocs, docs, NULL, flags,
-            insertedDocs);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_insertManyWithOptions() [PUBLIC]
-//   Insert multiple documents into the collection and return handles to the
-// newly created documents, if desired.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_insertManyWithOptions(dpiSodaColl *coll, uint32_t numDocs,
-        dpiSodaDoc **docs, dpiSodaOperOptions *options, uint32_t flags,
-        dpiSodaDoc **insertedDocs)
-{
-    void **docHandles, *optionsHandle = NULL;
-    dpiError error;
-    uint32_t i;
-    int status;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(coll, docs)
-    if (numDocs == 0) {
-        dpiError__set(&error, "check num documents", DPI_ERR_ARRAY_SIZE_ZERO);
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    }
-    for (i = 0; i < numDocs; i++) {
-        if (dpiGen__checkHandle(docs[i], DPI_HTYPE_SODA_DOC, "check document",
-                &error) < 0)
-            return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    }
-
-    // bulk insert is only supported with Oracle Client 18.5+
-    if (dpiUtils__checkClientVersion(coll->env->versionInfo, 18, 5,
-            &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-
-    // if options specified and the newly created document is to be returned,
-    // create the operation options handle
-    if (insertedDocs && options) {
-        if (dpiUtils__checkClientVersionMulti(coll->env->versionInfo, 19, 11,
-                21, 3, &error) < 0)
-            return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-        if (dpiSodaColl__createOperOptions(coll, options, &optionsHandle,
-                &error) < 0)
-            return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    }
-
-    // create and populate array to hold document handles
-    if (dpiUtils__allocateMemory(numDocs, sizeof(void*), 1,
-            "allocate document handles", (void**) &docHandles, &error) < 0) {
-        if (optionsHandle)
-            dpiOci__handleFree(optionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    }
-    for (i = 0; i < numDocs; i++)
-        docHandles[i] = docs[i]->handle;
-
-    // perform bulk insert
-    status = dpiSodaColl__insertMany(coll, numDocs, docHandles, flags,
-            insertedDocs, optionsHandle, &error);
-    dpiUtils__freeMemory(docHandles);
-    return dpiGen__endPublicFn(coll, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_insertOne() [PUBLIC]
-//   Similar to dpiSodaColl_insertOneWithOptions() but passing NULL options.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_insertOne(dpiSodaColl *coll, dpiSodaDoc *doc, uint32_t flags,
-        dpiSodaDoc **insertedDoc)
-{
-    return dpiSodaColl_insertOneWithOptions(coll, doc, NULL, flags,
-            insertedDoc);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_insertOneWithOptions() [PUBLIC]
-//   Insert a document into the collection and return a handle to the newly
-// created document, if desired.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_insertOneWithOptions(dpiSodaColl *coll, dpiSodaDoc *doc,
-        dpiSodaOperOptions *options, uint32_t flags, dpiSodaDoc **insertedDoc)
-{
-    void *docHandle, *optionsHandle = NULL;
-    dpiError error;
-    uint32_t mode;
-    int status;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(doc, DPI_HTYPE_SODA_DOC, "check document",
-            &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-
-    // if options specified and the newly created document is to be returned,
-    // create the operation options handle
-    if (insertedDoc && options) {
-        if (dpiUtils__checkClientVersionMulti(coll->env->versionInfo, 19, 11,
-                21, 3, &error) < 0)
-            return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-        if (dpiSodaColl__createOperOptions(coll, options, &optionsHandle,
-                &error) < 0)
-            return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    }
-
-    // determine OCI mode to use
-    mode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-
-    // insert document into collection
-    // use "AndGet" variants if the inserted document is requested
-    docHandle = doc->handle;
-    if (!insertedDoc)
-        status = dpiOci__sodaInsert(coll, docHandle, mode, &error);
-    else {
-        if (options) {
-            status = dpiOci__sodaInsertAndGetWithOpts(coll, &docHandle,
-                    optionsHandle, mode, &error);
-            dpiOci__handleFree(optionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
-        } else {
-            status = dpiOci__sodaInsertAndGet(coll, &docHandle, mode, &error);
-        }
-        if (status == 0) {
-            status = dpiSodaDoc__allocate(coll->db, docHandle, insertedDoc,
-                    &error);
-            if (status < 0)
-                dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
-        }
-    }
-
-    return dpiGen__endPublicFn(coll, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_release() [PUBLIC]
-//   Release a reference to the SODA collection.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_release(dpiSodaColl *coll)
-{
-    return dpiGen__release(coll, DPI_HTYPE_SODA_COLL, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_remove() [PUBLIC]
-//   Remove the documents from the collection that match the given criteria.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_remove(dpiSodaColl *coll, const dpiSodaOperOptions *options,
-        uint32_t flags, uint64_t *count)
-{
-    dpiError error;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(coll, count)
-
-    // perform removal
-    if (dpiSodaColl__remove(coll, options, flags, count, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-
-    return dpiGen__endPublicFn(coll, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_replaceOne() [PUBLIC]
-//   Replace the first document in the collection that matches the given
-// criteria. Returns a handle to the newly replaced document, if desired.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_replaceOne(dpiSodaColl *coll,
-        const dpiSodaOperOptions *options, dpiSodaDoc *doc, uint32_t flags,
-        int *replaced, dpiSodaDoc **replacedDoc)
-{
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(doc, DPI_HTYPE_SODA_DOC, "check document",
-            &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-
-    // perform replace
-    status = dpiSodaColl__replace(coll, options, doc, flags, replaced,
-            replacedDoc, &error);
-    return dpiGen__endPublicFn(coll, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_save() [PUBLIC]
-//   Similar to dpiSodaColl_saveWithOptions() but passing NULL options.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_save(dpiSodaColl *coll, dpiSodaDoc *doc, uint32_t flags,
-        dpiSodaDoc **savedDoc)
-{
-    return dpiSodaColl_saveWithOptions(coll, doc, NULL, flags, savedDoc);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_saveWithOptions() [PUBLIC]
-//   Save the document into the collection. This method is equivalent to
-// dpiSodaColl_insertOne() except that if client-assigned keys are used, and
-// the document with the specified key already exists in the collection, it
-// will be replaced with the input document. Returns a handle to the new
-// document, if desired.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_saveWithOptions(dpiSodaColl *coll, dpiSodaDoc *doc,
-        dpiSodaOperOptions *options, uint32_t flags, dpiSodaDoc **savedDoc)
-{
-    void *optionsHandle = NULL;
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(doc, DPI_HTYPE_SODA_DOC, "check document",
-            &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-
-    // save is only supported with Oracle Client 19.9+
-    if (dpiUtils__checkClientVersion(coll->env->versionInfo, 19, 9,
-            &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-
-    // if options specified and the newly created document is to be returned,
-    // create the operation options handle
-    if (savedDoc && options) {
-        if (dpiUtils__checkClientVersionMulti(coll->env->versionInfo, 19, 11,
-                21, 3, &error) < 0)
-            return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-        if (dpiSodaColl__createOperOptions(coll, options, &optionsHandle,
-                &error) < 0)
-            return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-    }
-
-    // perform save
-    status = dpiSodaColl__save(coll, doc, flags, savedDoc, optionsHandle,
-            &error);
-    return dpiGen__endPublicFn(coll, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaColl_truncate() [PUBLIC]
-//   Remove all of the documents in the collection.
-//-----------------------------------------------------------------------------
-int dpiSodaColl_truncate(dpiSodaColl *coll)
-{
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiSodaColl__check(coll, __func__, &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-
-    // truncate is only supported with Oracle Client 20+
-    if (dpiUtils__checkClientVersion(coll->env->versionInfo, 20, 1,
-            &error) < 0)
-        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
-
-    // perform truncate
-    status = dpiOci__sodaCollTruncate(coll, &error);
-    return dpiGen__endPublicFn(coll, status, &error);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiSodaColl.h ./odpi/src/dpiSodaColl.h
--- patched-godror/odpi/src/dpiSodaColl.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiSodaColl.h	2024-05-14 14:55:13
@@ -0,0 +1,1048 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2018, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl.c
+//   Implementation of SODA collections.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+// forward declarations of internal functions only used in this file
+static int dpiSodaColl__populateOperOptions(dpiSodaColl *coll,
+        const dpiSodaOperOptions *options, void *handle, dpiError *error);
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl__allocate() [INTERNAL]
+//   Allocate and initialize a SODA collection structure.
+//-----------------------------------------------------------------------------
+int dpiSodaColl__allocate(dpiSodaDb *db, void *handle, dpiSodaColl **coll,
+        dpiError *error)
+{
+    uint8_t sqlType, contentType;
+    dpiSodaColl *tempColl;
+
+    if (dpiOci__attrGet(handle, DPI_OCI_HTYPE_SODA_COLLECTION,
+            (void*) &sqlType, 0, DPI_OCI_ATTR_SODA_CTNT_SQL_TYPE,
+            "get content sql type", error) < 0)
+        return DPI_FAILURE;
+    if (dpiGen__allocate(DPI_HTYPE_SODA_COLL, db->env, (void**) &tempColl,
+            error) < 0)
+        return DPI_FAILURE;
+    dpiGen__setRefCount(db, error, 1);
+    tempColl->db = db;
+    tempColl->handle = handle;
+    if (sqlType == DPI_SQLT_BLOB) {
+        tempColl->binaryContent = 1;
+        contentType = 0;
+        dpiOci__attrGet(handle, DPI_OCI_HTYPE_SODA_COLLECTION,
+                (void*) &contentType, 0, DPI_OCI_ATTR_SODA_CTNT_FORMAT,
+                    NULL, error);
+        if (contentType == DPI_OCI_JSON_FORMAT_OSON)
+            tempColl->binaryContent = 0;
+    }
+    *coll = tempColl;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl__check() [INTERNAL]
+//   Determine if the SODA collection is available to use.
+//-----------------------------------------------------------------------------
+static int dpiSodaColl__check(dpiSodaColl *coll, const char *fnName,
+        dpiError *error)
+{
+    if (dpiGen__startPublicFn(coll, DPI_HTYPE_SODA_COLL, fnName, error) < 0)
+        return DPI_FAILURE;
+    if (!coll->db->conn->handle || coll->db->conn->closing)
+        return dpiError__set(error, "check connection", DPI_ERR_NOT_CONNECTED);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl__createOperOptions() [INTERNAL]
+//   Create a SODA operation options handle with the specified information.
+//-----------------------------------------------------------------------------
+static int dpiSodaColl__createOperOptions(dpiSodaColl *coll,
+        const dpiSodaOperOptions *options, void **handle, dpiError *error)
+{
+    dpiSodaOperOptions localOptions;
+
+    // if no options specified, use default values
+    if (!options) {
+        dpiContext__initSodaOperOptions(&localOptions);
+        options = &localOptions;
+
+    // size changed in version 4.2; this can be removed in version 5
+    } else if (coll->env->context->dpiMinorVersion < 2) {
+        dpiContext__initSodaOperOptions(&localOptions);
+        memcpy(&localOptions, options, sizeof(dpiSodaOperOptions__v41));
+        options = &localOptions;
+    }
+
+    // allocate new handle
+    if (dpiOci__handleAlloc(coll->env->handle, handle,
+            DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
+            "allocate SODA operation options handle", error) < 0)
+        return DPI_FAILURE;
+
+    // populate handle attributes
+    if (dpiSodaColl__populateOperOptions(coll, options, *handle, error) < 0) {
+        dpiOci__handleFree(*handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
+        return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl__find() [INTERNAL]
+//   Perform a find of SODA documents by creating an operation options handle
+// and populating it with the requested options. Once the find is complete,
+// return either a cursor or a document.
+//-----------------------------------------------------------------------------
+static int dpiSodaColl__find(dpiSodaColl *coll,
+        const dpiSodaOperOptions *options, uint32_t flags,
+        dpiSodaDocCursor **cursor, dpiSodaDoc **doc, dpiError *error)
+{
+    uint32_t ociMode, returnHandleType, ociFlags;
+    void *optionsHandle, *ociReturnHandle;
+    int status;
+
+    // determine OCI mode to pass
+    ociMode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        ociMode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+
+    // create new OCI operation options handle
+    if (dpiSodaColl__createOperOptions(coll, options, &optionsHandle,
+            error) < 0)
+        return DPI_FAILURE;
+
+    // determine OCI flags to use
+    ociFlags = (coll->binaryContent) ? DPI_OCI_SODA_AS_STORED :
+            DPI_OCI_SODA_AS_AL32UTF8;
+
+    // perform actual find
+    if (cursor) {
+        *cursor = NULL;
+        status = dpiOci__sodaFind(coll, optionsHandle, ociFlags, ociMode,
+                &ociReturnHandle, error);
+    } else {
+        *doc = NULL;
+        status = dpiOci__sodaFindOne(coll, optionsHandle, ociFlags, ociMode,
+                &ociReturnHandle, error);
+    }
+    dpiOci__handleFree(optionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
+    if (status < 0)
+        return DPI_FAILURE;
+
+    // return cursor or document, as appropriate
+    if (cursor) {
+        status = dpiSodaDocCursor__allocate(coll, ociReturnHandle, cursor,
+                error);
+        returnHandleType = DPI_OCI_HTYPE_SODA_DOC_CURSOR;
+    } else if (ociReturnHandle) {
+        status = dpiSodaDoc__allocate(coll->db, ociReturnHandle, doc, error);
+        returnHandleType = DPI_OCI_HTYPE_SODA_DOCUMENT;
+    }
+    if (status < 0)
+        dpiOci__handleFree(ociReturnHandle, returnHandleType);
+
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl__free() [INTERNAL]
+//   Free the memory for a SODA collection. Note that the reference to the
+// database must remain until after the handle is freed; otherwise, a segfault
+// can take place.
+//-----------------------------------------------------------------------------
+void dpiSodaColl__free(dpiSodaColl *coll, dpiError *error)
+{
+    if (coll->handle) {
+        dpiOci__handleFree(coll->handle, DPI_OCI_HTYPE_SODA_COLLECTION);
+        coll->handle = NULL;
+    }
+    if (coll->db) {
+        dpiGen__setRefCount(coll->db, error, -1);
+        coll->db = NULL;
+    }
+    dpiUtils__freeMemory(coll);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl__getDocCount() [INTERNAL]
+//   Internal method for getting document count.
+//-----------------------------------------------------------------------------
+static int dpiSodaColl__getDocCount(dpiSodaColl *coll,
+        const dpiSodaOperOptions *options, uint32_t flags, uint64_t *count,
+        dpiError *error)
+{
+    void *optionsHandle;
+    uint32_t ociMode;
+    int status;
+
+    // determine OCI mode to pass
+    ociMode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        ociMode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+
+    // create new OCI operation options handle
+    if (dpiSodaColl__createOperOptions(coll, options, &optionsHandle,
+            error) < 0)
+        return DPI_FAILURE;
+
+    // perform actual document count
+    status = dpiOci__sodaDocCount(coll, optionsHandle, ociMode, count, error);
+    dpiOci__handleFree(optionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl__insertMany() [INTERNAL]
+//   Insert multiple documents into the collection and return handles to the
+// newly created documents, if desired.
+//-----------------------------------------------------------------------------
+static int dpiSodaColl__insertMany(dpiSodaColl *coll, uint32_t numDocs,
+        void **docHandles, uint32_t flags, dpiSodaDoc **insertedDocs,
+        void *operOptionsHandle, dpiError *error)
+{
+    void *outputOptionsHandle;
+    uint32_t i, j, mode;
+    uint64_t docCount;
+    int status;
+
+    // create OCI output options handle
+    if (dpiOci__handleAlloc(coll->env->handle, &outputOptionsHandle,
+            DPI_OCI_HTYPE_SODA_OUTPUT_OPTIONS,
+            "allocate SODA output options handle", error) < 0)
+        return DPI_FAILURE;
+
+    // determine mode to pass
+    mode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+
+    // perform actual bulk insert
+    if (operOptionsHandle) {
+        status = dpiOci__sodaBulkInsertAndGetWithOpts(coll, docHandles,
+                numDocs, operOptionsHandle, outputOptionsHandle, mode, error);
+        dpiOci__handleFree(operOptionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
+    } else if (insertedDocs) {
+        status = dpiOci__sodaBulkInsertAndGet(coll, docHandles, numDocs,
+                outputOptionsHandle, mode, error);
+    } else {
+        status = dpiOci__sodaBulkInsert(coll, docHandles, numDocs,
+                outputOptionsHandle, mode, error);
+    }
+
+    // on failure, determine the number of documents that were successfully
+    // inserted and store that information in the error buffer
+    if (status < 0) {
+        dpiOci__attrGet(outputOptionsHandle, DPI_OCI_HTYPE_SODA_OUTPUT_OPTIONS,
+                (void*) &docCount, 0, DPI_OCI_ATTR_SODA_DOC_COUNT,
+                NULL, error);
+        error->buffer->offset = (uint32_t) docCount;
+    }
+    dpiOci__handleFree(outputOptionsHandle, DPI_OCI_HTYPE_SODA_OUTPUT_OPTIONS);
+
+    // on failure, if using the "AndGet" variant, any document handles that
+    // were created need to be freed
+    if (insertedDocs && status < 0) {
+        for (i = 0; i < numDocs; i++) {
+            if (docHandles[i]) {
+                dpiOci__handleFree(docHandles[i], DPI_OCI_HTYPE_SODA_DOCUMENT);
+                docHandles[i] = NULL;
+            }
+        }
+    }
+    if (status < 0)
+        return DPI_FAILURE;
+
+    // return document handles, if desired
+    if (insertedDocs) {
+        for (i = 0; i < numDocs; i++) {
+            if (dpiSodaDoc__allocate(coll->db, docHandles[i], &insertedDocs[i],
+                    error) < 0) {
+                for (j = 0; j < i; j++) {
+                    dpiSodaDoc__free(insertedDocs[j], error);
+                    insertedDocs[j] = NULL;
+                }
+                for (j = i; j < numDocs; j++) {
+                    dpiOci__handleFree(docHandles[i],
+                            DPI_OCI_HTYPE_SODA_DOCUMENT);
+                }
+                return DPI_FAILURE;
+            }
+        }
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl__populateOperOptions() [INTERNAL]
+//   Populate the SODA operation options handle with the information found in
+// the supplied structure.
+//-----------------------------------------------------------------------------
+static int dpiSodaColl__populateOperOptions(dpiSodaColl *coll,
+        const dpiSodaOperOptions *options, void *handle, dpiError *error)
+{
+    // set multiple keys, if applicable
+    if (options->numKeys > 0) {
+        if (dpiOci__sodaOperKeysSet(options, handle, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set single key, if applicable
+    if (options->keyLength > 0) {
+        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
+                (void*) options->key, options->keyLength,
+                DPI_OCI_ATTR_SODA_KEY, "set key", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set single version, if applicable
+    if (options->versionLength > 0) {
+        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
+                (void*) options->version, options->versionLength,
+                DPI_OCI_ATTR_SODA_VERSION, "set version", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set filter, if applicable
+    if (options->filterLength > 0) {
+        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
+                (void*) options->filter, options->filterLength,
+                DPI_OCI_ATTR_SODA_FILTER, "set filter", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set skip count, if applicable
+    if (options->skip > 0) {
+        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
+                (void*) &options->skip, 0, DPI_OCI_ATTR_SODA_SKIP,
+                "set skip count", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set limit, if applicable
+    if (options->limit > 0) {
+        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
+                (void*) &options->limit, 0, DPI_OCI_ATTR_SODA_LIMIT,
+                "set limit", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set fetch array size, if applicable (only available in 19.5+ client)
+    if (options->fetchArraySize > 0) {
+        if (dpiUtils__checkClientVersion(coll->env->versionInfo, 19, 5,
+                error) < 0)
+            return DPI_FAILURE;
+        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
+                (void*) &options->fetchArraySize, 0,
+                DPI_OCI_ATTR_SODA_FETCH_ARRAY_SIZE, "set fetch array size",
+                error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set hint, if applicable (only available in 19.11+/21.3+ client)
+    if (options->hintLength > 0) {
+        if (dpiUtils__checkClientVersionMulti(coll->env->versionInfo, 19, 11,
+                21, 3, error) < 0)
+            return DPI_FAILURE;
+        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS,
+                (void*) options->hint, options->hintLength,
+                DPI_OCI_ATTR_SODA_HINT, "set hint", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl__remove() [INTERNAL]
+//   Internal method for removing documents from a collection.
+//-----------------------------------------------------------------------------
+static int dpiSodaColl__remove(dpiSodaColl *coll,
+        const dpiSodaOperOptions *options, uint32_t flags, uint64_t *count,
+        dpiError *error)
+{
+    void *optionsHandle;
+    uint32_t mode;
+    int status;
+
+    // determine OCI mode to pass
+    mode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+
+    // create new OCI operation options handle
+    if (dpiSodaColl__createOperOptions(coll, options, &optionsHandle,
+            error) < 0)
+        return DPI_FAILURE;
+
+    // remove documents from collection
+    status = dpiOci__sodaRemove(coll, optionsHandle, mode, count, error);
+    dpiOci__handleFree(optionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl__replace() [INTERNAL]
+//   Internal method for replacing a document in the collection.
+//-----------------------------------------------------------------------------
+static int dpiSodaColl__replace(dpiSodaColl *coll,
+        const dpiSodaOperOptions *options, dpiSodaDoc *doc, uint32_t flags,
+        int *replaced, dpiSodaDoc **replacedDoc, dpiError *error)
+{
+    void *docHandle, *optionsHandle;
+    int status, dummyIsReplaced;
+    uint32_t mode;
+
+    // use dummy value if the replaced flag is not desired
+    if (!replaced)
+        replaced = &dummyIsReplaced;
+
+    // determine OCI mode to pass
+    mode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+
+    // create new OCI operation options handle
+    if (dpiSodaColl__createOperOptions(coll, options, &optionsHandle,
+            error) < 0)
+        return DPI_FAILURE;
+
+    // replace document in collection
+    // use "AndGet" variant if the replaced document is requested
+    docHandle = doc->handle;
+    if (!replacedDoc) {
+        status = dpiOci__sodaReplOne(coll, optionsHandle, docHandle, mode,
+                replaced, error);
+    } else {
+        *replacedDoc = NULL;
+        status = dpiOci__sodaReplOneAndGet(coll, optionsHandle, &docHandle,
+                mode, replaced, error);
+        if (status == 0 && docHandle) {
+            status = dpiSodaDoc__allocate(coll->db, docHandle, replacedDoc,
+                    error);
+            if (status < 0)
+                dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
+        }
+    }
+
+    dpiOci__handleFree(optionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl__save() [INTERNAL]
+//   Internal method for saving a document in the collection.
+//-----------------------------------------------------------------------------
+static int dpiSodaColl__save(dpiSodaColl *coll, dpiSodaDoc *doc,
+        uint32_t flags, dpiSodaDoc **savedDoc, void *optionsHandle,
+        dpiError *error)
+{
+    void *docHandle;
+    uint32_t mode;
+    int status;
+
+    // determine OCI mode to pass
+    mode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+
+    // save document in collection
+    // use "AndGet" variant if the saved document is requested
+    docHandle = doc->handle;
+    if (!savedDoc) {
+        status = dpiOci__sodaSave(coll, docHandle, mode, error);
+    } else {
+        *savedDoc = NULL;
+        if (optionsHandle) {
+            status = dpiOci__sodaSaveAndGetWithOpts(coll, &docHandle,
+                    optionsHandle, mode, error);
+            dpiOci__handleFree(optionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
+        } else {
+            status = dpiOci__sodaSaveAndGet(coll, &docHandle, mode, error);
+        }
+        if (status == 0 && docHandle) {
+            status = dpiSodaDoc__allocate(coll->db, docHandle, savedDoc,
+                    error);
+            if (status < 0)
+                dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
+        }
+    }
+
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_addRef() [PUBLIC]
+//   Add a reference to the SODA collection.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_addRef(dpiSodaColl *coll)
+{
+    return dpiGen__addRef(coll, DPI_HTYPE_SODA_COLL, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_createIndex() [PUBLIC]
+//   Create an index on the collection.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_createIndex(dpiSodaColl *coll, const char *indexSpec,
+        uint32_t indexSpecLength, uint32_t flags)
+{
+    dpiError error;
+    uint32_t mode;
+    int status;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(coll, indexSpec)
+
+    // determine mode to pass to OCI
+    mode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+
+    // create index
+    status = dpiOci__sodaIndexCreate(coll, indexSpec, indexSpecLength, mode,
+            &error);
+    return dpiGen__endPublicFn(coll, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_drop() [PUBLIC]
+//   Drop the collection.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_drop(dpiSodaColl *coll, uint32_t flags, int *isDropped)
+{
+    int status, dummyIsDropped;
+    dpiError error;
+    uint32_t mode;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+
+    // isDropped is not a mandatory parameter, but it is for OCI
+    if (!isDropped)
+        isDropped = &dummyIsDropped;
+
+    // determine mode to pass to OCI
+    mode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+
+    // drop collection
+    status = dpiOci__sodaCollDrop(coll, isDropped, mode, &error);
+    return dpiGen__endPublicFn(coll, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_dropIndex() [PUBLIC]
+//   Drop the index on the collection.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_dropIndex(dpiSodaColl *coll, const char *name,
+        uint32_t nameLength, uint32_t flags, int *isDropped)
+{
+    int status, dummyIsDropped;
+    dpiError error;
+    uint32_t mode;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(coll, name)
+
+    // isDropped is not a mandatory parameter, but it is for OCI
+    if (!isDropped)
+        isDropped = &dummyIsDropped;
+
+    // determine mode to pass to OCI
+    mode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+    if (flags & DPI_SODA_FLAGS_INDEX_DROP_FORCE)
+        mode |= DPI_OCI_SODA_INDEX_DROP_FORCE;
+
+    // drop index
+    status = dpiOci__sodaIndexDrop(coll, name, nameLength, mode, isDropped,
+            &error);
+    return dpiGen__endPublicFn(coll, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_find() [PUBLIC]
+//   Find documents in a collection and return a cursor.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_find(dpiSodaColl *coll, const dpiSodaOperOptions *options,
+        uint32_t flags, dpiSodaDocCursor **cursor)
+{
+    dpiError error;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(coll, cursor)
+
+    // perform find and return a cursor
+    if (dpiSodaColl__find(coll, options, flags, cursor, NULL, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+
+    return dpiGen__endPublicFn(coll, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_findOne() [PUBLIC]
+//   Find a single document in a collection and return it.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_findOne(dpiSodaColl *coll, const dpiSodaOperOptions *options,
+        uint32_t flags, dpiSodaDoc **doc)
+{
+    dpiError error;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(coll, doc)
+
+    // perform find and return a document
+    if (dpiSodaColl__find(coll, options, flags, NULL, doc, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+
+    return dpiGen__endPublicFn(coll, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_getDataGuide() [PUBLIC]
+//   Return the data guide document for the collection.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_getDataGuide(dpiSodaColl *coll, uint32_t flags,
+        dpiSodaDoc **doc)
+{
+    void *docHandle;
+    dpiError error;
+    uint32_t mode;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(coll, doc)
+
+    // determine mode to pass
+    mode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+
+    // get data guide
+    if (dpiOci__sodaDataGuideGet(coll, &docHandle, mode, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    if (!docHandle) {
+        *doc = NULL;
+    } else if (dpiSodaDoc__allocate(coll->db, docHandle, doc, &error) < 0) {
+        dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    }
+
+    return dpiGen__endPublicFn(coll, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_getDocCount() [PUBLIC]
+//   Return the number of documents in the collection that match the specified
+// criteria.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_getDocCount(dpiSodaColl *coll,
+        const dpiSodaOperOptions *options, uint32_t flags, uint64_t *count)
+{
+    dpiError error;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(coll, count)
+
+    // get document count
+    if (dpiSodaColl__getDocCount(coll, options, flags, count, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+
+    return dpiGen__endPublicFn(coll, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_getMetadata() [PUBLIC]
+//   Return the metadata for the collection.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_getMetadata(dpiSodaColl *coll, const char **value,
+        uint32_t *valueLength)
+{
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(coll, value)
+    DPI_CHECK_PTR_NOT_NULL(coll, valueLength)
+
+    // get attribute value
+    status = dpiOci__attrGet(coll->handle, DPI_OCI_HTYPE_SODA_COLLECTION,
+            (void*) value, valueLength, DPI_OCI_ATTR_SODA_COLL_DESCRIPTOR,
+            "get value", &error);
+    return dpiGen__endPublicFn(coll, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_getName() [PUBLIC]
+//   Return the name of the collection.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_getName(dpiSodaColl *coll, const char **value,
+        uint32_t *valueLength)
+{
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(coll, value)
+    DPI_CHECK_PTR_NOT_NULL(coll, valueLength)
+
+    // get attribute value
+    status = dpiOci__attrGet(coll->handle, DPI_OCI_HTYPE_SODA_COLLECTION,
+            (void*) value, valueLength, DPI_OCI_ATTR_SODA_COLL_NAME,
+            "get value", &error);
+    return dpiGen__endPublicFn(coll, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_insertMany() [PUBLIC]
+//   Similar to dpiSodaColl_insertManyWithOptions() but passing NULL options.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_insertMany(dpiSodaColl *coll, uint32_t numDocs,
+        dpiSodaDoc **docs, uint32_t flags, dpiSodaDoc **insertedDocs)
+{
+    return dpiSodaColl_insertManyWithOptions(coll, numDocs, docs, NULL, flags,
+            insertedDocs);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_insertManyWithOptions() [PUBLIC]
+//   Insert multiple documents into the collection and return handles to the
+// newly created documents, if desired.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_insertManyWithOptions(dpiSodaColl *coll, uint32_t numDocs,
+        dpiSodaDoc **docs, dpiSodaOperOptions *options, uint32_t flags,
+        dpiSodaDoc **insertedDocs)
+{
+    void **docHandles, *optionsHandle = NULL;
+    dpiError error;
+    uint32_t i;
+    int status;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(coll, docs)
+    if (numDocs == 0) {
+        dpiError__set(&error, "check num documents", DPI_ERR_ARRAY_SIZE_ZERO);
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    }
+    for (i = 0; i < numDocs; i++) {
+        if (dpiGen__checkHandle(docs[i], DPI_HTYPE_SODA_DOC, "check document",
+                &error) < 0)
+            return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    }
+
+    // bulk insert is only supported with Oracle Client 18.5+
+    if (dpiUtils__checkClientVersion(coll->env->versionInfo, 18, 5,
+            &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+
+    // if options specified and the newly created document is to be returned,
+    // create the operation options handle
+    if (insertedDocs && options) {
+        if (dpiUtils__checkClientVersionMulti(coll->env->versionInfo, 19, 11,
+                21, 3, &error) < 0)
+            return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+        if (dpiSodaColl__createOperOptions(coll, options, &optionsHandle,
+                &error) < 0)
+            return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    }
+
+    // create and populate array to hold document handles
+    if (dpiUtils__allocateMemory(numDocs, sizeof(void*), 1,
+            "allocate document handles", (void**) &docHandles, &error) < 0) {
+        if (optionsHandle)
+            dpiOci__handleFree(optionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    }
+    for (i = 0; i < numDocs; i++)
+        docHandles[i] = docs[i]->handle;
+
+    // perform bulk insert
+    status = dpiSodaColl__insertMany(coll, numDocs, docHandles, flags,
+            insertedDocs, optionsHandle, &error);
+    dpiUtils__freeMemory(docHandles);
+    return dpiGen__endPublicFn(coll, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_insertOne() [PUBLIC]
+//   Similar to dpiSodaColl_insertOneWithOptions() but passing NULL options.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_insertOne(dpiSodaColl *coll, dpiSodaDoc *doc, uint32_t flags,
+        dpiSodaDoc **insertedDoc)
+{
+    return dpiSodaColl_insertOneWithOptions(coll, doc, NULL, flags,
+            insertedDoc);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_insertOneWithOptions() [PUBLIC]
+//   Insert a document into the collection and return a handle to the newly
+// created document, if desired.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_insertOneWithOptions(dpiSodaColl *coll, dpiSodaDoc *doc,
+        dpiSodaOperOptions *options, uint32_t flags, dpiSodaDoc **insertedDoc)
+{
+    void *docHandle, *optionsHandle = NULL;
+    dpiError error;
+    uint32_t mode;
+    int status;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(doc, DPI_HTYPE_SODA_DOC, "check document",
+            &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+
+    // if options specified and the newly created document is to be returned,
+    // create the operation options handle
+    if (insertedDoc && options) {
+        if (dpiUtils__checkClientVersionMulti(coll->env->versionInfo, 19, 11,
+                21, 3, &error) < 0)
+            return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+        if (dpiSodaColl__createOperOptions(coll, options, &optionsHandle,
+                &error) < 0)
+            return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    }
+
+    // determine OCI mode to use
+    mode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+
+    // insert document into collection
+    // use "AndGet" variants if the inserted document is requested
+    docHandle = doc->handle;
+    if (!insertedDoc)
+        status = dpiOci__sodaInsert(coll, docHandle, mode, &error);
+    else {
+        if (options) {
+            status = dpiOci__sodaInsertAndGetWithOpts(coll, &docHandle,
+                    optionsHandle, mode, &error);
+            dpiOci__handleFree(optionsHandle, DPI_OCI_HTYPE_SODA_OPER_OPTIONS);
+        } else {
+            status = dpiOci__sodaInsertAndGet(coll, &docHandle, mode, &error);
+        }
+        if (status == 0) {
+            status = dpiSodaDoc__allocate(coll->db, docHandle, insertedDoc,
+                    &error);
+            if (status < 0)
+                dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
+        }
+    }
+
+    return dpiGen__endPublicFn(coll, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_release() [PUBLIC]
+//   Release a reference to the SODA collection.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_release(dpiSodaColl *coll)
+{
+    return dpiGen__release(coll, DPI_HTYPE_SODA_COLL, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_remove() [PUBLIC]
+//   Remove the documents from the collection that match the given criteria.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_remove(dpiSodaColl *coll, const dpiSodaOperOptions *options,
+        uint32_t flags, uint64_t *count)
+{
+    dpiError error;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(coll, count)
+
+    // perform removal
+    if (dpiSodaColl__remove(coll, options, flags, count, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+
+    return dpiGen__endPublicFn(coll, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_replaceOne() [PUBLIC]
+//   Replace the first document in the collection that matches the given
+// criteria. Returns a handle to the newly replaced document, if desired.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_replaceOne(dpiSodaColl *coll,
+        const dpiSodaOperOptions *options, dpiSodaDoc *doc, uint32_t flags,
+        int *replaced, dpiSodaDoc **replacedDoc)
+{
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(doc, DPI_HTYPE_SODA_DOC, "check document",
+            &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+
+    // perform replace
+    status = dpiSodaColl__replace(coll, options, doc, flags, replaced,
+            replacedDoc, &error);
+    return dpiGen__endPublicFn(coll, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_save() [PUBLIC]
+//   Similar to dpiSodaColl_saveWithOptions() but passing NULL options.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_save(dpiSodaColl *coll, dpiSodaDoc *doc, uint32_t flags,
+        dpiSodaDoc **savedDoc)
+{
+    return dpiSodaColl_saveWithOptions(coll, doc, NULL, flags, savedDoc);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_saveWithOptions() [PUBLIC]
+//   Save the document into the collection. This method is equivalent to
+// dpiSodaColl_insertOne() except that if client-assigned keys are used, and
+// the document with the specified key already exists in the collection, it
+// will be replaced with the input document. Returns a handle to the new
+// document, if desired.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_saveWithOptions(dpiSodaColl *coll, dpiSodaDoc *doc,
+        dpiSodaOperOptions *options, uint32_t flags, dpiSodaDoc **savedDoc)
+{
+    void *optionsHandle = NULL;
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(doc, DPI_HTYPE_SODA_DOC, "check document",
+            &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+
+    // save is only supported with Oracle Client 19.9+
+    if (dpiUtils__checkClientVersion(coll->env->versionInfo, 19, 9,
+            &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+
+    // if options specified and the newly created document is to be returned,
+    // create the operation options handle
+    if (savedDoc && options) {
+        if (dpiUtils__checkClientVersionMulti(coll->env->versionInfo, 19, 11,
+                21, 3, &error) < 0)
+            return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+        if (dpiSodaColl__createOperOptions(coll, options, &optionsHandle,
+                &error) < 0)
+            return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+    }
+
+    // perform save
+    status = dpiSodaColl__save(coll, doc, flags, savedDoc, optionsHandle,
+            &error);
+    return dpiGen__endPublicFn(coll, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaColl_truncate() [PUBLIC]
+//   Remove all of the documents in the collection.
+//-----------------------------------------------------------------------------
+int dpiSodaColl_truncate(dpiSodaColl *coll)
+{
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiSodaColl__check(coll, __func__, &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+
+    // truncate is only supported with Oracle Client 20+
+    if (dpiUtils__checkClientVersion(coll->env->versionInfo, 20, 1,
+            &error) < 0)
+        return dpiGen__endPublicFn(coll, DPI_FAILURE, &error);
+
+    // perform truncate
+    status = dpiOci__sodaCollTruncate(coll, &error);
+    return dpiGen__endPublicFn(coll, status, &error);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiSodaCollCursor.c ./odpi/src/dpiSodaCollCursor.c
--- patched-godror/odpi/src/dpiSodaCollCursor.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiSodaCollCursor.c	1970-01-01 01:00:00
@@ -1,153 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2018, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiSodaCollCursor.c
-//   Implementation of SODA collection cursors.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiSodaCollCursor__allocate() [INTERNAL]
-//   Allocate and initialize a SODA collection cursor structure.
-//-----------------------------------------------------------------------------
-int dpiSodaCollCursor__allocate(dpiSodaDb *db, void *handle,
-        dpiSodaCollCursor **cursor, dpiError *error)
-{
-    dpiSodaCollCursor *tempCursor;
-
-    if (dpiGen__allocate(DPI_HTYPE_SODA_COLL_CURSOR, db->env,
-            (void**) &tempCursor, error) < 0)
-        return DPI_FAILURE;
-    dpiGen__setRefCount(db, error, 1);
-    tempCursor->db = db;
-    tempCursor->handle = handle;
-    *cursor = tempCursor;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaCollCursor__check() [INTERNAL]
-//   Determine if the SODA collection cursor is available to use.
-//-----------------------------------------------------------------------------
-static int dpiSodaCollCursor__check(dpiSodaCollCursor *cursor,
-        const char *fnName, dpiError *error)
-{
-    if (dpiGen__startPublicFn(cursor, DPI_HTYPE_SODA_COLL_CURSOR, fnName,
-            error) < 0)
-        return DPI_FAILURE;
-    if (!cursor->handle)
-        return dpiError__set(error, "check closed",
-                DPI_ERR_SODA_CURSOR_CLOSED);
-    if (!cursor->db->conn->handle || cursor->db->conn->closing)
-        return dpiError__set(error, "check connection", DPI_ERR_NOT_CONNECTED);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaCollCursor__free() [INTERNAL]
-//   Free the memory for a SODA collection cursor. Note that the reference to
-//   the database must remain until after the handle is freed; otherwise, a
-//   segfault can take place.
-//-----------------------------------------------------------------------------
-void dpiSodaCollCursor__free(dpiSodaCollCursor *cursor, dpiError *error)
-{
-    if (cursor->handle) {
-        dpiOci__handleFree(cursor->handle, DPI_OCI_HTYPE_SODA_COLL_CURSOR);
-        cursor->handle = NULL;
-    }
-    if (cursor->db) {
-        dpiGen__setRefCount(cursor->db, error, -1);
-        cursor->db = NULL;
-    }
-    dpiUtils__freeMemory(cursor);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaCollCursor_addRef() [PUBLIC]
-//   Add a reference to the SODA collection cursor.
-//-----------------------------------------------------------------------------
-int dpiSodaCollCursor_addRef(dpiSodaCollCursor *cursor)
-{
-    return dpiGen__addRef(cursor, DPI_HTYPE_SODA_COLL_CURSOR, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaCollCursor_close() [PUBLIC]
-//   Close the cursor.
-//-----------------------------------------------------------------------------
-int dpiSodaCollCursor_close(dpiSodaCollCursor *cursor)
-{
-    dpiError error;
-
-    if (dpiSodaCollCursor__check(cursor, __func__, &error) < 0)
-        return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
-    if (cursor->handle) {
-        dpiOci__handleFree(cursor->handle, DPI_OCI_HTYPE_SODA_COLL_CURSOR);
-        cursor->handle = NULL;
-    }
-    return dpiGen__endPublicFn(cursor, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaCollCursor_getNext() [PUBLIC]
-//   Return the next collection available from the cursor.
-//-----------------------------------------------------------------------------
-int dpiSodaCollCursor_getNext(dpiSodaCollCursor *cursor, UNUSED uint32_t flags,
-        dpiSodaColl **coll)
-{
-    dpiError error;
-    void *handle;
-
-    if (dpiSodaCollCursor__check(cursor, __func__, &error) < 0)
-        return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(cursor, coll)
-    if (dpiOci__sodaCollGetNext(cursor->db->conn, cursor->handle, &handle,
-            &error) < 0)
-        return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
-    *coll = NULL;
-    if (handle) {
-        if (dpiSodaColl__allocate(cursor->db, handle, coll, &error) < 0) {
-            dpiOci__handleFree(handle, DPI_OCI_HTYPE_SODA_COLLECTION);
-            return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
-        }
-    }
-    return dpiGen__endPublicFn(cursor, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaCollCursor_release() [PUBLIC]
-//   Release a reference to the SODA collection cursor.
-//-----------------------------------------------------------------------------
-int dpiSodaCollCursor_release(dpiSodaCollCursor *cursor)
-{
-    return dpiGen__release(cursor, DPI_HTYPE_SODA_COLL_CURSOR, __func__);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiSodaCollCursor.h ./odpi/src/dpiSodaCollCursor.h
--- patched-godror/odpi/src/dpiSodaCollCursor.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiSodaCollCursor.h	2024-05-14 14:55:13
@@ -0,0 +1,153 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2018, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiSodaCollCursor.c
+//   Implementation of SODA collection cursors.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiSodaCollCursor__allocate() [INTERNAL]
+//   Allocate and initialize a SODA collection cursor structure.
+//-----------------------------------------------------------------------------
+int dpiSodaCollCursor__allocate(dpiSodaDb *db, void *handle,
+        dpiSodaCollCursor **cursor, dpiError *error)
+{
+    dpiSodaCollCursor *tempCursor;
+
+    if (dpiGen__allocate(DPI_HTYPE_SODA_COLL_CURSOR, db->env,
+            (void**) &tempCursor, error) < 0)
+        return DPI_FAILURE;
+    dpiGen__setRefCount(db, error, 1);
+    tempCursor->db = db;
+    tempCursor->handle = handle;
+    *cursor = tempCursor;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaCollCursor__check() [INTERNAL]
+//   Determine if the SODA collection cursor is available to use.
+//-----------------------------------------------------------------------------
+static int dpiSodaCollCursor__check(dpiSodaCollCursor *cursor,
+        const char *fnName, dpiError *error)
+{
+    if (dpiGen__startPublicFn(cursor, DPI_HTYPE_SODA_COLL_CURSOR, fnName,
+            error) < 0)
+        return DPI_FAILURE;
+    if (!cursor->handle)
+        return dpiError__set(error, "check closed",
+                DPI_ERR_SODA_CURSOR_CLOSED);
+    if (!cursor->db->conn->handle || cursor->db->conn->closing)
+        return dpiError__set(error, "check connection", DPI_ERR_NOT_CONNECTED);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaCollCursor__free() [INTERNAL]
+//   Free the memory for a SODA collection cursor. Note that the reference to
+//   the database must remain until after the handle is freed; otherwise, a
+//   segfault can take place.
+//-----------------------------------------------------------------------------
+void dpiSodaCollCursor__free(dpiSodaCollCursor *cursor, dpiError *error)
+{
+    if (cursor->handle) {
+        dpiOci__handleFree(cursor->handle, DPI_OCI_HTYPE_SODA_COLL_CURSOR);
+        cursor->handle = NULL;
+    }
+    if (cursor->db) {
+        dpiGen__setRefCount(cursor->db, error, -1);
+        cursor->db = NULL;
+    }
+    dpiUtils__freeMemory(cursor);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaCollCursor_addRef() [PUBLIC]
+//   Add a reference to the SODA collection cursor.
+//-----------------------------------------------------------------------------
+int dpiSodaCollCursor_addRef(dpiSodaCollCursor *cursor)
+{
+    return dpiGen__addRef(cursor, DPI_HTYPE_SODA_COLL_CURSOR, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaCollCursor_close() [PUBLIC]
+//   Close the cursor.
+//-----------------------------------------------------------------------------
+int dpiSodaCollCursor_close(dpiSodaCollCursor *cursor)
+{
+    dpiError error;
+
+    if (dpiSodaCollCursor__check(cursor, __func__, &error) < 0)
+        return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
+    if (cursor->handle) {
+        dpiOci__handleFree(cursor->handle, DPI_OCI_HTYPE_SODA_COLL_CURSOR);
+        cursor->handle = NULL;
+    }
+    return dpiGen__endPublicFn(cursor, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaCollCursor_getNext() [PUBLIC]
+//   Return the next collection available from the cursor.
+//-----------------------------------------------------------------------------
+int dpiSodaCollCursor_getNext(dpiSodaCollCursor *cursor, UNUSED uint32_t flags,
+        dpiSodaColl **coll)
+{
+    dpiError error;
+    void *handle;
+
+    if (dpiSodaCollCursor__check(cursor, __func__, &error) < 0)
+        return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(cursor, coll)
+    if (dpiOci__sodaCollGetNext(cursor->db->conn, cursor->handle, &handle,
+            &error) < 0)
+        return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
+    *coll = NULL;
+    if (handle) {
+        if (dpiSodaColl__allocate(cursor->db, handle, coll, &error) < 0) {
+            dpiOci__handleFree(handle, DPI_OCI_HTYPE_SODA_COLLECTION);
+            return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
+        }
+    }
+    return dpiGen__endPublicFn(cursor, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaCollCursor_release() [PUBLIC]
+//   Release a reference to the SODA collection cursor.
+//-----------------------------------------------------------------------------
+int dpiSodaCollCursor_release(dpiSodaCollCursor *cursor)
+{
+    return dpiGen__release(cursor, DPI_HTYPE_SODA_COLL_CURSOR, __func__);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiSodaDb.c ./odpi/src/dpiSodaDb.c
--- patched-godror/odpi/src/dpiSodaDb.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiSodaDb.c	1970-01-01 01:00:00
@@ -1,444 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2018, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiSodaDb.c
-//   Implementation of SODA database methods.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiSodaDb__checkConnected() [INTERNAL]
-//   Check to see that the connection to the database is available for use.
-//-----------------------------------------------------------------------------
-static int dpiSodaDb__checkConnected(dpiSodaDb *db, const char *fnName,
-        dpiError *error)
-{
-    if (dpiGen__startPublicFn(db, DPI_HTYPE_SODA_DB, fnName, error) < 0)
-        return DPI_FAILURE;
-    if (!db->conn->handle || db->conn->closing)
-        return dpiError__set(error, "check connection", DPI_ERR_NOT_CONNECTED);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDb__getCollectionNames() [PUBLIC]
-//   Internal method used for getting all collection names from the database.
-// The provided cursor handle is iterated until either the limit is reached
-// or there are no more collections to find.
-//-----------------------------------------------------------------------------
-static int dpiSodaDb__getCollectionNames(dpiSodaDb *db, void *cursorHandle,
-        uint32_t limit, dpiSodaCollNames *names, char **namesBuffer,
-        dpiError *error)
-{
-    uint32_t numAllocatedNames, namesBufferUsed, namesBufferAllocated;
-    uint32_t i, nameLength, *tempNameLengths;
-    char *name, *tempNamesBuffer, *ptr;
-    void *collectionHandle;
-
-    ptr = *namesBuffer;
-    namesBufferUsed = namesBufferAllocated = numAllocatedNames = 0;
-    while (names->numNames < limit || limit == 0) {
-
-        // get next collection from cursor
-        if (dpiOci__sodaCollGetNext(db->conn, cursorHandle, &collectionHandle,
-                error) < 0)
-            return DPI_FAILURE;
-        if (!collectionHandle)
-            break;
-
-        // get name from collection
-        if (dpiOci__attrGet(collectionHandle, DPI_OCI_HTYPE_SODA_COLLECTION,
-                (void*) &name, &nameLength, DPI_OCI_ATTR_SODA_COLL_NAME,
-                "get collection name", error) < 0) {
-            dpiOci__handleFree(collectionHandle,
-                    DPI_OCI_HTYPE_SODA_COLLECTION);
-            return DPI_FAILURE;
-        }
-
-        // allocate additional space for the lengths array, if needed
-        if (numAllocatedNames <= names->numNames) {
-            numAllocatedNames += 256;
-            if (dpiUtils__allocateMemory(numAllocatedNames, sizeof(uint32_t),
-                    0, "allocate lengths array", (void**) &tempNameLengths,
-                    error) < 0) {
-                dpiOci__handleFree(collectionHandle,
-                        DPI_OCI_HTYPE_SODA_COLLECTION);
-                return DPI_FAILURE;
-            }
-            if (names->nameLengths) {
-                memcpy(tempNameLengths, names->nameLengths,
-                        names->numNames * sizeof(uint32_t));
-                dpiUtils__freeMemory(names->nameLengths);
-            }
-            names->nameLengths = tempNameLengths;
-        }
-
-        // allocate additional space for the names buffer, if needed
-        if (namesBufferUsed + nameLength > namesBufferAllocated) {
-            namesBufferAllocated += 32768;
-            if (dpiUtils__allocateMemory(namesBufferAllocated, 1, 0,
-                    "allocate names buffer", (void**) &tempNamesBuffer,
-                    error) < 0) {
-                dpiOci__handleFree(collectionHandle,
-                        DPI_OCI_HTYPE_SODA_COLLECTION);
-                return DPI_FAILURE;
-            }
-            if (*namesBuffer) {
-                memcpy(tempNamesBuffer, *namesBuffer, namesBufferUsed);
-                dpiUtils__freeMemory(*namesBuffer);
-            }
-            *namesBuffer = tempNamesBuffer;
-            ptr = *namesBuffer + namesBufferUsed;
-        }
-
-        // store name in buffer and length in array
-        // the names array itself is created and populated afterwards in order
-        // to avoid unnecessary copying
-        memcpy(ptr, name, nameLength);
-        namesBufferUsed += nameLength;
-        names->nameLengths[names->numNames] = nameLength;
-        names->numNames++;
-        ptr += nameLength;
-
-        // free collection now that we have processed it successfully
-        dpiOci__handleFree(collectionHandle, DPI_OCI_HTYPE_SODA_COLLECTION);
-
-    }
-
-    // now that all of the names have been determined, populate names array
-    if (names->numNames > 0) {
-        if (dpiUtils__allocateMemory(names->numNames, sizeof(char*), 0,
-                "allocate names array", (void**) &names->names, error) < 0)
-            return DPI_FAILURE;
-        ptr = *namesBuffer;
-        for (i = 0; i < names->numNames; i++) {
-            names->names[i] = ptr;
-            ptr += names->nameLengths[i];
-        }
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDb__free() [INTERNAL]
-//   Free the memory for a SODA database.
-//-----------------------------------------------------------------------------
-void dpiSodaDb__free(dpiSodaDb *db, dpiError *error)
-{
-    if (db->conn) {
-        dpiGen__setRefCount(db->conn, error, -1);
-        db->conn = NULL;
-    }
-    dpiUtils__freeMemory(db);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDb_addRef() [PUBLIC]
-//   Add a reference to the SODA database.
-//-----------------------------------------------------------------------------
-int dpiSodaDb_addRef(dpiSodaDb *db)
-{
-    return dpiGen__addRef(db, DPI_HTYPE_SODA_DB, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDb_createCollection() [PUBLIC]
-//   Create a new SODA collection with the given name and metadata.
-//-----------------------------------------------------------------------------
-int dpiSodaDb_createCollection(dpiSodaDb *db, const char *name,
-        uint32_t nameLength, const char *metadata, uint32_t metadataLength,
-        uint32_t flags, dpiSodaColl **coll)
-{
-    dpiError error;
-    uint32_t mode;
-    void *handle;
-
-    // validate parameters
-    if (dpiSodaDb__checkConnected(db, __func__, &error) < 0)
-        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(db, name)
-    DPI_CHECK_PTR_AND_LENGTH(db, metadata)
-    DPI_CHECK_PTR_NOT_NULL(db, coll)
-
-    // determine OCI mode to use
-    mode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-    if (flags & DPI_SODA_FLAGS_CREATE_COLL_MAP)
-        mode |= DPI_OCI_SODA_COLL_CREATE_MAP;
-
-    // create collection
-    if (dpiOci__sodaCollCreateWithMetadata(db, name, nameLength, metadata,
-            metadataLength, mode, &handle, &error) < 0)
-        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-    if (dpiSodaColl__allocate(db, handle, coll, &error) < 0) {
-        dpiOci__handleFree(handle, DPI_OCI_HTYPE_SODA_COLLECTION);
-        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-    }
-    return dpiGen__endPublicFn(db, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDb_createDocument() [PUBLIC]
-//   Create a SODA document that can be inserted in the collection or can be
-// used to replace an existing document in the collection.
-//-----------------------------------------------------------------------------
-int dpiSodaDb_createDocument(dpiSodaDb *db, const char *key,
-        uint32_t keyLength, const char *content, uint32_t contentLength,
-        const char *mediaType, uint32_t mediaTypeLength, UNUSED uint32_t flags,
-        dpiSodaDoc **doc)
-{
-    int detectEncoding;
-    void *docHandle;
-    dpiError error;
-
-    // validate parameters
-    if (dpiSodaDb__checkConnected(db, __func__, &error) < 0)
-        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(db, key)
-    DPI_CHECK_PTR_AND_LENGTH(db, content)
-    DPI_CHECK_PTR_AND_LENGTH(db, mediaType)
-    DPI_CHECK_PTR_NOT_NULL(db, doc)
-
-    // allocate SODA document handle
-    if (dpiOci__handleAlloc(db->env->handle, &docHandle,
-            DPI_OCI_HTYPE_SODA_DOCUMENT, "allocate SODA document handle",
-            &error) < 0)
-        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-
-    // set key, if applicable
-    if (key && keyLength > 0) {
-        if (dpiOci__attrSet(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT,
-                (void*) key, keyLength, DPI_OCI_ATTR_SODA_KEY, "set key",
-                &error) < 0) {
-            dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
-            return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-        }
-    }
-
-    // set content, if applicable
-    if (content && contentLength > 0) {
-        detectEncoding = 1;
-        if (dpiOci__attrSet(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT,
-                (void*) &detectEncoding, 0, DPI_OCI_ATTR_SODA_DETECT_JSON_ENC,
-                "set detect encoding", &error) < 0) {
-            dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
-            return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-        }
-        if (dpiOci__attrSet(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT,
-                (void*) content, contentLength, DPI_OCI_ATTR_SODA_CONTENT,
-                "set content", &error) < 0) {
-            dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
-            return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-        }
-    }
-
-    // set media type, if applicable
-    if (mediaType && mediaTypeLength > 0) {
-        if (dpiOci__attrSet(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT,
-                (void*) mediaType, mediaTypeLength,
-                DPI_OCI_ATTR_SODA_MEDIA_TYPE, "set media type", &error) < 0) {
-            dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
-            return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-        }
-    }
-
-    // allocate the ODPI-C document that will be returned
-    if (dpiSodaDoc__allocate(db, docHandle, doc, &error) < 0) {
-        dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
-        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-    }
-    (*doc)->binaryContent = 1;
-
-    return dpiGen__endPublicFn(db, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDb_freeCollectionNames() [PUBLIC]
-//   Free the names of the collections allocated earlier with a call to
-// dpiSodaDb_getCollectionNames().
-//-----------------------------------------------------------------------------
-int dpiSodaDb_freeCollectionNames(dpiSodaDb *db, dpiSodaCollNames *names)
-{
-    dpiError error;
-
-    // validate parameters
-    if (dpiSodaDb__checkConnected(db, __func__, &error) < 0)
-        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(db, names)
-
-    // perform frees; note that the memory for the names themselves is stored
-    // in one contiguous block pointed to by the first name
-    if (names->names) {
-        dpiUtils__freeMemory((void*) names->names[0]);
-        dpiUtils__freeMemory((void*) names->names);
-        names->names = NULL;
-    }
-    if (names->nameLengths) {
-        dpiUtils__freeMemory(names->nameLengths);
-        names->nameLengths = NULL;
-    }
-    names->numNames = 0;
-
-    return dpiGen__endPublicFn(db, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDb_getCollections() [PUBLIC]
-//   Return a cursor to iterate over the SODA collections in the database.
-//-----------------------------------------------------------------------------
-int dpiSodaDb_getCollections(dpiSodaDb *db, const char *startName,
-        uint32_t startNameLength, uint32_t flags, dpiSodaCollCursor **cursor)
-{
-    dpiError error;
-    uint32_t mode;
-    void *handle;
-
-    if (dpiSodaDb__checkConnected(db, __func__, &error) < 0)
-        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(db, startName)
-    DPI_CHECK_PTR_NOT_NULL(db, cursor)
-    mode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-    if (dpiOci__sodaCollList(db, startName, startNameLength, &handle, mode,
-            &error) < 0)
-        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-    if (dpiSodaCollCursor__allocate(db, handle, cursor, &error) < 0) {
-        dpiOci__handleFree(handle, DPI_OCI_HTYPE_SODA_COLL_CURSOR);
-        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-    }
-    return dpiGen__endPublicFn(db, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDb_getCollectionNames() [PUBLIC]
-//   Return the names of all collections in the provided array.
-//-----------------------------------------------------------------------------
-int dpiSodaDb_getCollectionNames(dpiSodaDb *db, const char *startName,
-        uint32_t startNameLength, uint32_t limit, uint32_t flags,
-        dpiSodaCollNames *names)
-{
-    char *namesBuffer;
-    dpiError error;
-    uint32_t mode;
-    void *handle;
-    int status;
-
-    // validate parameters
-    if (dpiSodaDb__checkConnected(db, __func__, &error) < 0)
-        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(db, startName)
-    DPI_CHECK_PTR_NOT_NULL(db, names)
-
-    // initialize output structure
-    names->numNames = 0;
-    names->names = NULL;
-    names->nameLengths = NULL;
-
-    // determine OCI mode to use
-    mode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-
-    // acquire collection cursor
-    if (dpiOci__sodaCollList(db, startName, startNameLength, &handle, mode,
-            &error) < 0)
-        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-
-    // iterate over cursor to acquire collection names
-    namesBuffer = NULL;
-    status = dpiSodaDb__getCollectionNames(db, handle, limit, names,
-            &namesBuffer, &error);
-    dpiOci__handleFree(handle, DPI_OCI_HTYPE_SODA_COLL_CURSOR);
-    if (status < 0) {
-        names->numNames = 0;
-        if (namesBuffer) {
-            dpiUtils__freeMemory(namesBuffer);
-            namesBuffer = NULL;
-        }
-        if (names->names) {
-            dpiUtils__freeMemory((void*) names->names);
-            names->names = NULL;
-        }
-        if (names->nameLengths) {
-            dpiUtils__freeMemory(names->nameLengths);
-            names->nameLengths = NULL;
-        }
-    }
-    return dpiGen__endPublicFn(db, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDb_openCollection() [PUBLIC]
-//   Open an existing SODA collection and return a handle to it.
-//-----------------------------------------------------------------------------
-int dpiSodaDb_openCollection(dpiSodaDb *db, const char *name,
-        uint32_t nameLength, uint32_t flags, dpiSodaColl **coll)
-{
-    dpiError error;
-    uint32_t mode;
-    void *handle;
-
-    if (dpiSodaDb__checkConnected(db, __func__, &error) < 0)
-        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(db, name)
-    DPI_CHECK_PTR_NOT_NULL(db, coll)
-    mode = DPI_OCI_DEFAULT;
-    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
-        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
-    if (dpiOci__sodaCollOpen(db, name, nameLength, mode, &handle,
-            &error) < 0)
-        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-    *coll = NULL;
-    if (handle) {
-        if (dpiSodaColl__allocate(db, handle, coll, &error) < 0) {
-            dpiOci__handleFree(handle, DPI_OCI_HTYPE_SODA_COLLECTION);
-            return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
-        }
-    }
-    return dpiGen__endPublicFn(db, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDb_release() [PUBLIC]
-//   Release a reference to the SODA database.
-//-----------------------------------------------------------------------------
-int dpiSodaDb_release(dpiSodaDb *db)
-{
-    return dpiGen__release(db, DPI_HTYPE_SODA_DB, __func__);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiSodaDb.h ./odpi/src/dpiSodaDb.h
--- patched-godror/odpi/src/dpiSodaDb.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiSodaDb.h	2024-05-14 14:55:13
@@ -0,0 +1,444 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2018, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiSodaDb.c
+//   Implementation of SODA database methods.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiSodaDb__checkConnected() [INTERNAL]
+//   Check to see that the connection to the database is available for use.
+//-----------------------------------------------------------------------------
+static int dpiSodaDb__checkConnected(dpiSodaDb *db, const char *fnName,
+        dpiError *error)
+{
+    if (dpiGen__startPublicFn(db, DPI_HTYPE_SODA_DB, fnName, error) < 0)
+        return DPI_FAILURE;
+    if (!db->conn->handle || db->conn->closing)
+        return dpiError__set(error, "check connection", DPI_ERR_NOT_CONNECTED);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDb__getCollectionNames() [PUBLIC]
+//   Internal method used for getting all collection names from the database.
+// The provided cursor handle is iterated until either the limit is reached
+// or there are no more collections to find.
+//-----------------------------------------------------------------------------
+static int dpiSodaDb__getCollectionNames(dpiSodaDb *db, void *cursorHandle,
+        uint32_t limit, dpiSodaCollNames *names, char **namesBuffer,
+        dpiError *error)
+{
+    uint32_t numAllocatedNames, namesBufferUsed, namesBufferAllocated;
+    uint32_t i, nameLength, *tempNameLengths;
+    char *name, *tempNamesBuffer, *ptr;
+    void *collectionHandle;
+
+    ptr = *namesBuffer;
+    namesBufferUsed = namesBufferAllocated = numAllocatedNames = 0;
+    while (names->numNames < limit || limit == 0) {
+
+        // get next collection from cursor
+        if (dpiOci__sodaCollGetNext(db->conn, cursorHandle, &collectionHandle,
+                error) < 0)
+            return DPI_FAILURE;
+        if (!collectionHandle)
+            break;
+
+        // get name from collection
+        if (dpiOci__attrGet(collectionHandle, DPI_OCI_HTYPE_SODA_COLLECTION,
+                (void*) &name, &nameLength, DPI_OCI_ATTR_SODA_COLL_NAME,
+                "get collection name", error) < 0) {
+            dpiOci__handleFree(collectionHandle,
+                    DPI_OCI_HTYPE_SODA_COLLECTION);
+            return DPI_FAILURE;
+        }
+
+        // allocate additional space for the lengths array, if needed
+        if (numAllocatedNames <= names->numNames) {
+            numAllocatedNames += 256;
+            if (dpiUtils__allocateMemory(numAllocatedNames, sizeof(uint32_t),
+                    0, "allocate lengths array", (void**) &tempNameLengths,
+                    error) < 0) {
+                dpiOci__handleFree(collectionHandle,
+                        DPI_OCI_HTYPE_SODA_COLLECTION);
+                return DPI_FAILURE;
+            }
+            if (names->nameLengths) {
+                memcpy(tempNameLengths, names->nameLengths,
+                        names->numNames * sizeof(uint32_t));
+                dpiUtils__freeMemory(names->nameLengths);
+            }
+            names->nameLengths = tempNameLengths;
+        }
+
+        // allocate additional space for the names buffer, if needed
+        if (namesBufferUsed + nameLength > namesBufferAllocated) {
+            namesBufferAllocated += 32768;
+            if (dpiUtils__allocateMemory(namesBufferAllocated, 1, 0,
+                    "allocate names buffer", (void**) &tempNamesBuffer,
+                    error) < 0) {
+                dpiOci__handleFree(collectionHandle,
+                        DPI_OCI_HTYPE_SODA_COLLECTION);
+                return DPI_FAILURE;
+            }
+            if (*namesBuffer) {
+                memcpy(tempNamesBuffer, *namesBuffer, namesBufferUsed);
+                dpiUtils__freeMemory(*namesBuffer);
+            }
+            *namesBuffer = tempNamesBuffer;
+            ptr = *namesBuffer + namesBufferUsed;
+        }
+
+        // store name in buffer and length in array
+        // the names array itself is created and populated afterwards in order
+        // to avoid unnecessary copying
+        memcpy(ptr, name, nameLength);
+        namesBufferUsed += nameLength;
+        names->nameLengths[names->numNames] = nameLength;
+        names->numNames++;
+        ptr += nameLength;
+
+        // free collection now that we have processed it successfully
+        dpiOci__handleFree(collectionHandle, DPI_OCI_HTYPE_SODA_COLLECTION);
+
+    }
+
+    // now that all of the names have been determined, populate names array
+    if (names->numNames > 0) {
+        if (dpiUtils__allocateMemory(names->numNames, sizeof(char*), 0,
+                "allocate names array", (void**) &names->names, error) < 0)
+            return DPI_FAILURE;
+        ptr = *namesBuffer;
+        for (i = 0; i < names->numNames; i++) {
+            names->names[i] = ptr;
+            ptr += names->nameLengths[i];
+        }
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDb__free() [INTERNAL]
+//   Free the memory for a SODA database.
+//-----------------------------------------------------------------------------
+void dpiSodaDb__free(dpiSodaDb *db, dpiError *error)
+{
+    if (db->conn) {
+        dpiGen__setRefCount(db->conn, error, -1);
+        db->conn = NULL;
+    }
+    dpiUtils__freeMemory(db);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDb_addRef() [PUBLIC]
+//   Add a reference to the SODA database.
+//-----------------------------------------------------------------------------
+int dpiSodaDb_addRef(dpiSodaDb *db)
+{
+    return dpiGen__addRef(db, DPI_HTYPE_SODA_DB, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDb_createCollection() [PUBLIC]
+//   Create a new SODA collection with the given name and metadata.
+//-----------------------------------------------------------------------------
+int dpiSodaDb_createCollection(dpiSodaDb *db, const char *name,
+        uint32_t nameLength, const char *metadata, uint32_t metadataLength,
+        uint32_t flags, dpiSodaColl **coll)
+{
+    dpiError error;
+    uint32_t mode;
+    void *handle;
+
+    // validate parameters
+    if (dpiSodaDb__checkConnected(db, __func__, &error) < 0)
+        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(db, name)
+    DPI_CHECK_PTR_AND_LENGTH(db, metadata)
+    DPI_CHECK_PTR_NOT_NULL(db, coll)
+
+    // determine OCI mode to use
+    mode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+    if (flags & DPI_SODA_FLAGS_CREATE_COLL_MAP)
+        mode |= DPI_OCI_SODA_COLL_CREATE_MAP;
+
+    // create collection
+    if (dpiOci__sodaCollCreateWithMetadata(db, name, nameLength, metadata,
+            metadataLength, mode, &handle, &error) < 0)
+        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+    if (dpiSodaColl__allocate(db, handle, coll, &error) < 0) {
+        dpiOci__handleFree(handle, DPI_OCI_HTYPE_SODA_COLLECTION);
+        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+    }
+    return dpiGen__endPublicFn(db, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDb_createDocument() [PUBLIC]
+//   Create a SODA document that can be inserted in the collection or can be
+// used to replace an existing document in the collection.
+//-----------------------------------------------------------------------------
+int dpiSodaDb_createDocument(dpiSodaDb *db, const char *key,
+        uint32_t keyLength, const char *content, uint32_t contentLength,
+        const char *mediaType, uint32_t mediaTypeLength, UNUSED uint32_t flags,
+        dpiSodaDoc **doc)
+{
+    int detectEncoding;
+    void *docHandle;
+    dpiError error;
+
+    // validate parameters
+    if (dpiSodaDb__checkConnected(db, __func__, &error) < 0)
+        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(db, key)
+    DPI_CHECK_PTR_AND_LENGTH(db, content)
+    DPI_CHECK_PTR_AND_LENGTH(db, mediaType)
+    DPI_CHECK_PTR_NOT_NULL(db, doc)
+
+    // allocate SODA document handle
+    if (dpiOci__handleAlloc(db->env->handle, &docHandle,
+            DPI_OCI_HTYPE_SODA_DOCUMENT, "allocate SODA document handle",
+            &error) < 0)
+        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+
+    // set key, if applicable
+    if (key && keyLength > 0) {
+        if (dpiOci__attrSet(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT,
+                (void*) key, keyLength, DPI_OCI_ATTR_SODA_KEY, "set key",
+                &error) < 0) {
+            dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
+            return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+        }
+    }
+
+    // set content, if applicable
+    if (content && contentLength > 0) {
+        detectEncoding = 1;
+        if (dpiOci__attrSet(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT,
+                (void*) &detectEncoding, 0, DPI_OCI_ATTR_SODA_DETECT_JSON_ENC,
+                "set detect encoding", &error) < 0) {
+            dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
+            return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+        }
+        if (dpiOci__attrSet(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT,
+                (void*) content, contentLength, DPI_OCI_ATTR_SODA_CONTENT,
+                "set content", &error) < 0) {
+            dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
+            return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+        }
+    }
+
+    // set media type, if applicable
+    if (mediaType && mediaTypeLength > 0) {
+        if (dpiOci__attrSet(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT,
+                (void*) mediaType, mediaTypeLength,
+                DPI_OCI_ATTR_SODA_MEDIA_TYPE, "set media type", &error) < 0) {
+            dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
+            return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+        }
+    }
+
+    // allocate the ODPI-C document that will be returned
+    if (dpiSodaDoc__allocate(db, docHandle, doc, &error) < 0) {
+        dpiOci__handleFree(docHandle, DPI_OCI_HTYPE_SODA_DOCUMENT);
+        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+    }
+    (*doc)->binaryContent = 1;
+
+    return dpiGen__endPublicFn(db, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDb_freeCollectionNames() [PUBLIC]
+//   Free the names of the collections allocated earlier with a call to
+// dpiSodaDb_getCollectionNames().
+//-----------------------------------------------------------------------------
+int dpiSodaDb_freeCollectionNames(dpiSodaDb *db, dpiSodaCollNames *names)
+{
+    dpiError error;
+
+    // validate parameters
+    if (dpiSodaDb__checkConnected(db, __func__, &error) < 0)
+        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(db, names)
+
+    // perform frees; note that the memory for the names themselves is stored
+    // in one contiguous block pointed to by the first name
+    if (names->names) {
+        dpiUtils__freeMemory((void*) names->names[0]);
+        dpiUtils__freeMemory((void*) names->names);
+        names->names = NULL;
+    }
+    if (names->nameLengths) {
+        dpiUtils__freeMemory(names->nameLengths);
+        names->nameLengths = NULL;
+    }
+    names->numNames = 0;
+
+    return dpiGen__endPublicFn(db, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDb_getCollections() [PUBLIC]
+//   Return a cursor to iterate over the SODA collections in the database.
+//-----------------------------------------------------------------------------
+int dpiSodaDb_getCollections(dpiSodaDb *db, const char *startName,
+        uint32_t startNameLength, uint32_t flags, dpiSodaCollCursor **cursor)
+{
+    dpiError error;
+    uint32_t mode;
+    void *handle;
+
+    if (dpiSodaDb__checkConnected(db, __func__, &error) < 0)
+        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(db, startName)
+    DPI_CHECK_PTR_NOT_NULL(db, cursor)
+    mode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+    if (dpiOci__sodaCollList(db, startName, startNameLength, &handle, mode,
+            &error) < 0)
+        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+    if (dpiSodaCollCursor__allocate(db, handle, cursor, &error) < 0) {
+        dpiOci__handleFree(handle, DPI_OCI_HTYPE_SODA_COLL_CURSOR);
+        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+    }
+    return dpiGen__endPublicFn(db, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDb_getCollectionNames() [PUBLIC]
+//   Return the names of all collections in the provided array.
+//-----------------------------------------------------------------------------
+int dpiSodaDb_getCollectionNames(dpiSodaDb *db, const char *startName,
+        uint32_t startNameLength, uint32_t limit, uint32_t flags,
+        dpiSodaCollNames *names)
+{
+    char *namesBuffer;
+    dpiError error;
+    uint32_t mode;
+    void *handle;
+    int status;
+
+    // validate parameters
+    if (dpiSodaDb__checkConnected(db, __func__, &error) < 0)
+        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(db, startName)
+    DPI_CHECK_PTR_NOT_NULL(db, names)
+
+    // initialize output structure
+    names->numNames = 0;
+    names->names = NULL;
+    names->nameLengths = NULL;
+
+    // determine OCI mode to use
+    mode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+
+    // acquire collection cursor
+    if (dpiOci__sodaCollList(db, startName, startNameLength, &handle, mode,
+            &error) < 0)
+        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+
+    // iterate over cursor to acquire collection names
+    namesBuffer = NULL;
+    status = dpiSodaDb__getCollectionNames(db, handle, limit, names,
+            &namesBuffer, &error);
+    dpiOci__handleFree(handle, DPI_OCI_HTYPE_SODA_COLL_CURSOR);
+    if (status < 0) {
+        names->numNames = 0;
+        if (namesBuffer) {
+            dpiUtils__freeMemory(namesBuffer);
+            namesBuffer = NULL;
+        }
+        if (names->names) {
+            dpiUtils__freeMemory((void*) names->names);
+            names->names = NULL;
+        }
+        if (names->nameLengths) {
+            dpiUtils__freeMemory(names->nameLengths);
+            names->nameLengths = NULL;
+        }
+    }
+    return dpiGen__endPublicFn(db, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDb_openCollection() [PUBLIC]
+//   Open an existing SODA collection and return a handle to it.
+//-----------------------------------------------------------------------------
+int dpiSodaDb_openCollection(dpiSodaDb *db, const char *name,
+        uint32_t nameLength, uint32_t flags, dpiSodaColl **coll)
+{
+    dpiError error;
+    uint32_t mode;
+    void *handle;
+
+    if (dpiSodaDb__checkConnected(db, __func__, &error) < 0)
+        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(db, name)
+    DPI_CHECK_PTR_NOT_NULL(db, coll)
+    mode = DPI_OCI_DEFAULT;
+    if (flags & DPI_SODA_FLAGS_ATOMIC_COMMIT)
+        mode |= DPI_OCI_SODA_ATOMIC_COMMIT;
+    if (dpiOci__sodaCollOpen(db, name, nameLength, mode, &handle,
+            &error) < 0)
+        return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+    *coll = NULL;
+    if (handle) {
+        if (dpiSodaColl__allocate(db, handle, coll, &error) < 0) {
+            dpiOci__handleFree(handle, DPI_OCI_HTYPE_SODA_COLLECTION);
+            return dpiGen__endPublicFn(db, DPI_FAILURE, &error);
+        }
+    }
+    return dpiGen__endPublicFn(db, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDb_release() [PUBLIC]
+//   Release a reference to the SODA database.
+//-----------------------------------------------------------------------------
+int dpiSodaDb_release(dpiSodaDb *db)
+{
+    return dpiGen__release(db, DPI_HTYPE_SODA_DB, __func__);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiSodaDoc.c ./odpi/src/dpiSodaDoc.c
--- patched-godror/odpi/src/dpiSodaDoc.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiSodaDoc.c	1970-01-01 01:00:00
@@ -1,244 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2018, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiSodaDoc.c
-//   Implementation of SODA documents.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiSodaDoc__allocate() [INTERNAL]
-//   Allocate and initialize a SODA document structure.
-//-----------------------------------------------------------------------------
-int dpiSodaDoc__allocate(dpiSodaDb *db, void *handle, dpiSodaDoc **doc,
-        dpiError *error)
-{
-    dpiSodaDoc *tempDoc;
-
-    if (dpiGen__allocate(DPI_HTYPE_SODA_DOC, db->env, (void**) &tempDoc,
-            error) < 0)
-        return DPI_FAILURE;
-    dpiGen__setRefCount(db, error, 1);
-    tempDoc->db = db;
-    tempDoc->handle = handle;
-    *doc = tempDoc;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDoc__check() [INTERNAL]
-//   Determine if the SODA document is available to use.
-//-----------------------------------------------------------------------------
-static int dpiSodaDoc__check(dpiSodaDoc *doc, const char *fnName,
-        dpiError *error)
-{
-    if (dpiGen__startPublicFn(doc, DPI_HTYPE_SODA_DOC, fnName, error) < 0)
-        return DPI_FAILURE;
-    if (!doc->db->conn->handle || doc->db->conn->closing)
-        return dpiError__set(error, "check connection", DPI_ERR_NOT_CONNECTED);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDoc__free() [INTERNAL]
-//   Free the memory for a SODA document. Note that the reference to the
-// database must remain until after the handle is freed; otherwise, a segfault
-// can take place.
-//-----------------------------------------------------------------------------
-void dpiSodaDoc__free(dpiSodaDoc *doc, dpiError *error)
-{
-    if (doc->handle) {
-        dpiOci__handleFree(doc->handle, DPI_OCI_HTYPE_SODA_DOCUMENT);
-        doc->handle = NULL;
-    }
-    if (doc->db) {
-        dpiGen__setRefCount(doc->db, error, -1);
-        doc->db = NULL;
-    }
-    dpiUtils__freeMemory(doc);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDoc__getAttributeText() [INTERNAL]
-//   Get the value of the OCI attribute as a text string.
-//-----------------------------------------------------------------------------
-static int dpiSodaDoc__getAttributeText(dpiSodaDoc *doc, uint32_t attribute,
-        const char **value, uint32_t *valueLength, const char *fnName)
-{
-    dpiError error;
-    int status;
-
-    // validate parameters
-    if (dpiSodaDoc__check(doc, fnName, &error) < 0)
-        return dpiGen__endPublicFn(doc, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(doc, value)
-    DPI_CHECK_PTR_NOT_NULL(doc, valueLength)
-
-    // get attribute value
-    status = dpiOci__attrGet(doc->handle, DPI_OCI_HTYPE_SODA_DOCUMENT,
-            (void*) value, valueLength, attribute, "get value", &error);
-    return dpiGen__endPublicFn(doc, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDoc_addRef() [PUBLIC]
-//   Add a reference to the SODA document.
-//-----------------------------------------------------------------------------
-int dpiSodaDoc_addRef(dpiSodaDoc *doc)
-{
-    return dpiGen__addRef(doc, DPI_HTYPE_SODA_DOC, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDoc_getContent() [PUBLIC]
-//   Return the content of the SODA document.
-//-----------------------------------------------------------------------------
-int dpiSodaDoc_getContent(dpiSodaDoc *doc, const char **value,
-        uint32_t *valueLength, const char **encoding)
-{
-    uint16_t charsetId;
-    dpiError error;
-
-    // validate parameters
-    if (dpiSodaDoc__check(doc, __func__, &error) < 0)
-        return dpiGen__endPublicFn(doc, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(doc, value)
-    DPI_CHECK_PTR_NOT_NULL(doc, valueLength)
-    DPI_CHECK_PTR_NOT_NULL(doc, encoding)
-
-    // get content
-    if (dpiOci__attrGet(doc->handle, DPI_OCI_HTYPE_SODA_DOCUMENT,
-            (void*) value, valueLength, DPI_OCI_ATTR_SODA_CONTENT,
-            "get content", &error) < 0)
-        return dpiGen__endPublicFn(doc, DPI_FAILURE, &error);
-
-    // if content is not in binary form, always use UTF-8
-    if (!doc->binaryContent)
-        *encoding = DPI_CHARSET_NAME_UTF8;
-
-    // otherwise, determine the encoding from OCI
-    else {
-        if (dpiOci__attrGet(doc->handle, DPI_OCI_HTYPE_SODA_DOCUMENT,
-                (void*) &charsetId, 0, DPI_OCI_ATTR_SODA_JSON_CHARSET_ID,
-                "get charset", &error) < 0)
-            return dpiGen__endPublicFn(doc, DPI_FAILURE, &error);
-        switch (charsetId) {
-            case 0:
-                *encoding = NULL;
-                break;
-            case DPI_CHARSET_ID_UTF8:
-                *encoding = DPI_CHARSET_NAME_UTF8;
-                break;
-            case DPI_CHARSET_ID_UTF16BE:
-                *encoding = DPI_CHARSET_NAME_UTF16BE;
-                break;
-            case DPI_CHARSET_ID_UTF16LE:
-                *encoding = DPI_CHARSET_NAME_UTF16LE;
-                break;
-            default:
-                dpiError__set(&error, "check charset",
-                        DPI_ERR_INVALID_CHARSET_ID, charsetId);
-                return dpiGen__endPublicFn(doc, DPI_FAILURE, &error);
-        }
-    }
-
-    return dpiGen__endPublicFn(doc, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDoc_getCreatedOn() [PUBLIC]
-//   Return the created timestamp of the SODA document.
-//-----------------------------------------------------------------------------
-int dpiSodaDoc_getCreatedOn(dpiSodaDoc *doc, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiSodaDoc__getAttributeText(doc,
-            DPI_OCI_ATTR_SODA_CREATE_TIMESTAMP, value, valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDoc_getKey() [PUBLIC]
-//   Return the key of the SODA document.
-//-----------------------------------------------------------------------------
-int dpiSodaDoc_getKey(dpiSodaDoc *doc, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiSodaDoc__getAttributeText(doc, DPI_OCI_ATTR_SODA_KEY, value,
-            valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDoc_getLastModified() [PUBLIC]
-//   Return the last modified timestamp of the SODA document.
-//-----------------------------------------------------------------------------
-int dpiSodaDoc_getLastModified(dpiSodaDoc *doc, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiSodaDoc__getAttributeText(doc,
-            DPI_OCI_ATTR_SODA_LASTMOD_TIMESTAMP, value, valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDoc_getMediaType() [PUBLIC]
-//   Return the media type of the SODA document.
-//-----------------------------------------------------------------------------
-int dpiSodaDoc_getMediaType(dpiSodaDoc *doc, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiSodaDoc__getAttributeText(doc, DPI_OCI_ATTR_SODA_MEDIA_TYPE,
-            value, valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDoc_getVersion() [PUBLIC]
-//   Return the version of the SODA document.
-//-----------------------------------------------------------------------------
-int dpiSodaDoc_getVersion(dpiSodaDoc *doc, const char **value,
-        uint32_t *valueLength)
-{
-    return dpiSodaDoc__getAttributeText(doc, DPI_OCI_ATTR_SODA_VERSION,
-            value, valueLength, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDoc_release() [PUBLIC]
-//   Release a reference to the SODA document.
-//-----------------------------------------------------------------------------
-int dpiSodaDoc_release(dpiSodaDoc *doc)
-{
-    return dpiGen__release(doc, DPI_HTYPE_SODA_DOC, __func__);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiSodaDoc.h ./odpi/src/dpiSodaDoc.h
--- patched-godror/odpi/src/dpiSodaDoc.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiSodaDoc.h	2024-05-14 14:55:13
@@ -0,0 +1,244 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2018, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiSodaDoc.c
+//   Implementation of SODA documents.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiSodaDoc__allocate() [INTERNAL]
+//   Allocate and initialize a SODA document structure.
+//-----------------------------------------------------------------------------
+int dpiSodaDoc__allocate(dpiSodaDb *db, void *handle, dpiSodaDoc **doc,
+        dpiError *error)
+{
+    dpiSodaDoc *tempDoc;
+
+    if (dpiGen__allocate(DPI_HTYPE_SODA_DOC, db->env, (void**) &tempDoc,
+            error) < 0)
+        return DPI_FAILURE;
+    dpiGen__setRefCount(db, error, 1);
+    tempDoc->db = db;
+    tempDoc->handle = handle;
+    *doc = tempDoc;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDoc__check() [INTERNAL]
+//   Determine if the SODA document is available to use.
+//-----------------------------------------------------------------------------
+static int dpiSodaDoc__check(dpiSodaDoc *doc, const char *fnName,
+        dpiError *error)
+{
+    if (dpiGen__startPublicFn(doc, DPI_HTYPE_SODA_DOC, fnName, error) < 0)
+        return DPI_FAILURE;
+    if (!doc->db->conn->handle || doc->db->conn->closing)
+        return dpiError__set(error, "check connection", DPI_ERR_NOT_CONNECTED);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDoc__free() [INTERNAL]
+//   Free the memory for a SODA document. Note that the reference to the
+// database must remain until after the handle is freed; otherwise, a segfault
+// can take place.
+//-----------------------------------------------------------------------------
+void dpiSodaDoc__free(dpiSodaDoc *doc, dpiError *error)
+{
+    if (doc->handle) {
+        dpiOci__handleFree(doc->handle, DPI_OCI_HTYPE_SODA_DOCUMENT);
+        doc->handle = NULL;
+    }
+    if (doc->db) {
+        dpiGen__setRefCount(doc->db, error, -1);
+        doc->db = NULL;
+    }
+    dpiUtils__freeMemory(doc);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDoc__getAttributeText() [INTERNAL]
+//   Get the value of the OCI attribute as a text string.
+//-----------------------------------------------------------------------------
+static int dpiSodaDoc__getAttributeText(dpiSodaDoc *doc, uint32_t attribute,
+        const char **value, uint32_t *valueLength, const char *fnName)
+{
+    dpiError error;
+    int status;
+
+    // validate parameters
+    if (dpiSodaDoc__check(doc, fnName, &error) < 0)
+        return dpiGen__endPublicFn(doc, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(doc, value)
+    DPI_CHECK_PTR_NOT_NULL(doc, valueLength)
+
+    // get attribute value
+    status = dpiOci__attrGet(doc->handle, DPI_OCI_HTYPE_SODA_DOCUMENT,
+            (void*) value, valueLength, attribute, "get value", &error);
+    return dpiGen__endPublicFn(doc, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDoc_addRef() [PUBLIC]
+//   Add a reference to the SODA document.
+//-----------------------------------------------------------------------------
+int dpiSodaDoc_addRef(dpiSodaDoc *doc)
+{
+    return dpiGen__addRef(doc, DPI_HTYPE_SODA_DOC, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDoc_getContent() [PUBLIC]
+//   Return the content of the SODA document.
+//-----------------------------------------------------------------------------
+int dpiSodaDoc_getContent(dpiSodaDoc *doc, const char **value,
+        uint32_t *valueLength, const char **encoding)
+{
+    uint16_t charsetId;
+    dpiError error;
+
+    // validate parameters
+    if (dpiSodaDoc__check(doc, __func__, &error) < 0)
+        return dpiGen__endPublicFn(doc, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(doc, value)
+    DPI_CHECK_PTR_NOT_NULL(doc, valueLength)
+    DPI_CHECK_PTR_NOT_NULL(doc, encoding)
+
+    // get content
+    if (dpiOci__attrGet(doc->handle, DPI_OCI_HTYPE_SODA_DOCUMENT,
+            (void*) value, valueLength, DPI_OCI_ATTR_SODA_CONTENT,
+            "get content", &error) < 0)
+        return dpiGen__endPublicFn(doc, DPI_FAILURE, &error);
+
+    // if content is not in binary form, always use UTF-8
+    if (!doc->binaryContent)
+        *encoding = DPI_CHARSET_NAME_UTF8;
+
+    // otherwise, determine the encoding from OCI
+    else {
+        if (dpiOci__attrGet(doc->handle, DPI_OCI_HTYPE_SODA_DOCUMENT,
+                (void*) &charsetId, 0, DPI_OCI_ATTR_SODA_JSON_CHARSET_ID,
+                "get charset", &error) < 0)
+            return dpiGen__endPublicFn(doc, DPI_FAILURE, &error);
+        switch (charsetId) {
+            case 0:
+                *encoding = NULL;
+                break;
+            case DPI_CHARSET_ID_UTF8:
+                *encoding = DPI_CHARSET_NAME_UTF8;
+                break;
+            case DPI_CHARSET_ID_UTF16BE:
+                *encoding = DPI_CHARSET_NAME_UTF16BE;
+                break;
+            case DPI_CHARSET_ID_UTF16LE:
+                *encoding = DPI_CHARSET_NAME_UTF16LE;
+                break;
+            default:
+                dpiError__set(&error, "check charset",
+                        DPI_ERR_INVALID_CHARSET_ID, charsetId);
+                return dpiGen__endPublicFn(doc, DPI_FAILURE, &error);
+        }
+    }
+
+    return dpiGen__endPublicFn(doc, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDoc_getCreatedOn() [PUBLIC]
+//   Return the created timestamp of the SODA document.
+//-----------------------------------------------------------------------------
+int dpiSodaDoc_getCreatedOn(dpiSodaDoc *doc, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiSodaDoc__getAttributeText(doc,
+            DPI_OCI_ATTR_SODA_CREATE_TIMESTAMP, value, valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDoc_getKey() [PUBLIC]
+//   Return the key of the SODA document.
+//-----------------------------------------------------------------------------
+int dpiSodaDoc_getKey(dpiSodaDoc *doc, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiSodaDoc__getAttributeText(doc, DPI_OCI_ATTR_SODA_KEY, value,
+            valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDoc_getLastModified() [PUBLIC]
+//   Return the last modified timestamp of the SODA document.
+//-----------------------------------------------------------------------------
+int dpiSodaDoc_getLastModified(dpiSodaDoc *doc, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiSodaDoc__getAttributeText(doc,
+            DPI_OCI_ATTR_SODA_LASTMOD_TIMESTAMP, value, valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDoc_getMediaType() [PUBLIC]
+//   Return the media type of the SODA document.
+//-----------------------------------------------------------------------------
+int dpiSodaDoc_getMediaType(dpiSodaDoc *doc, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiSodaDoc__getAttributeText(doc, DPI_OCI_ATTR_SODA_MEDIA_TYPE,
+            value, valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDoc_getVersion() [PUBLIC]
+//   Return the version of the SODA document.
+//-----------------------------------------------------------------------------
+int dpiSodaDoc_getVersion(dpiSodaDoc *doc, const char **value,
+        uint32_t *valueLength)
+{
+    return dpiSodaDoc__getAttributeText(doc, DPI_OCI_ATTR_SODA_VERSION,
+            value, valueLength, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDoc_release() [PUBLIC]
+//   Release a reference to the SODA document.
+//-----------------------------------------------------------------------------
+int dpiSodaDoc_release(dpiSodaDoc *doc)
+{
+    return dpiGen__release(doc, DPI_HTYPE_SODA_DOC, __func__);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiSodaDocCursor.c ./odpi/src/dpiSodaDocCursor.c
--- patched-godror/odpi/src/dpiSodaDocCursor.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiSodaDocCursor.c	1970-01-01 01:00:00
@@ -1,153 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2018, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiSodaDocCursor.c
-//   Implementation of SODA document cursors.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiSodaDocCursor__allocate() [INTERNAL]
-//   Allocate and initialize a SODA document cursor structure.
-//-----------------------------------------------------------------------------
-int dpiSodaDocCursor__allocate(dpiSodaColl *coll, void *handle,
-        dpiSodaDocCursor **cursor, dpiError *error)
-{
-    dpiSodaDocCursor *tempCursor;
-
-    if (dpiGen__allocate(DPI_HTYPE_SODA_DOC_CURSOR, coll->env,
-            (void**) &tempCursor, error) < 0)
-        return DPI_FAILURE;
-    dpiGen__setRefCount(coll, error, 1);
-    tempCursor->coll = coll;
-    tempCursor->handle = handle;
-    *cursor = tempCursor;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDocCursor__check() [INTERNAL]
-//   Determine if the SODA document cursor is available to use.
-//-----------------------------------------------------------------------------
-static int dpiSodaDocCursor__check(dpiSodaDocCursor *cursor,
-        const char *fnName, dpiError *error)
-{
-    if (dpiGen__startPublicFn(cursor, DPI_HTYPE_SODA_DOC_CURSOR, fnName,
-            error) < 0)
-        return DPI_FAILURE;
-    if (!cursor->handle)
-        return dpiError__set(error, "check closed",
-                DPI_ERR_SODA_CURSOR_CLOSED);
-    if (!cursor->coll->db->conn->handle || cursor->coll->db->conn->closing)
-        return dpiError__set(error, "check connection", DPI_ERR_NOT_CONNECTED);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDocCursor__free() [INTERNAL]
-//   Free the memory for a SODA document cursor. Note that the reference to the
-// collection must remain until after the handle is freed; otherwise, a
-// segfault can take place.
-//-----------------------------------------------------------------------------
-void dpiSodaDocCursor__free(dpiSodaDocCursor *cursor, dpiError *error)
-{
-    if (cursor->handle) {
-        dpiOci__handleFree(cursor->handle, DPI_OCI_HTYPE_SODA_DOC_CURSOR);
-        cursor->handle = NULL;
-    }
-    if (cursor->coll) {
-        dpiGen__setRefCount(cursor->coll, error, -1);
-        cursor->coll = NULL;
-    }
-    dpiUtils__freeMemory(cursor);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDocCursor_addRef() [PUBLIC]
-//   Add a reference to the SODA document cursor.
-//-----------------------------------------------------------------------------
-int dpiSodaDocCursor_addRef(dpiSodaDocCursor *cursor)
-{
-    return dpiGen__addRef(cursor, DPI_HTYPE_SODA_DOC_CURSOR, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDocCursor_close() [PUBLIC]
-//   Close the cursor.
-//-----------------------------------------------------------------------------
-int dpiSodaDocCursor_close(dpiSodaDocCursor *cursor)
-{
-    dpiError error;
-
-    if (dpiSodaDocCursor__check(cursor, __func__, &error) < 0)
-        return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
-    if (cursor->handle) {
-        dpiOci__handleFree(cursor->handle, DPI_OCI_HTYPE_SODA_DOC_CURSOR);
-        cursor->handle = NULL;
-    }
-    return dpiGen__endPublicFn(cursor, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDocCursor_getNext() [PUBLIC]
-//   Return the next document available from the cursor.
-//-----------------------------------------------------------------------------
-int dpiSodaDocCursor_getNext(dpiSodaDocCursor *cursor, UNUSED uint32_t flags,
-        dpiSodaDoc **doc)
-{
-    dpiError error;
-    void *handle;
-
-    if (dpiSodaDocCursor__check(cursor, __func__, &error) < 0)
-        return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(cursor, doc)
-    if (dpiOci__sodaDocGetNext(cursor, &handle, &error) < 0)
-        return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
-    *doc = NULL;
-    if (handle) {
-        if (dpiSodaDoc__allocate(cursor->coll->db, handle, doc, &error) < 0) {
-            dpiOci__handleFree(handle, DPI_OCI_HTYPE_SODA_DOCUMENT);
-            return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
-        }
-        (*doc)->binaryContent = cursor->coll->binaryContent;
-    }
-    return dpiGen__endPublicFn(cursor, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSodaDocCursor_release() [PUBLIC]
-//   Release a reference to the SODA document cursor.
-//-----------------------------------------------------------------------------
-int dpiSodaDocCursor_release(dpiSodaDocCursor *cursor)
-{
-    return dpiGen__release(cursor, DPI_HTYPE_SODA_DOC_CURSOR, __func__);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiSodaDocCursor.h ./odpi/src/dpiSodaDocCursor.h
--- patched-godror/odpi/src/dpiSodaDocCursor.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiSodaDocCursor.h	2024-05-14 14:55:13
@@ -0,0 +1,153 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2018, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiSodaDocCursor.c
+//   Implementation of SODA document cursors.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiSodaDocCursor__allocate() [INTERNAL]
+//   Allocate and initialize a SODA document cursor structure.
+//-----------------------------------------------------------------------------
+int dpiSodaDocCursor__allocate(dpiSodaColl *coll, void *handle,
+        dpiSodaDocCursor **cursor, dpiError *error)
+{
+    dpiSodaDocCursor *tempCursor;
+
+    if (dpiGen__allocate(DPI_HTYPE_SODA_DOC_CURSOR, coll->env,
+            (void**) &tempCursor, error) < 0)
+        return DPI_FAILURE;
+    dpiGen__setRefCount(coll, error, 1);
+    tempCursor->coll = coll;
+    tempCursor->handle = handle;
+    *cursor = tempCursor;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDocCursor__check() [INTERNAL]
+//   Determine if the SODA document cursor is available to use.
+//-----------------------------------------------------------------------------
+static int dpiSodaDocCursor__check(dpiSodaDocCursor *cursor,
+        const char *fnName, dpiError *error)
+{
+    if (dpiGen__startPublicFn(cursor, DPI_HTYPE_SODA_DOC_CURSOR, fnName,
+            error) < 0)
+        return DPI_FAILURE;
+    if (!cursor->handle)
+        return dpiError__set(error, "check closed",
+                DPI_ERR_SODA_CURSOR_CLOSED);
+    if (!cursor->coll->db->conn->handle || cursor->coll->db->conn->closing)
+        return dpiError__set(error, "check connection", DPI_ERR_NOT_CONNECTED);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDocCursor__free() [INTERNAL]
+//   Free the memory for a SODA document cursor. Note that the reference to the
+// collection must remain until after the handle is freed; otherwise, a
+// segfault can take place.
+//-----------------------------------------------------------------------------
+void dpiSodaDocCursor__free(dpiSodaDocCursor *cursor, dpiError *error)
+{
+    if (cursor->handle) {
+        dpiOci__handleFree(cursor->handle, DPI_OCI_HTYPE_SODA_DOC_CURSOR);
+        cursor->handle = NULL;
+    }
+    if (cursor->coll) {
+        dpiGen__setRefCount(cursor->coll, error, -1);
+        cursor->coll = NULL;
+    }
+    dpiUtils__freeMemory(cursor);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDocCursor_addRef() [PUBLIC]
+//   Add a reference to the SODA document cursor.
+//-----------------------------------------------------------------------------
+int dpiSodaDocCursor_addRef(dpiSodaDocCursor *cursor)
+{
+    return dpiGen__addRef(cursor, DPI_HTYPE_SODA_DOC_CURSOR, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDocCursor_close() [PUBLIC]
+//   Close the cursor.
+//-----------------------------------------------------------------------------
+int dpiSodaDocCursor_close(dpiSodaDocCursor *cursor)
+{
+    dpiError error;
+
+    if (dpiSodaDocCursor__check(cursor, __func__, &error) < 0)
+        return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
+    if (cursor->handle) {
+        dpiOci__handleFree(cursor->handle, DPI_OCI_HTYPE_SODA_DOC_CURSOR);
+        cursor->handle = NULL;
+    }
+    return dpiGen__endPublicFn(cursor, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDocCursor_getNext() [PUBLIC]
+//   Return the next document available from the cursor.
+//-----------------------------------------------------------------------------
+int dpiSodaDocCursor_getNext(dpiSodaDocCursor *cursor, UNUSED uint32_t flags,
+        dpiSodaDoc **doc)
+{
+    dpiError error;
+    void *handle;
+
+    if (dpiSodaDocCursor__check(cursor, __func__, &error) < 0)
+        return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(cursor, doc)
+    if (dpiOci__sodaDocGetNext(cursor, &handle, &error) < 0)
+        return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
+    *doc = NULL;
+    if (handle) {
+        if (dpiSodaDoc__allocate(cursor->coll->db, handle, doc, &error) < 0) {
+            dpiOci__handleFree(handle, DPI_OCI_HTYPE_SODA_DOCUMENT);
+            return dpiGen__endPublicFn(cursor, DPI_FAILURE, &error);
+        }
+        (*doc)->binaryContent = cursor->coll->binaryContent;
+    }
+    return dpiGen__endPublicFn(cursor, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSodaDocCursor_release() [PUBLIC]
+//   Release a reference to the SODA document cursor.
+//-----------------------------------------------------------------------------
+int dpiSodaDocCursor_release(dpiSodaDocCursor *cursor)
+{
+    return dpiGen__release(cursor, DPI_HTYPE_SODA_DOC_CURSOR, __func__);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiStmt.c ./odpi/src/dpiStmt.c
--- patched-godror/odpi/src/dpiStmt.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiStmt.c	1970-01-01 01:00:00
@@ -1,2009 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiStmt.c
-//   Implementation of statements (cursors).
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-// forward declarations of internal functions only used in this file
-static int dpiStmt__getQueryInfo(dpiStmt *stmt, uint32_t pos,
-        dpiQueryInfo *info, dpiError *error);
-static int dpiStmt__getQueryInfoFromParam(dpiStmt *stmt, void *param,
-        dpiQueryInfo *info, dpiError *error);
-static int dpiStmt__postFetch(dpiStmt *stmt, dpiError *error);
-static int dpiStmt__beforeFetch(dpiStmt *stmt, dpiError *error);
-static int dpiStmt__reExecute(dpiStmt *stmt, uint32_t numIters,
-        uint32_t mode, dpiError *error);
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__allocate() [INTERNAL]
-//   Create a new statement object and return it. In case of error NULL is
-// returned.
-//-----------------------------------------------------------------------------
-int dpiStmt__allocate(dpiConn *conn, int scrollable, dpiStmt **stmt,
-        dpiError *error)
-{
-    dpiStmt *tempStmt;
-
-    *stmt = NULL;
-    if (dpiGen__allocate(DPI_HTYPE_STMT, conn->env, (void**) &tempStmt,
-            error) < 0)
-        return DPI_FAILURE;
-    dpiGen__setRefCount(conn, error, 1);
-    tempStmt->conn = conn;
-    tempStmt->fetchArraySize = DPI_DEFAULT_FETCH_ARRAY_SIZE;
-    tempStmt->prefetchRows = DPI_DEFAULT_PREFETCH_ROWS;
-    tempStmt->scrollable = scrollable;
-    *stmt = tempStmt;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__bind() [INTERNAL]
-//   Bind the variable to the statement using either a position or a name. A
-// reference to the variable will be retained.
-//-----------------------------------------------------------------------------
-static int dpiStmt__bind(dpiStmt *stmt, dpiVar *var, uint32_t pos,
-        const char *name, uint32_t nameLength, dpiError *error)
-{
-    dpiBindVar *bindVars, *entry = NULL;
-    int found, dynamicBind, status;
-    void *bindHandle = NULL;
-    uint32_t i;
-
-    // a zero length name is not supported
-    if (pos == 0 && nameLength == 0)
-        return dpiError__set(error, "bind zero length name",
-                DPI_ERR_NOT_SUPPORTED);
-
-    // prevent attempts to bind a statement to itself
-    if (var->type->oracleTypeNum == DPI_ORACLE_TYPE_STMT) {
-        for (i = 0; i < var->buffer.maxArraySize; i++) {
-            if (var->buffer.externalData[i].value.asStmt == stmt) {
-                return dpiError__set(error, "bind to self",
-                        DPI_ERR_NOT_SUPPORTED);
-            }
-        }
-    }
-
-    // check to see if the bind position or name has already been bound
-    found = 0;
-    for (i = 0; i < stmt->numBindVars; i++) {
-        entry = &stmt->bindVars[i];
-        if (entry->pos == pos && entry->nameLength == nameLength) {
-            if (nameLength > 0 && strncmp(entry->name, name, nameLength) != 0)
-                continue;
-            found = 1;
-            break;
-        }
-    }
-
-    // if already found, use that entry
-    if (found) {
-
-        // if already bound, no need to bind a second time
-        if (entry->var == var)
-            return DPI_SUCCESS;
-
-        // otherwise, release previously bound variable, if applicable
-        else if (entry->var) {
-            dpiGen__setRefCount(entry->var, error, -1);
-            entry->var = NULL;
-        }
-
-    // if not found, add to the list of bind variables
-    } else {
-
-        // allocate memory for additional bind variables, if needed
-        if (stmt->numBindVars == stmt->allocatedBindVars) {
-            if (dpiUtils__allocateMemory(stmt->allocatedBindVars + 8,
-                    sizeof(dpiBindVar), 1, "allocate bind vars",
-                    (void**) &bindVars, error) < 0)
-                return DPI_FAILURE;
-            if (stmt->bindVars) {
-                for (i = 0; i < stmt->numBindVars; i++)
-                    bindVars[i] = stmt->bindVars[i];
-                dpiUtils__freeMemory(stmt->bindVars);
-            }
-            stmt->bindVars = bindVars;
-            stmt->allocatedBindVars += 8;
-        }
-
-        // add to the list of bind variables
-        entry = &stmt->bindVars[stmt->numBindVars];
-        entry->var = NULL;
-        entry->pos = pos;
-        if (name) {
-            if (dpiUtils__allocateMemory(1, nameLength, 0,
-                    "allocate memory for name", (void**) &entry->name,
-                    error) < 0)
-                return DPI_FAILURE;
-            entry->nameLength = nameLength;
-            memcpy( (void*) entry->name, name, nameLength);
-        }
-        stmt->numBindVars++;
-
-    }
-
-    // for PL/SQL where the maxSize is greater than 32K, adjust the variable
-    // so that LOBs are used internally
-    if (var->isDynamic && (stmt->statementType == DPI_STMT_TYPE_BEGIN ||
-            stmt->statementType == DPI_STMT_TYPE_DECLARE ||
-            stmt->statementType == DPI_STMT_TYPE_CALL)) {
-        if (dpiVar__convertToLob(var, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // perform actual bind
-    dpiGen__setRefCount(var, error, 1);
-    entry->var = var;
-    dynamicBind = stmt->isReturning || var->isDynamic;
-    if (pos > 0) {
-        if (stmt->env->versionInfo->versionNum < 12)
-            status = dpiOci__bindByPos(stmt, &bindHandle, pos, dynamicBind,
-                    var, error);
-        else status = dpiOci__bindByPos2(stmt, &bindHandle, pos, dynamicBind,
-                var, error);
-    } else {
-        if (stmt->env->versionInfo->versionNum < 12)
-            status = dpiOci__bindByName(stmt, &bindHandle, name,
-                    (int32_t) nameLength, dynamicBind, var, error);
-        else status = dpiOci__bindByName2(stmt, &bindHandle, name,
-                (int32_t) nameLength, dynamicBind, var, error);
-    }
-
-    // attempt to improve message "ORA-01036: illegal variable name/number"
-    if (status < 0) {
-        if (error->buffer->code == 1036) {
-            if (stmt->statementType == DPI_STMT_TYPE_CREATE ||
-                    stmt->statementType == DPI_STMT_TYPE_DROP ||
-                    stmt->statementType == DPI_STMT_TYPE_ALTER)
-                dpiError__set(error, error->buffer->action,
-                        DPI_ERR_NO_BIND_VARS_IN_DDL);
-        }
-        return DPI_FAILURE;
-    }
-
-    // set the charset form if applicable
-    if (var->type->charsetForm != DPI_SQLCS_IMPLICIT) {
-        if (dpiOci__attrSet(bindHandle, DPI_OCI_HTYPE_BIND,
-                (void*) &var->type->charsetForm, 0, DPI_OCI_ATTR_CHARSET_FORM,
-                "set charset form", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set the max data size, if applicable
-    if (var->type->sizeInBytes == 0 && !var->isDynamic) {
-        if (dpiOci__attrSet(bindHandle, DPI_OCI_HTYPE_BIND,
-                (void*) &var->sizeInBytes, 0, DPI_OCI_ATTR_MAXDATA_SIZE,
-                "set max data size", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // bind object, if applicable
-    if (var->buffer.objectIndicator &&
-            dpiOci__bindObject(var, bindHandle, error) < 0)
-        return DPI_FAILURE;
-
-    // setup dynamic bind, if applicable
-    if (dynamicBind && dpiOci__bindDynamic(var, bindHandle, error) < 0)
-        return DPI_FAILURE;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__check() [INTERNAL]
-//   Determine if the statement is open and available for use.
-//-----------------------------------------------------------------------------
-static int dpiStmt__check(dpiStmt *stmt, const char *fnName, dpiError *error)
-{
-    if (dpiGen__startPublicFn(stmt, DPI_HTYPE_STMT, fnName, error) < 0)
-        return DPI_FAILURE;
-    if (!stmt->handle || (stmt->parentStmt && !stmt->parentStmt->handle))
-        return dpiError__set(error, "check closed", DPI_ERR_STMT_CLOSED);
-    if (dpiConn__checkConnected(stmt->conn, error) < 0)
-        return DPI_FAILURE;
-    if (stmt->statementType == 0 && dpiStmt__init(stmt, error) < 0)
-        return DPI_FAILURE;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__clearBatchErrors() [INTERNAL]
-//   Clear the batch errors associated with the statement.
-//-----------------------------------------------------------------------------
-static void dpiStmt__clearBatchErrors(dpiStmt *stmt)
-{
-    if (stmt->batchErrors) {
-        dpiUtils__freeMemory(stmt->batchErrors);
-        stmt->batchErrors = NULL;
-    }
-    stmt->numBatchErrors = 0;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__clearBindVars() [INTERNAL]
-//   Clear the bind variables associated with the statement.
-//-----------------------------------------------------------------------------
-static void dpiStmt__clearBindVars(dpiStmt *stmt, dpiError *error)
-{
-    uint32_t i;
-
-    if (stmt->bindVars) {
-        for (i = 0; i < stmt->numBindVars; i++) {
-            if (stmt->bindVars[i].var)
-                dpiGen__setRefCount(stmt->bindVars[i].var, error, -1);
-            if (stmt->bindVars[i].name)
-                dpiUtils__freeMemory( (void*) stmt->bindVars[i].name);
-        }
-        dpiUtils__freeMemory(stmt->bindVars);
-        stmt->bindVars = NULL;
-    }
-    stmt->numBindVars = 0;
-    stmt->allocatedBindVars = 0;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__clearQueryVars() [INTERNAL]
-//   Clear the query variables associated with the statement.
-//-----------------------------------------------------------------------------
-static void dpiStmt__clearQueryVars(dpiStmt *stmt, dpiError *error)
-{
-    uint32_t i;
-
-    if (stmt->queryVars) {
-        for (i = 0; i < stmt->numQueryVars; i++) {
-            if (stmt->queryVars[i]) {
-                dpiGen__setRefCount(stmt->queryVars[i], error, -1);
-                stmt->queryVars[i] = NULL;
-            }
-            if (stmt->queryInfo[i].typeInfo.objectType) {
-                dpiGen__setRefCount(stmt->queryInfo[i].typeInfo.objectType,
-                        error, -1);
-                stmt->queryInfo[i].typeInfo.objectType = NULL;
-            }
-        }
-        dpiUtils__freeMemory(stmt->queryVars);
-        stmt->queryVars = NULL;
-    }
-    if (stmt->queryInfo) {
-        dpiUtils__freeMemory(stmt->queryInfo);
-        stmt->queryInfo = NULL;
-    }
-    stmt->numQueryVars = 0;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__close() [INTERNAL]
-//   Internal method used for closing the statement. If the statement is marked
-// as needing to be dropped from the statement cache that is done as well. This
-// is called from dpiStmt_close() where errors are expected to be propagated
-// and from dpiStmt__free() where errors are ignored.
-//-----------------------------------------------------------------------------
-int dpiStmt__close(dpiStmt *stmt, const char *tag, uint32_t tagLength,
-        int propagateErrors, dpiError *error)
-{
-    int closing, status = DPI_SUCCESS;
-
-    // determine whether statement is already being closed and if not, mark
-    // statement as being closed; this MUST be done while holding the lock (if
-    // in threaded mode) to avoid race conditions!
-    if (stmt->env->threaded)
-        dpiMutex__acquire(stmt->env->mutex);
-    closing = stmt->closing;
-    stmt->closing = 1;
-    if (stmt->env->threaded)
-        dpiMutex__release(stmt->env->mutex);
-
-    // if statement is already being closed, nothing needs to be done
-    if (closing)
-        return DPI_SUCCESS;
-
-    // perform actual work of closing statement
-    dpiStmt__clearBatchErrors(stmt);
-    dpiStmt__clearBindVars(stmt, error);
-    dpiStmt__clearQueryVars(stmt, error);
-    if (stmt->lastRowid)
-        dpiGen__setRefCount(stmt->lastRowid, error, -1);
-    if (stmt->handle) {
-        if (stmt->parentStmt) {
-            dpiGen__setRefCount(stmt->parentStmt, error, -1);
-            stmt->parentStmt = NULL;
-        } else if (!stmt->conn->deadSession && stmt->conn->handle) {
-            if (stmt->isOwned)
-                dpiOci__handleFree(stmt->handle, DPI_OCI_HTYPE_STMT);
-            else status = dpiOci__stmtRelease(stmt, tag, tagLength,
-                    propagateErrors, error);
-        }
-        if (!stmt->conn->closing && !stmt->parentStmt)
-            dpiHandleList__removeHandle(stmt->conn->openStmts,
-                    stmt->openSlotNum);
-        stmt->handle = NULL;
-    }
-
-    // if actual close fails, reset closing flag; again, this must be done
-    // while holding the lock (if in threaded mode) in order to avoid race
-    // conditions!
-    if (status < 0) {
-        if (stmt->env->threaded)
-            dpiMutex__acquire(stmt->env->mutex);
-        stmt->closing = 0;
-        if (stmt->env->threaded)
-            dpiMutex__release(stmt->env->mutex);
-    }
-
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__createBindVar() [INTERNAL]
-//   Create a bind variable given a value to bind.
-//-----------------------------------------------------------------------------
-static int dpiStmt__createBindVar(dpiStmt *stmt,
-        dpiNativeTypeNum nativeTypeNum, dpiData *data, dpiVar **var,
-        uint32_t pos, const char *name, uint32_t nameLength, dpiError *error)
-{
-    dpiOracleTypeNum oracleTypeNum;
-    dpiObjectType *objType;
-    dpiData *varData;
-    dpiVar *tempVar;
-    uint32_t size;
-    int status;
-
-    // determine the type (and size) of bind variable to create
-    size = 0;
-    objType = NULL;
-    switch (nativeTypeNum) {
-        case DPI_NATIVE_TYPE_INT64:
-        case DPI_NATIVE_TYPE_UINT64:
-        case DPI_NATIVE_TYPE_FLOAT:
-        case DPI_NATIVE_TYPE_DOUBLE:
-            oracleTypeNum = DPI_ORACLE_TYPE_NUMBER;
-            break;
-        case DPI_NATIVE_TYPE_BYTES:
-            oracleTypeNum = DPI_ORACLE_TYPE_VARCHAR;
-            size = data->value.asBytes.length;
-            break;
-        case DPI_NATIVE_TYPE_TIMESTAMP:
-            oracleTypeNum = DPI_ORACLE_TYPE_TIMESTAMP;
-            break;
-        case DPI_NATIVE_TYPE_INTERVAL_DS:
-            oracleTypeNum = DPI_ORACLE_TYPE_INTERVAL_DS;
-            break;
-        case DPI_NATIVE_TYPE_INTERVAL_YM:
-            oracleTypeNum = DPI_ORACLE_TYPE_INTERVAL_YM;
-            break;
-        case DPI_NATIVE_TYPE_OBJECT:
-            oracleTypeNum = DPI_ORACLE_TYPE_OBJECT;
-            if (data->value.asObject)
-                objType = data->value.asObject->type;
-            break;
-        case DPI_NATIVE_TYPE_ROWID:
-            oracleTypeNum = DPI_ORACLE_TYPE_ROWID;
-            break;
-        case DPI_NATIVE_TYPE_BOOLEAN:
-            oracleTypeNum = DPI_ORACLE_TYPE_BOOLEAN;
-            break;
-        default:
-            return dpiError__set(error, "create bind var",
-                    DPI_ERR_UNHANDLED_CONVERSION, 0, nativeTypeNum);
-    }
-
-    // create the variable and set its value
-    if (dpiVar__allocate(stmt->conn, oracleTypeNum, nativeTypeNum, 1, size, 1,
-            0, objType, &tempVar, &varData, error) < 0)
-        return DPI_FAILURE;
-
-    // copy value from source to target data
-    if (dpiVar__copyData(tempVar, 0, data, error) < 0)
-        return DPI_FAILURE;
-
-    // bind variable to statement
-    status = dpiStmt__bind(stmt, tempVar,  pos, name, nameLength, error);
-    dpiGen__setRefCount(tempVar, error, -1);
-    if (status == DPI_SUCCESS)
-        *var = tempVar;
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__createQueryVars() [INTERNAL]
-//   Create space for the number of query variables required to support the
-// query.
-//-----------------------------------------------------------------------------
-static int dpiStmt__createQueryVars(dpiStmt *stmt, dpiError *error)
-{
-    uint32_t numQueryVars, i;
-
-    // determine number of query variables
-    if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT,
-            (void*) &numQueryVars, 0, DPI_OCI_ATTR_PARAM_COUNT,
-            "get parameter count", error) < 0)
-        return DPI_FAILURE;
-
-    // clear the previous query vars if the number has changed
-    if (stmt->numQueryVars > 0 && stmt->numQueryVars != numQueryVars)
-        dpiStmt__clearQueryVars(stmt, error);
-
-    // allocate space for the query vars, if needed
-    if (numQueryVars != stmt->numQueryVars) {
-        if (dpiUtils__allocateMemory(numQueryVars, sizeof(dpiVar*), 1,
-                "allocate query vars", (void**) &stmt->queryVars, error) < 0)
-            return DPI_FAILURE;
-        if (dpiUtils__allocateMemory(numQueryVars, sizeof(dpiQueryInfo), 1,
-                "allocate query info", (void**) &stmt->queryInfo, error) < 0) {
-            dpiStmt__clearQueryVars(stmt, error);
-            return DPI_FAILURE;
-        }
-        stmt->numQueryVars = numQueryVars;
-        for (i = 0; i < numQueryVars; i++) {
-            if (dpiStmt__getQueryInfo(stmt, i + 1, &stmt->queryInfo[i],
-                    error) < 0) {
-                dpiStmt__clearQueryVars(stmt, error);
-                return DPI_FAILURE;
-            }
-        }
-    }
-
-    // indicate start of fetch
-    stmt->bufferRowIndex = stmt->fetchArraySize;
-    stmt->hasRowsToFetch = 1;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__define() [INTERNAL]
-//   Define the variable that will accept output from the statement in the
-// specified column. At this point the statement, position and variable are all
-// assumed to be valid.
-//-----------------------------------------------------------------------------
-static int dpiStmt__define(dpiStmt *stmt, uint32_t pos, dpiVar *var,
-        dpiError *error)
-{
-    void *defineHandle = NULL;
-    dpiQueryInfo *queryInfo;
-    int tempBool;
-
-    // no need to perform define if variable is unchanged
-    if (stmt->queryVars[pos - 1] == var)
-        return DPI_SUCCESS;
-
-    // for objects, the type specified must match the type in the database
-    queryInfo = &stmt->queryInfo[pos - 1];
-    if (var->objectType && queryInfo->typeInfo.objectType &&
-            var->objectType->tdo != queryInfo->typeInfo.objectType->tdo)
-        return dpiError__set(error, "check type", DPI_ERR_WRONG_TYPE,
-                var->objectType->schemaLength, var->objectType->schema,
-                var->objectType->nameLength, var->objectType->name,
-                queryInfo->typeInfo.objectType->schemaLength,
-                queryInfo->typeInfo.objectType->schema,
-                queryInfo->typeInfo.objectType->nameLength,
-                queryInfo->typeInfo.objectType->name);
-
-    // perform the define
-    if (stmt->env->versionInfo->versionNum < 12) {
-        if (dpiOci__defineByPos(stmt, &defineHandle, pos, var, error) < 0)
-            return DPI_FAILURE;
-    } else {
-        if (dpiOci__defineByPos2(stmt, &defineHandle, pos, var, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set the charset form if applicable
-    if (var->type->charsetForm != DPI_SQLCS_IMPLICIT) {
-        if (dpiOci__attrSet(defineHandle, DPI_OCI_HTYPE_DEFINE,
-                (void*) &var->type->charsetForm, 0, DPI_OCI_ATTR_CHARSET_FORM,
-                "set charset form", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // specify that the LOB length should be prefetched
-    if (var->nativeTypeNum == DPI_NATIVE_TYPE_LOB) {
-        tempBool = 1;
-        if (dpiOci__attrSet(defineHandle, DPI_OCI_HTYPE_DEFINE,
-                (void*) &tempBool, 0, DPI_OCI_ATTR_LOBPREFETCH_LENGTH,
-                "set lob prefetch length", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // define objects, if applicable
-    if (var->buffer.objectIndicator && dpiOci__defineObject(var, defineHandle,
-            error) < 0)
-        return DPI_FAILURE;
-
-    // register callback for dynamic defines
-    if (var->isDynamic && dpiOci__defineDynamic(var, defineHandle, error) < 0)
-        return DPI_FAILURE;
-
-    // remove previous variable and retain new one
-    if (stmt->queryVars[pos - 1])
-        dpiGen__setRefCount(stmt->queryVars[pos - 1], error, -1);
-    dpiGen__setRefCount(var, error, 1);
-    stmt->queryVars[pos - 1] = var;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__execute() [INTERNAL]
-//   Internal execution of statement.
-//-----------------------------------------------------------------------------
-static int dpiStmt__execute(dpiStmt *stmt, uint32_t numIters,
-        uint32_t mode, int reExecute, dpiError *error)
-{
-    uint16_t tempOffset;
-    uint32_t i, j, temp;
-    dpiData *data;
-    dpiVar *var;
-
-    // for all bound variables, transfer data from dpiData structure to Oracle
-    // buffer structures
-    for (i = 0; i < stmt->numBindVars; i++) {
-        var = stmt->bindVars[i].var;
-        if (var->isArray && numIters > 1)
-            return dpiError__set(error, "bind array var",
-                    DPI_ERR_ARRAY_VAR_NOT_SUPPORTED);
-        for (j = 0; j < var->buffer.maxArraySize; j++) {
-            data = &var->buffer.externalData[j];
-            if (dpiVar__setValue(var, &var->buffer, j, data, error) < 0)
-                return DPI_FAILURE;
-            if (var->dynBindBuffers)
-                var->dynBindBuffers[j].actualArraySize = 0;
-        }
-        if (stmt->isReturning || var->isDynamic)
-            var->error = error;
-    }
-
-    // for queries, set the OCI prefetch; the default value prevents an
-    // additional round trip for single row fetches while avoiding the overhead
-    // of copying from the OCI prefetch buffer to our own buffers for larger
-    // fetches
-    if (stmt->statementType == DPI_STMT_TYPE_SELECT) {
-        if (dpiOci__attrSet(stmt->handle, DPI_OCI_HTYPE_STMT,
-                &stmt->prefetchRows, sizeof(stmt->prefetchRows),
-                DPI_OCI_ATTR_PREFETCH_ROWS, "set prefetch rows", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // clear batch errors from any previous execution
-    dpiStmt__clearBatchErrors(stmt);
-
-    // adjust mode for scrollable cursors
-    if (stmt->scrollable)
-        mode |= DPI_OCI_STMT_SCROLLABLE_READONLY;
-
-    // perform execution
-    // re-execute statement for ORA-01007: variable not in select list
-    // drop statement from cache for all errors (except those which are due to
-    // invalid data which may be fixed in subsequent execution)
-    if (dpiOci__stmtExecute(stmt, numIters, mode, error) < 0) {
-        dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, &tempOffset, 0,
-                DPI_OCI_ATTR_PARSE_ERROR_OFFSET, "set parse offset", error);
-        error->buffer->offset = tempOffset;
-        switch (error->buffer->code) {
-            case 1007:
-                if (reExecute)
-                    return dpiStmt__reExecute(stmt, numIters, mode, error);
-                stmt->deleteFromCache = 1;
-                break;
-            case 1:
-            case 1400:
-            case 1438:
-            case 1461:
-            case 2290:
-            case 2291:
-            case 2292:
-            case 21525:
-                break;
-            default:
-                stmt->deleteFromCache = 1;
-        }
-        return DPI_FAILURE;
-    }
-
-    // for queries, disable prefetch for subsequent fetches in order to avoid
-    // the overhead of copying from prefetch buffers to our own buffers
-    if (stmt->statementType == DPI_STMT_TYPE_SELECT) {
-        temp = 0;
-        if (dpiOci__attrSet(stmt->handle, DPI_OCI_HTYPE_STMT, &temp,
-                sizeof(temp), DPI_OCI_ATTR_PREFETCH_ROWS,
-                "reset prefetch rows", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // for all bound variables, transfer data from Oracle buffer structures to
-    // dpiData structures; OCI doesn't provide a way of knowing if a variable
-    // is an out variable so do this for all of them when this is a possibility
-    if (stmt->isReturning || stmt->statementType == DPI_STMT_TYPE_BEGIN ||
-            stmt->statementType == DPI_STMT_TYPE_DECLARE ||
-            stmt->statementType == DPI_STMT_TYPE_CALL) {
-        for (i = 0; i < stmt->numBindVars; i++) {
-            var = stmt->bindVars[i].var;
-            for (j = 0; j < var->buffer.maxArraySize; j++) {
-                if (dpiVar__getValue(var, &var->buffer, j, 0, error) < 0)
-                    return DPI_FAILURE;
-            }
-            var->error = NULL;
-        }
-    }
-
-    // create query variables (if applicable) and reset row count to zero
-    if (stmt->statementType == DPI_STMT_TYPE_SELECT) {
-        stmt->rowCount = 0;
-        if (!(mode & DPI_MODE_EXEC_PARSE_ONLY) &&
-                dpiStmt__createQueryVars(stmt, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__fetch() [INTERNAL]
-//   Performs the actual fetch from Oracle.
-//-----------------------------------------------------------------------------
-static int dpiStmt__fetch(dpiStmt *stmt, dpiError *error)
-{
-    // perform any pre-fetch activities required
-    if (dpiStmt__beforeFetch(stmt, error) < 0)
-        return DPI_FAILURE;
-
-    // perform fetch
-    if (dpiOci__stmtFetch2(stmt, stmt->fetchArraySize, DPI_MODE_FETCH_NEXT, 0,
-            error) < 0)
-        return DPI_FAILURE;
-
-    // determine the number of rows fetched into buffers
-    if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT,
-            &stmt->bufferRowCount, 0, DPI_OCI_ATTR_ROWS_FETCHED,
-            "get rows fetched", error) < 0)
-        return DPI_FAILURE;
-
-    // set buffer row info
-    stmt->bufferMinRow = stmt->rowCount + 1;
-    stmt->bufferRowIndex = 0;
-
-    // perform post-fetch activities required
-    if (dpiStmt__postFetch(stmt, error) < 0)
-        return DPI_FAILURE;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__free() [INTERNAL]
-//   Free the memory associated with the statement.
-//-----------------------------------------------------------------------------
-void dpiStmt__free(dpiStmt *stmt, dpiError *error)
-{
-    dpiStmt__close(stmt, NULL, 0, 0, error);
-    if (stmt->parentStmt) {
-        dpiGen__setRefCount(stmt->parentStmt, error, -1);
-        stmt->parentStmt = NULL;
-    }
-    if (stmt->conn) {
-        dpiGen__setRefCount(stmt->conn, error, -1);
-        stmt->conn = NULL;
-    }
-    dpiUtils__freeMemory(stmt);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__getBatchErrors() [INTERNAL]
-//   Get batch errors after statement executed with batch errors enabled.
-//-----------------------------------------------------------------------------
-static int dpiStmt__getBatchErrors(dpiStmt *stmt, dpiError *error)
-{
-    void *batchErrorHandle, *localErrorHandle;
-    dpiError localError;
-    int overallStatus;
-    int32_t rowOffset;
-    uint32_t i;
-
-    // determine the number of batch errors that were found
-    if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT,
-            &stmt->numBatchErrors, 0, DPI_OCI_ATTR_NUM_DML_ERRORS,
-            "get batch error count", error) < 0)
-        return DPI_FAILURE;
-
-    // allocate memory for the batch errors
-    if (dpiUtils__allocateMemory(stmt->numBatchErrors, sizeof(dpiErrorBuffer),
-            1, "allocate errors", (void**) &stmt->batchErrors, error) < 0) {
-        stmt->numBatchErrors = 0;
-        return DPI_FAILURE;
-    }
-
-    // allocate error handle used for OCIParamGet()
-    if (dpiOci__handleAlloc(stmt->env->handle, &localErrorHandle,
-            DPI_OCI_HTYPE_ERROR, "allocate parameter error handle",
-            error) < 0) {
-        dpiStmt__clearBatchErrors(stmt);
-        return DPI_FAILURE;
-    }
-
-    // allocate error handle used for batch errors
-    if (dpiOci__handleAlloc(stmt->env->handle, &batchErrorHandle,
-            DPI_OCI_HTYPE_ERROR, "allocate batch error handle", error) < 0) {
-        dpiStmt__clearBatchErrors(stmt);
-        dpiOci__handleFree(localErrorHandle, DPI_OCI_HTYPE_ERROR);
-        return DPI_FAILURE;
-    }
-
-    // process each error
-    overallStatus = DPI_SUCCESS;
-    localError.buffer = error->buffer;
-    localError.env = error->env;
-    for (i = 0; i < stmt->numBatchErrors; i++) {
-
-        // get error handle for iteration
-        if (dpiOci__paramGet(error->handle, DPI_OCI_HTYPE_ERROR,
-                &batchErrorHandle, i, "get batch error", error) < 0) {
-            overallStatus = dpiError__set(error, "get batch error",
-                    DPI_ERR_INVALID_INDEX, i);
-            break;
-        }
-
-        // determine row offset
-        localError.handle = localErrorHandle;
-        if (dpiOci__attrGet(batchErrorHandle, DPI_OCI_HTYPE_ERROR, &rowOffset,
-                0, DPI_OCI_ATTR_DML_ROW_OFFSET, "get row offset",
-                &localError) < 0) {
-            overallStatus = dpiError__set(error, "get row offset",
-                    DPI_ERR_CANNOT_GET_ROW_OFFSET);
-            break;
-        }
-
-        // get error message
-        localError.buffer = &stmt->batchErrors[i];
-        localError.handle = batchErrorHandle;
-        dpiError__setFromOCI(&localError, DPI_OCI_ERROR, stmt->conn,
-                "get batch error");
-        if (error->buffer->errorNum) {
-            overallStatus = DPI_FAILURE;
-            break;
-        }
-        localError.buffer->fnName = error->buffer->fnName;
-        localError.buffer->offset = (uint32_t) rowOffset;
-
-    }
-
-    // cleanup
-    dpiOci__handleFree(localErrorHandle, DPI_OCI_HTYPE_ERROR);
-    dpiOci__handleFree(batchErrorHandle, DPI_OCI_HTYPE_ERROR);
-    if (overallStatus < 0)
-        dpiStmt__clearBatchErrors(stmt);
-    return overallStatus;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__getRowCount() [INTERNAL]
-//   Return the number of rows affected by the last DML executed (for insert,
-// update, delete and merge) or the number of rows fetched (for queries). In
-// all other cases, 0 is returned.
-//-----------------------------------------------------------------------------
-static int dpiStmt__getRowCount(dpiStmt *stmt, uint64_t *count,
-        dpiError *error)
-{
-    uint32_t rowCount32;
-
-    if (stmt->statementType == DPI_STMT_TYPE_SELECT)
-        *count = stmt->rowCount;
-    else if (stmt->statementType != DPI_STMT_TYPE_INSERT &&
-            stmt->statementType != DPI_STMT_TYPE_UPDATE &&
-            stmt->statementType != DPI_STMT_TYPE_DELETE &&
-            stmt->statementType != DPI_STMT_TYPE_MERGE &&
-            stmt->statementType != DPI_STMT_TYPE_CALL &&
-            stmt->statementType != DPI_STMT_TYPE_BEGIN &&
-            stmt->statementType != DPI_STMT_TYPE_DECLARE) {
-        *count = 0;
-    } else if (stmt->env->versionInfo->versionNum < 12) {
-        if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, &rowCount32, 0,
-                DPI_OCI_ATTR_ROW_COUNT, "get row count", error) < 0)
-            return DPI_FAILURE;
-        *count = rowCount32;
-    } else {
-        if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, count, 0,
-                DPI_OCI_ATTR_UB8_ROW_COUNT, "get row count", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__getQueryInfo() [INTERNAL]
-//   Get query information for the position in question.
-//-----------------------------------------------------------------------------
-static int dpiStmt__getQueryInfo(dpiStmt *stmt, uint32_t pos,
-        dpiQueryInfo *info, dpiError *error)
-{
-    void *param;
-    int status;
-
-    // acquire parameter descriptor
-    if (dpiOci__paramGet(stmt->handle, DPI_OCI_HTYPE_STMT, &param, pos,
-            "get parameter", error) < 0)
-        return DPI_FAILURE;
-
-    // acquire information from the parameter descriptor
-    status = dpiStmt__getQueryInfoFromParam(stmt, param, info, error);
-    dpiOci__descriptorFree(param, DPI_OCI_DTYPE_PARAM);
-    return status;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__getQueryInfoFromParam() [INTERNAL]
-//   Get query information from the parameter.
-//-----------------------------------------------------------------------------
-static int dpiStmt__getQueryInfoFromParam(dpiStmt *stmt, void *param,
-        dpiQueryInfo *info, dpiError *error)
-{
-    uint8_t ociNullOk;
-
-    // aquire name of item
-    if (dpiOci__attrGet(param, DPI_OCI_HTYPE_DESCRIBE, (void*) &info->name,
-            &info->nameLength, DPI_OCI_ATTR_NAME, "get name", error) < 0)
-        return DPI_FAILURE;
-
-    // acquire type information
-    if (dpiOracleType__populateTypeInfo(stmt->conn, param,
-            DPI_OCI_HTYPE_DESCRIBE, &info->typeInfo, error) < 0)
-        return DPI_FAILURE;
-
-    // acquire if column is permitted to be null
-    if (dpiOci__attrGet(param, DPI_OCI_HTYPE_DESCRIBE, (void*) &ociNullOk, 0,
-            DPI_OCI_ATTR_IS_NULL, "get null ok", error) < 0)
-        return DPI_FAILURE;
-    info->nullOk = ociNullOk;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__init() [INTERNAL]
-//   Initialize the statement for use. This is needed when preparing a
-// statement for use and when returning a REF cursor.
-//-----------------------------------------------------------------------------
-int dpiStmt__init(dpiStmt *stmt, dpiError *error)
-{
-    // get statement type
-    if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT,
-            (void*) &stmt->statementType, 0, DPI_OCI_ATTR_STMT_TYPE,
-            "get statement type", error) < 0)
-        return DPI_FAILURE;
-
-    // for queries, mark statement as having rows to fetch
-    if (stmt->statementType == DPI_STMT_TYPE_SELECT)
-        stmt->hasRowsToFetch = 1;
-
-    // otherwise, check if this is a RETURNING statement
-    else if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT,
-            (void*) &stmt->isReturning, 0, DPI_OCI_ATTR_STMT_IS_RETURNING,
-            "get is returning", error) < 0)
-        return DPI_FAILURE;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__postFetch() [INTERNAL]
-//   Performs the transformations required to convert Oracle data values into
-// C data values.
-//-----------------------------------------------------------------------------
-static int dpiStmt__postFetch(dpiStmt *stmt, dpiError *error)
-{
-    uint32_t i, j;
-    dpiVar *var;
-
-    for (i = 0; i < stmt->numQueryVars; i++) {
-        var = stmt->queryVars[i];
-        for (j = 0; j < stmt->bufferRowCount; j++) {
-            if (dpiVar__getValue(var, &var->buffer, j, 1, error) < 0)
-                return DPI_FAILURE;
-            if (var->type->requiresPreFetch)
-                var->requiresPreFetch = 1;
-        }
-        var->error = NULL;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__beforeFetch() [INTERNAL]
-//   Performs work that needs to be done prior to fetch for each variable. In
-// addition, variables are created if they do not already exist. A check is
-// also made to ensure that the variable has enough space to support a fetch
-// of the requested size.
-//-----------------------------------------------------------------------------
-static int dpiStmt__beforeFetch(dpiStmt *stmt, dpiError *error)
-{
-    dpiQueryInfo *queryInfo;
-    dpiData *data;
-    dpiVar *var;
-    uint32_t i;
-
-    if (!stmt->queryInfo && dpiStmt__createQueryVars(stmt, error) < 0)
-        return DPI_FAILURE;
-    for (i = 0; i < stmt->numQueryVars; i++) {
-        var = stmt->queryVars[i];
-        if (!var) {
-            queryInfo = &stmt->queryInfo[i];
-            if (dpiVar__allocate(stmt->conn, queryInfo->typeInfo.oracleTypeNum,
-                    queryInfo->typeInfo.defaultNativeTypeNum,
-                    stmt->fetchArraySize,
-                    queryInfo->typeInfo.clientSizeInBytes, 1, 0,
-                    queryInfo->typeInfo.objectType, &var, &data, error) < 0)
-                return DPI_FAILURE;
-            if (dpiStmt__define(stmt, i + 1, var, error) < 0)
-                return DPI_FAILURE;
-            dpiGen__setRefCount(var, error, -1);
-        }
-        var->error = error;
-        if (stmt->fetchArraySize > var->buffer.maxArraySize)
-            return dpiError__set(error, "check array size",
-                    DPI_ERR_ARRAY_SIZE_TOO_SMALL, var->buffer.maxArraySize);
-        if (var->requiresPreFetch && dpiVar__extendedPreFetch(var,
-                &var->buffer, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__prepare() [INTERNAL]
-//   Prepare a statement for execution.
-//-----------------------------------------------------------------------------
-int dpiStmt__prepare(dpiStmt *stmt, const char *sql, uint32_t sqlLength,
-        const char *tag, uint32_t tagLength, dpiError *error)
-{
-    if (sql && dpiDebugLevel & DPI_DEBUG_LEVEL_SQL)
-        dpiDebug__print("SQL %.*s\n", sqlLength, sql);
-    if (dpiOci__stmtPrepare2(stmt, sql, sqlLength, tag, tagLength, error) < 0)
-        return DPI_FAILURE;
-    if (dpiHandleList__addHandle(stmt->conn->openStmts, stmt,
-            &stmt->openSlotNum, error) < 0) {
-        dpiOci__stmtRelease(stmt, NULL, 0, 0, error);
-        stmt->handle = NULL;
-        return DPI_FAILURE;
-    }
-
-    return dpiStmt__init(stmt, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt__reExecute() [INTERNAL]
-//   Re-execute the statement after receiving the error ORA-01007: variable not
-// in select list. This takes place when one of the columns in a query is
-// dropped, but the original metadata is still being used because the query
-// statement was found in the statement cache.
-//-----------------------------------------------------------------------------
-static int dpiStmt__reExecute(dpiStmt *stmt, uint32_t numIters,
-        uint32_t mode, dpiError *error)
-{
-    void *origHandle, *newHandle;
-    uint32_t sqlLength, i;
-    dpiError localError;
-    dpiBindVar *bindVar;
-    dpiVar *var;
-    int status;
-    char *sql;
-
-    // acquire the statement that was previously prepared; if this cannot be
-    // determined, let the original error propagate
-    localError.buffer = error->buffer;
-    localError.env = error->env;
-    localError.handle = error->handle;
-    if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, (void*) &sql,
-            &sqlLength, DPI_OCI_ATTR_STATEMENT, "get statement",
-            &localError) < 0)
-        return DPI_FAILURE;
-
-    // prepare statement a second time before releasing the original statement;
-    // release the original statement and delete it from the statement cache
-    // so that it does not return with the invalid metadata; again, if this
-    // cannot be done, let the original error propagate
-    origHandle = stmt->handle;
-    status = dpiOci__stmtPrepare2(stmt, sql, sqlLength, NULL, 0, &localError);
-    newHandle = stmt->handle;
-    stmt->handle = origHandle;
-    stmt->deleteFromCache = 1;
-    if (dpiOci__stmtRelease(stmt, NULL, 0, 1, &localError) < 0 || status < 0)
-        return DPI_FAILURE;
-    stmt->handle = newHandle;
-    dpiStmt__clearBatchErrors(stmt);
-    dpiStmt__clearQueryVars(stmt, error);
-
-    // perform binds
-    for (i = 0; i < stmt->numBindVars; i++) {
-        bindVar = &stmt->bindVars[i];
-        if (!bindVar->var)
-            continue;
-        var = bindVar->var;
-        bindVar->var = NULL;
-        if (dpiStmt__bind(stmt, var, bindVar->pos, bindVar->name,
-                bindVar->nameLength, error) < 0) {
-            dpiGen__setRefCount(var, error, -1);
-            return DPI_FAILURE;
-        }
-    }
-
-    // now re-execute the statement
-    return dpiStmt__execute(stmt, numIters, mode, 0, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_addRef() [PUBLIC]
-//   Add a reference to the statement.
-//-----------------------------------------------------------------------------
-int dpiStmt_addRef(dpiStmt *stmt)
-{
-    return dpiGen__addRef(stmt, DPI_HTYPE_STMT, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_bindByName() [PUBLIC]
-//   Bind the variable by name.
-//-----------------------------------------------------------------------------
-int dpiStmt_bindByName(dpiStmt *stmt, const char *name, uint32_t nameLength,
-        dpiVar *var)
-{
-    dpiError error;
-    int status;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, name)
-    if (dpiGen__checkHandle(var, DPI_HTYPE_VAR, "bind by name", &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    status = dpiStmt__bind(stmt, var, 0, name, nameLength, &error);
-    return dpiGen__endPublicFn(stmt, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_bindByPos() [PUBLIC]
-//   Bind the variable by position.
-//-----------------------------------------------------------------------------
-int dpiStmt_bindByPos(dpiStmt *stmt, uint32_t pos, dpiVar *var)
-{
-    dpiError error;
-    int status;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(var, DPI_HTYPE_VAR, "bind by pos", &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    status = dpiStmt__bind(stmt, var, pos, NULL, 0, &error);
-    return dpiGen__endPublicFn(stmt, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_bindValueByName() [PUBLIC]
-//   Create a variable and bind it by name.
-//-----------------------------------------------------------------------------
-int dpiStmt_bindValueByName(dpiStmt *stmt, const char *name,
-        uint32_t nameLength, dpiNativeTypeNum nativeTypeNum, dpiData *data)
-{
-    dpiVar *var = NULL;
-    dpiError error;
-    int status;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, name)
-    DPI_CHECK_PTR_NOT_NULL(stmt, data)
-    status = dpiStmt__createBindVar(stmt, nativeTypeNum, data, &var, 0, name,
-            nameLength, &error);
-    return dpiGen__endPublicFn(stmt, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_bindValueByPos() [PUBLIC]
-//   Create a variable and bind it by position.
-//-----------------------------------------------------------------------------
-int dpiStmt_bindValueByPos(dpiStmt *stmt, uint32_t pos,
-        dpiNativeTypeNum nativeTypeNum, dpiData *data)
-{
-    dpiVar *var = NULL;
-    dpiError error;
-    int status;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, data)
-    status = dpiStmt__createBindVar(stmt, nativeTypeNum, data, &var, pos, NULL,
-            0, &error);
-    return dpiGen__endPublicFn(stmt, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_close() [PUBLIC]
-//   Close the statement so that it is no longer usable and all resources have
-// been released.
-//-----------------------------------------------------------------------------
-int dpiStmt_close(dpiStmt *stmt, const char *tag, uint32_t tagLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(stmt, tag)
-    status = dpiStmt__close(stmt, tag, tagLength, 1, &error);
-    return dpiGen__endPublicFn(stmt, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_define() [PUBLIC]
-//   Define the variable that will accept output from the cursor in the
-// specified column.
-//-----------------------------------------------------------------------------
-int dpiStmt_define(dpiStmt *stmt, uint32_t pos, dpiVar *var)
-{
-    dpiError error;
-    int status;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    if (!stmt->queryInfo && dpiStmt__createQueryVars(stmt, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    if (pos == 0 || pos > stmt->numQueryVars) {
-        dpiError__set(&error, "check query position",
-                DPI_ERR_QUERY_POSITION_INVALID, pos);
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    }
-    if (dpiGen__checkHandle(var, DPI_HTYPE_VAR, "check variable", &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-
-    status = dpiStmt__define(stmt, pos, var, &error);
-    return dpiGen__endPublicFn(stmt, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_defineValue() [PUBLIC]
-//   Define the type of data to use for output from the cursor in the specified
-// column. This implicitly creates a variable of the specified type and is
-// intended for subsequent use by dpiStmt_getQueryValue(), which makes use of
-// implicitly created variables.
-//-----------------------------------------------------------------------------
-int dpiStmt_defineValue(dpiStmt *stmt, uint32_t pos,
-        dpiOracleTypeNum oracleTypeNum, dpiNativeTypeNum nativeTypeNum,
-        uint32_t size, int sizeIsBytes, dpiObjectType *objType)
-{
-    dpiError error;
-    dpiData *data;
-    dpiVar *var;
-
-    // verify parameters
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    if (!stmt->queryInfo && dpiStmt__createQueryVars(stmt, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    if (pos == 0 || pos > stmt->numQueryVars) {
-        dpiError__set(&error, "check query position",
-                DPI_ERR_QUERY_POSITION_INVALID, pos);
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    }
-
-    // create a new variable of the specified type
-    if (dpiVar__allocate(stmt->conn, oracleTypeNum, nativeTypeNum,
-            stmt->fetchArraySize, size, sizeIsBytes, 0, objType, &var, &data,
-            &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    if (dpiStmt__define(stmt, pos, var, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    dpiGen__setRefCount(var, &error, -1);
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_execute() [PUBLIC]
-//   Execute a statement. If the statement has been executed before, however,
-// and this is a query, the describe information is already available so defer
-// execution until the first fetch.
-//-----------------------------------------------------------------------------
-int dpiStmt_execute(dpiStmt *stmt, dpiExecMode mode, uint32_t *numQueryColumns)
-{
-    uint32_t numIters;
-    dpiError error;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    numIters = (stmt->statementType == DPI_STMT_TYPE_SELECT) ? 0 : 1;
-    if (dpiStmt__execute(stmt, numIters, mode, 1, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    if (numQueryColumns)
-        *numQueryColumns = stmt->numQueryVars;
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_executeMany() [PUBLIC]
-//   Execute a statement multiple times. Queries are not supported. The bind
-// variables are checked to ensure that their maxArraySize is sufficient to
-// support this.
-//-----------------------------------------------------------------------------
-int dpiStmt_executeMany(dpiStmt *stmt, dpiExecMode mode, uint32_t numIters)
-{
-    dpiError error;
-    uint32_t i;
-
-    // verify statement is open
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-
-    // queries are not supported
-    if (stmt->statementType == DPI_STMT_TYPE_SELECT) {
-        dpiError__set(&error, "check statement type", DPI_ERR_NOT_SUPPORTED);
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    }
-
-    // batch errors and array DML row counts are only supported with DML
-    // statements (insert, update, delete and merge)
-    if ((mode & DPI_MODE_EXEC_BATCH_ERRORS ||
-                mode & DPI_MODE_EXEC_ARRAY_DML_ROWCOUNTS) &&
-            stmt->statementType != DPI_STMT_TYPE_INSERT &&
-            stmt->statementType != DPI_STMT_TYPE_UPDATE &&
-            stmt->statementType != DPI_STMT_TYPE_DELETE &&
-            stmt->statementType != DPI_STMT_TYPE_MERGE) {
-        dpiError__set(&error, "check mode", DPI_ERR_EXEC_MODE_ONLY_FOR_DML);
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    }
-
-    // ensure that all bind variables have a big enough maxArraySize to
-    // support this operation
-    for (i = 0; i < stmt->numBindVars; i++) {
-        if (stmt->bindVars[i].var->buffer.maxArraySize < numIters) {
-            dpiError__set(&error, "check array size",
-                    DPI_ERR_ARRAY_SIZE_TOO_SMALL,
-                    stmt->bindVars[i].var->buffer.maxArraySize);
-            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-        }
-    }
-
-    // perform execution
-    dpiStmt__clearBatchErrors(stmt);
-    if (dpiStmt__execute(stmt, numIters, mode, 0, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-
-    // handle batch errors if mode was specified
-    if (mode & DPI_MODE_EXEC_BATCH_ERRORS) {
-        if (dpiStmt__getBatchErrors(stmt, &error) < 0)
-            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    }
-
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_fetch() [PUBLIC]
-//   Fetch a row from the database.
-//-----------------------------------------------------------------------------
-int dpiStmt_fetch(dpiStmt *stmt, int *found, uint32_t *bufferRowIndex)
-{
-    dpiError error;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, found)
-    DPI_CHECK_PTR_NOT_NULL(stmt, bufferRowIndex)
-    if (stmt->bufferRowIndex >= stmt->bufferRowCount) {
-        if (stmt->hasRowsToFetch && dpiStmt__fetch(stmt, &error) < 0)
-            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-        if (stmt->bufferRowIndex >= stmt->bufferRowCount) {
-            *found = 0;
-            return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-        }
-    }
-    *found = 1;
-    *bufferRowIndex = stmt->bufferRowIndex;
-    stmt->bufferRowIndex++;
-    stmt->rowCount++;
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_fetchRows() [PUBLIC]
-//   Fetch rows into buffers and return the number of rows that were so
-// fetched. If there are still rows available in the buffer, no additional
-// fetch will take place.
-//-----------------------------------------------------------------------------
-int dpiStmt_fetchRows(dpiStmt *stmt, uint32_t maxRows,
-        uint32_t *bufferRowIndex, uint32_t *numRowsFetched, int *moreRows)
-{
-    dpiError error;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, bufferRowIndex)
-    DPI_CHECK_PTR_NOT_NULL(stmt, numRowsFetched)
-    DPI_CHECK_PTR_NOT_NULL(stmt, moreRows)
-    if (stmt->bufferRowIndex >= stmt->bufferRowCount) {
-        if (stmt->hasRowsToFetch && dpiStmt__fetch(stmt, &error) < 0)
-            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-        if (stmt->bufferRowIndex >= stmt->bufferRowCount) {
-            *moreRows = 0;
-            *bufferRowIndex = 0;
-            *numRowsFetched = 0;
-            return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-        }
-    }
-    *bufferRowIndex = stmt->bufferRowIndex;
-    *numRowsFetched = stmt->bufferRowCount - stmt->bufferRowIndex;
-    *moreRows = stmt->hasRowsToFetch;
-    if (*numRowsFetched > maxRows) {
-        *numRowsFetched = maxRows;
-        *moreRows = 1;
-    }
-    stmt->bufferRowIndex += *numRowsFetched;
-    stmt->rowCount += *numRowsFetched;
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getBatchErrorCount() [PUBLIC]
-//   Return the number of batch errors that took place during the last
-// execution of the statement.
-//-----------------------------------------------------------------------------
-int dpiStmt_getBatchErrorCount(dpiStmt *stmt, uint32_t *count)
-{
-    dpiError error;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, count)
-    *count = stmt->numBatchErrors;
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getBatchErrors() [PUBLIC]
-//   Return the batch errors that took place during the last execution of the
-// statement.
-//-----------------------------------------------------------------------------
-int dpiStmt_getBatchErrors(dpiStmt *stmt, uint32_t numErrors,
-        dpiErrorInfo *errors)
-{
-    dpiError error, tempError;
-    uint32_t i;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, errors)
-    if (numErrors < stmt->numBatchErrors) {
-        dpiError__set(&error, "check num errors", DPI_ERR_ARRAY_SIZE_TOO_SMALL,
-                numErrors);
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    }
-    for (i = 0; i < stmt->numBatchErrors; i++) {
-        tempError.buffer = &stmt->batchErrors[i];
-        dpiError__getInfo(&tempError, &errors[i]);
-    }
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getBindCount() [PUBLIC]
-//   Return the number of bind variables referenced in the prepared SQL. In
-// SQL statements this counts all bind variables but in PL/SQL statements
-// this counts only uniquely named bind variables.
-//-----------------------------------------------------------------------------
-int dpiStmt_getBindCount(dpiStmt *stmt, uint32_t *count)
-{
-    dpiError error;
-    int status;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, count)
-    status = dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, (void*) count,
-            0, DPI_OCI_ATTR_BIND_COUNT, "get bind count", &error);
-    return dpiGen__endPublicFn(stmt, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getBindNames() [PUBLIC]
-//   Return the unique names of the bind variables referenced in the prepared
-// SQL.
-//-----------------------------------------------------------------------------
-int dpiStmt_getBindNames(dpiStmt *stmt, uint32_t *numBindNames,
-        const char **bindNames, uint32_t *bindNameLengths)
-{
-    uint8_t bindNameLengthsBuffer[8], indNameLengthsBuffer[8], isDuplicate[8];
-    uint32_t startLoc, i, numThisPass, numActualBindNames;
-    char *bindNamesBuffer[8], *indNamesBuffer[8];
-    void *bindHandles[8];
-    int32_t numFound;
-    dpiError error;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, numBindNames)
-    DPI_CHECK_PTR_NOT_NULL(stmt, bindNames)
-    DPI_CHECK_PTR_NOT_NULL(stmt, bindNameLengths)
-    startLoc = 1;
-    numActualBindNames = 0;
-    while (1) {
-        if (dpiOci__stmtGetBindInfo(stmt, 8, startLoc, &numFound,
-                bindNamesBuffer, bindNameLengthsBuffer, indNamesBuffer,
-                indNameLengthsBuffer, isDuplicate, bindHandles, &error) < 0)
-            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-        if (numFound == 0)
-            break;
-        numThisPass = abs(numFound) - startLoc + 1;
-        if (numThisPass > 8)
-            numThisPass = 8;
-        for (i = 0; i < numThisPass; i++) {
-            startLoc++;
-            if (isDuplicate[i])
-                continue;
-            if (numActualBindNames == *numBindNames) {
-                dpiError__set(&error, "check num bind names",
-                        DPI_ERR_ARRAY_SIZE_TOO_SMALL, *numBindNames);
-                return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-            }
-            bindNames[numActualBindNames] = bindNamesBuffer[i];
-            bindNameLengths[numActualBindNames] = bindNameLengthsBuffer[i];
-            numActualBindNames++;
-        }
-        if (numFound > 0)
-            break;
-    }
-    *numBindNames = numActualBindNames;
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getFetchArraySize() [PUBLIC]
-//   Get the array size used for fetches.
-//-----------------------------------------------------------------------------
-int dpiStmt_getFetchArraySize(dpiStmt *stmt, uint32_t *arraySize)
-{
-    dpiError error;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, arraySize)
-    *arraySize = stmt->fetchArraySize;
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getImplicitResult() [PUBLIC]
-//   Return the next implicit result from the previously executed statement. If
-// no more implicit results exist, NULL is returned.
-//-----------------------------------------------------------------------------
-int dpiStmt_getImplicitResult(dpiStmt *stmt, dpiStmt **implicitResult)
-{
-    dpiStmt *tempStmt;
-    dpiError error;
-    void *handle;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, implicitResult)
-    if (dpiUtils__checkClientVersion(stmt->env->versionInfo, 12, 1,
-            &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    if (dpiOci__stmtGetNextResult(stmt, &handle, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    *implicitResult = NULL;
-    if (handle) {
-        if (dpiStmt__allocate(stmt->conn, 0, &tempStmt, &error) < 0)
-            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-        tempStmt->handle = handle;
-        dpiGen__setRefCount(stmt, &error, 1);
-        tempStmt->parentStmt = stmt;
-        if (dpiStmt__createQueryVars(tempStmt, &error) < 0) {
-            dpiStmt__free(tempStmt, &error);
-            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-        }
-        *implicitResult = tempStmt;
-    }
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getInfo() [PUBLIC]
-//   Return information about the statement in the provided structure.
-//-----------------------------------------------------------------------------
-int dpiStmt_getInfo(dpiStmt *stmt, dpiStmtInfo *info)
-{
-    dpiError error;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, info)
-    info->isQuery = (stmt->statementType == DPI_STMT_TYPE_SELECT);
-    info->isPLSQL = (stmt->statementType == DPI_STMT_TYPE_BEGIN ||
-            stmt->statementType == DPI_STMT_TYPE_DECLARE ||
-            stmt->statementType == DPI_STMT_TYPE_CALL);
-    info->isDDL = (stmt->statementType == DPI_STMT_TYPE_CREATE ||
-            stmt->statementType == DPI_STMT_TYPE_DROP ||
-            stmt->statementType == DPI_STMT_TYPE_ALTER);
-    info->isDML = (stmt->statementType == DPI_STMT_TYPE_INSERT ||
-            stmt->statementType == DPI_STMT_TYPE_UPDATE ||
-            stmt->statementType == DPI_STMT_TYPE_DELETE ||
-            stmt->statementType == DPI_STMT_TYPE_MERGE);
-    info->statementType = stmt->statementType;
-    info->isReturning = stmt->isReturning;
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getLastRowid() [PUBLIC]
-//   Returns the rowid of the last row that was affected by a DML statement. If
-// no rows were affected by the last statement executed or the last statement
-// executed was not a DML statement, NULL is returned.
-//-----------------------------------------------------------------------------
-int dpiStmt_getLastRowid(dpiStmt *stmt, dpiRowid **rowid)
-{
-    uint64_t rowCount;
-    uint32_t tempSize;
-    dpiError error;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, rowid)
-    *rowid = NULL;
-    if (stmt->statementType == DPI_STMT_TYPE_INSERT ||
-            stmt->statementType == DPI_STMT_TYPE_UPDATE ||
-            stmt->statementType == DPI_STMT_TYPE_DELETE ||
-            stmt->statementType == DPI_STMT_TYPE_MERGE) {
-        if (dpiStmt__getRowCount(stmt, &rowCount, &error) < 0)
-            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-        if (rowCount > 0) {
-            if (stmt->lastRowid) {
-                dpiGen__setRefCount(stmt->lastRowid, &error, -1);
-                stmt->lastRowid = NULL;
-            }
-            if (dpiRowid__allocate(stmt->conn, &stmt->lastRowid, &error) < 0)
-                return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-            if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT,
-                    stmt->lastRowid->handle, &tempSize, DPI_OCI_ATTR_ROWID,
-                    "get last rowid", &error) < 0)
-                return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-            if (tempSize)
-                *rowid = stmt->lastRowid;
-        }
-    }
-
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getNumQueryColumns() [PUBLIC]
-//   Returns the number of query columns associated with a statement. If the
-// statement does not refer to a query, 0 is returned.
-//-----------------------------------------------------------------------------
-int dpiStmt_getNumQueryColumns(dpiStmt *stmt, uint32_t *numQueryColumns)
-{
-    dpiError error;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, numQueryColumns)
-    if (stmt->statementType == DPI_STMT_TYPE_SELECT &&
-            stmt->numQueryVars == 0 &&
-            dpiStmt__createQueryVars(stmt, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    *numQueryColumns = stmt->numQueryVars;
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getOciAttr() [PUBLIC]
-//   Get the OCI attribute directly. This is intended for testing of attributes
-// not currently exposed by ODPI-C and should only be used for that purpose.
-//-----------------------------------------------------------------------------
-int dpiStmt_getOciAttr(dpiStmt *stmt, uint32_t attribute, dpiDataBuffer *value,
-        uint32_t *valueLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, value)
-    DPI_CHECK_PTR_NOT_NULL(stmt, valueLength)
-    status = dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, &value->asRaw,
-            valueLength, attribute, "generic get OCI attribute", &error);
-    return dpiGen__endPublicFn(stmt, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getPrefetchRows() [PUBLIC]
-//   Returns the number of rows that will be prefetched when a query is
-// executed.
-//-----------------------------------------------------------------------------
-int dpiStmt_getPrefetchRows(dpiStmt *stmt, uint32_t *numRows)
-{
-    dpiError error;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, numRows)
-    *numRows = stmt->prefetchRows;
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getQueryInfo() [PUBLIC]
-//   Get query information for the position in question.
-//-----------------------------------------------------------------------------
-int dpiStmt_getQueryInfo(dpiStmt *stmt, uint32_t pos, dpiQueryInfo *info)
-{
-    dpiError error;
-
-    // validate parameters
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, info)
-    if (!stmt->queryInfo && dpiStmt__createQueryVars(stmt, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    if (pos == 0 || pos > stmt->numQueryVars) {
-        dpiError__set(&error, "check query position",
-                DPI_ERR_QUERY_POSITION_INVALID, pos);
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    }
-
-    // copy query information from internal cache
-    memcpy(info, &stmt->queryInfo[pos - 1], sizeof(dpiQueryInfo));
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getQueryValue() [PUBLIC]
-//   Get value from query at specified position.
-//-----------------------------------------------------------------------------
-int dpiStmt_getQueryValue(dpiStmt *stmt, uint32_t pos,
-        dpiNativeTypeNum *nativeTypeNum, dpiData **data)
-{
-    dpiError error;
-    dpiVar *var;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, nativeTypeNum)
-    DPI_CHECK_PTR_NOT_NULL(stmt, data)
-    if (!stmt->queryVars) {
-        dpiError__set(&error, "check query vars", DPI_ERR_QUERY_NOT_EXECUTED);
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    }
-    if (pos == 0 || pos > stmt->numQueryVars) {
-        dpiError__set(&error, "check query position",
-                DPI_ERR_QUERY_POSITION_INVALID, pos);
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    }
-    var = stmt->queryVars[pos - 1];
-    if (!var || stmt->bufferRowIndex == 0 ||
-            stmt->bufferRowIndex > stmt->bufferRowCount) {
-        dpiError__set(&error, "check fetched row", DPI_ERR_NO_ROW_FETCHED);
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    }
-    *nativeTypeNum = var->nativeTypeNum;
-    *data = &var->buffer.externalData[stmt->bufferRowIndex - 1];
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getRowCount() [PUBLIC]
-//   Return the number of rows affected by the last DML executed (for insert,
-// update, delete and merge) or the number of rows fetched (for queries). In
-// all other cases, 0 is returned.
-//-----------------------------------------------------------------------------
-int dpiStmt_getRowCount(dpiStmt *stmt, uint64_t *count)
-{
-    dpiError error;
-    int status;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, count)
-    status = dpiStmt__getRowCount(stmt, count, &error);
-    return dpiGen__endPublicFn(stmt, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getRowCounts() [PUBLIC]
-//   Return the number of rows affected by each of the iterations executed
-// using dpiStmt_executeMany().
-//-----------------------------------------------------------------------------
-int dpiStmt_getRowCounts(dpiStmt *stmt, uint32_t *numRowCounts,
-        uint64_t **rowCounts)
-{
-    dpiError error;
-    int status;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, numRowCounts)
-    DPI_CHECK_PTR_NOT_NULL(stmt, rowCounts)
-    if (dpiUtils__checkClientVersion(stmt->env->versionInfo, 12, 1,
-            &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    status = dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, rowCounts,
-            numRowCounts, DPI_OCI_ATTR_DML_ROW_COUNT_ARRAY, "get row counts",
-            &error);
-    return dpiGen__endPublicFn(stmt, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_getSubscrQueryId() [PUBLIC]
-//   Return the query id for a query registered using this statement.
-//-----------------------------------------------------------------------------
-int dpiStmt_getSubscrQueryId(dpiStmt *stmt, uint64_t *queryId)
-{
-    dpiError error;
-    int status;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, queryId)
-    status = dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, queryId, 0,
-            DPI_OCI_ATTR_CQ_QUERYID, "get query id", &error);
-    return dpiGen__endPublicFn(stmt, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_release() [PUBLIC]
-//   Release a reference to the statement.
-//-----------------------------------------------------------------------------
-int dpiStmt_release(dpiStmt *stmt)
-{
-    return dpiGen__release(stmt, DPI_HTYPE_STMT, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_scroll() [PUBLIC]
-//   Scroll to the specified location in the cursor.
-//-----------------------------------------------------------------------------
-int dpiStmt_scroll(dpiStmt *stmt, dpiFetchMode mode, int32_t offset,
-        int32_t rowCountOffset)
-{
-    uint32_t numRows, currentPosition;
-    uint64_t desiredRow = 0;
-    dpiError error;
-
-    // make sure the cursor is open
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-
-    // validate mode; determine desired row to fetch
-    switch (mode) {
-        case DPI_MODE_FETCH_NEXT:
-            desiredRow = stmt->rowCount + rowCountOffset + 1;
-            break;
-        case DPI_MODE_FETCH_PRIOR:
-            desiredRow = stmt->rowCount + rowCountOffset - 1;
-            break;
-        case DPI_MODE_FETCH_FIRST:
-            desiredRow = 1;
-            break;
-        case DPI_MODE_FETCH_LAST:
-            break;
-        case DPI_MODE_FETCH_ABSOLUTE:
-            desiredRow = (uint64_t) offset;
-            break;
-        case DPI_MODE_FETCH_RELATIVE:
-            desiredRow = stmt->rowCount + rowCountOffset + offset;
-            offset = (int32_t) (desiredRow -
-                    (stmt->bufferMinRow + stmt->bufferRowCount - 1));
-            break;
-        default:
-            dpiError__set(&error, "scroll mode", DPI_ERR_NOT_SUPPORTED);
-            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    }
-
-    // determine if a fetch is actually required; "last" is always fetched
-    if (mode != DPI_MODE_FETCH_LAST && desiredRow >= stmt->bufferMinRow &&
-            desiredRow < stmt->bufferMinRow + stmt->bufferRowCount) {
-        stmt->bufferRowIndex = (uint32_t) (desiredRow - stmt->bufferMinRow);
-        stmt->rowCount = desiredRow - 1;
-        return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-    }
-
-    // perform any pre-fetch activities required
-    if (dpiStmt__beforeFetch(stmt, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-
-    // perform fetch; when fetching the last row, only fetch a single row
-    numRows = (mode == DPI_MODE_FETCH_LAST) ? 1 : stmt->fetchArraySize;
-    if (dpiOci__stmtFetch2(stmt, numRows, mode, offset, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-
-    // determine the number of rows actually fetched
-    if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT,
-            &stmt->bufferRowCount, 0, DPI_OCI_ATTR_ROWS_FETCHED,
-            "get rows fetched", &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-
-    // check that we haven't gone outside of the result set
-    if (stmt->bufferRowCount == 0) {
-        if (mode != DPI_MODE_FETCH_FIRST && mode != DPI_MODE_FETCH_LAST) {
-            dpiError__set(&error, "check result set bounds",
-                    DPI_ERR_SCROLL_OUT_OF_RS);
-            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-        }
-        stmt->hasRowsToFetch = 0;
-        stmt->rowCount = 0;
-        stmt->bufferRowIndex = 0;
-        stmt->bufferMinRow = 0;
-        return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-    }
-
-    // determine the current position of the cursor
-    if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, &currentPosition, 0,
-            DPI_OCI_ATTR_CURRENT_POSITION, "get current pos", &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-
-    // reset buffer row index and row count
-    stmt->rowCount = currentPosition - stmt->bufferRowCount;
-    stmt->bufferMinRow = stmt->rowCount + 1;
-    stmt->bufferRowIndex = 0;
-
-    // perform post-fetch activities required
-    if (dpiStmt__postFetch(stmt, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_setFetchArraySize() [PUBLIC]
-//   Set the array size used for fetches. Using a value of zero will select the
-// default value. A check is made to ensure that all defined variables have
-// sufficient space to support the array size.
-//-----------------------------------------------------------------------------
-int dpiStmt_setFetchArraySize(dpiStmt *stmt, uint32_t arraySize)
-{
-    dpiError error;
-    dpiVar *var;
-    uint32_t i;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    if (arraySize == 0)
-        arraySize = DPI_DEFAULT_FETCH_ARRAY_SIZE;
-    for (i = 0; i < stmt->numQueryVars; i++) {
-        var = stmt->queryVars[i];
-        if (var && var->buffer.maxArraySize < arraySize) {
-            dpiError__set(&error, "check array size",
-                    DPI_ERR_ARRAY_SIZE_TOO_BIG, arraySize);
-            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-        }
-    }
-    stmt->fetchArraySize = arraySize;
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_setOciAttr() [PUBLIC]
-//   Set the OCI attribute directly. This is intended for testing of attributes
-// not currently exposed by ODPI-C and should only be used for that purpose.
-//-----------------------------------------------------------------------------
-int dpiStmt_setOciAttr(dpiStmt *stmt, uint32_t attribute, void *value,
-        uint32_t valueLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(stmt, value)
-
-    status = dpiOci__attrSet(stmt->handle, DPI_OCI_HTYPE_STMT, value,
-            valueLength, attribute, "generic set OCI attribute", &error);
-    return dpiGen__endPublicFn(stmt, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_setPrefetchRows() [PUBLIC]
-//   Set the number of rows to prefetch when a query is executed.
-//-----------------------------------------------------------------------------
-int dpiStmt_setPrefetchRows(dpiStmt *stmt, uint32_t numRows)
-{
-    dpiError error;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    stmt->prefetchRows = numRows;
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiStmt_deleteFromCache() [PUBLIC]
-//   Excludes the associated SQL statement from the statement cache. If the SQL
-// statment was not already in the cache, it will not be added.
-//-----------------------------------------------------------------------------
-int dpiStmt_deleteFromCache(dpiStmt *stmt)
-{
-    dpiError error;
-
-    if (dpiStmt__check(stmt, __func__, &error) < 0)
-        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
-    stmt->deleteFromCache = 1;
-    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiStmt.h ./odpi/src/dpiStmt.h
--- patched-godror/odpi/src/dpiStmt.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiStmt.h	2024-05-14 14:55:13
@@ -0,0 +1,2009 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiStmt.c
+//   Implementation of statements (cursors).
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+// forward declarations of internal functions only used in this file
+static int dpiStmt__getQueryInfo(dpiStmt *stmt, uint32_t pos,
+        dpiQueryInfo *info, dpiError *error);
+static int dpiStmt__getQueryInfoFromParam(dpiStmt *stmt, void *param,
+        dpiQueryInfo *info, dpiError *error);
+static int dpiStmt__postFetch(dpiStmt *stmt, dpiError *error);
+static int dpiStmt__beforeFetch(dpiStmt *stmt, dpiError *error);
+static int dpiStmt__reExecute(dpiStmt *stmt, uint32_t numIters,
+        uint32_t mode, dpiError *error);
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__allocate() [INTERNAL]
+//   Create a new statement object and return it. In case of error NULL is
+// returned.
+//-----------------------------------------------------------------------------
+int dpiStmt__allocate(dpiConn *conn, int scrollable, dpiStmt **stmt,
+        dpiError *error)
+{
+    dpiStmt *tempStmt;
+
+    *stmt = NULL;
+    if (dpiGen__allocate(DPI_HTYPE_STMT, conn->env, (void**) &tempStmt,
+            error) < 0)
+        return DPI_FAILURE;
+    dpiGen__setRefCount(conn, error, 1);
+    tempStmt->conn = conn;
+    tempStmt->fetchArraySize = DPI_DEFAULT_FETCH_ARRAY_SIZE;
+    tempStmt->prefetchRows = DPI_DEFAULT_PREFETCH_ROWS;
+    tempStmt->scrollable = scrollable;
+    *stmt = tempStmt;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__bind() [INTERNAL]
+//   Bind the variable to the statement using either a position or a name. A
+// reference to the variable will be retained.
+//-----------------------------------------------------------------------------
+static int dpiStmt__bind(dpiStmt *stmt, dpiVar *var, uint32_t pos,
+        const char *name, uint32_t nameLength, dpiError *error)
+{
+    dpiBindVar *bindVars, *entry = NULL;
+    int found, dynamicBind, status;
+    void *bindHandle = NULL;
+    uint32_t i;
+
+    // a zero length name is not supported
+    if (pos == 0 && nameLength == 0)
+        return dpiError__set(error, "bind zero length name",
+                DPI_ERR_NOT_SUPPORTED);
+
+    // prevent attempts to bind a statement to itself
+    if (var->type->oracleTypeNum == DPI_ORACLE_TYPE_STMT) {
+        for (i = 0; i < var->buffer.maxArraySize; i++) {
+            if (var->buffer.externalData[i].value.asStmt == stmt) {
+                return dpiError__set(error, "bind to self",
+                        DPI_ERR_NOT_SUPPORTED);
+            }
+        }
+    }
+
+    // check to see if the bind position or name has already been bound
+    found = 0;
+    for (i = 0; i < stmt->numBindVars; i++) {
+        entry = &stmt->bindVars[i];
+        if (entry->pos == pos && entry->nameLength == nameLength) {
+            if (nameLength > 0 && strncmp(entry->name, name, nameLength) != 0)
+                continue;
+            found = 1;
+            break;
+        }
+    }
+
+    // if already found, use that entry
+    if (found) {
+
+        // if already bound, no need to bind a second time
+        if (entry->var == var)
+            return DPI_SUCCESS;
+
+        // otherwise, release previously bound variable, if applicable
+        else if (entry->var) {
+            dpiGen__setRefCount(entry->var, error, -1);
+            entry->var = NULL;
+        }
+
+    // if not found, add to the list of bind variables
+    } else {
+
+        // allocate memory for additional bind variables, if needed
+        if (stmt->numBindVars == stmt->allocatedBindVars) {
+            if (dpiUtils__allocateMemory(stmt->allocatedBindVars + 8,
+                    sizeof(dpiBindVar), 1, "allocate bind vars",
+                    (void**) &bindVars, error) < 0)
+                return DPI_FAILURE;
+            if (stmt->bindVars) {
+                for (i = 0; i < stmt->numBindVars; i++)
+                    bindVars[i] = stmt->bindVars[i];
+                dpiUtils__freeMemory(stmt->bindVars);
+            }
+            stmt->bindVars = bindVars;
+            stmt->allocatedBindVars += 8;
+        }
+
+        // add to the list of bind variables
+        entry = &stmt->bindVars[stmt->numBindVars];
+        entry->var = NULL;
+        entry->pos = pos;
+        if (name) {
+            if (dpiUtils__allocateMemory(1, nameLength, 0,
+                    "allocate memory for name", (void**) &entry->name,
+                    error) < 0)
+                return DPI_FAILURE;
+            entry->nameLength = nameLength;
+            memcpy( (void*) entry->name, name, nameLength);
+        }
+        stmt->numBindVars++;
+
+    }
+
+    // for PL/SQL where the maxSize is greater than 32K, adjust the variable
+    // so that LOBs are used internally
+    if (var->isDynamic && (stmt->statementType == DPI_STMT_TYPE_BEGIN ||
+            stmt->statementType == DPI_STMT_TYPE_DECLARE ||
+            stmt->statementType == DPI_STMT_TYPE_CALL)) {
+        if (dpiVar__convertToLob(var, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // perform actual bind
+    dpiGen__setRefCount(var, error, 1);
+    entry->var = var;
+    dynamicBind = stmt->isReturning || var->isDynamic;
+    if (pos > 0) {
+        if (stmt->env->versionInfo->versionNum < 12)
+            status = dpiOci__bindByPos(stmt, &bindHandle, pos, dynamicBind,
+                    var, error);
+        else status = dpiOci__bindByPos2(stmt, &bindHandle, pos, dynamicBind,
+                var, error);
+    } else {
+        if (stmt->env->versionInfo->versionNum < 12)
+            status = dpiOci__bindByName(stmt, &bindHandle, name,
+                    (int32_t) nameLength, dynamicBind, var, error);
+        else status = dpiOci__bindByName2(stmt, &bindHandle, name,
+                (int32_t) nameLength, dynamicBind, var, error);
+    }
+
+    // attempt to improve message "ORA-01036: illegal variable name/number"
+    if (status < 0) {
+        if (error->buffer->code == 1036) {
+            if (stmt->statementType == DPI_STMT_TYPE_CREATE ||
+                    stmt->statementType == DPI_STMT_TYPE_DROP ||
+                    stmt->statementType == DPI_STMT_TYPE_ALTER)
+                dpiError__set(error, error->buffer->action,
+                        DPI_ERR_NO_BIND_VARS_IN_DDL);
+        }
+        return DPI_FAILURE;
+    }
+
+    // set the charset form if applicable
+    if (var->type->charsetForm != DPI_SQLCS_IMPLICIT) {
+        if (dpiOci__attrSet(bindHandle, DPI_OCI_HTYPE_BIND,
+                (void*) &var->type->charsetForm, 0, DPI_OCI_ATTR_CHARSET_FORM,
+                "set charset form", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set the max data size, if applicable
+    if (var->type->sizeInBytes == 0 && !var->isDynamic) {
+        if (dpiOci__attrSet(bindHandle, DPI_OCI_HTYPE_BIND,
+                (void*) &var->sizeInBytes, 0, DPI_OCI_ATTR_MAXDATA_SIZE,
+                "set max data size", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // bind object, if applicable
+    if (var->buffer.objectIndicator &&
+            dpiOci__bindObject(var, bindHandle, error) < 0)
+        return DPI_FAILURE;
+
+    // setup dynamic bind, if applicable
+    if (dynamicBind && dpiOci__bindDynamic(var, bindHandle, error) < 0)
+        return DPI_FAILURE;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__check() [INTERNAL]
+//   Determine if the statement is open and available for use.
+//-----------------------------------------------------------------------------
+static int dpiStmt__check(dpiStmt *stmt, const char *fnName, dpiError *error)
+{
+    if (dpiGen__startPublicFn(stmt, DPI_HTYPE_STMT, fnName, error) < 0)
+        return DPI_FAILURE;
+    if (!stmt->handle || (stmt->parentStmt && !stmt->parentStmt->handle))
+        return dpiError__set(error, "check closed", DPI_ERR_STMT_CLOSED);
+    if (dpiConn__checkConnected(stmt->conn, error) < 0)
+        return DPI_FAILURE;
+    if (stmt->statementType == 0 && dpiStmt__init(stmt, error) < 0)
+        return DPI_FAILURE;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__clearBatchErrors() [INTERNAL]
+//   Clear the batch errors associated with the statement.
+//-----------------------------------------------------------------------------
+static void dpiStmt__clearBatchErrors(dpiStmt *stmt)
+{
+    if (stmt->batchErrors) {
+        dpiUtils__freeMemory(stmt->batchErrors);
+        stmt->batchErrors = NULL;
+    }
+    stmt->numBatchErrors = 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__clearBindVars() [INTERNAL]
+//   Clear the bind variables associated with the statement.
+//-----------------------------------------------------------------------------
+static void dpiStmt__clearBindVars(dpiStmt *stmt, dpiError *error)
+{
+    uint32_t i;
+
+    if (stmt->bindVars) {
+        for (i = 0; i < stmt->numBindVars; i++) {
+            if (stmt->bindVars[i].var)
+                dpiGen__setRefCount(stmt->bindVars[i].var, error, -1);
+            if (stmt->bindVars[i].name)
+                dpiUtils__freeMemory( (void*) stmt->bindVars[i].name);
+        }
+        dpiUtils__freeMemory(stmt->bindVars);
+        stmt->bindVars = NULL;
+    }
+    stmt->numBindVars = 0;
+    stmt->allocatedBindVars = 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__clearQueryVars() [INTERNAL]
+//   Clear the query variables associated with the statement.
+//-----------------------------------------------------------------------------
+static void dpiStmt__clearQueryVars(dpiStmt *stmt, dpiError *error)
+{
+    uint32_t i;
+
+    if (stmt->queryVars) {
+        for (i = 0; i < stmt->numQueryVars; i++) {
+            if (stmt->queryVars[i]) {
+                dpiGen__setRefCount(stmt->queryVars[i], error, -1);
+                stmt->queryVars[i] = NULL;
+            }
+            if (stmt->queryInfo[i].typeInfo.objectType) {
+                dpiGen__setRefCount(stmt->queryInfo[i].typeInfo.objectType,
+                        error, -1);
+                stmt->queryInfo[i].typeInfo.objectType = NULL;
+            }
+        }
+        dpiUtils__freeMemory(stmt->queryVars);
+        stmt->queryVars = NULL;
+    }
+    if (stmt->queryInfo) {
+        dpiUtils__freeMemory(stmt->queryInfo);
+        stmt->queryInfo = NULL;
+    }
+    stmt->numQueryVars = 0;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__close() [INTERNAL]
+//   Internal method used for closing the statement. If the statement is marked
+// as needing to be dropped from the statement cache that is done as well. This
+// is called from dpiStmt_close() where errors are expected to be propagated
+// and from dpiStmt__free() where errors are ignored.
+//-----------------------------------------------------------------------------
+int dpiStmt__close(dpiStmt *stmt, const char *tag, uint32_t tagLength,
+        int propagateErrors, dpiError *error)
+{
+    int closing, status = DPI_SUCCESS;
+
+    // determine whether statement is already being closed and if not, mark
+    // statement as being closed; this MUST be done while holding the lock (if
+    // in threaded mode) to avoid race conditions!
+    if (stmt->env->threaded)
+        dpiMutex__acquire(stmt->env->mutex);
+    closing = stmt->closing;
+    stmt->closing = 1;
+    if (stmt->env->threaded)
+        dpiMutex__release(stmt->env->mutex);
+
+    // if statement is already being closed, nothing needs to be done
+    if (closing)
+        return DPI_SUCCESS;
+
+    // perform actual work of closing statement
+    dpiStmt__clearBatchErrors(stmt);
+    dpiStmt__clearBindVars(stmt, error);
+    dpiStmt__clearQueryVars(stmt, error);
+    if (stmt->lastRowid)
+        dpiGen__setRefCount(stmt->lastRowid, error, -1);
+    if (stmt->handle) {
+        if (stmt->parentStmt) {
+            dpiGen__setRefCount(stmt->parentStmt, error, -1);
+            stmt->parentStmt = NULL;
+        } else if (!stmt->conn->deadSession && stmt->conn->handle) {
+            if (stmt->isOwned)
+                dpiOci__handleFree(stmt->handle, DPI_OCI_HTYPE_STMT);
+            else status = dpiOci__stmtRelease(stmt, tag, tagLength,
+                    propagateErrors, error);
+        }
+        if (!stmt->conn->closing && !stmt->parentStmt)
+            dpiHandleList__removeHandle(stmt->conn->openStmts,
+                    stmt->openSlotNum);
+        stmt->handle = NULL;
+    }
+
+    // if actual close fails, reset closing flag; again, this must be done
+    // while holding the lock (if in threaded mode) in order to avoid race
+    // conditions!
+    if (status < 0) {
+        if (stmt->env->threaded)
+            dpiMutex__acquire(stmt->env->mutex);
+        stmt->closing = 0;
+        if (stmt->env->threaded)
+            dpiMutex__release(stmt->env->mutex);
+    }
+
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__createBindVar() [INTERNAL]
+//   Create a bind variable given a value to bind.
+//-----------------------------------------------------------------------------
+static int dpiStmt__createBindVar(dpiStmt *stmt,
+        dpiNativeTypeNum nativeTypeNum, dpiData *data, dpiVar **var,
+        uint32_t pos, const char *name, uint32_t nameLength, dpiError *error)
+{
+    dpiOracleTypeNum oracleTypeNum;
+    dpiObjectType *objType;
+    dpiData *varData;
+    dpiVar *tempVar;
+    uint32_t size;
+    int status;
+
+    // determine the type (and size) of bind variable to create
+    size = 0;
+    objType = NULL;
+    switch (nativeTypeNum) {
+        case DPI_NATIVE_TYPE_INT64:
+        case DPI_NATIVE_TYPE_UINT64:
+        case DPI_NATIVE_TYPE_FLOAT:
+        case DPI_NATIVE_TYPE_DOUBLE:
+            oracleTypeNum = DPI_ORACLE_TYPE_NUMBER;
+            break;
+        case DPI_NATIVE_TYPE_BYTES:
+            oracleTypeNum = DPI_ORACLE_TYPE_VARCHAR;
+            size = data->value.asBytes.length;
+            break;
+        case DPI_NATIVE_TYPE_TIMESTAMP:
+            oracleTypeNum = DPI_ORACLE_TYPE_TIMESTAMP;
+            break;
+        case DPI_NATIVE_TYPE_INTERVAL_DS:
+            oracleTypeNum = DPI_ORACLE_TYPE_INTERVAL_DS;
+            break;
+        case DPI_NATIVE_TYPE_INTERVAL_YM:
+            oracleTypeNum = DPI_ORACLE_TYPE_INTERVAL_YM;
+            break;
+        case DPI_NATIVE_TYPE_OBJECT:
+            oracleTypeNum = DPI_ORACLE_TYPE_OBJECT;
+            if (data->value.asObject)
+                objType = data->value.asObject->type;
+            break;
+        case DPI_NATIVE_TYPE_ROWID:
+            oracleTypeNum = DPI_ORACLE_TYPE_ROWID;
+            break;
+        case DPI_NATIVE_TYPE_BOOLEAN:
+            oracleTypeNum = DPI_ORACLE_TYPE_BOOLEAN;
+            break;
+        default:
+            return dpiError__set(error, "create bind var",
+                    DPI_ERR_UNHANDLED_CONVERSION, 0, nativeTypeNum);
+    }
+
+    // create the variable and set its value
+    if (dpiVar__allocate(stmt->conn, oracleTypeNum, nativeTypeNum, 1, size, 1,
+            0, objType, &tempVar, &varData, error) < 0)
+        return DPI_FAILURE;
+
+    // copy value from source to target data
+    if (dpiVar__copyData(tempVar, 0, data, error) < 0)
+        return DPI_FAILURE;
+
+    // bind variable to statement
+    status = dpiStmt__bind(stmt, tempVar,  pos, name, nameLength, error);
+    dpiGen__setRefCount(tempVar, error, -1);
+    if (status == DPI_SUCCESS)
+        *var = tempVar;
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__createQueryVars() [INTERNAL]
+//   Create space for the number of query variables required to support the
+// query.
+//-----------------------------------------------------------------------------
+static int dpiStmt__createQueryVars(dpiStmt *stmt, dpiError *error)
+{
+    uint32_t numQueryVars, i;
+
+    // determine number of query variables
+    if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT,
+            (void*) &numQueryVars, 0, DPI_OCI_ATTR_PARAM_COUNT,
+            "get parameter count", error) < 0)
+        return DPI_FAILURE;
+
+    // clear the previous query vars if the number has changed
+    if (stmt->numQueryVars > 0 && stmt->numQueryVars != numQueryVars)
+        dpiStmt__clearQueryVars(stmt, error);
+
+    // allocate space for the query vars, if needed
+    if (numQueryVars != stmt->numQueryVars) {
+        if (dpiUtils__allocateMemory(numQueryVars, sizeof(dpiVar*), 1,
+                "allocate query vars", (void**) &stmt->queryVars, error) < 0)
+            return DPI_FAILURE;
+        if (dpiUtils__allocateMemory(numQueryVars, sizeof(dpiQueryInfo), 1,
+                "allocate query info", (void**) &stmt->queryInfo, error) < 0) {
+            dpiStmt__clearQueryVars(stmt, error);
+            return DPI_FAILURE;
+        }
+        stmt->numQueryVars = numQueryVars;
+        for (i = 0; i < numQueryVars; i++) {
+            if (dpiStmt__getQueryInfo(stmt, i + 1, &stmt->queryInfo[i],
+                    error) < 0) {
+                dpiStmt__clearQueryVars(stmt, error);
+                return DPI_FAILURE;
+            }
+        }
+    }
+
+    // indicate start of fetch
+    stmt->bufferRowIndex = stmt->fetchArraySize;
+    stmt->hasRowsToFetch = 1;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__define() [INTERNAL]
+//   Define the variable that will accept output from the statement in the
+// specified column. At this point the statement, position and variable are all
+// assumed to be valid.
+//-----------------------------------------------------------------------------
+static int dpiStmt__define(dpiStmt *stmt, uint32_t pos, dpiVar *var,
+        dpiError *error)
+{
+    void *defineHandle = NULL;
+    dpiQueryInfo *queryInfo;
+    int tempBool;
+
+    // no need to perform define if variable is unchanged
+    if (stmt->queryVars[pos - 1] == var)
+        return DPI_SUCCESS;
+
+    // for objects, the type specified must match the type in the database
+    queryInfo = &stmt->queryInfo[pos - 1];
+    if (var->objectType && queryInfo->typeInfo.objectType &&
+            var->objectType->tdo != queryInfo->typeInfo.objectType->tdo)
+        return dpiError__set(error, "check type", DPI_ERR_WRONG_TYPE,
+                var->objectType->schemaLength, var->objectType->schema,
+                var->objectType->nameLength, var->objectType->name,
+                queryInfo->typeInfo.objectType->schemaLength,
+                queryInfo->typeInfo.objectType->schema,
+                queryInfo->typeInfo.objectType->nameLength,
+                queryInfo->typeInfo.objectType->name);
+
+    // perform the define
+    if (stmt->env->versionInfo->versionNum < 12) {
+        if (dpiOci__defineByPos(stmt, &defineHandle, pos, var, error) < 0)
+            return DPI_FAILURE;
+    } else {
+        if (dpiOci__defineByPos2(stmt, &defineHandle, pos, var, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set the charset form if applicable
+    if (var->type->charsetForm != DPI_SQLCS_IMPLICIT) {
+        if (dpiOci__attrSet(defineHandle, DPI_OCI_HTYPE_DEFINE,
+                (void*) &var->type->charsetForm, 0, DPI_OCI_ATTR_CHARSET_FORM,
+                "set charset form", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // specify that the LOB length should be prefetched
+    if (var->nativeTypeNum == DPI_NATIVE_TYPE_LOB) {
+        tempBool = 1;
+        if (dpiOci__attrSet(defineHandle, DPI_OCI_HTYPE_DEFINE,
+                (void*) &tempBool, 0, DPI_OCI_ATTR_LOBPREFETCH_LENGTH,
+                "set lob prefetch length", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // define objects, if applicable
+    if (var->buffer.objectIndicator && dpiOci__defineObject(var, defineHandle,
+            error) < 0)
+        return DPI_FAILURE;
+
+    // register callback for dynamic defines
+    if (var->isDynamic && dpiOci__defineDynamic(var, defineHandle, error) < 0)
+        return DPI_FAILURE;
+
+    // remove previous variable and retain new one
+    if (stmt->queryVars[pos - 1])
+        dpiGen__setRefCount(stmt->queryVars[pos - 1], error, -1);
+    dpiGen__setRefCount(var, error, 1);
+    stmt->queryVars[pos - 1] = var;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__execute() [INTERNAL]
+//   Internal execution of statement.
+//-----------------------------------------------------------------------------
+static int dpiStmt__execute(dpiStmt *stmt, uint32_t numIters,
+        uint32_t mode, int reExecute, dpiError *error)
+{
+    uint16_t tempOffset;
+    uint32_t i, j, temp;
+    dpiData *data;
+    dpiVar *var;
+
+    // for all bound variables, transfer data from dpiData structure to Oracle
+    // buffer structures
+    for (i = 0; i < stmt->numBindVars; i++) {
+        var = stmt->bindVars[i].var;
+        if (var->isArray && numIters > 1)
+            return dpiError__set(error, "bind array var",
+                    DPI_ERR_ARRAY_VAR_NOT_SUPPORTED);
+        for (j = 0; j < var->buffer.maxArraySize; j++) {
+            data = &var->buffer.externalData[j];
+            if (dpiVar__setValue(var, &var->buffer, j, data, error) < 0)
+                return DPI_FAILURE;
+            if (var->dynBindBuffers)
+                var->dynBindBuffers[j].actualArraySize = 0;
+        }
+        if (stmt->isReturning || var->isDynamic)
+            var->error = error;
+    }
+
+    // for queries, set the OCI prefetch; the default value prevents an
+    // additional round trip for single row fetches while avoiding the overhead
+    // of copying from the OCI prefetch buffer to our own buffers for larger
+    // fetches
+    if (stmt->statementType == DPI_STMT_TYPE_SELECT) {
+        if (dpiOci__attrSet(stmt->handle, DPI_OCI_HTYPE_STMT,
+                &stmt->prefetchRows, sizeof(stmt->prefetchRows),
+                DPI_OCI_ATTR_PREFETCH_ROWS, "set prefetch rows", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // clear batch errors from any previous execution
+    dpiStmt__clearBatchErrors(stmt);
+
+    // adjust mode for scrollable cursors
+    if (stmt->scrollable)
+        mode |= DPI_OCI_STMT_SCROLLABLE_READONLY;
+
+    // perform execution
+    // re-execute statement for ORA-01007: variable not in select list
+    // drop statement from cache for all errors (except those which are due to
+    // invalid data which may be fixed in subsequent execution)
+    if (dpiOci__stmtExecute(stmt, numIters, mode, error) < 0) {
+        dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, &tempOffset, 0,
+                DPI_OCI_ATTR_PARSE_ERROR_OFFSET, "set parse offset", error);
+        error->buffer->offset = tempOffset;
+        switch (error->buffer->code) {
+            case 1007:
+                if (reExecute)
+                    return dpiStmt__reExecute(stmt, numIters, mode, error);
+                stmt->deleteFromCache = 1;
+                break;
+            case 1:
+            case 1400:
+            case 1438:
+            case 1461:
+            case 2290:
+            case 2291:
+            case 2292:
+            case 21525:
+                break;
+            default:
+                stmt->deleteFromCache = 1;
+        }
+        return DPI_FAILURE;
+    }
+
+    // for queries, disable prefetch for subsequent fetches in order to avoid
+    // the overhead of copying from prefetch buffers to our own buffers
+    if (stmt->statementType == DPI_STMT_TYPE_SELECT) {
+        temp = 0;
+        if (dpiOci__attrSet(stmt->handle, DPI_OCI_HTYPE_STMT, &temp,
+                sizeof(temp), DPI_OCI_ATTR_PREFETCH_ROWS,
+                "reset prefetch rows", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // for all bound variables, transfer data from Oracle buffer structures to
+    // dpiData structures; OCI doesn't provide a way of knowing if a variable
+    // is an out variable so do this for all of them when this is a possibility
+    if (stmt->isReturning || stmt->statementType == DPI_STMT_TYPE_BEGIN ||
+            stmt->statementType == DPI_STMT_TYPE_DECLARE ||
+            stmt->statementType == DPI_STMT_TYPE_CALL) {
+        for (i = 0; i < stmt->numBindVars; i++) {
+            var = stmt->bindVars[i].var;
+            for (j = 0; j < var->buffer.maxArraySize; j++) {
+                if (dpiVar__getValue(var, &var->buffer, j, 0, error) < 0)
+                    return DPI_FAILURE;
+            }
+            var->error = NULL;
+        }
+    }
+
+    // create query variables (if applicable) and reset row count to zero
+    if (stmt->statementType == DPI_STMT_TYPE_SELECT) {
+        stmt->rowCount = 0;
+        if (!(mode & DPI_MODE_EXEC_PARSE_ONLY) &&
+                dpiStmt__createQueryVars(stmt, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__fetch() [INTERNAL]
+//   Performs the actual fetch from Oracle.
+//-----------------------------------------------------------------------------
+static int dpiStmt__fetch(dpiStmt *stmt, dpiError *error)
+{
+    // perform any pre-fetch activities required
+    if (dpiStmt__beforeFetch(stmt, error) < 0)
+        return DPI_FAILURE;
+
+    // perform fetch
+    if (dpiOci__stmtFetch2(stmt, stmt->fetchArraySize, DPI_MODE_FETCH_NEXT, 0,
+            error) < 0)
+        return DPI_FAILURE;
+
+    // determine the number of rows fetched into buffers
+    if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT,
+            &stmt->bufferRowCount, 0, DPI_OCI_ATTR_ROWS_FETCHED,
+            "get rows fetched", error) < 0)
+        return DPI_FAILURE;
+
+    // set buffer row info
+    stmt->bufferMinRow = stmt->rowCount + 1;
+    stmt->bufferRowIndex = 0;
+
+    // perform post-fetch activities required
+    if (dpiStmt__postFetch(stmt, error) < 0)
+        return DPI_FAILURE;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__free() [INTERNAL]
+//   Free the memory associated with the statement.
+//-----------------------------------------------------------------------------
+void dpiStmt__free(dpiStmt *stmt, dpiError *error)
+{
+    dpiStmt__close(stmt, NULL, 0, 0, error);
+    if (stmt->parentStmt) {
+        dpiGen__setRefCount(stmt->parentStmt, error, -1);
+        stmt->parentStmt = NULL;
+    }
+    if (stmt->conn) {
+        dpiGen__setRefCount(stmt->conn, error, -1);
+        stmt->conn = NULL;
+    }
+    dpiUtils__freeMemory(stmt);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__getBatchErrors() [INTERNAL]
+//   Get batch errors after statement executed with batch errors enabled.
+//-----------------------------------------------------------------------------
+static int dpiStmt__getBatchErrors(dpiStmt *stmt, dpiError *error)
+{
+    void *batchErrorHandle, *localErrorHandle;
+    dpiError localError;
+    int overallStatus;
+    int32_t rowOffset;
+    uint32_t i;
+
+    // determine the number of batch errors that were found
+    if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT,
+            &stmt->numBatchErrors, 0, DPI_OCI_ATTR_NUM_DML_ERRORS,
+            "get batch error count", error) < 0)
+        return DPI_FAILURE;
+
+    // allocate memory for the batch errors
+    if (dpiUtils__allocateMemory(stmt->numBatchErrors, sizeof(dpiErrorBuffer),
+            1, "allocate errors", (void**) &stmt->batchErrors, error) < 0) {
+        stmt->numBatchErrors = 0;
+        return DPI_FAILURE;
+    }
+
+    // allocate error handle used for OCIParamGet()
+    if (dpiOci__handleAlloc(stmt->env->handle, &localErrorHandle,
+            DPI_OCI_HTYPE_ERROR, "allocate parameter error handle",
+            error) < 0) {
+        dpiStmt__clearBatchErrors(stmt);
+        return DPI_FAILURE;
+    }
+
+    // allocate error handle used for batch errors
+    if (dpiOci__handleAlloc(stmt->env->handle, &batchErrorHandle,
+            DPI_OCI_HTYPE_ERROR, "allocate batch error handle", error) < 0) {
+        dpiStmt__clearBatchErrors(stmt);
+        dpiOci__handleFree(localErrorHandle, DPI_OCI_HTYPE_ERROR);
+        return DPI_FAILURE;
+    }
+
+    // process each error
+    overallStatus = DPI_SUCCESS;
+    localError.buffer = error->buffer;
+    localError.env = error->env;
+    for (i = 0; i < stmt->numBatchErrors; i++) {
+
+        // get error handle for iteration
+        if (dpiOci__paramGet(error->handle, DPI_OCI_HTYPE_ERROR,
+                &batchErrorHandle, i, "get batch error", error) < 0) {
+            overallStatus = dpiError__set(error, "get batch error",
+                    DPI_ERR_INVALID_INDEX, i);
+            break;
+        }
+
+        // determine row offset
+        localError.handle = localErrorHandle;
+        if (dpiOci__attrGet(batchErrorHandle, DPI_OCI_HTYPE_ERROR, &rowOffset,
+                0, DPI_OCI_ATTR_DML_ROW_OFFSET, "get row offset",
+                &localError) < 0) {
+            overallStatus = dpiError__set(error, "get row offset",
+                    DPI_ERR_CANNOT_GET_ROW_OFFSET);
+            break;
+        }
+
+        // get error message
+        localError.buffer = &stmt->batchErrors[i];
+        localError.handle = batchErrorHandle;
+        dpiError__setFromOCI(&localError, DPI_OCI_ERROR, stmt->conn,
+                "get batch error");
+        if (error->buffer->errorNum) {
+            overallStatus = DPI_FAILURE;
+            break;
+        }
+        localError.buffer->fnName = error->buffer->fnName;
+        localError.buffer->offset = (uint32_t) rowOffset;
+
+    }
+
+    // cleanup
+    dpiOci__handleFree(localErrorHandle, DPI_OCI_HTYPE_ERROR);
+    dpiOci__handleFree(batchErrorHandle, DPI_OCI_HTYPE_ERROR);
+    if (overallStatus < 0)
+        dpiStmt__clearBatchErrors(stmt);
+    return overallStatus;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__getRowCount() [INTERNAL]
+//   Return the number of rows affected by the last DML executed (for insert,
+// update, delete and merge) or the number of rows fetched (for queries). In
+// all other cases, 0 is returned.
+//-----------------------------------------------------------------------------
+static int dpiStmt__getRowCount(dpiStmt *stmt, uint64_t *count,
+        dpiError *error)
+{
+    uint32_t rowCount32;
+
+    if (stmt->statementType == DPI_STMT_TYPE_SELECT)
+        *count = stmt->rowCount;
+    else if (stmt->statementType != DPI_STMT_TYPE_INSERT &&
+            stmt->statementType != DPI_STMT_TYPE_UPDATE &&
+            stmt->statementType != DPI_STMT_TYPE_DELETE &&
+            stmt->statementType != DPI_STMT_TYPE_MERGE &&
+            stmt->statementType != DPI_STMT_TYPE_CALL &&
+            stmt->statementType != DPI_STMT_TYPE_BEGIN &&
+            stmt->statementType != DPI_STMT_TYPE_DECLARE) {
+        *count = 0;
+    } else if (stmt->env->versionInfo->versionNum < 12) {
+        if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, &rowCount32, 0,
+                DPI_OCI_ATTR_ROW_COUNT, "get row count", error) < 0)
+            return DPI_FAILURE;
+        *count = rowCount32;
+    } else {
+        if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, count, 0,
+                DPI_OCI_ATTR_UB8_ROW_COUNT, "get row count", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__getQueryInfo() [INTERNAL]
+//   Get query information for the position in question.
+//-----------------------------------------------------------------------------
+static int dpiStmt__getQueryInfo(dpiStmt *stmt, uint32_t pos,
+        dpiQueryInfo *info, dpiError *error)
+{
+    void *param;
+    int status;
+
+    // acquire parameter descriptor
+    if (dpiOci__paramGet(stmt->handle, DPI_OCI_HTYPE_STMT, &param, pos,
+            "get parameter", error) < 0)
+        return DPI_FAILURE;
+
+    // acquire information from the parameter descriptor
+    status = dpiStmt__getQueryInfoFromParam(stmt, param, info, error);
+    dpiOci__descriptorFree(param, DPI_OCI_DTYPE_PARAM);
+    return status;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__getQueryInfoFromParam() [INTERNAL]
+//   Get query information from the parameter.
+//-----------------------------------------------------------------------------
+static int dpiStmt__getQueryInfoFromParam(dpiStmt *stmt, void *param,
+        dpiQueryInfo *info, dpiError *error)
+{
+    uint8_t ociNullOk;
+
+    // aquire name of item
+    if (dpiOci__attrGet(param, DPI_OCI_HTYPE_DESCRIBE, (void*) &info->name,
+            &info->nameLength, DPI_OCI_ATTR_NAME, "get name", error) < 0)
+        return DPI_FAILURE;
+
+    // acquire type information
+    if (dpiOracleType__populateTypeInfo(stmt->conn, param,
+            DPI_OCI_HTYPE_DESCRIBE, &info->typeInfo, error) < 0)
+        return DPI_FAILURE;
+
+    // acquire if column is permitted to be null
+    if (dpiOci__attrGet(param, DPI_OCI_HTYPE_DESCRIBE, (void*) &ociNullOk, 0,
+            DPI_OCI_ATTR_IS_NULL, "get null ok", error) < 0)
+        return DPI_FAILURE;
+    info->nullOk = ociNullOk;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__init() [INTERNAL]
+//   Initialize the statement for use. This is needed when preparing a
+// statement for use and when returning a REF cursor.
+//-----------------------------------------------------------------------------
+int dpiStmt__init(dpiStmt *stmt, dpiError *error)
+{
+    // get statement type
+    if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT,
+            (void*) &stmt->statementType, 0, DPI_OCI_ATTR_STMT_TYPE,
+            "get statement type", error) < 0)
+        return DPI_FAILURE;
+
+    // for queries, mark statement as having rows to fetch
+    if (stmt->statementType == DPI_STMT_TYPE_SELECT)
+        stmt->hasRowsToFetch = 1;
+
+    // otherwise, check if this is a RETURNING statement
+    else if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT,
+            (void*) &stmt->isReturning, 0, DPI_OCI_ATTR_STMT_IS_RETURNING,
+            "get is returning", error) < 0)
+        return DPI_FAILURE;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__postFetch() [INTERNAL]
+//   Performs the transformations required to convert Oracle data values into
+// C data values.
+//-----------------------------------------------------------------------------
+static int dpiStmt__postFetch(dpiStmt *stmt, dpiError *error)
+{
+    uint32_t i, j;
+    dpiVar *var;
+
+    for (i = 0; i < stmt->numQueryVars; i++) {
+        var = stmt->queryVars[i];
+        for (j = 0; j < stmt->bufferRowCount; j++) {
+            if (dpiVar__getValue(var, &var->buffer, j, 1, error) < 0)
+                return DPI_FAILURE;
+            if (var->type->requiresPreFetch)
+                var->requiresPreFetch = 1;
+        }
+        var->error = NULL;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__beforeFetch() [INTERNAL]
+//   Performs work that needs to be done prior to fetch for each variable. In
+// addition, variables are created if they do not already exist. A check is
+// also made to ensure that the variable has enough space to support a fetch
+// of the requested size.
+//-----------------------------------------------------------------------------
+static int dpiStmt__beforeFetch(dpiStmt *stmt, dpiError *error)
+{
+    dpiQueryInfo *queryInfo;
+    dpiData *data;
+    dpiVar *var;
+    uint32_t i;
+
+    if (!stmt->queryInfo && dpiStmt__createQueryVars(stmt, error) < 0)
+        return DPI_FAILURE;
+    for (i = 0; i < stmt->numQueryVars; i++) {
+        var = stmt->queryVars[i];
+        if (!var) {
+            queryInfo = &stmt->queryInfo[i];
+            if (dpiVar__allocate(stmt->conn, queryInfo->typeInfo.oracleTypeNum,
+                    queryInfo->typeInfo.defaultNativeTypeNum,
+                    stmt->fetchArraySize,
+                    queryInfo->typeInfo.clientSizeInBytes, 1, 0,
+                    queryInfo->typeInfo.objectType, &var, &data, error) < 0)
+                return DPI_FAILURE;
+            if (dpiStmt__define(stmt, i + 1, var, error) < 0)
+                return DPI_FAILURE;
+            dpiGen__setRefCount(var, error, -1);
+        }
+        var->error = error;
+        if (stmt->fetchArraySize > var->buffer.maxArraySize)
+            return dpiError__set(error, "check array size",
+                    DPI_ERR_ARRAY_SIZE_TOO_SMALL, var->buffer.maxArraySize);
+        if (var->requiresPreFetch && dpiVar__extendedPreFetch(var,
+                &var->buffer, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__prepare() [INTERNAL]
+//   Prepare a statement for execution.
+//-----------------------------------------------------------------------------
+int dpiStmt__prepare(dpiStmt *stmt, const char *sql, uint32_t sqlLength,
+        const char *tag, uint32_t tagLength, dpiError *error)
+{
+    if (sql && dpiDebugLevel & DPI_DEBUG_LEVEL_SQL)
+        dpiDebug__print("SQL %.*s\n", sqlLength, sql);
+    if (dpiOci__stmtPrepare2(stmt, sql, sqlLength, tag, tagLength, error) < 0)
+        return DPI_FAILURE;
+    if (dpiHandleList__addHandle(stmt->conn->openStmts, stmt,
+            &stmt->openSlotNum, error) < 0) {
+        dpiOci__stmtRelease(stmt, NULL, 0, 0, error);
+        stmt->handle = NULL;
+        return DPI_FAILURE;
+    }
+
+    return dpiStmt__init(stmt, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt__reExecute() [INTERNAL]
+//   Re-execute the statement after receiving the error ORA-01007: variable not
+// in select list. This takes place when one of the columns in a query is
+// dropped, but the original metadata is still being used because the query
+// statement was found in the statement cache.
+//-----------------------------------------------------------------------------
+static int dpiStmt__reExecute(dpiStmt *stmt, uint32_t numIters,
+        uint32_t mode, dpiError *error)
+{
+    void *origHandle, *newHandle;
+    uint32_t sqlLength, i;
+    dpiError localError;
+    dpiBindVar *bindVar;
+    dpiVar *var;
+    int status;
+    char *sql;
+
+    // acquire the statement that was previously prepared; if this cannot be
+    // determined, let the original error propagate
+    localError.buffer = error->buffer;
+    localError.env = error->env;
+    localError.handle = error->handle;
+    if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, (void*) &sql,
+            &sqlLength, DPI_OCI_ATTR_STATEMENT, "get statement",
+            &localError) < 0)
+        return DPI_FAILURE;
+
+    // prepare statement a second time before releasing the original statement;
+    // release the original statement and delete it from the statement cache
+    // so that it does not return with the invalid metadata; again, if this
+    // cannot be done, let the original error propagate
+    origHandle = stmt->handle;
+    status = dpiOci__stmtPrepare2(stmt, sql, sqlLength, NULL, 0, &localError);
+    newHandle = stmt->handle;
+    stmt->handle = origHandle;
+    stmt->deleteFromCache = 1;
+    if (dpiOci__stmtRelease(stmt, NULL, 0, 1, &localError) < 0 || status < 0)
+        return DPI_FAILURE;
+    stmt->handle = newHandle;
+    dpiStmt__clearBatchErrors(stmt);
+    dpiStmt__clearQueryVars(stmt, error);
+
+    // perform binds
+    for (i = 0; i < stmt->numBindVars; i++) {
+        bindVar = &stmt->bindVars[i];
+        if (!bindVar->var)
+            continue;
+        var = bindVar->var;
+        bindVar->var = NULL;
+        if (dpiStmt__bind(stmt, var, bindVar->pos, bindVar->name,
+                bindVar->nameLength, error) < 0) {
+            dpiGen__setRefCount(var, error, -1);
+            return DPI_FAILURE;
+        }
+    }
+
+    // now re-execute the statement
+    return dpiStmt__execute(stmt, numIters, mode, 0, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_addRef() [PUBLIC]
+//   Add a reference to the statement.
+//-----------------------------------------------------------------------------
+int dpiStmt_addRef(dpiStmt *stmt)
+{
+    return dpiGen__addRef(stmt, DPI_HTYPE_STMT, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_bindByName() [PUBLIC]
+//   Bind the variable by name.
+//-----------------------------------------------------------------------------
+int dpiStmt_bindByName(dpiStmt *stmt, const char *name, uint32_t nameLength,
+        dpiVar *var)
+{
+    dpiError error;
+    int status;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, name)
+    if (dpiGen__checkHandle(var, DPI_HTYPE_VAR, "bind by name", &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    status = dpiStmt__bind(stmt, var, 0, name, nameLength, &error);
+    return dpiGen__endPublicFn(stmt, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_bindByPos() [PUBLIC]
+//   Bind the variable by position.
+//-----------------------------------------------------------------------------
+int dpiStmt_bindByPos(dpiStmt *stmt, uint32_t pos, dpiVar *var)
+{
+    dpiError error;
+    int status;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(var, DPI_HTYPE_VAR, "bind by pos", &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    status = dpiStmt__bind(stmt, var, pos, NULL, 0, &error);
+    return dpiGen__endPublicFn(stmt, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_bindValueByName() [PUBLIC]
+//   Create a variable and bind it by name.
+//-----------------------------------------------------------------------------
+int dpiStmt_bindValueByName(dpiStmt *stmt, const char *name,
+        uint32_t nameLength, dpiNativeTypeNum nativeTypeNum, dpiData *data)
+{
+    dpiVar *var = NULL;
+    dpiError error;
+    int status;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, name)
+    DPI_CHECK_PTR_NOT_NULL(stmt, data)
+    status = dpiStmt__createBindVar(stmt, nativeTypeNum, data, &var, 0, name,
+            nameLength, &error);
+    return dpiGen__endPublicFn(stmt, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_bindValueByPos() [PUBLIC]
+//   Create a variable and bind it by position.
+//-----------------------------------------------------------------------------
+int dpiStmt_bindValueByPos(dpiStmt *stmt, uint32_t pos,
+        dpiNativeTypeNum nativeTypeNum, dpiData *data)
+{
+    dpiVar *var = NULL;
+    dpiError error;
+    int status;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, data)
+    status = dpiStmt__createBindVar(stmt, nativeTypeNum, data, &var, pos, NULL,
+            0, &error);
+    return dpiGen__endPublicFn(stmt, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_close() [PUBLIC]
+//   Close the statement so that it is no longer usable and all resources have
+// been released.
+//-----------------------------------------------------------------------------
+int dpiStmt_close(dpiStmt *stmt, const char *tag, uint32_t tagLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(stmt, tag)
+    status = dpiStmt__close(stmt, tag, tagLength, 1, &error);
+    return dpiGen__endPublicFn(stmt, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_define() [PUBLIC]
+//   Define the variable that will accept output from the cursor in the
+// specified column.
+//-----------------------------------------------------------------------------
+int dpiStmt_define(dpiStmt *stmt, uint32_t pos, dpiVar *var)
+{
+    dpiError error;
+    int status;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    if (!stmt->queryInfo && dpiStmt__createQueryVars(stmt, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    if (pos == 0 || pos > stmt->numQueryVars) {
+        dpiError__set(&error, "check query position",
+                DPI_ERR_QUERY_POSITION_INVALID, pos);
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    }
+    if (dpiGen__checkHandle(var, DPI_HTYPE_VAR, "check variable", &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+
+    status = dpiStmt__define(stmt, pos, var, &error);
+    return dpiGen__endPublicFn(stmt, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_defineValue() [PUBLIC]
+//   Define the type of data to use for output from the cursor in the specified
+// column. This implicitly creates a variable of the specified type and is
+// intended for subsequent use by dpiStmt_getQueryValue(), which makes use of
+// implicitly created variables.
+//-----------------------------------------------------------------------------
+int dpiStmt_defineValue(dpiStmt *stmt, uint32_t pos,
+        dpiOracleTypeNum oracleTypeNum, dpiNativeTypeNum nativeTypeNum,
+        uint32_t size, int sizeIsBytes, dpiObjectType *objType)
+{
+    dpiError error;
+    dpiData *data;
+    dpiVar *var;
+
+    // verify parameters
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    if (!stmt->queryInfo && dpiStmt__createQueryVars(stmt, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    if (pos == 0 || pos > stmt->numQueryVars) {
+        dpiError__set(&error, "check query position",
+                DPI_ERR_QUERY_POSITION_INVALID, pos);
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    }
+
+    // create a new variable of the specified type
+    if (dpiVar__allocate(stmt->conn, oracleTypeNum, nativeTypeNum,
+            stmt->fetchArraySize, size, sizeIsBytes, 0, objType, &var, &data,
+            &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    if (dpiStmt__define(stmt, pos, var, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    dpiGen__setRefCount(var, &error, -1);
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_execute() [PUBLIC]
+//   Execute a statement. If the statement has been executed before, however,
+// and this is a query, the describe information is already available so defer
+// execution until the first fetch.
+//-----------------------------------------------------------------------------
+int dpiStmt_execute(dpiStmt *stmt, dpiExecMode mode, uint32_t *numQueryColumns)
+{
+    uint32_t numIters;
+    dpiError error;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    numIters = (stmt->statementType == DPI_STMT_TYPE_SELECT) ? 0 : 1;
+    if (dpiStmt__execute(stmt, numIters, mode, 1, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    if (numQueryColumns)
+        *numQueryColumns = stmt->numQueryVars;
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_executeMany() [PUBLIC]
+//   Execute a statement multiple times. Queries are not supported. The bind
+// variables are checked to ensure that their maxArraySize is sufficient to
+// support this.
+//-----------------------------------------------------------------------------
+int dpiStmt_executeMany(dpiStmt *stmt, dpiExecMode mode, uint32_t numIters)
+{
+    dpiError error;
+    uint32_t i;
+
+    // verify statement is open
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+
+    // queries are not supported
+    if (stmt->statementType == DPI_STMT_TYPE_SELECT) {
+        dpiError__set(&error, "check statement type", DPI_ERR_NOT_SUPPORTED);
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    }
+
+    // batch errors and array DML row counts are only supported with DML
+    // statements (insert, update, delete and merge)
+    if ((mode & DPI_MODE_EXEC_BATCH_ERRORS ||
+                mode & DPI_MODE_EXEC_ARRAY_DML_ROWCOUNTS) &&
+            stmt->statementType != DPI_STMT_TYPE_INSERT &&
+            stmt->statementType != DPI_STMT_TYPE_UPDATE &&
+            stmt->statementType != DPI_STMT_TYPE_DELETE &&
+            stmt->statementType != DPI_STMT_TYPE_MERGE) {
+        dpiError__set(&error, "check mode", DPI_ERR_EXEC_MODE_ONLY_FOR_DML);
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    }
+
+    // ensure that all bind variables have a big enough maxArraySize to
+    // support this operation
+    for (i = 0; i < stmt->numBindVars; i++) {
+        if (stmt->bindVars[i].var->buffer.maxArraySize < numIters) {
+            dpiError__set(&error, "check array size",
+                    DPI_ERR_ARRAY_SIZE_TOO_SMALL,
+                    stmt->bindVars[i].var->buffer.maxArraySize);
+            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+        }
+    }
+
+    // perform execution
+    dpiStmt__clearBatchErrors(stmt);
+    if (dpiStmt__execute(stmt, numIters, mode, 0, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+
+    // handle batch errors if mode was specified
+    if (mode & DPI_MODE_EXEC_BATCH_ERRORS) {
+        if (dpiStmt__getBatchErrors(stmt, &error) < 0)
+            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    }
+
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_fetch() [PUBLIC]
+//   Fetch a row from the database.
+//-----------------------------------------------------------------------------
+int dpiStmt_fetch(dpiStmt *stmt, int *found, uint32_t *bufferRowIndex)
+{
+    dpiError error;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, found)
+    DPI_CHECK_PTR_NOT_NULL(stmt, bufferRowIndex)
+    if (stmt->bufferRowIndex >= stmt->bufferRowCount) {
+        if (stmt->hasRowsToFetch && dpiStmt__fetch(stmt, &error) < 0)
+            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+        if (stmt->bufferRowIndex >= stmt->bufferRowCount) {
+            *found = 0;
+            return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+        }
+    }
+    *found = 1;
+    *bufferRowIndex = stmt->bufferRowIndex;
+    stmt->bufferRowIndex++;
+    stmt->rowCount++;
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_fetchRows() [PUBLIC]
+//   Fetch rows into buffers and return the number of rows that were so
+// fetched. If there are still rows available in the buffer, no additional
+// fetch will take place.
+//-----------------------------------------------------------------------------
+int dpiStmt_fetchRows(dpiStmt *stmt, uint32_t maxRows,
+        uint32_t *bufferRowIndex, uint32_t *numRowsFetched, int *moreRows)
+{
+    dpiError error;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, bufferRowIndex)
+    DPI_CHECK_PTR_NOT_NULL(stmt, numRowsFetched)
+    DPI_CHECK_PTR_NOT_NULL(stmt, moreRows)
+    if (stmt->bufferRowIndex >= stmt->bufferRowCount) {
+        if (stmt->hasRowsToFetch && dpiStmt__fetch(stmt, &error) < 0)
+            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+        if (stmt->bufferRowIndex >= stmt->bufferRowCount) {
+            *moreRows = 0;
+            *bufferRowIndex = 0;
+            *numRowsFetched = 0;
+            return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+        }
+    }
+    *bufferRowIndex = stmt->bufferRowIndex;
+    *numRowsFetched = stmt->bufferRowCount - stmt->bufferRowIndex;
+    *moreRows = stmt->hasRowsToFetch;
+    if (*numRowsFetched > maxRows) {
+        *numRowsFetched = maxRows;
+        *moreRows = 1;
+    }
+    stmt->bufferRowIndex += *numRowsFetched;
+    stmt->rowCount += *numRowsFetched;
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getBatchErrorCount() [PUBLIC]
+//   Return the number of batch errors that took place during the last
+// execution of the statement.
+//-----------------------------------------------------------------------------
+int dpiStmt_getBatchErrorCount(dpiStmt *stmt, uint32_t *count)
+{
+    dpiError error;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, count)
+    *count = stmt->numBatchErrors;
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getBatchErrors() [PUBLIC]
+//   Return the batch errors that took place during the last execution of the
+// statement.
+//-----------------------------------------------------------------------------
+int dpiStmt_getBatchErrors(dpiStmt *stmt, uint32_t numErrors,
+        dpiErrorInfo *errors)
+{
+    dpiError error, tempError;
+    uint32_t i;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, errors)
+    if (numErrors < stmt->numBatchErrors) {
+        dpiError__set(&error, "check num errors", DPI_ERR_ARRAY_SIZE_TOO_SMALL,
+                numErrors);
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    }
+    for (i = 0; i < stmt->numBatchErrors; i++) {
+        tempError.buffer = &stmt->batchErrors[i];
+        dpiError__getInfo(&tempError, &errors[i]);
+    }
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getBindCount() [PUBLIC]
+//   Return the number of bind variables referenced in the prepared SQL. In
+// SQL statements this counts all bind variables but in PL/SQL statements
+// this counts only uniquely named bind variables.
+//-----------------------------------------------------------------------------
+int dpiStmt_getBindCount(dpiStmt *stmt, uint32_t *count)
+{
+    dpiError error;
+    int status;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, count)
+    status = dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, (void*) count,
+            0, DPI_OCI_ATTR_BIND_COUNT, "get bind count", &error);
+    return dpiGen__endPublicFn(stmt, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getBindNames() [PUBLIC]
+//   Return the unique names of the bind variables referenced in the prepared
+// SQL.
+//-----------------------------------------------------------------------------
+int dpiStmt_getBindNames(dpiStmt *stmt, uint32_t *numBindNames,
+        const char **bindNames, uint32_t *bindNameLengths)
+{
+    uint8_t bindNameLengthsBuffer[8], indNameLengthsBuffer[8], isDuplicate[8];
+    uint32_t startLoc, i, numThisPass, numActualBindNames;
+    char *bindNamesBuffer[8], *indNamesBuffer[8];
+    void *bindHandles[8];
+    int32_t numFound;
+    dpiError error;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, numBindNames)
+    DPI_CHECK_PTR_NOT_NULL(stmt, bindNames)
+    DPI_CHECK_PTR_NOT_NULL(stmt, bindNameLengths)
+    startLoc = 1;
+    numActualBindNames = 0;
+    while (1) {
+        if (dpiOci__stmtGetBindInfo(stmt, 8, startLoc, &numFound,
+                bindNamesBuffer, bindNameLengthsBuffer, indNamesBuffer,
+                indNameLengthsBuffer, isDuplicate, bindHandles, &error) < 0)
+            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+        if (numFound == 0)
+            break;
+        numThisPass = abs(numFound) - startLoc + 1;
+        if (numThisPass > 8)
+            numThisPass = 8;
+        for (i = 0; i < numThisPass; i++) {
+            startLoc++;
+            if (isDuplicate[i])
+                continue;
+            if (numActualBindNames == *numBindNames) {
+                dpiError__set(&error, "check num bind names",
+                        DPI_ERR_ARRAY_SIZE_TOO_SMALL, *numBindNames);
+                return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+            }
+            bindNames[numActualBindNames] = bindNamesBuffer[i];
+            bindNameLengths[numActualBindNames] = bindNameLengthsBuffer[i];
+            numActualBindNames++;
+        }
+        if (numFound > 0)
+            break;
+    }
+    *numBindNames = numActualBindNames;
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getFetchArraySize() [PUBLIC]
+//   Get the array size used for fetches.
+//-----------------------------------------------------------------------------
+int dpiStmt_getFetchArraySize(dpiStmt *stmt, uint32_t *arraySize)
+{
+    dpiError error;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, arraySize)
+    *arraySize = stmt->fetchArraySize;
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getImplicitResult() [PUBLIC]
+//   Return the next implicit result from the previously executed statement. If
+// no more implicit results exist, NULL is returned.
+//-----------------------------------------------------------------------------
+int dpiStmt_getImplicitResult(dpiStmt *stmt, dpiStmt **implicitResult)
+{
+    dpiStmt *tempStmt;
+    dpiError error;
+    void *handle;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, implicitResult)
+    if (dpiUtils__checkClientVersion(stmt->env->versionInfo, 12, 1,
+            &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    if (dpiOci__stmtGetNextResult(stmt, &handle, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    *implicitResult = NULL;
+    if (handle) {
+        if (dpiStmt__allocate(stmt->conn, 0, &tempStmt, &error) < 0)
+            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+        tempStmt->handle = handle;
+        dpiGen__setRefCount(stmt, &error, 1);
+        tempStmt->parentStmt = stmt;
+        if (dpiStmt__createQueryVars(tempStmt, &error) < 0) {
+            dpiStmt__free(tempStmt, &error);
+            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+        }
+        *implicitResult = tempStmt;
+    }
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getInfo() [PUBLIC]
+//   Return information about the statement in the provided structure.
+//-----------------------------------------------------------------------------
+int dpiStmt_getInfo(dpiStmt *stmt, dpiStmtInfo *info)
+{
+    dpiError error;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, info)
+    info->isQuery = (stmt->statementType == DPI_STMT_TYPE_SELECT);
+    info->isPLSQL = (stmt->statementType == DPI_STMT_TYPE_BEGIN ||
+            stmt->statementType == DPI_STMT_TYPE_DECLARE ||
+            stmt->statementType == DPI_STMT_TYPE_CALL);
+    info->isDDL = (stmt->statementType == DPI_STMT_TYPE_CREATE ||
+            stmt->statementType == DPI_STMT_TYPE_DROP ||
+            stmt->statementType == DPI_STMT_TYPE_ALTER);
+    info->isDML = (stmt->statementType == DPI_STMT_TYPE_INSERT ||
+            stmt->statementType == DPI_STMT_TYPE_UPDATE ||
+            stmt->statementType == DPI_STMT_TYPE_DELETE ||
+            stmt->statementType == DPI_STMT_TYPE_MERGE);
+    info->statementType = stmt->statementType;
+    info->isReturning = stmt->isReturning;
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getLastRowid() [PUBLIC]
+//   Returns the rowid of the last row that was affected by a DML statement. If
+// no rows were affected by the last statement executed or the last statement
+// executed was not a DML statement, NULL is returned.
+//-----------------------------------------------------------------------------
+int dpiStmt_getLastRowid(dpiStmt *stmt, dpiRowid **rowid)
+{
+    uint64_t rowCount;
+    uint32_t tempSize;
+    dpiError error;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, rowid)
+    *rowid = NULL;
+    if (stmt->statementType == DPI_STMT_TYPE_INSERT ||
+            stmt->statementType == DPI_STMT_TYPE_UPDATE ||
+            stmt->statementType == DPI_STMT_TYPE_DELETE ||
+            stmt->statementType == DPI_STMT_TYPE_MERGE) {
+        if (dpiStmt__getRowCount(stmt, &rowCount, &error) < 0)
+            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+        if (rowCount > 0) {
+            if (stmt->lastRowid) {
+                dpiGen__setRefCount(stmt->lastRowid, &error, -1);
+                stmt->lastRowid = NULL;
+            }
+            if (dpiRowid__allocate(stmt->conn, &stmt->lastRowid, &error) < 0)
+                return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+            if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT,
+                    stmt->lastRowid->handle, &tempSize, DPI_OCI_ATTR_ROWID,
+                    "get last rowid", &error) < 0)
+                return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+            if (tempSize)
+                *rowid = stmt->lastRowid;
+        }
+    }
+
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getNumQueryColumns() [PUBLIC]
+//   Returns the number of query columns associated with a statement. If the
+// statement does not refer to a query, 0 is returned.
+//-----------------------------------------------------------------------------
+int dpiStmt_getNumQueryColumns(dpiStmt *stmt, uint32_t *numQueryColumns)
+{
+    dpiError error;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, numQueryColumns)
+    if (stmt->statementType == DPI_STMT_TYPE_SELECT &&
+            stmt->numQueryVars == 0 &&
+            dpiStmt__createQueryVars(stmt, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    *numQueryColumns = stmt->numQueryVars;
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getOciAttr() [PUBLIC]
+//   Get the OCI attribute directly. This is intended for testing of attributes
+// not currently exposed by ODPI-C and should only be used for that purpose.
+//-----------------------------------------------------------------------------
+int dpiStmt_getOciAttr(dpiStmt *stmt, uint32_t attribute, dpiDataBuffer *value,
+        uint32_t *valueLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, value)
+    DPI_CHECK_PTR_NOT_NULL(stmt, valueLength)
+    status = dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, &value->asRaw,
+            valueLength, attribute, "generic get OCI attribute", &error);
+    return dpiGen__endPublicFn(stmt, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getPrefetchRows() [PUBLIC]
+//   Returns the number of rows that will be prefetched when a query is
+// executed.
+//-----------------------------------------------------------------------------
+int dpiStmt_getPrefetchRows(dpiStmt *stmt, uint32_t *numRows)
+{
+    dpiError error;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, numRows)
+    *numRows = stmt->prefetchRows;
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getQueryInfo() [PUBLIC]
+//   Get query information for the position in question.
+//-----------------------------------------------------------------------------
+int dpiStmt_getQueryInfo(dpiStmt *stmt, uint32_t pos, dpiQueryInfo *info)
+{
+    dpiError error;
+
+    // validate parameters
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, info)
+    if (!stmt->queryInfo && dpiStmt__createQueryVars(stmt, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    if (pos == 0 || pos > stmt->numQueryVars) {
+        dpiError__set(&error, "check query position",
+                DPI_ERR_QUERY_POSITION_INVALID, pos);
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    }
+
+    // copy query information from internal cache
+    memcpy(info, &stmt->queryInfo[pos - 1], sizeof(dpiQueryInfo));
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getQueryValue() [PUBLIC]
+//   Get value from query at specified position.
+//-----------------------------------------------------------------------------
+int dpiStmt_getQueryValue(dpiStmt *stmt, uint32_t pos,
+        dpiNativeTypeNum *nativeTypeNum, dpiData **data)
+{
+    dpiError error;
+    dpiVar *var;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, nativeTypeNum)
+    DPI_CHECK_PTR_NOT_NULL(stmt, data)
+    if (!stmt->queryVars) {
+        dpiError__set(&error, "check query vars", DPI_ERR_QUERY_NOT_EXECUTED);
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    }
+    if (pos == 0 || pos > stmt->numQueryVars) {
+        dpiError__set(&error, "check query position",
+                DPI_ERR_QUERY_POSITION_INVALID, pos);
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    }
+    var = stmt->queryVars[pos - 1];
+    if (!var || stmt->bufferRowIndex == 0 ||
+            stmt->bufferRowIndex > stmt->bufferRowCount) {
+        dpiError__set(&error, "check fetched row", DPI_ERR_NO_ROW_FETCHED);
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    }
+    *nativeTypeNum = var->nativeTypeNum;
+    *data = &var->buffer.externalData[stmt->bufferRowIndex - 1];
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getRowCount() [PUBLIC]
+//   Return the number of rows affected by the last DML executed (for insert,
+// update, delete and merge) or the number of rows fetched (for queries). In
+// all other cases, 0 is returned.
+//-----------------------------------------------------------------------------
+int dpiStmt_getRowCount(dpiStmt *stmt, uint64_t *count)
+{
+    dpiError error;
+    int status;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, count)
+    status = dpiStmt__getRowCount(stmt, count, &error);
+    return dpiGen__endPublicFn(stmt, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getRowCounts() [PUBLIC]
+//   Return the number of rows affected by each of the iterations executed
+// using dpiStmt_executeMany().
+//-----------------------------------------------------------------------------
+int dpiStmt_getRowCounts(dpiStmt *stmt, uint32_t *numRowCounts,
+        uint64_t **rowCounts)
+{
+    dpiError error;
+    int status;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, numRowCounts)
+    DPI_CHECK_PTR_NOT_NULL(stmt, rowCounts)
+    if (dpiUtils__checkClientVersion(stmt->env->versionInfo, 12, 1,
+            &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    status = dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, rowCounts,
+            numRowCounts, DPI_OCI_ATTR_DML_ROW_COUNT_ARRAY, "get row counts",
+            &error);
+    return dpiGen__endPublicFn(stmt, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_getSubscrQueryId() [PUBLIC]
+//   Return the query id for a query registered using this statement.
+//-----------------------------------------------------------------------------
+int dpiStmt_getSubscrQueryId(dpiStmt *stmt, uint64_t *queryId)
+{
+    dpiError error;
+    int status;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, queryId)
+    status = dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, queryId, 0,
+            DPI_OCI_ATTR_CQ_QUERYID, "get query id", &error);
+    return dpiGen__endPublicFn(stmt, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_release() [PUBLIC]
+//   Release a reference to the statement.
+//-----------------------------------------------------------------------------
+int dpiStmt_release(dpiStmt *stmt)
+{
+    return dpiGen__release(stmt, DPI_HTYPE_STMT, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_scroll() [PUBLIC]
+//   Scroll to the specified location in the cursor.
+//-----------------------------------------------------------------------------
+int dpiStmt_scroll(dpiStmt *stmt, dpiFetchMode mode, int32_t offset,
+        int32_t rowCountOffset)
+{
+    uint32_t numRows, currentPosition;
+    uint64_t desiredRow = 0;
+    dpiError error;
+
+    // make sure the cursor is open
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+
+    // validate mode; determine desired row to fetch
+    switch (mode) {
+        case DPI_MODE_FETCH_NEXT:
+            desiredRow = stmt->rowCount + rowCountOffset + 1;
+            break;
+        case DPI_MODE_FETCH_PRIOR:
+            desiredRow = stmt->rowCount + rowCountOffset - 1;
+            break;
+        case DPI_MODE_FETCH_FIRST:
+            desiredRow = 1;
+            break;
+        case DPI_MODE_FETCH_LAST:
+            break;
+        case DPI_MODE_FETCH_ABSOLUTE:
+            desiredRow = (uint64_t) offset;
+            break;
+        case DPI_MODE_FETCH_RELATIVE:
+            desiredRow = stmt->rowCount + rowCountOffset + offset;
+            offset = (int32_t) (desiredRow -
+                    (stmt->bufferMinRow + stmt->bufferRowCount - 1));
+            break;
+        default:
+            dpiError__set(&error, "scroll mode", DPI_ERR_NOT_SUPPORTED);
+            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    }
+
+    // determine if a fetch is actually required; "last" is always fetched
+    if (mode != DPI_MODE_FETCH_LAST && desiredRow >= stmt->bufferMinRow &&
+            desiredRow < stmt->bufferMinRow + stmt->bufferRowCount) {
+        stmt->bufferRowIndex = (uint32_t) (desiredRow - stmt->bufferMinRow);
+        stmt->rowCount = desiredRow - 1;
+        return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+    }
+
+    // perform any pre-fetch activities required
+    if (dpiStmt__beforeFetch(stmt, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+
+    // perform fetch; when fetching the last row, only fetch a single row
+    numRows = (mode == DPI_MODE_FETCH_LAST) ? 1 : stmt->fetchArraySize;
+    if (dpiOci__stmtFetch2(stmt, numRows, mode, offset, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+
+    // determine the number of rows actually fetched
+    if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT,
+            &stmt->bufferRowCount, 0, DPI_OCI_ATTR_ROWS_FETCHED,
+            "get rows fetched", &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+
+    // check that we haven't gone outside of the result set
+    if (stmt->bufferRowCount == 0) {
+        if (mode != DPI_MODE_FETCH_FIRST && mode != DPI_MODE_FETCH_LAST) {
+            dpiError__set(&error, "check result set bounds",
+                    DPI_ERR_SCROLL_OUT_OF_RS);
+            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+        }
+        stmt->hasRowsToFetch = 0;
+        stmt->rowCount = 0;
+        stmt->bufferRowIndex = 0;
+        stmt->bufferMinRow = 0;
+        return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+    }
+
+    // determine the current position of the cursor
+    if (dpiOci__attrGet(stmt->handle, DPI_OCI_HTYPE_STMT, &currentPosition, 0,
+            DPI_OCI_ATTR_CURRENT_POSITION, "get current pos", &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+
+    // reset buffer row index and row count
+    stmt->rowCount = currentPosition - stmt->bufferRowCount;
+    stmt->bufferMinRow = stmt->rowCount + 1;
+    stmt->bufferRowIndex = 0;
+
+    // perform post-fetch activities required
+    if (dpiStmt__postFetch(stmt, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_setFetchArraySize() [PUBLIC]
+//   Set the array size used for fetches. Using a value of zero will select the
+// default value. A check is made to ensure that all defined variables have
+// sufficient space to support the array size.
+//-----------------------------------------------------------------------------
+int dpiStmt_setFetchArraySize(dpiStmt *stmt, uint32_t arraySize)
+{
+    dpiError error;
+    dpiVar *var;
+    uint32_t i;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    if (arraySize == 0)
+        arraySize = DPI_DEFAULT_FETCH_ARRAY_SIZE;
+    for (i = 0; i < stmt->numQueryVars; i++) {
+        var = stmt->queryVars[i];
+        if (var && var->buffer.maxArraySize < arraySize) {
+            dpiError__set(&error, "check array size",
+                    DPI_ERR_ARRAY_SIZE_TOO_BIG, arraySize);
+            return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+        }
+    }
+    stmt->fetchArraySize = arraySize;
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_setOciAttr() [PUBLIC]
+//   Set the OCI attribute directly. This is intended for testing of attributes
+// not currently exposed by ODPI-C and should only be used for that purpose.
+//-----------------------------------------------------------------------------
+int dpiStmt_setOciAttr(dpiStmt *stmt, uint32_t attribute, void *value,
+        uint32_t valueLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(stmt, value)
+
+    status = dpiOci__attrSet(stmt->handle, DPI_OCI_HTYPE_STMT, value,
+            valueLength, attribute, "generic set OCI attribute", &error);
+    return dpiGen__endPublicFn(stmt, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_setPrefetchRows() [PUBLIC]
+//   Set the number of rows to prefetch when a query is executed.
+//-----------------------------------------------------------------------------
+int dpiStmt_setPrefetchRows(dpiStmt *stmt, uint32_t numRows)
+{
+    dpiError error;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    stmt->prefetchRows = numRows;
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiStmt_deleteFromCache() [PUBLIC]
+//   Excludes the associated SQL statement from the statement cache. If the SQL
+// statment was not already in the cache, it will not be added.
+//-----------------------------------------------------------------------------
+int dpiStmt_deleteFromCache(dpiStmt *stmt)
+{
+    dpiError error;
+
+    if (dpiStmt__check(stmt, __func__, &error) < 0)
+        return dpiGen__endPublicFn(stmt, DPI_FAILURE, &error);
+    stmt->deleteFromCache = 1;
+    return dpiGen__endPublicFn(stmt, DPI_SUCCESS, &error);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiSubscr.c ./odpi/src/dpiSubscr.c
--- patched-godror/odpi/src/dpiSubscr.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiSubscr.c	1970-01-01 01:00:00
@@ -1,734 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiSubscr.c
-//   Implementation of subscriptions (CQN).
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-// forward declarations of internal functions only used in this file
-static void dpiSubscr__freeMessage(dpiSubscrMessage *message);
-static int dpiSubscr__populateMessage(dpiSubscr *subscr,
-        dpiSubscrMessage *message, void *descriptor, dpiError *error);
-static int dpiSubscr__populateMessageTable(dpiSubscr *subscr,
-        dpiSubscrMessageTable *table, void *descriptor, dpiError *error);
-static int dpiSubscr__populateQueryChangeMessage(dpiSubscr *subscr,
-        dpiSubscrMessage *message, void *descriptor, dpiError *error);
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr__callback() [INTERNAL]
-//   Callback that is used to execute the callback registered when the
-// subscription was created.
-//-----------------------------------------------------------------------------
-static void dpiSubscr__callback(dpiSubscr *subscr, UNUSED void *handle,
-        UNUSED void *payload, UNUSED uint32_t payloadLength, void *descriptor,
-        UNUSED uint32_t mode)
-{
-    dpiSubscrMessage message;
-    dpiErrorInfo errorInfo;
-    dpiError error;
-
-    // ensure that the subscription handle is still valid
-    if (dpiGen__startPublicFn(subscr, DPI_HTYPE_SUBSCR, __func__,
-            &error) < 0) {
-        dpiGen__endPublicFn(subscr, DPI_FAILURE, &error);
-        return;
-    }
-
-    // if the subscription is no longer registered, nothing further to do
-    dpiMutex__acquire(subscr->mutex);
-    if (!subscr->registered) {
-        dpiMutex__release(subscr->mutex);
-        dpiGen__endPublicFn(subscr, DPI_SUCCESS, &error);
-        return;
-    }
-
-    // populate message
-    memset(&message, 0, sizeof(message));
-    if (dpiSubscr__populateMessage(subscr, &message, descriptor, &error) < 0) {
-        dpiError__getInfo(&error, &errorInfo);
-        message.errorInfo = &errorInfo;
-    }
-    message.registered = subscr->registered;
-
-    // invoke user callback; temporarily increase reference count to ensure
-    // that the subscription is not freed during the callback
-    dpiGen__setRefCount(subscr, &error, 1);
-    (*subscr->callback)(subscr->callbackContext, &message);
-    dpiSubscr__freeMessage(&message);
-    dpiMutex__release(subscr->mutex);
-    dpiGen__setRefCount(subscr, &error, -1);
-    dpiGen__endPublicFn(subscr, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr__check() [INTERNAL]
-//   Determine if the subscription is open and available for use.
-//-----------------------------------------------------------------------------
-static int dpiSubscr__check(dpiSubscr *subscr, const char *fnName,
-        dpiError *error)
-{
-    if (dpiGen__startPublicFn(subscr, DPI_HTYPE_SUBSCR, fnName, error) < 0)
-        return DPI_FAILURE;
-    if (!subscr->handle)
-        return dpiError__set(error, "check closed", DPI_ERR_SUBSCR_CLOSED);
-    return dpiConn__checkConnected(subscr->conn, error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr__create() [INTERNAL]
-//   Create a new subscription structure and return it. In case of error NULL
-// is returned.
-//-----------------------------------------------------------------------------
-int dpiSubscr__create(dpiSubscr *subscr, dpiConn *conn,
-        dpiSubscrCreateParams *params, dpiError *error)
-{
-    uint32_t qosFlags, mode;
-    int32_t int32Val;
-    int rowids;
-
-    // retain a reference to the connection
-    dpiGen__setRefCount(conn, error, 1);
-    subscr->conn = conn;
-    subscr->callback = params->callback;
-    subscr->callbackContext = params->callbackContext;
-    subscr->subscrNamespace = params->subscrNamespace;
-    subscr->qos = params->qos;
-    subscr->clientInitiated = params->clientInitiated;
-    dpiMutex__initialize(subscr->mutex);
-
-    // create the subscription handle
-    if (dpiOci__handleAlloc(conn->env->handle, &subscr->handle,
-            DPI_OCI_HTYPE_SUBSCRIPTION, "create subscr handle", error) < 0)
-        return DPI_FAILURE;
-
-    // set the namespace
-    if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
-            (void*) &params->subscrNamespace, sizeof(uint32_t),
-            DPI_OCI_ATTR_SUBSCR_NAMESPACE, "set namespace", error) < 0)
-        return DPI_FAILURE;
-
-    // set the protocol
-    if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
-            (void*) &params->protocol, sizeof(uint32_t),
-            DPI_OCI_ATTR_SUBSCR_RECPTPROTO, "set protocol", error) < 0)
-        return DPI_FAILURE;
-
-    // set the timeout
-    if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
-            (void*) &params->timeout, sizeof(uint32_t),
-            DPI_OCI_ATTR_SUBSCR_TIMEOUT, "set timeout", error) < 0)
-        return DPI_FAILURE;
-
-    // set the IP address used on the client to listen for events
-    if (params->ipAddress && params->ipAddressLength > 0 &&
-            dpiOci__attrSet(subscr->env->handle, DPI_OCI_HTYPE_ENV,
-                    (void*) params->ipAddress, params->ipAddressLength,
-                    DPI_OCI_ATTR_SUBSCR_IPADDR, "set IP address", error) < 0)
-        return DPI_FAILURE;
-
-    // set the port number used on the client to listen for events
-    if (params->portNumber > 0 && dpiOci__attrSet(subscr->env->handle,
-            DPI_OCI_HTYPE_ENV, (void*) &params->portNumber, 0,
-            DPI_OCI_ATTR_SUBSCR_PORTNO, "set port number", error) < 0)
-        return DPI_FAILURE;
-
-    // set the context for the callback
-    if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
-            (void*) subscr, 0, DPI_OCI_ATTR_SUBSCR_CTX, "set callback context",
-            error) < 0)
-        return DPI_FAILURE;
-
-    // set the callback, if applicable
-    if (params->callback && dpiOci__attrSet(subscr->handle,
-            DPI_OCI_HTYPE_SUBSCRIPTION, (void*) dpiSubscr__callback, 0,
-            DPI_OCI_ATTR_SUBSCR_CALLBACK, "set callback", error) < 0)
-        return DPI_FAILURE;
-
-    // set the subscription name, if applicable
-    if (params->name && params->nameLength > 0 &&
-            dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
-                    (void*) params->name, params->nameLength,
-                    DPI_OCI_ATTR_SUBSCR_NAME, "set name", error) < 0)
-        return DPI_FAILURE;
-
-    // set QOS flags
-    qosFlags = 0;
-    if (params->qos & DPI_SUBSCR_QOS_RELIABLE)
-        qosFlags |= DPI_OCI_SUBSCR_QOS_RELIABLE;
-    if (params->qos & DPI_SUBSCR_QOS_DEREG_NFY)
-        qosFlags |= DPI_OCI_SUBSCR_QOS_PURGE_ON_NTFN;
-    if (qosFlags && dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
-            (void*) &qosFlags, sizeof(uint32_t), DPI_OCI_ATTR_SUBSCR_QOSFLAGS,
-            "set QOS", error) < 0)
-        return DPI_FAILURE;
-
-    // set CQ specific QOS flags
-    qosFlags = 0;
-    if (params->qos & DPI_SUBSCR_QOS_QUERY)
-        qosFlags |= DPI_OCI_SUBSCR_CQ_QOS_QUERY;
-    if (params->qos & DPI_SUBSCR_QOS_BEST_EFFORT)
-        qosFlags |= DPI_OCI_SUBSCR_CQ_QOS_BEST_EFFORT;
-    if (qosFlags && dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
-            (void*) &qosFlags, sizeof(uint32_t),
-            DPI_OCI_ATTR_SUBSCR_CQ_QOSFLAGS, "set CQ QOS", error) < 0)
-        return DPI_FAILURE;
-
-    // set rowids flag, if applicable
-    if (params->qos & DPI_SUBSCR_QOS_ROWIDS) {
-        rowids = 1;
-        if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
-                (void*) &rowids, 0, DPI_OCI_ATTR_CHNF_ROWIDS,
-                "set rowids flag", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set which operations are desired, if applicable
-    if (params->operations && dpiOci__attrSet(subscr->handle,
-            DPI_OCI_HTYPE_SUBSCRIPTION, (void*) &params->operations, 0,
-            DPI_OCI_ATTR_CHNF_OPERATIONS, "set operations", error) < 0)
-        return DPI_FAILURE;
-
-    // set grouping information, if applicable
-    if (params->groupingClass) {
-
-        // set grouping class
-        if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
-                (void*) &params->groupingClass, 0,
-                DPI_OCI_ATTR_SUBSCR_NTFN_GROUPING_CLASS, "set grouping class",
-                error) < 0)
-            return DPI_FAILURE;
-
-        // set grouping value
-        if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
-                (void*) &params->groupingValue, 0,
-                DPI_OCI_ATTR_SUBSCR_NTFN_GROUPING_VALUE, "set grouping value",
-                error) < 0)
-            return DPI_FAILURE;
-
-        // set grouping type
-        if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
-                (void*) &params->groupingType, 0,
-                DPI_OCI_ATTR_SUBSCR_NTFN_GROUPING_TYPE, "set grouping type",
-                error) < 0)
-            return DPI_FAILURE;
-
-        // set grouping repeat count
-        int32Val = DPI_SUBSCR_GROUPING_FOREVER;
-        if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
-                (void*) &int32Val, 0,
-                DPI_OCI_ATTR_SUBSCR_NTFN_GROUPING_REPEAT_COUNT,
-                "set grouping repeat count", error) < 0)
-            return DPI_FAILURE;
-
-    }
-
-    // register the subscription; client initiated subscriptions are only valid
-    // with 19.4 client and database
-    mode = DPI_OCI_DEFAULT;
-    if (params->clientInitiated) {
-        if (dpiUtils__checkClientVersion(conn->env->versionInfo, 19, 4,
-                error) < 0)
-            return DPI_FAILURE;
-        if (dpiUtils__checkDatabaseVersion(conn, 19, 4, error) < 0)
-            return DPI_FAILURE;
-        mode = DPI_OCI_SECURE_NOTIFICATION;
-    }
-    if (dpiOci__subscriptionRegister(conn, &subscr->handle, mode, error) < 0)
-        return DPI_FAILURE;
-    subscr->registered = 1;
-
-    // acquire the registration id
-    if (dpiOci__attrGet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
-            &params->outRegId, NULL, DPI_OCI_ATTR_SUBSCR_CQ_REGID,
-            "get registration id", error) < 0)
-        return DPI_FAILURE;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr__free() [INTERNAL]
-//   Free the memory and any resources associated with the subscription.
-//-----------------------------------------------------------------------------
-void dpiSubscr__free(dpiSubscr *subscr, dpiError *error)
-{
-    dpiMutex__acquire(subscr->mutex);
-    if (subscr->handle) {
-        if (subscr->registered)
-            dpiOci__subscriptionUnRegister(subscr->conn, subscr, error);
-        dpiOci__handleFree(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION);
-        subscr->handle = NULL;
-    }
-    if (subscr->conn) {
-        dpiGen__setRefCount(subscr->conn, error, -1);
-        subscr->conn = NULL;
-    }
-    dpiMutex__release(subscr->mutex);
-    dpiMutex__destroy(subscr->mutex);
-    dpiUtils__freeMemory(subscr);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr__freeMessage() [INTERNAL]
-//   Free memory associated with the message.
-//-----------------------------------------------------------------------------
-static void dpiSubscr__freeMessage(dpiSubscrMessage *message)
-{
-    dpiSubscrMessageQuery *query;
-    uint32_t i, j;
-
-    // free the tables for the message
-    if (message->numTables > 0) {
-        for (i = 0; i < message->numTables; i++) {
-            if (message->tables[i].numRows > 0)
-                dpiUtils__freeMemory(message->tables[i].rows);
-        }
-        dpiUtils__freeMemory(message->tables);
-    }
-
-    // free the queries for the message
-    if (message->numQueries > 0) {
-        for (i = 0; i < message->numQueries; i++) {
-            query = &message->queries[i];
-            if (query->numTables > 0) {
-                for (j = 0; j < query->numTables; j++) {
-                    if (query->tables[j].numRows > 0)
-                        dpiUtils__freeMemory(query->tables[j].rows);
-                }
-                dpiUtils__freeMemory(query->tables);
-            }
-        }
-        dpiUtils__freeMemory(message->queries);
-    }
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr__populateAQMessage() [INTERNAL]
-//   Populate message with details.
-//-----------------------------------------------------------------------------
-static int dpiSubscr__populateAQMessage(dpiSubscr *subscr,
-        dpiSubscrMessage *message, void *descriptor, dpiError *error)
-{
-    uint32_t flags = 0;
-    void *rawValue;
-
-    // determine if message is a deregistration message
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_AQNFY_DESCRIPTOR, &flags,
-            NULL, DPI_OCI_ATTR_NFY_FLAGS, "get flags", error) < 0)
-        return DPI_FAILURE;
-    message->eventType = (flags == 1) ? DPI_EVENT_DEREG : DPI_EVENT_AQ;
-    if (message->eventType == DPI_EVENT_DEREG) {
-        subscr->registered = 0;
-        return DPI_SUCCESS;
-    }
-
-    // determine the name of the queue which spawned the event
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_AQNFY_DESCRIPTOR,
-            (void*) &message->queueName, &message->queueNameLength,
-            DPI_OCI_ATTR_QUEUE_NAME, "get queue name", error) < 0)
-        return DPI_FAILURE;
-
-    // determine the consumer name for the queue that spawned the event
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_AQNFY_DESCRIPTOR,
-            (void*) &message->consumerName, &message->consumerNameLength,
-            DPI_OCI_ATTR_CONSUMER_NAME, "get consumer name", error) < 0)
-        return DPI_FAILURE;
-
-    // determine the msgid of the message of queue that spawned the event
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_AQNFY_DESCRIPTOR, &rawValue,
-            NULL, DPI_OCI_ATTR_NFY_MSGID, "get message id", error) < 0)
-        return DPI_FAILURE;
-    dpiOci__rawPtr(subscr->env->handle, rawValue, (void**) &message->aqMsgId);
-    dpiOci__rawSize(subscr->env->handle, rawValue, &message->aqMsgIdLength);
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr__populateObjectChangeMessage() [INTERNAL]
-//   Populate object change message with details.
-//-----------------------------------------------------------------------------
-static int dpiSubscr__populateObjectChangeMessage(dpiSubscr *subscr,
-        dpiSubscrMessage *message, void *descriptor, dpiError *error)
-{
-    void **tableDescriptor, *indicator;
-    int32_t numTables;
-    void *tables;
-    uint32_t i;
-    int exists;
-
-    // determine table collection
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CHDES, &tables, 0,
-            DPI_OCI_ATTR_CHDES_TABLE_CHANGES, "get tables", error) < 0)
-        return DPI_FAILURE;
-    if (!tables)
-        return DPI_SUCCESS;
-
-    // determine number of tables
-    if (dpiOci__collSize(subscr->conn, tables, &numTables, error) < 0)
-        return DPI_FAILURE;
-
-    // allocate memory for table entries
-    if (dpiUtils__allocateMemory((size_t) numTables,
-            sizeof(dpiSubscrMessageTable), 1, "allocate msg tables",
-            (void**) &message->tables, error) < 0)
-        return DPI_FAILURE;
-    message->numTables = (uint32_t) numTables;
-
-    // populate message table entries
-    for (i = 0; i < message->numTables; i++) {
-        if (dpiOci__collGetElem(subscr->conn, tables, (int32_t) i, &exists,
-                (void**) &tableDescriptor, &indicator, error) < 0)
-            return DPI_FAILURE;
-        if (dpiSubscr__populateMessageTable(subscr, &message->tables[i],
-                *tableDescriptor, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr__populateMessage() [INTERNAL]
-//   Populate message with details.
-//-----------------------------------------------------------------------------
-static int dpiSubscr__populateMessage(dpiSubscr *subscr,
-        dpiSubscrMessage *message, void *descriptor, dpiError *error)
-{
-    void *rawValue;
-
-    // if quality of service flag indicates that deregistration should take
-    // place when the first notification is received, mark the subscription
-    // as no longer registered
-    if (subscr->qos & DPI_SUBSCR_QOS_DEREG_NFY)
-        subscr->registered = 0;
-
-    // handle AQ messages, if applicable
-    if (subscr->subscrNamespace == DPI_SUBSCR_NAMESPACE_AQ)
-        return dpiSubscr__populateAQMessage(subscr, message, descriptor,
-                error);
-
-    // determine the type of event that was spawned
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CHDES, &message->eventType,
-            NULL, DPI_OCI_ATTR_CHDES_NFYTYPE, "get event type", error) < 0)
-        return DPI_FAILURE;
-
-    // determine the name of the database which spawned the event
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CHDES,
-            (void*) &message->dbName, &message->dbNameLength,
-            DPI_OCI_ATTR_CHDES_DBNAME, "get DB name", error) < 0)
-        return DPI_FAILURE;
-
-    // determine the id of the transaction which spawned the event
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CHDES, &rawValue, NULL,
-            DPI_OCI_ATTR_CHDES_XID, "get transaction id", error) < 0)
-        return DPI_FAILURE;
-    dpiOci__rawPtr(subscr->env->handle, rawValue, (void**) &message->txId);
-    dpiOci__rawSize(subscr->env->handle, rawValue, &message->txIdLength);
-
-    // populate event specific attributes
-    switch (message->eventType) {
-        case DPI_EVENT_OBJCHANGE:
-            return dpiSubscr__populateObjectChangeMessage(subscr, message,
-                    descriptor, error);
-        case DPI_EVENT_QUERYCHANGE:
-            return dpiSubscr__populateQueryChangeMessage(subscr, message,
-                    descriptor, error);
-        case DPI_EVENT_DEREG:
-            subscr->registered = 0;
-            break;
-        case DPI_EVENT_STARTUP:
-        case DPI_EVENT_SHUTDOWN:
-        case DPI_EVENT_SHUTDOWN_ANY:
-            break;
-        default:
-            return dpiError__set(error, "event type", DPI_ERR_NOT_SUPPORTED);
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr__populateMessageQuery() [INTERNAL]
-//   Populate a message query structure from the OCI descriptor.
-//-----------------------------------------------------------------------------
-static int dpiSubscr__populateMessageQuery(dpiSubscr *subscr,
-        dpiSubscrMessageQuery *query, void *descriptor, dpiError *error)
-{
-    void **tableDescriptor, *indicator, *tables;
-    int32_t numTables;
-    uint32_t i;
-    int exists;
-
-    // determine query id
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CQDES, &query->id, 0,
-            DPI_OCI_ATTR_CQDES_QUERYID, "get id", error) < 0)
-        return DPI_FAILURE;
-
-    // determine operation
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CQDES, &query->operation, 0,
-            DPI_OCI_ATTR_CQDES_OPERATION, "get operation", error) < 0)
-        return DPI_FAILURE;
-
-    // determine table collection
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CQDES, &tables, 0,
-            DPI_OCI_ATTR_CQDES_TABLE_CHANGES, "get table descriptor",
-            error) < 0)
-        return DPI_FAILURE;
-    if (!tables)
-        return DPI_SUCCESS;
-
-    // determine number of tables
-    if (dpiOci__collSize(subscr->conn, tables, &numTables, error) < 0)
-        return DPI_FAILURE;
-
-    // allocate memory for table entries
-    if (dpiUtils__allocateMemory((size_t) numTables,
-            sizeof(dpiSubscrMessageTable), 1, "allocate query tables",
-            (void**) &query->tables, error) < 0)
-        return DPI_FAILURE;
-    query->numTables = (uint32_t) numTables;
-
-    // populate message table entries
-    for (i = 0; i < query->numTables; i++) {
-        if (dpiOci__collGetElem(subscr->conn, tables, (int32_t) i, &exists,
-                (void**) &tableDescriptor, &indicator, error) < 0)
-            return DPI_FAILURE;
-        if (dpiSubscr__populateMessageTable(subscr, &query->tables[i],
-                *tableDescriptor, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr__populateMessageRow() [INTERNAL]
-//   Populate a message row structure from the OCI descriptor.
-//-----------------------------------------------------------------------------
-static int dpiSubscr__populateMessageRow(dpiSubscrMessageRow *row,
-        void *descriptor, dpiError *error)
-{
-    // determine operation
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_ROW_CHDES, &row->operation,
-            0, DPI_OCI_ATTR_CHDES_ROW_OPFLAGS, "get operation", error) < 0)
-        return DPI_FAILURE;
-
-    // determine rowid
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_ROW_CHDES,
-            (void*) &row->rowid, &row->rowidLength,
-            DPI_OCI_ATTR_CHDES_ROW_ROWID, "get rowid", error) < 0)
-        return DPI_FAILURE;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr__populateMessageTable() [INTERNAL]
-//   Populate a message table structure from the OCI descriptor.
-//-----------------------------------------------------------------------------
-static int dpiSubscr__populateMessageTable(dpiSubscr *subscr,
-        dpiSubscrMessageTable *table, void *descriptor, dpiError *error)
-{
-    void **rowDescriptor, *indicator, *rows;
-    int32_t numRows;
-    int exists;
-    uint32_t i;
-
-    // determine operation
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_TABLE_CHDES,
-            &table->operation, 0, DPI_OCI_ATTR_CHDES_TABLE_OPFLAGS,
-            "get operation", error) < 0)
-        return DPI_FAILURE;
-
-    // determine table name
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_TABLE_CHDES,
-            (void*) &table->name, &table->nameLength,
-            DPI_OCI_ATTR_CHDES_TABLE_NAME, "get table name", error) < 0)
-        return DPI_FAILURE;
-
-    // if change invalidated all rows, nothing to do
-    if (table->operation & DPI_OPCODE_ALL_ROWS)
-        return DPI_SUCCESS;
-
-    // determine rows collection
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_TABLE_CHDES, &rows, 0,
-            DPI_OCI_ATTR_CHDES_TABLE_ROW_CHANGES, "get rows descriptor",
-            error) < 0)
-        return DPI_FAILURE;
-
-    // determine number of rows in collection
-    if (dpiOci__collSize(subscr->conn, rows, &numRows, error) < 0)
-        return DPI_FAILURE;
-
-    // allocate memory for row entries
-    if (dpiUtils__allocateMemory((size_t) numRows, sizeof(dpiSubscrMessageRow),
-            1, "allocate rows", (void**) &table->rows, error) < 0)
-        return DPI_FAILURE;
-    table->numRows = (uint32_t) numRows;
-
-    // populate the rows attribute
-    for (i = 0; i < table->numRows; i++) {
-        if (dpiOci__collGetElem(subscr->conn, rows, (int32_t) i, &exists,
-                (void**) &rowDescriptor, &indicator, error) < 0)
-            return DPI_FAILURE;
-        if (dpiSubscr__populateMessageRow(&table->rows[i], *rowDescriptor,
-                error) < 0)
-            return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr__populateQueryChangeMessage() [INTERNAL]
-//   Populate query change message with details.
-//-----------------------------------------------------------------------------
-static int dpiSubscr__populateQueryChangeMessage(dpiSubscr *subscr,
-        dpiSubscrMessage *message, void *descriptor, dpiError *error)
-{
-    void **queryDescriptor, *indicator, *queries;
-    int32_t numQueries;
-    int exists;
-    uint32_t i;
-
-    // determine query collection
-    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CHDES, &queries, 0,
-            DPI_OCI_ATTR_CHDES_QUERIES, "get queries", error) < 0)
-        return DPI_FAILURE;
-    if (!queries)
-        return DPI_SUCCESS;
-
-    // determine number of queries
-    if (dpiOci__collSize(subscr->conn, queries, &numQueries, error) < 0)
-        return DPI_FAILURE;
-
-    // allocate memory for query entries
-    if (dpiUtils__allocateMemory((size_t) numQueries,
-            sizeof(dpiSubscrMessageQuery), 1, "allocate queries",
-            (void**) &message->queries, error) < 0)
-        return DPI_FAILURE;
-    message->numQueries = (uint32_t) numQueries;
-
-    // populate each entry with a message query instance
-    for (i = 0; i < message->numQueries; i++) {
-        if (dpiOci__collGetElem(subscr->conn, queries, (int32_t) i, &exists,
-                (void**) &queryDescriptor, &indicator, error) < 0)
-            return DPI_FAILURE;
-        if (dpiSubscr__populateMessageQuery(subscr, &message->queries[i],
-                *queryDescriptor, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr__prepareStmt() [INTERNAL]
-//   Internal method for preparing statement against a subscription. This
-// allows for normal error processing without having to worry about freeing the
-// statement for every error that might take place.
-//-----------------------------------------------------------------------------
-static int dpiSubscr__prepareStmt(dpiSubscr *subscr, dpiStmt *stmt,
-        const char *sql, uint32_t sqlLength, dpiError *error)
-{
-    // prepare statement for execution; only SELECT statements are supported
-    if (dpiStmt__prepare(stmt, sql, sqlLength, NULL, 0, error) < 0)
-        return DPI_FAILURE;
-    if (stmt->statementType != DPI_STMT_TYPE_SELECT)
-        return dpiError__set(error, "subscr prepare statement",
-                DPI_ERR_NOT_SUPPORTED);
-
-    // fetch array size is set to 1 in order to avoid over allocation since
-    // the query is not really going to be used for fetching rows, just for
-    // registration
-    stmt->fetchArraySize = 1;
-
-    // set subscription handle
-    return dpiOci__attrSet(stmt->handle, DPI_OCI_HTYPE_STMT, subscr->handle, 0,
-            DPI_OCI_ATTR_CHNF_REGHANDLE, "set subscription handle", error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr_addRef() [PUBLIC]
-//   Add a reference to the subscription.
-//-----------------------------------------------------------------------------
-int dpiSubscr_addRef(dpiSubscr *subscr)
-{
-    return dpiGen__addRef(subscr, DPI_HTYPE_SUBSCR, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr_prepareStmt() [PUBLIC]
-//   Prepare statement for registration with subscription.
-//-----------------------------------------------------------------------------
-int dpiSubscr_prepareStmt(dpiSubscr *subscr, const char *sql,
-        uint32_t sqlLength, dpiStmt **stmt)
-{
-    dpiStmt *tempStmt;
-    dpiError error;
-
-    if (dpiSubscr__check(subscr, __func__, &error) < 0)
-        return dpiGen__endPublicFn(subscr, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(subscr, sql)
-    DPI_CHECK_PTR_NOT_NULL(subscr, stmt)
-    if (dpiStmt__allocate(subscr->conn, 0, &tempStmt, &error) < 0)
-        return dpiGen__endPublicFn(subscr, DPI_FAILURE, &error);
-    if (dpiSubscr__prepareStmt(subscr, tempStmt, sql, sqlLength,
-            &error) < 0) {
-        dpiStmt__free(tempStmt, &error);
-        return dpiGen__endPublicFn(subscr, DPI_FAILURE, &error);
-    }
-
-    *stmt = tempStmt;
-    return dpiGen__endPublicFn(subscr, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiSubscr_release() [PUBLIC]
-//   Release a reference to the subscription.
-//-----------------------------------------------------------------------------
-int dpiSubscr_release(dpiSubscr *subscr)
-{
-    return dpiGen__release(subscr, DPI_HTYPE_SUBSCR, __func__);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiSubscr.h ./odpi/src/dpiSubscr.h
--- patched-godror/odpi/src/dpiSubscr.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiSubscr.h	2024-05-14 14:55:13
@@ -0,0 +1,734 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiSubscr.c
+//   Implementation of subscriptions (CQN).
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+// forward declarations of internal functions only used in this file
+static void dpiSubscr__freeMessage(dpiSubscrMessage *message);
+static int dpiSubscr__populateMessage(dpiSubscr *subscr,
+        dpiSubscrMessage *message, void *descriptor, dpiError *error);
+static int dpiSubscr__populateMessageTable(dpiSubscr *subscr,
+        dpiSubscrMessageTable *table, void *descriptor, dpiError *error);
+static int dpiSubscr__populateQueryChangeMessage(dpiSubscr *subscr,
+        dpiSubscrMessage *message, void *descriptor, dpiError *error);
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr__callback() [INTERNAL]
+//   Callback that is used to execute the callback registered when the
+// subscription was created.
+//-----------------------------------------------------------------------------
+static void dpiSubscr__callback(dpiSubscr *subscr, UNUSED void *handle,
+        UNUSED void *payload, UNUSED uint32_t payloadLength, void *descriptor,
+        UNUSED uint32_t mode)
+{
+    dpiSubscrMessage message;
+    dpiErrorInfo errorInfo;
+    dpiError error;
+
+    // ensure that the subscription handle is still valid
+    if (dpiGen__startPublicFn(subscr, DPI_HTYPE_SUBSCR, __func__,
+            &error) < 0) {
+        dpiGen__endPublicFn(subscr, DPI_FAILURE, &error);
+        return;
+    }
+
+    // if the subscription is no longer registered, nothing further to do
+    dpiMutex__acquire(subscr->mutex);
+    if (!subscr->registered) {
+        dpiMutex__release(subscr->mutex);
+        dpiGen__endPublicFn(subscr, DPI_SUCCESS, &error);
+        return;
+    }
+
+    // populate message
+    memset(&message, 0, sizeof(message));
+    if (dpiSubscr__populateMessage(subscr, &message, descriptor, &error) < 0) {
+        dpiError__getInfo(&error, &errorInfo);
+        message.errorInfo = &errorInfo;
+    }
+    message.registered = subscr->registered;
+
+    // invoke user callback; temporarily increase reference count to ensure
+    // that the subscription is not freed during the callback
+    dpiGen__setRefCount(subscr, &error, 1);
+    (*subscr->callback)(subscr->callbackContext, &message);
+    dpiSubscr__freeMessage(&message);
+    dpiMutex__release(subscr->mutex);
+    dpiGen__setRefCount(subscr, &error, -1);
+    dpiGen__endPublicFn(subscr, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr__check() [INTERNAL]
+//   Determine if the subscription is open and available for use.
+//-----------------------------------------------------------------------------
+static int dpiSubscr__check(dpiSubscr *subscr, const char *fnName,
+        dpiError *error)
+{
+    if (dpiGen__startPublicFn(subscr, DPI_HTYPE_SUBSCR, fnName, error) < 0)
+        return DPI_FAILURE;
+    if (!subscr->handle)
+        return dpiError__set(error, "check closed", DPI_ERR_SUBSCR_CLOSED);
+    return dpiConn__checkConnected(subscr->conn, error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr__create() [INTERNAL]
+//   Create a new subscription structure and return it. In case of error NULL
+// is returned.
+//-----------------------------------------------------------------------------
+int dpiSubscr__create(dpiSubscr *subscr, dpiConn *conn,
+        dpiSubscrCreateParams *params, dpiError *error)
+{
+    uint32_t qosFlags, mode;
+    int32_t int32Val;
+    int rowids;
+
+    // retain a reference to the connection
+    dpiGen__setRefCount(conn, error, 1);
+    subscr->conn = conn;
+    subscr->callback = params->callback;
+    subscr->callbackContext = params->callbackContext;
+    subscr->subscrNamespace = params->subscrNamespace;
+    subscr->qos = params->qos;
+    subscr->clientInitiated = params->clientInitiated;
+    dpiMutex__initialize(subscr->mutex);
+
+    // create the subscription handle
+    if (dpiOci__handleAlloc(conn->env->handle, &subscr->handle,
+            DPI_OCI_HTYPE_SUBSCRIPTION, "create subscr handle", error) < 0)
+        return DPI_FAILURE;
+
+    // set the namespace
+    if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
+            (void*) &params->subscrNamespace, sizeof(uint32_t),
+            DPI_OCI_ATTR_SUBSCR_NAMESPACE, "set namespace", error) < 0)
+        return DPI_FAILURE;
+
+    // set the protocol
+    if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
+            (void*) &params->protocol, sizeof(uint32_t),
+            DPI_OCI_ATTR_SUBSCR_RECPTPROTO, "set protocol", error) < 0)
+        return DPI_FAILURE;
+
+    // set the timeout
+    if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
+            (void*) &params->timeout, sizeof(uint32_t),
+            DPI_OCI_ATTR_SUBSCR_TIMEOUT, "set timeout", error) < 0)
+        return DPI_FAILURE;
+
+    // set the IP address used on the client to listen for events
+    if (params->ipAddress && params->ipAddressLength > 0 &&
+            dpiOci__attrSet(subscr->env->handle, DPI_OCI_HTYPE_ENV,
+                    (void*) params->ipAddress, params->ipAddressLength,
+                    DPI_OCI_ATTR_SUBSCR_IPADDR, "set IP address", error) < 0)
+        return DPI_FAILURE;
+
+    // set the port number used on the client to listen for events
+    if (params->portNumber > 0 && dpiOci__attrSet(subscr->env->handle,
+            DPI_OCI_HTYPE_ENV, (void*) &params->portNumber, 0,
+            DPI_OCI_ATTR_SUBSCR_PORTNO, "set port number", error) < 0)
+        return DPI_FAILURE;
+
+    // set the context for the callback
+    if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
+            (void*) subscr, 0, DPI_OCI_ATTR_SUBSCR_CTX, "set callback context",
+            error) < 0)
+        return DPI_FAILURE;
+
+    // set the callback, if applicable
+    if (params->callback && dpiOci__attrSet(subscr->handle,
+            DPI_OCI_HTYPE_SUBSCRIPTION, (void*) dpiSubscr__callback, 0,
+            DPI_OCI_ATTR_SUBSCR_CALLBACK, "set callback", error) < 0)
+        return DPI_FAILURE;
+
+    // set the subscription name, if applicable
+    if (params->name && params->nameLength > 0 &&
+            dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
+                    (void*) params->name, params->nameLength,
+                    DPI_OCI_ATTR_SUBSCR_NAME, "set name", error) < 0)
+        return DPI_FAILURE;
+
+    // set QOS flags
+    qosFlags = 0;
+    if (params->qos & DPI_SUBSCR_QOS_RELIABLE)
+        qosFlags |= DPI_OCI_SUBSCR_QOS_RELIABLE;
+    if (params->qos & DPI_SUBSCR_QOS_DEREG_NFY)
+        qosFlags |= DPI_OCI_SUBSCR_QOS_PURGE_ON_NTFN;
+    if (qosFlags && dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
+            (void*) &qosFlags, sizeof(uint32_t), DPI_OCI_ATTR_SUBSCR_QOSFLAGS,
+            "set QOS", error) < 0)
+        return DPI_FAILURE;
+
+    // set CQ specific QOS flags
+    qosFlags = 0;
+    if (params->qos & DPI_SUBSCR_QOS_QUERY)
+        qosFlags |= DPI_OCI_SUBSCR_CQ_QOS_QUERY;
+    if (params->qos & DPI_SUBSCR_QOS_BEST_EFFORT)
+        qosFlags |= DPI_OCI_SUBSCR_CQ_QOS_BEST_EFFORT;
+    if (qosFlags && dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
+            (void*) &qosFlags, sizeof(uint32_t),
+            DPI_OCI_ATTR_SUBSCR_CQ_QOSFLAGS, "set CQ QOS", error) < 0)
+        return DPI_FAILURE;
+
+    // set rowids flag, if applicable
+    if (params->qos & DPI_SUBSCR_QOS_ROWIDS) {
+        rowids = 1;
+        if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
+                (void*) &rowids, 0, DPI_OCI_ATTR_CHNF_ROWIDS,
+                "set rowids flag", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set which operations are desired, if applicable
+    if (params->operations && dpiOci__attrSet(subscr->handle,
+            DPI_OCI_HTYPE_SUBSCRIPTION, (void*) &params->operations, 0,
+            DPI_OCI_ATTR_CHNF_OPERATIONS, "set operations", error) < 0)
+        return DPI_FAILURE;
+
+    // set grouping information, if applicable
+    if (params->groupingClass) {
+
+        // set grouping class
+        if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
+                (void*) &params->groupingClass, 0,
+                DPI_OCI_ATTR_SUBSCR_NTFN_GROUPING_CLASS, "set grouping class",
+                error) < 0)
+            return DPI_FAILURE;
+
+        // set grouping value
+        if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
+                (void*) &params->groupingValue, 0,
+                DPI_OCI_ATTR_SUBSCR_NTFN_GROUPING_VALUE, "set grouping value",
+                error) < 0)
+            return DPI_FAILURE;
+
+        // set grouping type
+        if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
+                (void*) &params->groupingType, 0,
+                DPI_OCI_ATTR_SUBSCR_NTFN_GROUPING_TYPE, "set grouping type",
+                error) < 0)
+            return DPI_FAILURE;
+
+        // set grouping repeat count
+        int32Val = DPI_SUBSCR_GROUPING_FOREVER;
+        if (dpiOci__attrSet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
+                (void*) &int32Val, 0,
+                DPI_OCI_ATTR_SUBSCR_NTFN_GROUPING_REPEAT_COUNT,
+                "set grouping repeat count", error) < 0)
+            return DPI_FAILURE;
+
+    }
+
+    // register the subscription; client initiated subscriptions are only valid
+    // with 19.4 client and database
+    mode = DPI_OCI_DEFAULT;
+    if (params->clientInitiated) {
+        if (dpiUtils__checkClientVersion(conn->env->versionInfo, 19, 4,
+                error) < 0)
+            return DPI_FAILURE;
+        if (dpiUtils__checkDatabaseVersion(conn, 19, 4, error) < 0)
+            return DPI_FAILURE;
+        mode = DPI_OCI_SECURE_NOTIFICATION;
+    }
+    if (dpiOci__subscriptionRegister(conn, &subscr->handle, mode, error) < 0)
+        return DPI_FAILURE;
+    subscr->registered = 1;
+
+    // acquire the registration id
+    if (dpiOci__attrGet(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION,
+            &params->outRegId, NULL, DPI_OCI_ATTR_SUBSCR_CQ_REGID,
+            "get registration id", error) < 0)
+        return DPI_FAILURE;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr__free() [INTERNAL]
+//   Free the memory and any resources associated with the subscription.
+//-----------------------------------------------------------------------------
+void dpiSubscr__free(dpiSubscr *subscr, dpiError *error)
+{
+    dpiMutex__acquire(subscr->mutex);
+    if (subscr->handle) {
+        if (subscr->registered)
+            dpiOci__subscriptionUnRegister(subscr->conn, subscr, error);
+        dpiOci__handleFree(subscr->handle, DPI_OCI_HTYPE_SUBSCRIPTION);
+        subscr->handle = NULL;
+    }
+    if (subscr->conn) {
+        dpiGen__setRefCount(subscr->conn, error, -1);
+        subscr->conn = NULL;
+    }
+    dpiMutex__release(subscr->mutex);
+    dpiMutex__destroy(subscr->mutex);
+    dpiUtils__freeMemory(subscr);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr__freeMessage() [INTERNAL]
+//   Free memory associated with the message.
+//-----------------------------------------------------------------------------
+static void dpiSubscr__freeMessage(dpiSubscrMessage *message)
+{
+    dpiSubscrMessageQuery *query;
+    uint32_t i, j;
+
+    // free the tables for the message
+    if (message->numTables > 0) {
+        for (i = 0; i < message->numTables; i++) {
+            if (message->tables[i].numRows > 0)
+                dpiUtils__freeMemory(message->tables[i].rows);
+        }
+        dpiUtils__freeMemory(message->tables);
+    }
+
+    // free the queries for the message
+    if (message->numQueries > 0) {
+        for (i = 0; i < message->numQueries; i++) {
+            query = &message->queries[i];
+            if (query->numTables > 0) {
+                for (j = 0; j < query->numTables; j++) {
+                    if (query->tables[j].numRows > 0)
+                        dpiUtils__freeMemory(query->tables[j].rows);
+                }
+                dpiUtils__freeMemory(query->tables);
+            }
+        }
+        dpiUtils__freeMemory(message->queries);
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr__populateAQMessage() [INTERNAL]
+//   Populate message with details.
+//-----------------------------------------------------------------------------
+static int dpiSubscr__populateAQMessage(dpiSubscr *subscr,
+        dpiSubscrMessage *message, void *descriptor, dpiError *error)
+{
+    uint32_t flags = 0;
+    void *rawValue;
+
+    // determine if message is a deregistration message
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_AQNFY_DESCRIPTOR, &flags,
+            NULL, DPI_OCI_ATTR_NFY_FLAGS, "get flags", error) < 0)
+        return DPI_FAILURE;
+    message->eventType = (flags == 1) ? DPI_EVENT_DEREG : DPI_EVENT_AQ;
+    if (message->eventType == DPI_EVENT_DEREG) {
+        subscr->registered = 0;
+        return DPI_SUCCESS;
+    }
+
+    // determine the name of the queue which spawned the event
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_AQNFY_DESCRIPTOR,
+            (void*) &message->queueName, &message->queueNameLength,
+            DPI_OCI_ATTR_QUEUE_NAME, "get queue name", error) < 0)
+        return DPI_FAILURE;
+
+    // determine the consumer name for the queue that spawned the event
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_AQNFY_DESCRIPTOR,
+            (void*) &message->consumerName, &message->consumerNameLength,
+            DPI_OCI_ATTR_CONSUMER_NAME, "get consumer name", error) < 0)
+        return DPI_FAILURE;
+
+    // determine the msgid of the message of queue that spawned the event
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_AQNFY_DESCRIPTOR, &rawValue,
+            NULL, DPI_OCI_ATTR_NFY_MSGID, "get message id", error) < 0)
+        return DPI_FAILURE;
+    dpiOci__rawPtr(subscr->env->handle, rawValue, (void**) &message->aqMsgId);
+    dpiOci__rawSize(subscr->env->handle, rawValue, &message->aqMsgIdLength);
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr__populateObjectChangeMessage() [INTERNAL]
+//   Populate object change message with details.
+//-----------------------------------------------------------------------------
+static int dpiSubscr__populateObjectChangeMessage(dpiSubscr *subscr,
+        dpiSubscrMessage *message, void *descriptor, dpiError *error)
+{
+    void **tableDescriptor, *indicator;
+    int32_t numTables;
+    void *tables;
+    uint32_t i;
+    int exists;
+
+    // determine table collection
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CHDES, &tables, 0,
+            DPI_OCI_ATTR_CHDES_TABLE_CHANGES, "get tables", error) < 0)
+        return DPI_FAILURE;
+    if (!tables)
+        return DPI_SUCCESS;
+
+    // determine number of tables
+    if (dpiOci__collSize(subscr->conn, tables, &numTables, error) < 0)
+        return DPI_FAILURE;
+
+    // allocate memory for table entries
+    if (dpiUtils__allocateMemory((size_t) numTables,
+            sizeof(dpiSubscrMessageTable), 1, "allocate msg tables",
+            (void**) &message->tables, error) < 0)
+        return DPI_FAILURE;
+    message->numTables = (uint32_t) numTables;
+
+    // populate message table entries
+    for (i = 0; i < message->numTables; i++) {
+        if (dpiOci__collGetElem(subscr->conn, tables, (int32_t) i, &exists,
+                (void**) &tableDescriptor, &indicator, error) < 0)
+            return DPI_FAILURE;
+        if (dpiSubscr__populateMessageTable(subscr, &message->tables[i],
+                *tableDescriptor, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr__populateMessage() [INTERNAL]
+//   Populate message with details.
+//-----------------------------------------------------------------------------
+static int dpiSubscr__populateMessage(dpiSubscr *subscr,
+        dpiSubscrMessage *message, void *descriptor, dpiError *error)
+{
+    void *rawValue;
+
+    // if quality of service flag indicates that deregistration should take
+    // place when the first notification is received, mark the subscription
+    // as no longer registered
+    if (subscr->qos & DPI_SUBSCR_QOS_DEREG_NFY)
+        subscr->registered = 0;
+
+    // handle AQ messages, if applicable
+    if (subscr->subscrNamespace == DPI_SUBSCR_NAMESPACE_AQ)
+        return dpiSubscr__populateAQMessage(subscr, message, descriptor,
+                error);
+
+    // determine the type of event that was spawned
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CHDES, &message->eventType,
+            NULL, DPI_OCI_ATTR_CHDES_NFYTYPE, "get event type", error) < 0)
+        return DPI_FAILURE;
+
+    // determine the name of the database which spawned the event
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CHDES,
+            (void*) &message->dbName, &message->dbNameLength,
+            DPI_OCI_ATTR_CHDES_DBNAME, "get DB name", error) < 0)
+        return DPI_FAILURE;
+
+    // determine the id of the transaction which spawned the event
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CHDES, &rawValue, NULL,
+            DPI_OCI_ATTR_CHDES_XID, "get transaction id", error) < 0)
+        return DPI_FAILURE;
+    dpiOci__rawPtr(subscr->env->handle, rawValue, (void**) &message->txId);
+    dpiOci__rawSize(subscr->env->handle, rawValue, &message->txIdLength);
+
+    // populate event specific attributes
+    switch (message->eventType) {
+        case DPI_EVENT_OBJCHANGE:
+            return dpiSubscr__populateObjectChangeMessage(subscr, message,
+                    descriptor, error);
+        case DPI_EVENT_QUERYCHANGE:
+            return dpiSubscr__populateQueryChangeMessage(subscr, message,
+                    descriptor, error);
+        case DPI_EVENT_DEREG:
+            subscr->registered = 0;
+            break;
+        case DPI_EVENT_STARTUP:
+        case DPI_EVENT_SHUTDOWN:
+        case DPI_EVENT_SHUTDOWN_ANY:
+            break;
+        default:
+            return dpiError__set(error, "event type", DPI_ERR_NOT_SUPPORTED);
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr__populateMessageQuery() [INTERNAL]
+//   Populate a message query structure from the OCI descriptor.
+//-----------------------------------------------------------------------------
+static int dpiSubscr__populateMessageQuery(dpiSubscr *subscr,
+        dpiSubscrMessageQuery *query, void *descriptor, dpiError *error)
+{
+    void **tableDescriptor, *indicator, *tables;
+    int32_t numTables;
+    uint32_t i;
+    int exists;
+
+    // determine query id
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CQDES, &query->id, 0,
+            DPI_OCI_ATTR_CQDES_QUERYID, "get id", error) < 0)
+        return DPI_FAILURE;
+
+    // determine operation
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CQDES, &query->operation, 0,
+            DPI_OCI_ATTR_CQDES_OPERATION, "get operation", error) < 0)
+        return DPI_FAILURE;
+
+    // determine table collection
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CQDES, &tables, 0,
+            DPI_OCI_ATTR_CQDES_TABLE_CHANGES, "get table descriptor",
+            error) < 0)
+        return DPI_FAILURE;
+    if (!tables)
+        return DPI_SUCCESS;
+
+    // determine number of tables
+    if (dpiOci__collSize(subscr->conn, tables, &numTables, error) < 0)
+        return DPI_FAILURE;
+
+    // allocate memory for table entries
+    if (dpiUtils__allocateMemory((size_t) numTables,
+            sizeof(dpiSubscrMessageTable), 1, "allocate query tables",
+            (void**) &query->tables, error) < 0)
+        return DPI_FAILURE;
+    query->numTables = (uint32_t) numTables;
+
+    // populate message table entries
+    for (i = 0; i < query->numTables; i++) {
+        if (dpiOci__collGetElem(subscr->conn, tables, (int32_t) i, &exists,
+                (void**) &tableDescriptor, &indicator, error) < 0)
+            return DPI_FAILURE;
+        if (dpiSubscr__populateMessageTable(subscr, &query->tables[i],
+                *tableDescriptor, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr__populateMessageRow() [INTERNAL]
+//   Populate a message row structure from the OCI descriptor.
+//-----------------------------------------------------------------------------
+static int dpiSubscr__populateMessageRow(dpiSubscrMessageRow *row,
+        void *descriptor, dpiError *error)
+{
+    // determine operation
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_ROW_CHDES, &row->operation,
+            0, DPI_OCI_ATTR_CHDES_ROW_OPFLAGS, "get operation", error) < 0)
+        return DPI_FAILURE;
+
+    // determine rowid
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_ROW_CHDES,
+            (void*) &row->rowid, &row->rowidLength,
+            DPI_OCI_ATTR_CHDES_ROW_ROWID, "get rowid", error) < 0)
+        return DPI_FAILURE;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr__populateMessageTable() [INTERNAL]
+//   Populate a message table structure from the OCI descriptor.
+//-----------------------------------------------------------------------------
+static int dpiSubscr__populateMessageTable(dpiSubscr *subscr,
+        dpiSubscrMessageTable *table, void *descriptor, dpiError *error)
+{
+    void **rowDescriptor, *indicator, *rows;
+    int32_t numRows;
+    int exists;
+    uint32_t i;
+
+    // determine operation
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_TABLE_CHDES,
+            &table->operation, 0, DPI_OCI_ATTR_CHDES_TABLE_OPFLAGS,
+            "get operation", error) < 0)
+        return DPI_FAILURE;
+
+    // determine table name
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_TABLE_CHDES,
+            (void*) &table->name, &table->nameLength,
+            DPI_OCI_ATTR_CHDES_TABLE_NAME, "get table name", error) < 0)
+        return DPI_FAILURE;
+
+    // if change invalidated all rows, nothing to do
+    if (table->operation & DPI_OPCODE_ALL_ROWS)
+        return DPI_SUCCESS;
+
+    // determine rows collection
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_TABLE_CHDES, &rows, 0,
+            DPI_OCI_ATTR_CHDES_TABLE_ROW_CHANGES, "get rows descriptor",
+            error) < 0)
+        return DPI_FAILURE;
+
+    // determine number of rows in collection
+    if (dpiOci__collSize(subscr->conn, rows, &numRows, error) < 0)
+        return DPI_FAILURE;
+
+    // allocate memory for row entries
+    if (dpiUtils__allocateMemory((size_t) numRows, sizeof(dpiSubscrMessageRow),
+            1, "allocate rows", (void**) &table->rows, error) < 0)
+        return DPI_FAILURE;
+    table->numRows = (uint32_t) numRows;
+
+    // populate the rows attribute
+    for (i = 0; i < table->numRows; i++) {
+        if (dpiOci__collGetElem(subscr->conn, rows, (int32_t) i, &exists,
+                (void**) &rowDescriptor, &indicator, error) < 0)
+            return DPI_FAILURE;
+        if (dpiSubscr__populateMessageRow(&table->rows[i], *rowDescriptor,
+                error) < 0)
+            return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr__populateQueryChangeMessage() [INTERNAL]
+//   Populate query change message with details.
+//-----------------------------------------------------------------------------
+static int dpiSubscr__populateQueryChangeMessage(dpiSubscr *subscr,
+        dpiSubscrMessage *message, void *descriptor, dpiError *error)
+{
+    void **queryDescriptor, *indicator, *queries;
+    int32_t numQueries;
+    int exists;
+    uint32_t i;
+
+    // determine query collection
+    if (dpiOci__attrGet(descriptor, DPI_OCI_DTYPE_CHDES, &queries, 0,
+            DPI_OCI_ATTR_CHDES_QUERIES, "get queries", error) < 0)
+        return DPI_FAILURE;
+    if (!queries)
+        return DPI_SUCCESS;
+
+    // determine number of queries
+    if (dpiOci__collSize(subscr->conn, queries, &numQueries, error) < 0)
+        return DPI_FAILURE;
+
+    // allocate memory for query entries
+    if (dpiUtils__allocateMemory((size_t) numQueries,
+            sizeof(dpiSubscrMessageQuery), 1, "allocate queries",
+            (void**) &message->queries, error) < 0)
+        return DPI_FAILURE;
+    message->numQueries = (uint32_t) numQueries;
+
+    // populate each entry with a message query instance
+    for (i = 0; i < message->numQueries; i++) {
+        if (dpiOci__collGetElem(subscr->conn, queries, (int32_t) i, &exists,
+                (void**) &queryDescriptor, &indicator, error) < 0)
+            return DPI_FAILURE;
+        if (dpiSubscr__populateMessageQuery(subscr, &message->queries[i],
+                *queryDescriptor, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr__prepareStmt() [INTERNAL]
+//   Internal method for preparing statement against a subscription. This
+// allows for normal error processing without having to worry about freeing the
+// statement for every error that might take place.
+//-----------------------------------------------------------------------------
+static int dpiSubscr__prepareStmt(dpiSubscr *subscr, dpiStmt *stmt,
+        const char *sql, uint32_t sqlLength, dpiError *error)
+{
+    // prepare statement for execution; only SELECT statements are supported
+    if (dpiStmt__prepare(stmt, sql, sqlLength, NULL, 0, error) < 0)
+        return DPI_FAILURE;
+    if (stmt->statementType != DPI_STMT_TYPE_SELECT)
+        return dpiError__set(error, "subscr prepare statement",
+                DPI_ERR_NOT_SUPPORTED);
+
+    // fetch array size is set to 1 in order to avoid over allocation since
+    // the query is not really going to be used for fetching rows, just for
+    // registration
+    stmt->fetchArraySize = 1;
+
+    // set subscription handle
+    return dpiOci__attrSet(stmt->handle, DPI_OCI_HTYPE_STMT, subscr->handle, 0,
+            DPI_OCI_ATTR_CHNF_REGHANDLE, "set subscription handle", error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr_addRef() [PUBLIC]
+//   Add a reference to the subscription.
+//-----------------------------------------------------------------------------
+int dpiSubscr_addRef(dpiSubscr *subscr)
+{
+    return dpiGen__addRef(subscr, DPI_HTYPE_SUBSCR, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr_prepareStmt() [PUBLIC]
+//   Prepare statement for registration with subscription.
+//-----------------------------------------------------------------------------
+int dpiSubscr_prepareStmt(dpiSubscr *subscr, const char *sql,
+        uint32_t sqlLength, dpiStmt **stmt)
+{
+    dpiStmt *tempStmt;
+    dpiError error;
+
+    if (dpiSubscr__check(subscr, __func__, &error) < 0)
+        return dpiGen__endPublicFn(subscr, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(subscr, sql)
+    DPI_CHECK_PTR_NOT_NULL(subscr, stmt)
+    if (dpiStmt__allocate(subscr->conn, 0, &tempStmt, &error) < 0)
+        return dpiGen__endPublicFn(subscr, DPI_FAILURE, &error);
+    if (dpiSubscr__prepareStmt(subscr, tempStmt, sql, sqlLength,
+            &error) < 0) {
+        dpiStmt__free(tempStmt, &error);
+        return dpiGen__endPublicFn(subscr, DPI_FAILURE, &error);
+    }
+
+    *stmt = tempStmt;
+    return dpiGen__endPublicFn(subscr, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiSubscr_release() [PUBLIC]
+//   Release a reference to the subscription.
+//-----------------------------------------------------------------------------
+int dpiSubscr_release(dpiSubscr *subscr)
+{
+    return dpiGen__release(subscr, DPI_HTYPE_SUBSCR, __func__);
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiUtils.c ./odpi/src/dpiUtils.c
--- patched-godror/odpi/src/dpiUtils.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiUtils.c	1970-01-01 01:00:00
@@ -1,585 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiUtils.c
-//   Utility methods that aren't specific to a particular type.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-//-----------------------------------------------------------------------------
-// dpiUtils__allocateMemory() [INTERNAL]
-//   Method for allocating memory which permits tracing and populates the error
-// structure in the event of a memory allocation failure.
-//-----------------------------------------------------------------------------
-int dpiUtils__allocateMemory(size_t numMembers, size_t memberSize,
-        int clearMemory, const char *action, void **ptr, dpiError *error)
-{
-    if (clearMemory)
-        *ptr = calloc(numMembers, memberSize);
-    else *ptr = malloc(numMembers * memberSize);
-    if (!*ptr)
-        return dpiError__set(error, action, DPI_ERR_NO_MEMORY);
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_MEM)
-        dpiDebug__print("allocated %u bytes at %p (%s)\n",
-                numMembers * memberSize, *ptr, action);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiUtils__checkClientVersion() [INTERNAL]
-//   Check the Oracle Client version and verify that it is at least at the
-// minimum version that is required.
-//-----------------------------------------------------------------------------
-int dpiUtils__checkClientVersion(dpiVersionInfo *versionInfo,
-        int minVersionNum, int minReleaseNum, dpiError *error)
-{
-    if (versionInfo->versionNum < minVersionNum ||
-            (versionInfo->versionNum == minVersionNum &&
-                    versionInfo->releaseNum < minReleaseNum))
-        return dpiError__set(error, "check Oracle Client version",
-                DPI_ERR_ORACLE_CLIENT_TOO_OLD, versionInfo->versionNum,
-                versionInfo->releaseNum, minVersionNum, minReleaseNum);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiUtils__checkClientVersionMulti() [INTERNAL]
-//   Check the Oracle Client version and verify that it is at least at the
-// minimum version that is required.
-//-----------------------------------------------------------------------------
-int dpiUtils__checkClientVersionMulti(dpiVersionInfo *versionInfo,
-        int minVersionNum1, int minReleaseNum1, int minVersionNum2,
-        int minReleaseNum2, dpiError *error)
-{
-    if (versionInfo->versionNum < minVersionNum1 ||
-            (versionInfo->versionNum == minVersionNum1 &&
-                    versionInfo->releaseNum < minReleaseNum1) ||
-            (versionInfo->versionNum > minVersionNum1 &&
-                    versionInfo->versionNum < minVersionNum2) ||
-            (versionInfo->versionNum == minVersionNum2 &&
-                    versionInfo->releaseNum < minReleaseNum2))
-        return dpiError__set(error, "check Oracle Client version",
-                DPI_ERR_ORACLE_CLIENT_TOO_OLD_MULTI, versionInfo->versionNum,
-                versionInfo->releaseNum, minVersionNum1, minReleaseNum1,
-                minVersionNum2, minReleaseNum2);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiUtils__checkDatabaseVersion() [INTERNAL]
-//   Check the Oracle Database version and verify that it is at least at the
-// minimum version that is required.
-//-----------------------------------------------------------------------------
-int dpiUtils__checkDatabaseVersion(dpiConn *conn, int minVersionNum,
-        int minReleaseNum, dpiError *error)
-{
-    if (dpiConn__getServerVersion(conn, 0, error) < 0)
-        return DPI_FAILURE;
-    if (conn->versionInfo.versionNum < minVersionNum ||
-            (conn->versionInfo.versionNum == minVersionNum &&
-                    conn->versionInfo.releaseNum < minReleaseNum))
-        return dpiError__set(error, "check Oracle Database version",
-                DPI_ERR_ORACLE_DB_TOO_OLD, conn->versionInfo.versionNum,
-                conn->versionInfo.releaseNum, minVersionNum, minReleaseNum);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiUtils__clearMemory() [INTERNAL]
-//   Method for clearing memory that will not be optimised away by the
-// compiler. Simple use of memset() can be optimised away. This routine makes
-// use of a volatile pointer which most compilers will avoid optimising away,
-// even if the pointer appears to be unused after the call.
-//-----------------------------------------------------------------------------
-void dpiUtils__clearMemory(void *ptr, size_t length)
-{
-    volatile unsigned char *temp = (unsigned char *) ptr;
-
-    while (length--)
-        *temp++ = '\0';
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiUtils__ensureBuffer() [INTERNAL]
-//   Ensure that a buffer of the specified size is available. If a buffer of
-// the requested size is not available, free any existing buffer and allocate a
-// new, larger buffer.
-//-----------------------------------------------------------------------------
-int dpiUtils__ensureBuffer(size_t desiredSize, const char *action,
-        void **ptr, size_t *currentSize, dpiError *error)
-{
-    if (desiredSize <= *currentSize)
-        return DPI_SUCCESS;
-    if (*ptr) {
-        dpiUtils__freeMemory(*ptr);
-        *ptr = NULL;
-        *currentSize = 0;
-    }
-    if (dpiUtils__allocateMemory(1, desiredSize, 0, action, ptr, error) < 0)
-        return DPI_FAILURE;
-    *currentSize = desiredSize;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiUtils__freeMemory() [INTERNAL]
-//   Method for allocating memory which permits tracing and populates the error
-// structure in the event of a memory allocation failure.
-//-----------------------------------------------------------------------------
-void dpiUtils__freeMemory(void *ptr)
-{
-    if (dpiDebugLevel & DPI_DEBUG_LEVEL_MEM)
-        dpiDebug__print("freed ptr at %p\n", ptr);
-    free(ptr);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiUtils__getAttrStringWithDup() [INTERNAL]
-//   Get the string attribute from the OCI and duplicate its contents.
-//-----------------------------------------------------------------------------
-int dpiUtils__getAttrStringWithDup(const char *action, const void *ociHandle,
-        uint32_t ociHandleType, uint32_t ociAttribute, const char **value,
-        uint32_t *valueLength, dpiError *error)
-{
-    char *source, *temp;
-
-    if (dpiOci__attrGet(ociHandle, ociHandleType, (void*) &source,
-            valueLength, ociAttribute, action, error) < 0)
-        return DPI_FAILURE;
-    if (*valueLength == 0) {
-        *value = NULL;
-    } else {
-        if (dpiUtils__allocateMemory(1, *valueLength, 0, action,
-                (void**) &temp, error) < 0)
-            return DPI_FAILURE;
-        *value = (const char*) memcpy(temp, source, *valueLength);
-    }
-    return DPI_SUCCESS;
-}
-
-
-#ifdef _WIN32
-//-----------------------------------------------------------------------------
-// dpiUtils__getWindowsError() [INTERNAL]
-//   Get the error message from Windows and place into the supplied buffer. The
-// buffer and length are provided as pointers and memory is allocated as needed
-// in order to be able to store the entire error message.
-//-----------------------------------------------------------------------------
-int dpiUtils__getWindowsError(DWORD errorNum, char **buffer,
-        size_t *bufferLength, dpiError *error)
-{
-    char *fallbackErrorFormat = "failed to get message for Windows Error %d";
-    wchar_t *wLoadError = NULL;
-    DWORD length = 0, status;
-
-    // use English unless English error messages aren't available
-    status = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
-            FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER,
-            NULL, errorNum, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
-            (LPWSTR) &wLoadError, 0, NULL);
-    if (!status && GetLastError() == ERROR_MUI_FILE_NOT_FOUND)
-        FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
-                FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER,
-                NULL, errorNum, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
-                (LPWSTR) &wLoadError, 0, NULL);
-
-    // transform UTF-16 to UTF-8
-    if (wLoadError) {
-
-        // strip trailing period and carriage return from message, if needed
-        length = (DWORD) wcslen(wLoadError);
-        while (length > 0) {
-            if (wLoadError[length - 1] > 127 ||
-                    (wLoadError[length - 1] != L'.' &&
-                    !isspace(wLoadError[length - 1])))
-                break;
-            length--;
-        }
-        wLoadError[length] = L'\0';
-
-        // convert to UTF-8 encoding
-        if (length > 0) {
-            length = WideCharToMultiByte(CP_UTF8, 0, wLoadError, -1, NULL, 0,
-                    NULL, NULL);
-            if (length > 0) {
-                if (dpiUtils__ensureBuffer(length,
-                        "allocate buffer for Windows error message",
-                        (void**) buffer, bufferLength, error) < 0) {
-                    LocalFree(wLoadError);
-                    return DPI_FAILURE;
-                }
-                length = WideCharToMultiByte(CP_UTF8, 0, wLoadError, -1,
-                        *buffer, (int) *bufferLength, NULL, NULL);
-            }
-        }
-        LocalFree(wLoadError);
-
-    }
-
-    if (length == 0) {
-        if (dpiUtils__ensureBuffer(strlen(fallbackErrorFormat) + 20,
-                "allocate buffer for fallback error message",
-                (void**) buffer, bufferLength, error) < 0)
-            return DPI_FAILURE;
-        (void) sprintf(*buffer, fallbackErrorFormat, errorNum);
-    }
-
-    return DPI_SUCCESS;
-}
-#endif
-
-
-//-----------------------------------------------------------------------------
-// dpiUtils__parseNumberString() [INTERNAL]
-//   Parse the contents of a string that is supposed to contain a number. The
-// number is expected to be in the format (www.json.org):
-//   - optional negative sign (-)
-//   - any number of digits but at least one (0-9)
-//   - an optional decimal point (.)
-//   - any number of digits but at least one if decimal point specified (0-9)
-//   - an optional exponent indicator (e or E)
-//   - an optional exponent sign (+ or -)
-//   - any number of digits, but at least one if exponent specified (0-9)
-// What is returned is an indication of whether the number is negative, what
-// the index of the decimal point in the string is and the list of digits
-// without the decimal point. Note that OCI doesn't support more than 40 digits
-// so if there are more than this amount an error is raised. OCI doesn't
-// support larger than 1e126 so check for this value and raise a numeric
-// overflow error if found. OCI also doesn't support smaller than 1E-130 so
-// check for this value as well and if smaller than that value simply return
-// zero.
-//-----------------------------------------------------------------------------
-int dpiUtils__parseNumberString(const char *value, uint32_t valueLength,
-        uint16_t charsetId, int *isNegative, int16_t *decimalPointIndex,
-        uint8_t *numDigits, uint8_t *digits, dpiError *error)
-{
-    char convertedValue[DPI_NUMBER_AS_TEXT_CHARS], exponentDigits[4];
-    uint8_t numExponentDigits, digit;
-    uint32_t convertedValueLength;
-    uint16_t *utf16chars, i;
-    int exponentIsNegative;
-    const char *endValue;
-    int16_t exponent;
-
-    // empty strings are not valid numbers
-    if (valueLength == 0)
-        return dpiError__set(error, "zero length", DPI_ERR_INVALID_NUMBER);
-
-    // strings longer than the maximum length of a valid number are also
-    // excluded
-    if ((charsetId == DPI_CHARSET_ID_UTF16 &&
-                    valueLength > DPI_NUMBER_AS_TEXT_CHARS * 2) ||
-            (charsetId != DPI_CHARSET_ID_UTF16 &&
-                    valueLength > DPI_NUMBER_AS_TEXT_CHARS))
-        return dpiError__set(error, "check length",
-                DPI_ERR_NUMBER_STRING_TOO_LONG);
-
-    // if value is encoded in UTF-16, convert to single byte encoding first
-    // check for values that cannot be encoded in a single byte and are
-    // obviously not part of a valid numeric string
-    // also verify maximum length of number
-    if (charsetId == DPI_CHARSET_ID_UTF16) {
-        utf16chars = (uint16_t*) value;
-        convertedValue[0] = '\0';
-        convertedValueLength = valueLength / 2;
-        for (i = 0; i < convertedValueLength; i++) {
-            if (*utf16chars > 127)
-                return dpiError__set(error, "convert from UTF-16",
-                        DPI_ERR_INVALID_NUMBER);
-            convertedValue[i] = (char) *utf16chars++;
-        }
-        value = convertedValue;
-        valueLength = convertedValueLength;
-    }
-
-    // see if first character is a minus sign (number is negative)
-    endValue = value + valueLength;
-    *isNegative = (*value == '-');
-    if (*isNegative)
-        value++;
-
-    // scan for digits until the decimal point or exponent indicator is found
-    *numDigits = 0;
-    while (value < endValue) {
-        if (*value == '.' || *value == 'e' || *value == 'E')
-            break;
-        if (*value < '0' || *value > '9')
-            return dpiError__set(error, "check digits before decimal point",
-                    DPI_ERR_INVALID_NUMBER);
-        digit = (uint8_t) (*value++ - '0');
-        if (digit == 0 && *numDigits == 0)
-            continue;
-        *digits++ = digit;
-        (*numDigits)++;
-    }
-    *decimalPointIndex = *numDigits;
-
-    // scan for digits following the decimal point, if applicable
-    if (value < endValue && *value == '.') {
-        value++;
-        while (value < endValue) {
-            if (*value == 'e' || *value == 'E')
-                break;
-            if (*value < '0' || *value > '9')
-                return dpiError__set(error, "check digits after decimal point",
-                        DPI_ERR_INVALID_NUMBER);
-            digit = (uint8_t) (*value++ - '0');
-            if (digit == 0 && *numDigits == 0) {
-                (*decimalPointIndex)--;
-                continue;
-            }
-            *digits++ = digit;
-            (*numDigits)++;
-        }
-    }
-
-    // handle exponent, if applicable
-    if (value < endValue && (*value == 'e' || *value == 'E')) {
-        value++;
-        exponentIsNegative = 0;
-        numExponentDigits = 0;
-        if (value < endValue && (*value == '+' || *value == '-')) {
-            exponentIsNegative = (*value == '-');
-            value++;
-        }
-        while (value < endValue) {
-            if (*value < '0' || *value > '9')
-                return dpiError__set(error, "check digits in exponent",
-                        DPI_ERR_INVALID_NUMBER);
-            if (numExponentDigits == 3)
-                return dpiError__set(error, "check exponent digits > 3",
-                        DPI_ERR_NOT_SUPPORTED);
-            exponentDigits[numExponentDigits] = *value++;
-            numExponentDigits++;
-        }
-        if (numExponentDigits == 0)
-            return dpiError__set(error, "no digits in exponent",
-                    DPI_ERR_INVALID_NUMBER);
-        exponentDigits[numExponentDigits] = '\0';
-        exponent = (int16_t) strtol(exponentDigits, NULL, 10);
-        if (exponentIsNegative)
-            exponent = -exponent;
-        *decimalPointIndex += exponent;
-    }
-
-    // if there is anything left in the string, that indicates an invalid
-    // number as well
-    if (value < endValue)
-        return dpiError__set(error, "check string used",
-                DPI_ERR_INVALID_NUMBER);
-
-    // strip trailing zeroes
-    digits--;
-    while (*numDigits > 0 && *digits-- == 0)
-        (*numDigits)--;
-
-    // values must be less than 1e126 and greater than 1e-129; the number of
-    // digits also cannot exceed the maximum precision of Oracle numbers
-    if (*numDigits > DPI_NUMBER_MAX_DIGITS || *decimalPointIndex > 126 ||
-            *decimalPointIndex < -129) {
-        return dpiError__set(error, "check value can be represented",
-                DPI_ERR_NUMBER_NO_REPR);
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiUtils__parseOracleNumber() [INTERNAL]
-//   Parse the contents of an Oracle number and return its constituent parts
-// so that a string can be generated from it easily.
-//-----------------------------------------------------------------------------
-int dpiUtils__parseOracleNumber(void *oracleValue, int *isNegative,
-        int16_t *decimalPointIndex, uint8_t *numDigits, uint8_t *digits,
-        dpiError *error)
-{
-    uint8_t *source, length, i, byte, digit;
-    int8_t ociExponent;
-
-    // the first byte of the structure is a length byte which includes the
-    // exponent and the mantissa bytes
-    source = (uint8_t*) oracleValue;
-    length = *source++ - 1;
-
-    // a mantissa length longer than 20 signals corruption of some kind
-    if (length > 20)
-        return dpiError__set(error, "check mantissa length",
-                DPI_ERR_INVALID_OCI_NUMBER);
-
-    // the second byte of the structure is the exponent
-    // positive numbers have the highest order bit set whereas negative numbers
-    // have the highest order bit cleared and the bits inverted
-    ociExponent = (int8_t) *source++;
-    *isNegative = (ociExponent & 0x80) ? 0 : 1;
-    if (*isNegative)
-        ociExponent = ~ociExponent;
-    ociExponent -= 193;
-    *decimalPointIndex = ociExponent * 2 + 2;
-
-    // a mantissa length of 0 implies a value of 0 (if positive)
-    // or -1e126 (if negative)
-    if (length == 0) {
-        if (*isNegative) {
-            *digits = 1;
-            *decimalPointIndex = 127;
-        }
-        else {
-            *decimalPointIndex = 1;
-            *digits = 0;
-        }
-        *numDigits = 1;
-        return DPI_SUCCESS;
-    }
-
-    // check for the trailing 102 byte for negative numbers and if present,
-    // reduce the number of mantissa digits
-    if (*isNegative && source[length - 1] == 102)
-        length--;
-
-    // process the mantissa which are the remaining bytes
-    // each mantissa byte is a base-100 digit
-    *numDigits = length * 2;
-    for (i = 0; i < length; i++) {
-        byte = *source++;
-
-        // positive numbers have 1 added to them; negative numbers are
-        // subtracted from the value 101
-        if (*isNegative)
-            byte = 101 - byte;
-        else byte--;
-
-        // process the first digit; leading zeroes are ignored
-        digit = (uint8_t) (byte / 10);
-        if (digit == 0 && i == 0) {
-            (*numDigits)--;
-            (*decimalPointIndex)--;
-        } else if (digit == 10) {
-            (*numDigits)++;
-            (*decimalPointIndex)++;
-            *digits++ = 1;
-            *digits++ = 0;
-        } else *digits++ = digit;
-
-        // process the second digit; trailing zeroes are ignored
-        digit = byte % 10;
-        if (digit == 0 && i == length - 1)
-            (*numDigits)--;
-        else *digits++ = digit;
-
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiUtils__setAttributesFromCommonCreateParams() [INTERNAL]
-//   Set the attributes on the authorization info structure or session handle
-// using the specified parameters.
-//-----------------------------------------------------------------------------
-int dpiUtils__setAttributesFromCommonCreateParams(void *handle,
-        uint32_t handleType, const dpiCommonCreateParams *params,
-        dpiError *error)
-{
-    if (params->driverName && params->driverNameLength > 0 &&
-            dpiOci__attrSet(handle, handleType, (void*) params->driverName,
-                    params->driverNameLength, DPI_OCI_ATTR_DRIVER_NAME,
-                    "set driver name", error) < 0)
-        return DPI_FAILURE;
-    if (params->edition && params->editionLength > 0 &&
-            dpiOci__attrSet(handle, handleType,
-                    (void*) params->edition, params->editionLength,
-                    DPI_OCI_ATTR_EDITION, "set edition", error) < 0)
-        return DPI_FAILURE;
-
-    return DPI_SUCCESS;
-}
-
-
-
-//-----------------------------------------------------------------------------
-// dpiUtils__setAccessTokenAttributes() [INTERNAL]
-//   Set the token and private key for token based authentication on the auth
-// handle.
-//-----------------------------------------------------------------------------
-int dpiUtils__setAccessTokenAttributes(void *handle,
-        dpiAccessToken *accessToken, dpiVersionInfo *versionInfo,
-        dpiError *error)
-{
-    int isBearer = 1;
-
-    // check validity of access token
-    if (!accessToken->token || accessToken->tokenLength == 0 ||
-            (accessToken->privateKey && accessToken->privateKeyLength == 0))
-        return dpiError__set(error,
-                "check token based authentication parameters",
-                DPI_ERR_TOKEN_BASED_AUTH);
-
-    // IAM feature only available in Oracle Client 19.14+ and 21.5+ libraries
-    if (accessToken->privateKey) {
-        if (dpiUtils__checkClientVersionMulti(versionInfo, 19, 14, 21, 5,
-                error) < 0)
-            return DPI_FAILURE;
-
-    // OAuth feature only available in Oracle Client 19.15+ and 21.7+ libraries
-    } else {
-        if (dpiUtils__checkClientVersionMulti(versionInfo, 19, 15, 21, 7,
-                error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // set token on auth handle
-    if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_AUTHINFO,
-            (void*) accessToken->token, accessToken->tokenLength,
-            DPI_OCI_ATTR_TOKEN, "set access token", error) < 0)
-        return DPI_FAILURE;
-
-    // set IAM private key on auth handle
-    if (accessToken->privateKey) {
-        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_AUTHINFO,
-                (void*) accessToken->privateKey,
-                accessToken->privateKeyLength, DPI_OCI_ATTR_IAM_PRIVKEY,
-                "set access token private key", error) < 0)
-            return DPI_FAILURE;
-
-    // set OAuth bearer flag on auth handle
-    } else {
-        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_AUTHINFO,
-                (void*) &isBearer, 0, DPI_OCI_ATTR_TOKEN_ISBEARER,
-                "set bearer flag", error) < 0)
-            return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiUtils.h ./odpi/src/dpiUtils.h
--- patched-godror/odpi/src/dpiUtils.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiUtils.h	2024-05-14 14:55:13
@@ -0,0 +1,585 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiUtils.c
+//   Utility methods that aren't specific to a particular type.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+//-----------------------------------------------------------------------------
+// dpiUtils__allocateMemory() [INTERNAL]
+//   Method for allocating memory which permits tracing and populates the error
+// structure in the event of a memory allocation failure.
+//-----------------------------------------------------------------------------
+int dpiUtils__allocateMemory(size_t numMembers, size_t memberSize,
+        int clearMemory, const char *action, void **ptr, dpiError *error)
+{
+    if (clearMemory)
+        *ptr = calloc(numMembers, memberSize);
+    else *ptr = malloc(numMembers * memberSize);
+    if (!*ptr)
+        return dpiError__set(error, action, DPI_ERR_NO_MEMORY);
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_MEM)
+        dpiDebug__print("allocated %u bytes at %p (%s)\n",
+                numMembers * memberSize, *ptr, action);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiUtils__checkClientVersion() [INTERNAL]
+//   Check the Oracle Client version and verify that it is at least at the
+// minimum version that is required.
+//-----------------------------------------------------------------------------
+int dpiUtils__checkClientVersion(dpiVersionInfo *versionInfo,
+        int minVersionNum, int minReleaseNum, dpiError *error)
+{
+    if (versionInfo->versionNum < minVersionNum ||
+            (versionInfo->versionNum == minVersionNum &&
+                    versionInfo->releaseNum < minReleaseNum))
+        return dpiError__set(error, "check Oracle Client version",
+                DPI_ERR_ORACLE_CLIENT_TOO_OLD, versionInfo->versionNum,
+                versionInfo->releaseNum, minVersionNum, minReleaseNum);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiUtils__checkClientVersionMulti() [INTERNAL]
+//   Check the Oracle Client version and verify that it is at least at the
+// minimum version that is required.
+//-----------------------------------------------------------------------------
+int dpiUtils__checkClientVersionMulti(dpiVersionInfo *versionInfo,
+        int minVersionNum1, int minReleaseNum1, int minVersionNum2,
+        int minReleaseNum2, dpiError *error)
+{
+    if (versionInfo->versionNum < minVersionNum1 ||
+            (versionInfo->versionNum == minVersionNum1 &&
+                    versionInfo->releaseNum < minReleaseNum1) ||
+            (versionInfo->versionNum > minVersionNum1 &&
+                    versionInfo->versionNum < minVersionNum2) ||
+            (versionInfo->versionNum == minVersionNum2 &&
+                    versionInfo->releaseNum < minReleaseNum2))
+        return dpiError__set(error, "check Oracle Client version",
+                DPI_ERR_ORACLE_CLIENT_TOO_OLD_MULTI, versionInfo->versionNum,
+                versionInfo->releaseNum, minVersionNum1, minReleaseNum1,
+                minVersionNum2, minReleaseNum2);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiUtils__checkDatabaseVersion() [INTERNAL]
+//   Check the Oracle Database version and verify that it is at least at the
+// minimum version that is required.
+//-----------------------------------------------------------------------------
+int dpiUtils__checkDatabaseVersion(dpiConn *conn, int minVersionNum,
+        int minReleaseNum, dpiError *error)
+{
+    if (dpiConn__getServerVersion(conn, 0, error) < 0)
+        return DPI_FAILURE;
+    if (conn->versionInfo.versionNum < minVersionNum ||
+            (conn->versionInfo.versionNum == minVersionNum &&
+                    conn->versionInfo.releaseNum < minReleaseNum))
+        return dpiError__set(error, "check Oracle Database version",
+                DPI_ERR_ORACLE_DB_TOO_OLD, conn->versionInfo.versionNum,
+                conn->versionInfo.releaseNum, minVersionNum, minReleaseNum);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiUtils__clearMemory() [INTERNAL]
+//   Method for clearing memory that will not be optimised away by the
+// compiler. Simple use of memset() can be optimised away. This routine makes
+// use of a volatile pointer which most compilers will avoid optimising away,
+// even if the pointer appears to be unused after the call.
+//-----------------------------------------------------------------------------
+void dpiUtils__clearMemory(void *ptr, size_t length)
+{
+    volatile unsigned char *temp = (unsigned char *) ptr;
+
+    while (length--)
+        *temp++ = '\0';
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiUtils__ensureBuffer() [INTERNAL]
+//   Ensure that a buffer of the specified size is available. If a buffer of
+// the requested size is not available, free any existing buffer and allocate a
+// new, larger buffer.
+//-----------------------------------------------------------------------------
+int dpiUtils__ensureBuffer(size_t desiredSize, const char *action,
+        void **ptr, size_t *currentSize, dpiError *error)
+{
+    if (desiredSize <= *currentSize)
+        return DPI_SUCCESS;
+    if (*ptr) {
+        dpiUtils__freeMemory(*ptr);
+        *ptr = NULL;
+        *currentSize = 0;
+    }
+    if (dpiUtils__allocateMemory(1, desiredSize, 0, action, ptr, error) < 0)
+        return DPI_FAILURE;
+    *currentSize = desiredSize;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiUtils__freeMemory() [INTERNAL]
+//   Method for allocating memory which permits tracing and populates the error
+// structure in the event of a memory allocation failure.
+//-----------------------------------------------------------------------------
+void dpiUtils__freeMemory(void *ptr)
+{
+    if (dpiDebugLevel & DPI_DEBUG_LEVEL_MEM)
+        dpiDebug__print("freed ptr at %p\n", ptr);
+    free(ptr);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiUtils__getAttrStringWithDup() [INTERNAL]
+//   Get the string attribute from the OCI and duplicate its contents.
+//-----------------------------------------------------------------------------
+int dpiUtils__getAttrStringWithDup(const char *action, const void *ociHandle,
+        uint32_t ociHandleType, uint32_t ociAttribute, const char **value,
+        uint32_t *valueLength, dpiError *error)
+{
+    char *source, *temp;
+
+    if (dpiOci__attrGet(ociHandle, ociHandleType, (void*) &source,
+            valueLength, ociAttribute, action, error) < 0)
+        return DPI_FAILURE;
+    if (*valueLength == 0) {
+        *value = NULL;
+    } else {
+        if (dpiUtils__allocateMemory(1, *valueLength, 0, action,
+                (void**) &temp, error) < 0)
+            return DPI_FAILURE;
+        *value = (const char*) memcpy(temp, source, *valueLength);
+    }
+    return DPI_SUCCESS;
+}
+
+
+#ifdef _WIN32
+//-----------------------------------------------------------------------------
+// dpiUtils__getWindowsError() [INTERNAL]
+//   Get the error message from Windows and place into the supplied buffer. The
+// buffer and length are provided as pointers and memory is allocated as needed
+// in order to be able to store the entire error message.
+//-----------------------------------------------------------------------------
+int dpiUtils__getWindowsError(DWORD errorNum, char **buffer,
+        size_t *bufferLength, dpiError *error)
+{
+    char *fallbackErrorFormat = "failed to get message for Windows Error %d";
+    wchar_t *wLoadError = NULL;
+    DWORD length = 0, status;
+
+    // use English unless English error messages aren't available
+    status = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
+            FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER,
+            NULL, errorNum, MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
+            (LPWSTR) &wLoadError, 0, NULL);
+    if (!status && GetLastError() == ERROR_MUI_FILE_NOT_FOUND)
+        FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM |
+                FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_ALLOCATE_BUFFER,
+                NULL, errorNum, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
+                (LPWSTR) &wLoadError, 0, NULL);
+
+    // transform UTF-16 to UTF-8
+    if (wLoadError) {
+
+        // strip trailing period and carriage return from message, if needed
+        length = (DWORD) wcslen(wLoadError);
+        while (length > 0) {
+            if (wLoadError[length - 1] > 127 ||
+                    (wLoadError[length - 1] != L'.' &&
+                    !isspace(wLoadError[length - 1])))
+                break;
+            length--;
+        }
+        wLoadError[length] = L'\0';
+
+        // convert to UTF-8 encoding
+        if (length > 0) {
+            length = WideCharToMultiByte(CP_UTF8, 0, wLoadError, -1, NULL, 0,
+                    NULL, NULL);
+            if (length > 0) {
+                if (dpiUtils__ensureBuffer(length,
+                        "allocate buffer for Windows error message",
+                        (void**) buffer, bufferLength, error) < 0) {
+                    LocalFree(wLoadError);
+                    return DPI_FAILURE;
+                }
+                length = WideCharToMultiByte(CP_UTF8, 0, wLoadError, -1,
+                        *buffer, (int) *bufferLength, NULL, NULL);
+            }
+        }
+        LocalFree(wLoadError);
+
+    }
+
+    if (length == 0) {
+        if (dpiUtils__ensureBuffer(strlen(fallbackErrorFormat) + 20,
+                "allocate buffer for fallback error message",
+                (void**) buffer, bufferLength, error) < 0)
+            return DPI_FAILURE;
+        (void) sprintf(*buffer, fallbackErrorFormat, errorNum);
+    }
+
+    return DPI_SUCCESS;
+}
+#endif
+
+
+//-----------------------------------------------------------------------------
+// dpiUtils__parseNumberString() [INTERNAL]
+//   Parse the contents of a string that is supposed to contain a number. The
+// number is expected to be in the format (www.json.org):
+//   - optional negative sign (-)
+//   - any number of digits but at least one (0-9)
+//   - an optional decimal point (.)
+//   - any number of digits but at least one if decimal point specified (0-9)
+//   - an optional exponent indicator (e or E)
+//   - an optional exponent sign (+ or -)
+//   - any number of digits, but at least one if exponent specified (0-9)
+// What is returned is an indication of whether the number is negative, what
+// the index of the decimal point in the string is and the list of digits
+// without the decimal point. Note that OCI doesn't support more than 40 digits
+// so if there are more than this amount an error is raised. OCI doesn't
+// support larger than 1e126 so check for this value and raise a numeric
+// overflow error if found. OCI also doesn't support smaller than 1E-130 so
+// check for this value as well and if smaller than that value simply return
+// zero.
+//-----------------------------------------------------------------------------
+int dpiUtils__parseNumberString(const char *value, uint32_t valueLength,
+        uint16_t charsetId, int *isNegative, int16_t *decimalPointIndex,
+        uint8_t *numDigits, uint8_t *digits, dpiError *error)
+{
+    char convertedValue[DPI_NUMBER_AS_TEXT_CHARS], exponentDigits[4];
+    uint8_t numExponentDigits, digit;
+    uint32_t convertedValueLength;
+    uint16_t *utf16chars, i;
+    int exponentIsNegative;
+    const char *endValue;
+    int16_t exponent;
+
+    // empty strings are not valid numbers
+    if (valueLength == 0)
+        return dpiError__set(error, "zero length", DPI_ERR_INVALID_NUMBER);
+
+    // strings longer than the maximum length of a valid number are also
+    // excluded
+    if ((charsetId == DPI_CHARSET_ID_UTF16 &&
+                    valueLength > DPI_NUMBER_AS_TEXT_CHARS * 2) ||
+            (charsetId != DPI_CHARSET_ID_UTF16 &&
+                    valueLength > DPI_NUMBER_AS_TEXT_CHARS))
+        return dpiError__set(error, "check length",
+                DPI_ERR_NUMBER_STRING_TOO_LONG);
+
+    // if value is encoded in UTF-16, convert to single byte encoding first
+    // check for values that cannot be encoded in a single byte and are
+    // obviously not part of a valid numeric string
+    // also verify maximum length of number
+    if (charsetId == DPI_CHARSET_ID_UTF16) {
+        utf16chars = (uint16_t*) value;
+        convertedValue[0] = '\0';
+        convertedValueLength = valueLength / 2;
+        for (i = 0; i < convertedValueLength; i++) {
+            if (*utf16chars > 127)
+                return dpiError__set(error, "convert from UTF-16",
+                        DPI_ERR_INVALID_NUMBER);
+            convertedValue[i] = (char) *utf16chars++;
+        }
+        value = convertedValue;
+        valueLength = convertedValueLength;
+    }
+
+    // see if first character is a minus sign (number is negative)
+    endValue = value + valueLength;
+    *isNegative = (*value == '-');
+    if (*isNegative)
+        value++;
+
+    // scan for digits until the decimal point or exponent indicator is found
+    *numDigits = 0;
+    while (value < endValue) {
+        if (*value == '.' || *value == 'e' || *value == 'E')
+            break;
+        if (*value < '0' || *value > '9')
+            return dpiError__set(error, "check digits before decimal point",
+                    DPI_ERR_INVALID_NUMBER);
+        digit = (uint8_t) (*value++ - '0');
+        if (digit == 0 && *numDigits == 0)
+            continue;
+        *digits++ = digit;
+        (*numDigits)++;
+    }
+    *decimalPointIndex = *numDigits;
+
+    // scan for digits following the decimal point, if applicable
+    if (value < endValue && *value == '.') {
+        value++;
+        while (value < endValue) {
+            if (*value == 'e' || *value == 'E')
+                break;
+            if (*value < '0' || *value > '9')
+                return dpiError__set(error, "check digits after decimal point",
+                        DPI_ERR_INVALID_NUMBER);
+            digit = (uint8_t) (*value++ - '0');
+            if (digit == 0 && *numDigits == 0) {
+                (*decimalPointIndex)--;
+                continue;
+            }
+            *digits++ = digit;
+            (*numDigits)++;
+        }
+    }
+
+    // handle exponent, if applicable
+    if (value < endValue && (*value == 'e' || *value == 'E')) {
+        value++;
+        exponentIsNegative = 0;
+        numExponentDigits = 0;
+        if (value < endValue && (*value == '+' || *value == '-')) {
+            exponentIsNegative = (*value == '-');
+            value++;
+        }
+        while (value < endValue) {
+            if (*value < '0' || *value > '9')
+                return dpiError__set(error, "check digits in exponent",
+                        DPI_ERR_INVALID_NUMBER);
+            if (numExponentDigits == 3)
+                return dpiError__set(error, "check exponent digits > 3",
+                        DPI_ERR_NOT_SUPPORTED);
+            exponentDigits[numExponentDigits] = *value++;
+            numExponentDigits++;
+        }
+        if (numExponentDigits == 0)
+            return dpiError__set(error, "no digits in exponent",
+                    DPI_ERR_INVALID_NUMBER);
+        exponentDigits[numExponentDigits] = '\0';
+        exponent = (int16_t) strtol(exponentDigits, NULL, 10);
+        if (exponentIsNegative)
+            exponent = -exponent;
+        *decimalPointIndex += exponent;
+    }
+
+    // if there is anything left in the string, that indicates an invalid
+    // number as well
+    if (value < endValue)
+        return dpiError__set(error, "check string used",
+                DPI_ERR_INVALID_NUMBER);
+
+    // strip trailing zeroes
+    digits--;
+    while (*numDigits > 0 && *digits-- == 0)
+        (*numDigits)--;
+
+    // values must be less than 1e126 and greater than 1e-129; the number of
+    // digits also cannot exceed the maximum precision of Oracle numbers
+    if (*numDigits > DPI_NUMBER_MAX_DIGITS || *decimalPointIndex > 126 ||
+            *decimalPointIndex < -129) {
+        return dpiError__set(error, "check value can be represented",
+                DPI_ERR_NUMBER_NO_REPR);
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiUtils__parseOracleNumber() [INTERNAL]
+//   Parse the contents of an Oracle number and return its constituent parts
+// so that a string can be generated from it easily.
+//-----------------------------------------------------------------------------
+int dpiUtils__parseOracleNumber(void *oracleValue, int *isNegative,
+        int16_t *decimalPointIndex, uint8_t *numDigits, uint8_t *digits,
+        dpiError *error)
+{
+    uint8_t *source, length, i, byte, digit;
+    int8_t ociExponent;
+
+    // the first byte of the structure is a length byte which includes the
+    // exponent and the mantissa bytes
+    source = (uint8_t*) oracleValue;
+    length = *source++ - 1;
+
+    // a mantissa length longer than 20 signals corruption of some kind
+    if (length > 20)
+        return dpiError__set(error, "check mantissa length",
+                DPI_ERR_INVALID_OCI_NUMBER);
+
+    // the second byte of the structure is the exponent
+    // positive numbers have the highest order bit set whereas negative numbers
+    // have the highest order bit cleared and the bits inverted
+    ociExponent = (int8_t) *source++;
+    *isNegative = (ociExponent & 0x80) ? 0 : 1;
+    if (*isNegative)
+        ociExponent = ~ociExponent;
+    ociExponent -= 193;
+    *decimalPointIndex = ociExponent * 2 + 2;
+
+    // a mantissa length of 0 implies a value of 0 (if positive)
+    // or -1e126 (if negative)
+    if (length == 0) {
+        if (*isNegative) {
+            *digits = 1;
+            *decimalPointIndex = 127;
+        }
+        else {
+            *decimalPointIndex = 1;
+            *digits = 0;
+        }
+        *numDigits = 1;
+        return DPI_SUCCESS;
+    }
+
+    // check for the trailing 102 byte for negative numbers and if present,
+    // reduce the number of mantissa digits
+    if (*isNegative && source[length - 1] == 102)
+        length--;
+
+    // process the mantissa which are the remaining bytes
+    // each mantissa byte is a base-100 digit
+    *numDigits = length * 2;
+    for (i = 0; i < length; i++) {
+        byte = *source++;
+
+        // positive numbers have 1 added to them; negative numbers are
+        // subtracted from the value 101
+        if (*isNegative)
+            byte = 101 - byte;
+        else byte--;
+
+        // process the first digit; leading zeroes are ignored
+        digit = (uint8_t) (byte / 10);
+        if (digit == 0 && i == 0) {
+            (*numDigits)--;
+            (*decimalPointIndex)--;
+        } else if (digit == 10) {
+            (*numDigits)++;
+            (*decimalPointIndex)++;
+            *digits++ = 1;
+            *digits++ = 0;
+        } else *digits++ = digit;
+
+        // process the second digit; trailing zeroes are ignored
+        digit = byte % 10;
+        if (digit == 0 && i == length - 1)
+            (*numDigits)--;
+        else *digits++ = digit;
+
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiUtils__setAttributesFromCommonCreateParams() [INTERNAL]
+//   Set the attributes on the authorization info structure or session handle
+// using the specified parameters.
+//-----------------------------------------------------------------------------
+int dpiUtils__setAttributesFromCommonCreateParams(void *handle,
+        uint32_t handleType, const dpiCommonCreateParams *params,
+        dpiError *error)
+{
+    if (params->driverName && params->driverNameLength > 0 &&
+            dpiOci__attrSet(handle, handleType, (void*) params->driverName,
+                    params->driverNameLength, DPI_OCI_ATTR_DRIVER_NAME,
+                    "set driver name", error) < 0)
+        return DPI_FAILURE;
+    if (params->edition && params->editionLength > 0 &&
+            dpiOci__attrSet(handle, handleType,
+                    (void*) params->edition, params->editionLength,
+                    DPI_OCI_ATTR_EDITION, "set edition", error) < 0)
+        return DPI_FAILURE;
+
+    return DPI_SUCCESS;
+}
+
+
+
+//-----------------------------------------------------------------------------
+// dpiUtils__setAccessTokenAttributes() [INTERNAL]
+//   Set the token and private key for token based authentication on the auth
+// handle.
+//-----------------------------------------------------------------------------
+int dpiUtils__setAccessTokenAttributes(void *handle,
+        dpiAccessToken *accessToken, dpiVersionInfo *versionInfo,
+        dpiError *error)
+{
+    int isBearer = 1;
+
+    // check validity of access token
+    if (!accessToken->token || accessToken->tokenLength == 0 ||
+            (accessToken->privateKey && accessToken->privateKeyLength == 0))
+        return dpiError__set(error,
+                "check token based authentication parameters",
+                DPI_ERR_TOKEN_BASED_AUTH);
+
+    // IAM feature only available in Oracle Client 19.14+ and 21.5+ libraries
+    if (accessToken->privateKey) {
+        if (dpiUtils__checkClientVersionMulti(versionInfo, 19, 14, 21, 5,
+                error) < 0)
+            return DPI_FAILURE;
+
+    // OAuth feature only available in Oracle Client 19.15+ and 21.7+ libraries
+    } else {
+        if (dpiUtils__checkClientVersionMulti(versionInfo, 19, 15, 21, 7,
+                error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // set token on auth handle
+    if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_AUTHINFO,
+            (void*) accessToken->token, accessToken->tokenLength,
+            DPI_OCI_ATTR_TOKEN, "set access token", error) < 0)
+        return DPI_FAILURE;
+
+    // set IAM private key on auth handle
+    if (accessToken->privateKey) {
+        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_AUTHINFO,
+                (void*) accessToken->privateKey,
+                accessToken->privateKeyLength, DPI_OCI_ATTR_IAM_PRIVKEY,
+                "set access token private key", error) < 0)
+            return DPI_FAILURE;
+
+    // set OAuth bearer flag on auth handle
+    } else {
+        if (dpiOci__attrSet(handle, DPI_OCI_HTYPE_AUTHINFO,
+                (void*) &isBearer, 0, DPI_OCI_ATTR_TOKEN_ISBEARER,
+                "set bearer flag", error) < 0)
+            return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
diff -ruN -x .git/* patched-godror/odpi/src/dpiVar.c ./odpi/src/dpiVar.c
--- patched-godror/odpi/src/dpiVar.c	2024-05-14 16:25:02
+++ ./odpi/src/dpiVar.c	1970-01-01 01:00:00
@@ -1,1921 +0,0 @@
-//-----------------------------------------------------------------------------
-// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
-//
-// This software is dual-licensed to you under the Universal Permissive License
-// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
-// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
-// either license.
-//
-// If you elect to accept the software under the Apache License, Version 2.0,
-// the following applies:
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//    https://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-//-----------------------------------------------------------------------------
-
-//-----------------------------------------------------------------------------
-// dpiVar.c
-//   Implementation of variables.
-//-----------------------------------------------------------------------------
-
-#include "dpiImpl.h"
-
-// forward declarations of internal functions only used in this file
-static int dpiVar__initBuffer(dpiVar *var, dpiVarBuffer *buffer,
-        dpiError *error);
-static int dpiVar__setBytesFromDynamicBytes(dpiBytes *bytes,
-        dpiDynamicBytes *dynBytes, dpiError *error);
-static int dpiVar__setBytesFromLob(dpiBytes *bytes, dpiDynamicBytes *dynBytes,
-        dpiLob *lob, dpiError *error);
-static int dpiVar__setFromBytes(dpiVar *var, uint32_t pos, const char *value,
-        uint32_t valueLength, dpiError *error);
-static int dpiVar__setFromJson(dpiVar *var, uint32_t pos, dpiJson *json,
-        dpiError *error);
-static int dpiVar__setFromLob(dpiVar *var, uint32_t pos, dpiLob *lob,
-        dpiError *error);
-static int dpiVar__setFromObject(dpiVar *var, uint32_t pos, dpiObject *obj,
-        dpiError *error);
-static int dpiVar__setFromRowid(dpiVar *var, uint32_t pos, dpiRowid *rowid,
-        dpiError *error);
-static int dpiVar__setFromStmt(dpiVar *var, uint32_t pos, dpiStmt *stmt,
-        dpiError *error);
-static int dpiVar__validateTypes(const dpiOracleType *oracleType,
-        dpiNativeTypeNum nativeTypeNum, dpiError *error);
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__allocate() [INTERNAL]
-//   Create a new variable object and return it. In case of error NULL is
-// returned.
-//-----------------------------------------------------------------------------
-int dpiVar__allocate(dpiConn *conn, dpiOracleTypeNum oracleTypeNum,
-        dpiNativeTypeNum nativeTypeNum, uint32_t maxArraySize, uint32_t size,
-        int sizeIsBytes, int isArray, dpiObjectType *objType, dpiVar **var,
-        dpiData **data, dpiError *error)
-{
-    const dpiOracleType *type;
-    uint32_t sizeInBytes;
-    dpiVar *tempVar;
-
-    // validate arguments
-    *var = NULL;
-    type = dpiOracleType__getFromNum(oracleTypeNum, error);
-    if (!type)
-        return DPI_FAILURE;
-    if (maxArraySize == 0)
-        return dpiError__set(error, "check max array size",
-                DPI_ERR_ARRAY_SIZE_ZERO);
-    if (isArray && !type->canBeInArray)
-        return dpiError__set(error, "check can be in array",
-                DPI_ERR_NOT_SUPPORTED);
-    if (oracleTypeNum == DPI_ORACLE_TYPE_BOOLEAN &&
-            dpiUtils__checkClientVersion(conn->env->versionInfo, 12, 1,
-                    error) < 0)
-        return DPI_FAILURE;
-    if (nativeTypeNum != type->defaultNativeTypeNum) {
-        if (dpiVar__validateTypes(type, nativeTypeNum, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // calculate size in bytes
-    if (size == 0)
-        size = 1;
-    if (type->sizeInBytes)
-        sizeInBytes = type->sizeInBytes;
-    else if (sizeIsBytes || !type->isCharacterData)
-        sizeInBytes = size;
-    else if (type->charsetForm == DPI_SQLCS_IMPLICIT)
-        sizeInBytes = size * conn->env->maxBytesPerCharacter;
-    else sizeInBytes = size * conn->env->nmaxBytesPerCharacter;
-
-    // allocate memory for variable type
-    if (dpiGen__allocate(DPI_HTYPE_VAR, conn->env, (void**) &tempVar,
-            error) < 0)
-        return DPI_FAILURE;
-
-    // basic initialization
-    tempVar->buffer.maxArraySize = maxArraySize;
-    if (!isArray)
-        tempVar->buffer.actualArraySize = maxArraySize;
-    tempVar->sizeInBytes = sizeInBytes;
-    if (sizeInBytes > DPI_MAX_BASIC_BUFFER_SIZE) {
-        tempVar->sizeInBytes = 0;
-        tempVar->isDynamic = 1;
-        tempVar->requiresPreFetch = 1;
-    }
-    tempVar->type = type;
-    tempVar->nativeTypeNum = nativeTypeNum;
-    tempVar->isArray = isArray;
-    dpiGen__setRefCount(conn, error, 1);
-    tempVar->conn = conn;
-    if (objType) {
-        if (dpiGen__checkHandle(objType, DPI_HTYPE_OBJECT_TYPE,
-                "check object type", error) < 0) {
-            dpiVar__free(tempVar, error);
-            return DPI_FAILURE;
-        }
-        dpiGen__setRefCount(objType, error, 1);
-        tempVar->objectType = objType;
-    }
-
-    // allocate the data for the variable
-    if (dpiVar__initBuffer(tempVar, &tempVar->buffer, error) < 0) {
-        dpiVar__free(tempVar, error);
-        return DPI_FAILURE;
-    }
-
-    *var = tempVar;
-    *data = tempVar->buffer.externalData;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__allocateChunks() [INTERNAL]
-//   Allocate more chunks for handling dynamic bytes.
-//-----------------------------------------------------------------------------
-static int dpiVar__allocateChunks(dpiDynamicBytes *dynBytes, dpiError *error)
-{
-    dpiDynamicBytesChunk *chunks;
-    uint32_t allocatedChunks;
-
-    allocatedChunks = dynBytes->allocatedChunks + 8;
-    if (dpiUtils__allocateMemory(allocatedChunks, sizeof(dpiDynamicBytesChunk),
-            1, "allocate chunks", (void**) &chunks, error) < 0)
-        return DPI_FAILURE;
-    if (dynBytes->chunks) {
-        memcpy(chunks, dynBytes->chunks,
-                dynBytes->numChunks * sizeof(dpiDynamicBytesChunk));
-        dpiUtils__freeMemory(dynBytes->chunks);
-    }
-    dynBytes->chunks = chunks;
-    dynBytes->allocatedChunks = allocatedChunks;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__allocateDynamicBytes() [INTERNAL]
-//   Allocate space in the dynamic bytes structure for the specified number of
-// bytes. When complete, there will be exactly one allocated chunk of the
-// specified size or greater in the dynamic bytes structure.
-//-----------------------------------------------------------------------------
-static int dpiVar__allocateDynamicBytes(dpiDynamicBytes *dynBytes,
-        uint32_t size, dpiError *error)
-{
-    // if an error occurs, none of the original space is valid
-    dynBytes->numChunks = 0;
-
-    // if there are no chunks at all, make sure some exist
-    if (dynBytes->allocatedChunks == 0 &&
-            dpiVar__allocateChunks(dynBytes, error) < 0)
-        return DPI_FAILURE;
-
-    // at this point there should be 0 or 1 chunks as any retrieval that
-    // resulted in multiple chunks would have been consolidated already
-    // make sure that chunk has enough space in it
-    if (size > dynBytes->chunks->allocatedLength) {
-        if (dynBytes->chunks->ptr)
-            dpiUtils__freeMemory(dynBytes->chunks->ptr);
-        dynBytes->chunks->allocatedLength =
-                (size + DPI_DYNAMIC_BYTES_CHUNK_SIZE - 1) &
-                        ~(DPI_DYNAMIC_BYTES_CHUNK_SIZE - 1);
-        if (dpiUtils__allocateMemory(1, dynBytes->chunks->allocatedLength, 0,
-                "allocate chunk", (void**) &dynBytes->chunks->ptr, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__assignCallbackBuffer() [INTERNAL]
-//   Assign callback pointers during OCI statement execution. This is used with
-// the callack functions used for dynamic binding during DML returning
-// statement execution.
-//-----------------------------------------------------------------------------
-static void dpiVar__assignCallbackBuffer(dpiVar *var, dpiVarBuffer *buffer,
-        uint32_t index, void **bufpp)
-{
-    switch (var->type->oracleTypeNum) {
-        case DPI_ORACLE_TYPE_TIMESTAMP:
-        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
-        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
-            *bufpp = buffer->data.asTimestamp[index];
-            break;
-        case DPI_ORACLE_TYPE_INTERVAL_DS:
-        case DPI_ORACLE_TYPE_INTERVAL_YM:
-            *bufpp = buffer->data.asInterval[index];
-            break;
-        case DPI_ORACLE_TYPE_CLOB:
-        case DPI_ORACLE_TYPE_BLOB:
-        case DPI_ORACLE_TYPE_NCLOB:
-        case DPI_ORACLE_TYPE_BFILE:
-            *bufpp = buffer->data.asLobLocator[index];
-            break;
-        case DPI_ORACLE_TYPE_ROWID:
-            *bufpp = buffer->data.asRowid[index];
-            break;
-        case DPI_ORACLE_TYPE_JSON:
-            *bufpp = buffer->data.asJsonDescriptor[index];
-            break;
-        case DPI_ORACLE_TYPE_STMT:
-            *bufpp = buffer->data.asStmt[index];
-            break;
-        default:
-            *bufpp = buffer->data.asBytes + index * var->sizeInBytes;
-            break;
-    }
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__checkArraySize() [INTERNAL]
-//   Verifies that the array size has not been exceeded.
-//-----------------------------------------------------------------------------
-static int dpiVar__checkArraySize(dpiVar *var, uint32_t pos,
-        const char *fnName, dpiError *error)
-{
-    if (dpiGen__startPublicFn(var, DPI_HTYPE_VAR, fnName, error) < 0)
-        return DPI_FAILURE;
-    if (pos >= var->buffer.maxArraySize)
-        return dpiError__set(error, "check array size",
-                DPI_ERR_INVALID_ARRAY_POSITION, pos,
-                var->buffer.maxArraySize);
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__convertToLob() [INTERNAL]
-//   Convert the variable from using dynamic bytes for a long string to using a
-// LOB instead. This is needed for PL/SQL which cannot handle more than 32K
-// without the use of a LOB.
-//-----------------------------------------------------------------------------
-int dpiVar__convertToLob(dpiVar *var, dpiError *error)
-{
-    dpiDynamicBytes *dynBytes;
-    dpiLob *lob;
-    uint32_t i;
-
-    // change type based on the original Oracle type
-    if (var->type->oracleTypeNum == DPI_ORACLE_TYPE_RAW ||
-            var->type->oracleTypeNum == DPI_ORACLE_TYPE_LONG_RAW)
-        var->type = dpiOracleType__getFromNum(DPI_ORACLE_TYPE_BLOB, error);
-    else if (var->type->oracleTypeNum == DPI_ORACLE_TYPE_NCHAR)
-        var->type = dpiOracleType__getFromNum(DPI_ORACLE_TYPE_NCLOB,
-                error);
-    else var->type = dpiOracleType__getFromNum(DPI_ORACLE_TYPE_CLOB,
-            error);
-
-    // adjust attributes and re-initialize buffers
-    // the dynamic bytes structures will not be removed
-    var->sizeInBytes = var->type->sizeInBytes;
-    var->isDynamic = 0;
-    if (dpiVar__initBuffer(var, &var->buffer, error) < 0)
-        return DPI_FAILURE;
-
-    // copy any values already set
-    for (i = 0; i < var->buffer.maxArraySize; i++) {
-        dynBytes = &var->buffer.dynamicBytes[i];
-        lob = var->buffer.references[i].asLOB;
-        if (dynBytes->numChunks == 0)
-            continue;
-        if (dpiLob__setFromBytes(lob, dynBytes->chunks->ptr,
-                dynBytes->chunks->length, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__copyData() [INTERNAL]
-//   Copy the data from the source to the target variable at the given array
-// position.
-//-----------------------------------------------------------------------------
-int dpiVar__copyData(dpiVar *var, uint32_t pos, dpiData *sourceData,
-        dpiError *error)
-{
-    dpiData *targetData = &var->buffer.externalData[pos];
-
-    // handle null case
-    targetData->isNull = sourceData->isNull;
-    if (sourceData->isNull)
-        return DPI_SUCCESS;
-
-    // handle copying of value from source to target
-    switch (var->nativeTypeNum) {
-        case DPI_NATIVE_TYPE_BYTES:
-            return dpiVar__setFromBytes(var, pos,
-                    sourceData->value.asBytes.ptr,
-                    sourceData->value.asBytes.length, error);
-        case DPI_NATIVE_TYPE_JSON:
-            return dpiVar__setFromJson(var, pos, sourceData->value.asJson,
-                    error);
-        case DPI_NATIVE_TYPE_LOB:
-            return dpiVar__setFromLob(var, pos, sourceData->value.asLOB,
-                    error);
-        case DPI_NATIVE_TYPE_OBJECT:
-            return dpiVar__setFromObject(var, pos, sourceData->value.asObject,
-                    error);
-        case DPI_NATIVE_TYPE_STMT:
-            return dpiVar__setFromStmt(var, pos, sourceData->value.asStmt,
-                    error);
-        case DPI_NATIVE_TYPE_ROWID:
-            return dpiVar__setFromRowid(var, pos, sourceData->value.asRowid,
-                    error);
-        default:
-            memcpy(targetData, sourceData, sizeof(dpiData));
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__defineCallback() [INTERNAL]
-//   Callback which runs during OCI statement execution and allocates the
-// buffers required as well as provides that information to the OCI. This is
-// intended for handling string and raw columns for which the size is unknown.
-// These include LONG, LONG RAW and retrieving CLOB and BLOB as bytes, rather
-// than use the LOB API.
-//-----------------------------------------------------------------------------
-int32_t dpiVar__defineCallback(dpiVar *var, UNUSED void *defnp, uint32_t iter,
-        void **bufpp, uint32_t **alenpp, UNUSED uint8_t *piecep, void **indpp,
-        uint16_t **rcodepp)
-{
-    dpiDynamicBytesChunk *chunk;
-    dpiDynamicBytes *bytes;
-
-    // allocate more chunks, if necessary
-    bytes = &var->buffer.dynamicBytes[iter];
-    if (bytes->numChunks == bytes->allocatedChunks &&
-            dpiVar__allocateChunks(bytes, var->error) < 0)
-        return DPI_OCI_ERROR;
-
-    // allocate memory for the chunk, if needed
-    chunk = &bytes->chunks[bytes->numChunks];
-    if (!chunk->ptr) {
-        chunk->allocatedLength = DPI_DYNAMIC_BYTES_CHUNK_SIZE;
-        if (dpiUtils__allocateMemory(1, chunk->allocatedLength, 0,
-                "allocate chunk", (void**) &chunk->ptr, var->error) < 0)
-            return DPI_OCI_ERROR;
-    }
-
-    // return chunk to OCI
-    bytes->numChunks++;
-    chunk->length = chunk->allocatedLength;
-    *bufpp = chunk->ptr;
-    *alenpp = &chunk->length;
-    *indpp = &(var->buffer.indicator[iter]);
-    *rcodepp = NULL;
-    return DPI_OCI_CONTINUE;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__extendedPreFetch() [INTERNAL]
-//   Perform any necessary actions prior to fetching data.
-//-----------------------------------------------------------------------------
-int dpiVar__extendedPreFetch(dpiVar *var, dpiVarBuffer *buffer,
-        dpiError *error)
-{
-    dpiRowid *rowid;
-    dpiData *data;
-    dpiStmt *stmt;
-    dpiJson *json;
-    dpiLob *lob;
-    uint32_t i;
-
-    if (var->isDynamic) {
-        for (i = 0; i < buffer->maxArraySize; i++)
-            buffer->dynamicBytes[i].numChunks = 0;
-        return DPI_SUCCESS;
-    }
-
-    switch (var->type->oracleTypeNum) {
-        case DPI_ORACLE_TYPE_STMT:
-            for (i = 0; i < buffer->maxArraySize; i++) {
-                data = &buffer->externalData[i];
-                if (buffer->references[i].asStmt) {
-                    dpiGen__setRefCount(buffer->references[i].asStmt,
-                            error, -1);
-                    buffer->references[i].asStmt = NULL;
-                }
-                buffer->data.asStmt[i] = NULL;
-                data->value.asStmt = NULL;
-                if (dpiStmt__allocate(var->conn, 0, &stmt, error) < 0)
-                    return DPI_FAILURE;
-                if (dpiOci__handleAlloc(var->env->handle, &stmt->handle,
-                        DPI_OCI_HTYPE_STMT, "allocate statement", error) < 0) {
-                    dpiStmt__free(stmt, error);
-                    return DPI_FAILURE;
-                }
-                if (dpiHandleList__addHandle(var->conn->openStmts, stmt,
-                        &stmt->openSlotNum, error) < 0) {
-                    dpiOci__handleFree(stmt->handle, DPI_OCI_HTYPE_STMT);
-                    stmt->handle = NULL;
-                    dpiStmt__free(stmt, error);
-                    return DPI_FAILURE;
-                }
-                buffer->references[i].asStmt = stmt;
-                stmt->isOwned = 1;
-                buffer->data.asStmt[i] = stmt->handle;
-                data->value.asStmt = stmt;
-            }
-            break;
-        case DPI_ORACLE_TYPE_CLOB:
-        case DPI_ORACLE_TYPE_BLOB:
-        case DPI_ORACLE_TYPE_NCLOB:
-        case DPI_ORACLE_TYPE_BFILE:
-            for (i = 0; i < buffer->maxArraySize; i++) {
-                data = &buffer->externalData[i];
-                if (buffer->references[i].asLOB) {
-                    dpiGen__setRefCount(buffer->references[i].asLOB,
-                            error, -1);
-                    buffer->references[i].asLOB = NULL;
-                }
-                buffer->data.asLobLocator[i] = NULL;
-                data->value.asLOB = NULL;
-                if (dpiLob__allocate(var->conn, var->type, &lob, error) < 0)
-                    return DPI_FAILURE;
-                buffer->references[i].asLOB = lob;
-                buffer->data.asLobLocator[i] = lob->locator;
-                data->value.asLOB = lob;
-                if (buffer->dynamicBytes &&
-                        dpiOci__lobCreateTemporary(lob, error) < 0)
-                    return DPI_FAILURE;
-            }
-            break;
-        case DPI_ORACLE_TYPE_ROWID:
-            for (i = 0; i < buffer->maxArraySize; i++) {
-                data = &buffer->externalData[i];
-                if (buffer->references[i].asRowid) {
-                    dpiGen__setRefCount(buffer->references[i].asRowid,
-                            error, -1);
-                    buffer->references[i].asRowid = NULL;
-                }
-                buffer->data.asRowid[i] = NULL;
-                data->value.asRowid = NULL;
-                if (dpiRowid__allocate(var->conn, &rowid, error) < 0)
-                    return DPI_FAILURE;
-                buffer->references[i].asRowid = rowid;
-                buffer->data.asRowid[i] = rowid->handle;
-                data->value.asRowid = rowid;
-            }
-            break;
-        case DPI_ORACLE_TYPE_OBJECT:
-            for (i = 0; i < buffer->maxArraySize; i++) {
-                data = &buffer->externalData[i];
-                if (buffer->references[i].asObject) {
-                    dpiGen__setRefCount(buffer->references[i].asObject,
-                            error, -1);
-                    buffer->references[i].asObject = NULL;
-                }
-                buffer->data.asObject[i] = NULL;
-                buffer->objectIndicator[i] = NULL;
-                data->value.asObject = NULL;
-            }
-            break;
-        case DPI_ORACLE_TYPE_JSON:
-            for (i = 0; i < buffer->maxArraySize; i++) {
-                data = &buffer->externalData[i];
-                if (buffer->references[i].asJson) {
-                    dpiGen__setRefCount(buffer->references[i].asJson,
-                            error, -1);
-                    buffer->references[i].asJson = NULL;
-                }
-                buffer->data.asJsonDescriptor[i] = NULL;
-                data->value.asJson = NULL;
-                if (dpiJson__allocate(var->conn, &json, error) < 0)
-                    return DPI_FAILURE;
-                buffer->references[i].asJson = json;
-                buffer->data.asJsonDescriptor[i] = json->handle;
-                data->value.asJson = json;
-            }
-            break;
-        default:
-            break;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__finalizeBuffer() [INTERNAL]
-//   Finalize buffer used for passing data to/from Oracle.
-//-----------------------------------------------------------------------------
-static void dpiVar__finalizeBuffer(dpiVar *var, dpiVarBuffer *buffer,
-        dpiError *error)
-{
-    dpiDynamicBytes *dynBytes;
-    uint32_t i, j;
-
-    // free any descriptors that were created
-    switch (var->type->oracleTypeNum) {
-        case DPI_ORACLE_TYPE_TIMESTAMP:
-            dpiOci__arrayDescriptorFree(&buffer->data.asTimestamp[0],
-                    DPI_OCI_DTYPE_TIMESTAMP);
-            break;
-        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
-            dpiOci__arrayDescriptorFree(&buffer->data.asTimestamp[0],
-                    DPI_OCI_DTYPE_TIMESTAMP_TZ);
-            break;
-        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
-            dpiOci__arrayDescriptorFree(&buffer->data.asTimestamp[0],
-                    DPI_OCI_DTYPE_TIMESTAMP_LTZ);
-            break;
-        case DPI_ORACLE_TYPE_INTERVAL_DS:
-            dpiOci__arrayDescriptorFree(&buffer->data.asInterval[0],
-                    DPI_OCI_DTYPE_INTERVAL_DS);
-            break;
-        case DPI_ORACLE_TYPE_INTERVAL_YM:
-            dpiOci__arrayDescriptorFree(&buffer->data.asInterval[0],
-                    DPI_OCI_DTYPE_INTERVAL_YM);
-            break;
-        default:
-            break;
-    }
-
-    // release any references that were created
-    if (buffer->references) {
-        for (i = 0; i < buffer->maxArraySize; i++) {
-            if (buffer->references[i].asHandle) {
-                dpiGen__setRefCount(buffer->references[i].asHandle, error, -1);
-                buffer->references[i].asHandle = NULL;
-            }
-        }
-        dpiUtils__freeMemory(buffer->references);
-        buffer->references = NULL;
-    }
-
-    // free any dynamic buffers
-    if (buffer->dynamicBytes) {
-        for (i = 0; i < buffer->maxArraySize; i++) {
-            dynBytes = &buffer->dynamicBytes[i];
-            if (dynBytes->allocatedChunks > 0) {
-                for (j = 0; j < dynBytes->allocatedChunks; j++) {
-                    if (dynBytes->chunks[j].ptr) {
-                        dpiUtils__freeMemory(dynBytes->chunks[j].ptr);
-                        dynBytes->chunks[j].ptr = NULL;
-                    }
-                }
-                dpiUtils__freeMemory(dynBytes->chunks);
-                dynBytes->allocatedChunks = 0;
-                dynBytes->chunks = NULL;
-            }
-        }
-        dpiUtils__freeMemory(buffer->dynamicBytes);
-        buffer->dynamicBytes = NULL;
-    }
-
-    // free other memory allocated
-    if (buffer->indicator) {
-        dpiUtils__freeMemory(buffer->indicator);
-        buffer->indicator = NULL;
-    }
-    if (buffer->returnCode) {
-        dpiUtils__freeMemory(buffer->returnCode);
-        buffer->returnCode = NULL;
-    }
-    if (buffer->actualLength16) {
-        dpiUtils__freeMemory(buffer->actualLength16);
-        buffer->actualLength16 = NULL;
-    }
-    if (buffer->actualLength32) {
-        dpiUtils__freeMemory(buffer->actualLength32);
-        buffer->actualLength32 = NULL;
-    }
-    if (buffer->externalData) {
-        dpiUtils__freeMemory(buffer->externalData);
-        buffer->externalData = NULL;
-    }
-    if (buffer->data.asRaw) {
-        dpiUtils__freeMemory(buffer->data.asRaw);
-        buffer->data.asRaw = NULL;
-    }
-    if (buffer->objectIndicator) {
-        dpiUtils__freeMemory(buffer->objectIndicator);
-        buffer->objectIndicator = NULL;
-    }
-    if (buffer->tempBuffer) {
-        dpiUtils__freeMemory(buffer->tempBuffer);
-        buffer->tempBuffer = NULL;
-    }
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__free() [INTERNAL]
-//   Free the memory associated with the variable.
-//-----------------------------------------------------------------------------
-void dpiVar__free(dpiVar *var, dpiError *error)
-{
-    uint32_t i;
-
-    dpiVar__finalizeBuffer(var, &var->buffer, error);
-    if (var->dynBindBuffers) {
-        for (i = 0; i < var->buffer.maxArraySize; i++)
-            dpiVar__finalizeBuffer(var, &var->dynBindBuffers[i], error);
-        dpiUtils__freeMemory(var->dynBindBuffers);
-        var->dynBindBuffers = NULL;
-    }
-    if (var->objectType) {
-        dpiGen__setRefCount(var->objectType, error, -1);
-        var->objectType = NULL;
-    }
-    if (var->conn) {
-        dpiGen__setRefCount(var->conn, error, -1);
-        var->conn = NULL;
-    }
-    dpiUtils__freeMemory(var);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__getValue() [PRIVATE]
-//   Returns the contents of the variable in the type specified, if possible.
-//-----------------------------------------------------------------------------
-int dpiVar__getValue(dpiVar *var, dpiVarBuffer *buffer, uint32_t pos,
-        int inFetch, dpiError *error)
-{
-    dpiOracleTypeNum oracleTypeNum;
-    dpiBytes *bytes;
-    dpiData *data;
-    uint32_t i;
-
-    // check for dynamic binds first; if they exist, process them instead
-    if (var->dynBindBuffers && buffer == &var->buffer) {
-        buffer = &var->dynBindBuffers[pos];
-        for (i = 0; i < buffer->maxArraySize; i++) {
-            if (dpiVar__getValue(var, buffer, i, inFetch, error) < 0)
-                return DPI_FAILURE;
-        }
-        return DPI_SUCCESS;
-    }
-
-    // check for a NULL value; for objects the indicator is elsewhere
-    data = &buffer->externalData[pos];
-    if (!buffer->objectIndicator)
-        data->isNull = (buffer->indicator[pos] == DPI_OCI_IND_NULL);
-    else if (buffer->objectIndicator[pos])
-        data->isNull = (*((int16_t*) buffer->objectIndicator[pos]) ==
-                DPI_OCI_IND_NULL);
-    else data->isNull = 1;
-    if (data->isNull) {
-        if (inFetch && var->objectType && var->objectType->isCollection) {
-            if (dpiOci__objectFree(var->env->handle,
-                    buffer->data.asObject[pos], 1, error) < 0)
-                return DPI_FAILURE;
-            if (dpiOci__objectFree(var->env->handle,
-                    buffer->objectIndicator[pos], 1, error) < 0)
-                return DPI_FAILURE;
-        }
-        return DPI_SUCCESS;
-    }
-
-    // check return code for variable length data
-    if (buffer->returnCode) {
-        if (buffer->returnCode[pos] != 0) {
-            dpiError__set(error, "check return code", DPI_ERR_COLUMN_FETCH,
-                    pos, buffer->returnCode[pos]);
-            error->buffer->code = buffer->returnCode[pos];
-            return DPI_FAILURE;
-        }
-    }
-
-    // for 11g, dynamic lengths are 32-bit whereas static lengths are 16-bit
-    if (buffer->actualLength16 && buffer->actualLength32)
-        buffer->actualLength16[pos] = (uint16_t) buffer->actualLength32[pos];
-
-    // transform the various types
-    oracleTypeNum = var->type->oracleTypeNum;
-    switch (var->nativeTypeNum) {
-        case DPI_NATIVE_TYPE_INT64:
-        case DPI_NATIVE_TYPE_UINT64:
-            switch (oracleTypeNum) {
-                case DPI_ORACLE_TYPE_NATIVE_INT:
-                    data->value.asInt64 = buffer->data.asInt64[pos];
-                    return DPI_SUCCESS;
-                case DPI_ORACLE_TYPE_NATIVE_UINT:
-                    data->value.asUint64 = buffer->data.asUint64[pos];
-                    return DPI_SUCCESS;
-                case DPI_ORACLE_TYPE_NUMBER:
-                    if (var->nativeTypeNum == DPI_NATIVE_TYPE_INT64)
-                        return dpiDataBuffer__fromOracleNumberAsInteger(
-                                &data->value, error,
-                                &buffer->data.asNumber[pos]);
-                    return dpiDataBuffer__fromOracleNumberAsUnsignedInteger(
-                            &data->value, error, &buffer->data.asNumber[pos]);
-                default:
-                    break;
-            }
-            break;
-        case DPI_NATIVE_TYPE_DOUBLE:
-            switch (oracleTypeNum) {
-                case DPI_ORACLE_TYPE_NUMBER:
-                    return dpiDataBuffer__fromOracleNumberAsDouble(
-                            &data->value, error, &buffer->data.asNumber[pos]);
-                case DPI_ORACLE_TYPE_NATIVE_DOUBLE:
-                    data->value.asDouble = buffer->data.asDouble[pos];
-                    return DPI_SUCCESS;
-                case DPI_ORACLE_TYPE_DATE:
-                    return dpiDataBuffer__fromOracleDateAsDouble(&data->value,
-                            var->env, error, &buffer->data.asDate[pos]);
-                case DPI_ORACLE_TYPE_TIMESTAMP:
-                case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
-                case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
-                    return dpiDataBuffer__fromOracleTimestampAsDouble(
-                            &data->value, oracleTypeNum, var->env, error,
-                            buffer->data.asTimestamp[pos]);
-                default:
-                    break;
-            }
-            break;
-        case DPI_NATIVE_TYPE_BYTES:
-            bytes = &data->value.asBytes;
-            switch (oracleTypeNum) {
-                case DPI_ORACLE_TYPE_VARCHAR:
-                case DPI_ORACLE_TYPE_NVARCHAR:
-                case DPI_ORACLE_TYPE_CHAR:
-                case DPI_ORACLE_TYPE_NCHAR:
-                case DPI_ORACLE_TYPE_ROWID:
-                case DPI_ORACLE_TYPE_RAW:
-                case DPI_ORACLE_TYPE_LONG_VARCHAR:
-                case DPI_ORACLE_TYPE_LONG_NVARCHAR:
-                case DPI_ORACLE_TYPE_LONG_RAW:
-                    if (buffer->dynamicBytes)
-                        return dpiVar__setBytesFromDynamicBytes(bytes,
-                                &buffer->dynamicBytes[pos], error);
-                    if (buffer->actualLength16)
-                        bytes->length = buffer->actualLength16[pos];
-                    else bytes->length = buffer->actualLength32[pos];
-                    return DPI_SUCCESS;
-                case DPI_ORACLE_TYPE_CLOB:
-                case DPI_ORACLE_TYPE_NCLOB:
-                case DPI_ORACLE_TYPE_BLOB:
-                case DPI_ORACLE_TYPE_BFILE:
-                    return dpiVar__setBytesFromLob(bytes,
-                            &buffer->dynamicBytes[pos],
-                            buffer->references[pos].asLOB, error);
-                case DPI_ORACLE_TYPE_NUMBER:
-                    bytes->length = DPI_NUMBER_AS_TEXT_CHARS;
-                    if (var->env->charsetId == DPI_CHARSET_ID_UTF16)
-                        bytes->length *= 2;
-                    return dpiDataBuffer__fromOracleNumberAsText(&data->value,
-                            var->env, error, &buffer->data.asNumber[pos]);
-                default:
-                    break;
-            }
-            break;
-        case DPI_NATIVE_TYPE_FLOAT:
-            data->value.asFloat = buffer->data.asFloat[pos];
-            break;
-        case DPI_NATIVE_TYPE_TIMESTAMP:
-            if (oracleTypeNum == DPI_ORACLE_TYPE_DATE)
-                return dpiDataBuffer__fromOracleDate(&data->value,
-                        &buffer->data.asDate[pos]);
-            return dpiDataBuffer__fromOracleTimestamp(&data->value, var->env,
-                    error, buffer->data.asTimestamp[pos],
-                    oracleTypeNum != DPI_ORACLE_TYPE_TIMESTAMP);
-            break;
-        case DPI_NATIVE_TYPE_INTERVAL_DS:
-            return dpiDataBuffer__fromOracleIntervalDS(&data->value, var->env,
-                    error, buffer->data.asInterval[pos]);
-        case DPI_NATIVE_TYPE_INTERVAL_YM:
-            return dpiDataBuffer__fromOracleIntervalYM(&data->value, var->env,
-                    error, buffer->data.asInterval[pos]);
-        case DPI_NATIVE_TYPE_OBJECT:
-            data->value.asObject = NULL;
-            if (!buffer->references[pos].asObject) {
-                if (dpiObject__allocate(var->objectType,
-                        buffer->data.asObject[pos],
-                        buffer->objectIndicator[pos], NULL,
-                        &buffer->references[pos].asObject, error) < 0)
-                    return DPI_FAILURE;
-                if (inFetch && var->objectType->isCollection)
-                    buffer->references[pos].asObject->freeIndicator = 1;
-            }
-            data->value.asObject = buffer->references[pos].asObject;
-            break;
-        case DPI_NATIVE_TYPE_STMT:
-            data->value.asStmt = buffer->references[pos].asStmt;
-            break;
-        case DPI_NATIVE_TYPE_BOOLEAN:
-            data->value.asBoolean = buffer->data.asBoolean[pos];
-            break;
-        default:
-            break;
-    }
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__inBindCallback() [INTERNAL]
-//   Callback which runs during OCI statement execution and provides buffers to
-// OCI for binding data IN. This is not used with DML returning so this method
-// does nothing useful except satisfy OCI requirements.
-//-----------------------------------------------------------------------------
-int32_t dpiVar__inBindCallback(dpiVar *var, UNUSED void *bindp,
-        UNUSED uint32_t iter, UNUSED uint32_t index, void **bufpp,
-        uint32_t *alenp, uint8_t *piecep, void **indpp)
-{
-    dpiDynamicBytes *dynBytes;
-
-    if (var->isDynamic) {
-        dynBytes = &var->buffer.dynamicBytes[iter];
-        if (dynBytes->allocatedChunks == 0) {
-            *bufpp = NULL;
-            *alenp = 0;
-        } else {
-            *bufpp = dynBytes->chunks->ptr;
-            *alenp = dynBytes->chunks->length;
-        }
-    } else {
-        dpiVar__assignCallbackBuffer(var, &var->buffer, iter, bufpp);
-        if (var->buffer.actualLength16)
-            *alenp = var->buffer.actualLength16[iter];
-        else if (var->buffer.actualLength32)
-            *alenp = var->buffer.actualLength32[iter];
-        else *alenp = var->type->sizeInBytes;
-    }
-    *piecep = DPI_OCI_ONE_PIECE;
-    if (var->buffer.objectIndicator)
-        *indpp = var->buffer.objectIndicator[iter];
-    else *indpp = &var->buffer.indicator[iter];
-    return DPI_OCI_CONTINUE;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__initBuffer() [INTERNAL]
-//   Initialize buffers necessary for passing data to/from Oracle.
-//-----------------------------------------------------------------------------
-static int dpiVar__initBuffer(dpiVar *var, dpiVarBuffer *buffer,
-        dpiError *error)
-{
-    uint32_t i, tempBufferSize = 0;
-    unsigned long long dataLength;
-    dpiBytes *bytes;
-
-    // initialize dynamic buffers for dynamic variables
-    if (var->isDynamic) {
-        if (dpiUtils__allocateMemory(buffer->maxArraySize,
-                sizeof(dpiDynamicBytes), 1, "allocate dynamic bytes",
-                (void**) &buffer->dynamicBytes, error) < 0)
-            return DPI_FAILURE;
-
-    // for all other variables, validate length and allocate buffers
-    } else {
-        dataLength = (unsigned long long) buffer->maxArraySize *
-                (unsigned long long) var->sizeInBytes;
-        if (dataLength > INT_MAX)
-            return dpiError__set(error, "check max array size",
-                    DPI_ERR_ARRAY_SIZE_TOO_BIG, buffer->maxArraySize);
-        if (dpiUtils__allocateMemory(1, (size_t) dataLength, 0,
-                "allocate buffer", (void**) &buffer->data.asRaw, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // allocate the indicator for the variable
-    // ensure all values start out as null
-    if (!buffer->indicator) {
-        if (dpiUtils__allocateMemory(buffer->maxArraySize, sizeof(int16_t), 0,
-                "allocate indicator", (void**) &buffer->indicator, error) < 0)
-            return DPI_FAILURE;
-        for (i = 0; i < buffer->maxArraySize; i++)
-            buffer->indicator[i] = DPI_OCI_IND_NULL;
-    }
-
-    // allocate the actual length buffers for all but dynamic bytes which are
-    // handled differently; ensure actual length starts out as maximum value
-    if (!var->isDynamic && !buffer->actualLength16 &&
-            !buffer->actualLength32) {
-        if (var->env->versionInfo->versionNum < 12 && buffer == &var->buffer) {
-            if (dpiUtils__allocateMemory(buffer->maxArraySize,
-                    sizeof(uint16_t), 0, "allocate actual length",
-                    (void**) &buffer->actualLength16, error) < 0)
-                return DPI_FAILURE;
-            for (i = 0; i < buffer->maxArraySize; i++)
-                buffer->actualLength16[i] = (uint16_t) var->sizeInBytes;
-        } else {
-            if (dpiUtils__allocateMemory(buffer->maxArraySize,
-                    sizeof(uint32_t), 0, "allocate actual length",
-                    (void**) &buffer->actualLength32, error) < 0)
-                return DPI_FAILURE;
-            for (i = 0; i < buffer->maxArraySize; i++)
-                buffer->actualLength32[i] = var->sizeInBytes;
-        }
-    }
-
-    // for variable length data, also allocate the return code array
-    if (var->type->defaultNativeTypeNum == DPI_NATIVE_TYPE_BYTES &&
-            !var->isDynamic && !buffer->returnCode) {
-        if (dpiUtils__allocateMemory(buffer->maxArraySize, sizeof(uint16_t), 0,
-                "allocate return code", (void**) &buffer->returnCode,
-                error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // for numbers transferred to/from Oracle as bytes, allocate an additional
-    // set of buffers
-    if (var->type->oracleTypeNum == DPI_ORACLE_TYPE_NUMBER &&
-            var->nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
-        tempBufferSize = DPI_NUMBER_AS_TEXT_CHARS;
-        if (var->env->charsetId == DPI_CHARSET_ID_UTF16)
-            tempBufferSize *= 2;
-        if (!buffer->tempBuffer) {
-            if (dpiUtils__allocateMemory(buffer->maxArraySize, tempBufferSize,
-                    0, "allocate temp buffer", (void**) &buffer->tempBuffer,
-                    error) < 0)
-                return DPI_FAILURE;
-        }
-    }
-
-    // allocate the external data array, if needed
-    if (!buffer->externalData) {
-        if (dpiUtils__allocateMemory(buffer->maxArraySize, sizeof(dpiData), 1,
-                "allocate external data", (void**) &buffer->externalData,
-                error) < 0)
-            return DPI_FAILURE;
-        for (i = 0; i < buffer->maxArraySize; i++)
-            buffer->externalData[i].isNull = 1;
-    }
-
-    // for bytes transfers, set encoding and pointers for small strings
-    if (var->nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
-        for (i = 0; i < buffer->maxArraySize; i++) {
-            bytes = &buffer->externalData[i].value.asBytes;
-            if (var->type->charsetForm == DPI_SQLCS_IMPLICIT)
-                bytes->encoding = var->env->encoding;
-            else bytes->encoding = var->env->nencoding;
-            if (buffer->tempBuffer)
-                bytes->ptr = buffer->tempBuffer + i * tempBufferSize;
-            else if (!var->isDynamic && !buffer->dynamicBytes)
-                bytes->ptr = buffer->data.asBytes + i * var->sizeInBytes;
-        }
-    }
-
-    // create array of references, if applicable
-    if (var->type->requiresPreFetch && !var->isDynamic) {
-        if (dpiUtils__allocateMemory(buffer->maxArraySize,
-                sizeof(dpiReferenceBuffer), 1, "allocate references",
-                (void**) &buffer->references, error) < 0)
-            return DPI_FAILURE;
-    }
-
-    // perform variable specific initialization
-    switch (var->type->oracleTypeNum) {
-        case DPI_ORACLE_TYPE_TIMESTAMP:
-            return dpiOci__arrayDescriptorAlloc(var->env->handle,
-                    &buffer->data.asTimestamp[0], DPI_OCI_DTYPE_TIMESTAMP,
-                    buffer->maxArraySize, error);
-        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
-            return dpiOci__arrayDescriptorAlloc(var->env->handle,
-                    &buffer->data.asTimestamp[0], DPI_OCI_DTYPE_TIMESTAMP_TZ,
-                    buffer->maxArraySize, error);
-        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
-            return dpiOci__arrayDescriptorAlloc(var->env->handle,
-                    &buffer->data.asTimestamp[0], DPI_OCI_DTYPE_TIMESTAMP_LTZ,
-                    buffer->maxArraySize, error);
-        case DPI_ORACLE_TYPE_INTERVAL_DS:
-            return dpiOci__arrayDescriptorAlloc(var->env->handle,
-                    &buffer->data.asInterval[0], DPI_OCI_DTYPE_INTERVAL_DS,
-                    buffer->maxArraySize, error);
-        case DPI_ORACLE_TYPE_INTERVAL_YM:
-            return dpiOci__arrayDescriptorAlloc(var->env->handle,
-                    &buffer->data.asInterval[0], DPI_OCI_DTYPE_INTERVAL_YM,
-                    buffer->maxArraySize, error);
-        case DPI_ORACLE_TYPE_CLOB:
-        case DPI_ORACLE_TYPE_BLOB:
-        case DPI_ORACLE_TYPE_NCLOB:
-        case DPI_ORACLE_TYPE_BFILE:
-        case DPI_ORACLE_TYPE_STMT:
-        case DPI_ORACLE_TYPE_ROWID:
-        case DPI_ORACLE_TYPE_JSON:
-            return dpiVar__extendedPreFetch(var, buffer, error);
-        case DPI_ORACLE_TYPE_OBJECT:
-            if (!var->objectType)
-                return dpiError__set(error, "check object type",
-                        DPI_ERR_NO_OBJECT_TYPE);
-            if (dpiUtils__allocateMemory(buffer->maxArraySize, sizeof(void*),
-                    0, "allocate object indicator",
-                    (void**) &buffer->objectIndicator, error) < 0)
-                return DPI_FAILURE;
-            return dpiVar__extendedPreFetch(var, buffer, error);
-        default:
-            break;
-    }
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__outBindCallback() [INTERNAL]
-//   Callback which runs during OCI statement execution and allocates the
-// buffers required as well as provides that information to the OCI. This is
-// intended for use with DML returning only.
-//-----------------------------------------------------------------------------
-int32_t dpiVar__outBindCallback(dpiVar *var, void *bindp, UNUSED uint32_t iter,
-        uint32_t index, void **bufpp, uint32_t **alenpp, uint8_t *piecep,
-        void **indpp, uint16_t **rcodepp)
-{
-    dpiDynamicBytesChunk *chunk;
-    uint32_t numRowsReturned;
-    dpiDynamicBytes *bytes;
-    dpiVarBuffer *buffer;
-
-    // determine which variable buffer to use
-    if (!var->dynBindBuffers) {
-        if (dpiUtils__allocateMemory(var->buffer.maxArraySize,
-                sizeof(dpiVarBuffer), 1, "allocate DML returning buffers",
-                (void**) &var->dynBindBuffers, var->error) < 0)
-            return DPI_FAILURE;
-    }
-    buffer = &var->dynBindBuffers[iter];
-
-    // special processing during first value returned for each iteration
-    if (index == 0) {
-
-        // determine number of rows returned
-        if (dpiOci__attrGet(bindp, DPI_OCI_HTYPE_BIND, &numRowsReturned, 0,
-                DPI_OCI_ATTR_ROWS_RETURNED, "get rows returned",
-                var->error) < 0)
-            return DPI_OCI_ERROR;
-
-        // reallocate buffers, if needed
-        if (numRowsReturned > buffer->maxArraySize) {
-            dpiVar__finalizeBuffer(var, buffer, var->error);
-            buffer->maxArraySize = numRowsReturned;
-            if (dpiVar__initBuffer(var, buffer, var->error) < 0)
-                return DPI_OCI_ERROR;
-        }
-
-        // set actual array size to number of rows returned
-        buffer->actualArraySize = numRowsReturned;
-
-    }
-
-    // handle dynamically allocated strings (multiple piece)
-    // index is the current index into the chunks
-    if (var->isDynamic) {
-
-        // allocate more chunks, if necessary
-        bytes = &buffer->dynamicBytes[index];
-        if (*piecep == DPI_OCI_ONE_PIECE)
-            bytes->numChunks = 0;
-        if (bytes->numChunks == bytes->allocatedChunks &&
-                dpiVar__allocateChunks(bytes, var->error) < 0)
-            return DPI_OCI_ERROR;
-
-        // allocate memory for the chunk, if needed
-        chunk = &bytes->chunks[bytes->numChunks];
-        if (!chunk->ptr) {
-            chunk->allocatedLength = DPI_DYNAMIC_BYTES_CHUNK_SIZE;
-            if (dpiUtils__allocateMemory(1, chunk->allocatedLength, 0,
-                    "allocate chunk", (void**) &chunk->ptr, var->error) < 0)
-                return DPI_OCI_ERROR;
-        }
-
-        // return chunk to OCI
-        bytes->numChunks++;
-        chunk->length = chunk->allocatedLength;
-        *bufpp = chunk->ptr;
-        *alenpp = &chunk->length;
-        *indpp = &(buffer->indicator[index]);
-        *rcodepp = NULL;
-
-    // handle normally allocated variables (one piece)
-    } else {
-
-        *piecep = DPI_OCI_ONE_PIECE;
-        if (dpiVar__setValue(var, buffer, index, &buffer->externalData[index],
-                var->error) < 0)
-            return DPI_OCI_ERROR;
-        dpiVar__assignCallbackBuffer(var, buffer, index, bufpp);
-        if (buffer->actualLength32 || buffer->actualLength16) {
-            if (!buffer->actualLength32) {
-                if (dpiUtils__allocateMemory(buffer->maxArraySize,
-                        sizeof(uint32_t), 1, "allocate 11g lengths",
-                        (void**) &buffer->actualLength32, var->error) < 0)
-                    return DPI_OCI_ERROR;
-            }
-            buffer->actualLength32[index] = var->sizeInBytes;
-            *alenpp = &(buffer->actualLength32[index]);
-        } else if (*alenpp && var->type->sizeInBytes)
-            **alenpp = var->type->sizeInBytes;
-        if (buffer->objectIndicator)
-            *indpp = buffer->objectIndicator[index];
-        else *indpp = &(buffer->indicator[index]);
-        if (buffer->returnCode)
-            *rcodepp = &buffer->returnCode[index];
-
-    }
-
-    return DPI_OCI_CONTINUE;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__setBytesFromDynamicBytes() [PRIVATE]
-//   Set the pointer and length in the dpiBytes structure to the values
-// retrieved from the database. At this point, if multiple chunks exist, they
-// are combined into one.
-//-----------------------------------------------------------------------------
-static int dpiVar__setBytesFromDynamicBytes(dpiBytes *bytes,
-        dpiDynamicBytes *dynBytes, dpiError *error)
-{
-    uint32_t i, totalAllocatedLength;
-
-    // if only one chunk is available, make use of it
-    if (dynBytes->numChunks == 1) {
-        bytes->ptr = dynBytes->chunks->ptr;
-        bytes->length = dynBytes->chunks->length;
-        return DPI_SUCCESS;
-    }
-
-    // determine total allocated size of all chunks
-    totalAllocatedLength = 0;
-    for (i = 0; i < dynBytes->numChunks; i++)
-        totalAllocatedLength += dynBytes->chunks[i].allocatedLength;
-
-    // allocate new memory consolidating all of the chunks
-    if (dpiUtils__allocateMemory(1, totalAllocatedLength, 0,
-            "allocate consolidated chunk", (void**) &bytes->ptr, error) < 0)
-        return DPI_FAILURE;
-
-    // copy memory from chunks to consolidated chunk
-    bytes->length = 0;
-    for (i = 0; i < dynBytes->numChunks; i++) {
-        memcpy(bytes->ptr + bytes->length, dynBytes->chunks[i].ptr,
-                dynBytes->chunks[i].length);
-        bytes->length += dynBytes->chunks[i].length;
-        dpiUtils__freeMemory(dynBytes->chunks[i].ptr);
-        dynBytes->chunks[i].ptr = NULL;
-        dynBytes->chunks[i].length = 0;
-        dynBytes->chunks[i].allocatedLength = 0;
-    }
-
-    // populate first chunk with consolidated information
-    dynBytes->numChunks = 1;
-    dynBytes->chunks->ptr = bytes->ptr;
-    dynBytes->chunks->length = bytes->length;
-    dynBytes->chunks->allocatedLength = totalAllocatedLength;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__setBytesFromLob() [PRIVATE]
-//   Populate the dynamic bytes structure with the data from the LOB and then
-// populate the bytes structure.
-//-----------------------------------------------------------------------------
-static int dpiVar__setBytesFromLob(dpiBytes *bytes, dpiDynamicBytes *dynBytes,
-        dpiLob *lob, dpiError *error)
-{
-    uint64_t length, lengthInBytes, lengthReadInBytes;
-
-    // determine length of LOB in bytes
-    if (dpiOci__lobGetLength2(lob, &length, error) < 0)
-        return DPI_FAILURE;
-    if (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_CLOB)
-        lengthInBytes = length * lob->env->maxBytesPerCharacter;
-    else if (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_NCLOB)
-        lengthInBytes = length * lob->env->nmaxBytesPerCharacter;
-    else lengthInBytes = length;
-
-    // ensure there is enough space to store the entire LOB value
-    if (lengthInBytes > UINT_MAX)
-        return dpiError__set(error, "check max length", DPI_ERR_NOT_SUPPORTED);
-    if (dpiVar__allocateDynamicBytes(dynBytes, (uint32_t) lengthInBytes,
-            error) < 0)
-        return DPI_FAILURE;
-
-    // read data from the LOB
-    lengthReadInBytes = lengthInBytes;
-    if (length > 0 && dpiLob__readBytes(lob, 1, length, dynBytes->chunks->ptr,
-            &lengthReadInBytes, error) < 0)
-        return DPI_FAILURE;
-
-    dynBytes->chunks->length = (uint32_t) lengthReadInBytes;
-    bytes->ptr = dynBytes->chunks->ptr;
-    bytes->length = dynBytes->chunks->length;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__setFromBytes() [PRIVATE]
-//   Set the value of the variable at the given array position from a byte
-// string. The byte string is not retained in any way. A copy will be made into
-// buffers allocated by ODPI-C.
-//-----------------------------------------------------------------------------
-static int dpiVar__setFromBytes(dpiVar *var, uint32_t pos, const char *value,
-        uint32_t valueLength, dpiError *error)
-{
-    dpiData *data = &var->buffer.externalData[pos];
-    dpiDynamicBytes *dynBytes;
-    dpiBytes *bytes;
-
-    // for internally used LOBs, write the data directly
-    if (var->buffer.references) {
-        data->isNull = 0;
-        return dpiLob__setFromBytes(var->buffer.references[pos].asLOB, value,
-                valueLength, error);
-    }
-
-    // validate the target can accept the input
-    if ((var->buffer.tempBuffer &&
-                    var->env->charsetId == DPI_CHARSET_ID_UTF16 &&
-                    valueLength > DPI_NUMBER_AS_TEXT_CHARS * 2) ||
-            (var->buffer.tempBuffer &&
-                    var->env->charsetId != DPI_CHARSET_ID_UTF16 &&
-                    valueLength > DPI_NUMBER_AS_TEXT_CHARS) ||
-            (!var->buffer.dynamicBytes && !var->buffer.tempBuffer &&
-                    valueLength > var->sizeInBytes))
-        return dpiError__set(error, "check source length",
-                DPI_ERR_BUFFER_SIZE_TOO_SMALL, var->sizeInBytes);
-
-    // for dynamic bytes, allocate space as needed
-    bytes = &data->value.asBytes;
-    if (var->buffer.dynamicBytes) {
-        dynBytes = &var->buffer.dynamicBytes[pos];
-        if (dpiVar__allocateDynamicBytes(dynBytes, valueLength, error) < 0)
-            return DPI_FAILURE;
-        if (valueLength > 0)
-            memcpy(dynBytes->chunks->ptr, value, valueLength);
-        dynBytes->numChunks = 1;
-        dynBytes->chunks->length = valueLength;
-        bytes->ptr = dynBytes->chunks->ptr;
-        bytes->length = valueLength;
-
-    // for everything else, space has already been allocated
-    } else {
-        bytes->length = valueLength;
-        if (valueLength > 0)
-            memcpy(bytes->ptr, value, valueLength);
-        if (var->type->sizeInBytes == 0) {
-            if (var->buffer.actualLength32)
-                var->buffer.actualLength32[pos] = valueLength;
-            else if (var->buffer.actualLength16)
-                var->buffer.actualLength16[pos] = (uint16_t) valueLength;
-        }
-        if (var->buffer.returnCode)
-            var->buffer.returnCode[pos] = 0;
-    }
-    data->isNull = 0;
-
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__setFromJson() [PRIVATE]
-//   Set the value of the variable at the given array position from a JSON
-// value. A reference to the JSON value is retained by the variable.
-//-----------------------------------------------------------------------------
-static int dpiVar__setFromJson(dpiVar *var, uint32_t pos, dpiJson *json,
-        dpiError *error)
-{
-    dpiData *data;
-
-    // validate the JSON value
-    if (dpiGen__checkHandle(json, DPI_HTYPE_JSON, "check JSON", error) < 0)
-        return DPI_FAILURE;
-
-    // mark the value as not null
-    data = &var->buffer.externalData[pos];
-    data->isNull = 0;
-
-    // if values are the same, nothing to do
-    if (var->buffer.references[pos].asJson == json)
-        return DPI_SUCCESS;
-
-    // clear original value, if needed
-    if (var->buffer.references[pos].asJson) {
-        dpiGen__setRefCount(var->buffer.references[pos].asJson, error, -1);
-        var->buffer.references[pos].asJson = NULL;
-    }
-
-    // add reference to passed object
-    dpiGen__setRefCount(json, error, 1);
-    var->buffer.references[pos].asJson = json;
-    var->buffer.data.asJsonDescriptor[pos] = json->handle;
-    data->value.asJson = json;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__setFromLob() [PRIVATE]
-//   Set the value of the variable at the given array position from a LOB.
-// A reference to the LOB is retained by the variable.
-//-----------------------------------------------------------------------------
-static int dpiVar__setFromLob(dpiVar *var, uint32_t pos, dpiLob *lob,
-        dpiError *error)
-{
-    dpiData *data;
-
-    // validate the LOB object
-    if (dpiGen__checkHandle(lob, DPI_HTYPE_LOB, "check LOB", error) < 0)
-        return DPI_FAILURE;
-
-    // mark the value as not null
-    data = &var->buffer.externalData[pos];
-    data->isNull = 0;
-
-    // if values are the same, nothing to do
-    if (var->buffer.references[pos].asLOB == lob)
-        return DPI_SUCCESS;
-
-    // clear original value, if needed
-    if (var->buffer.references[pos].asLOB) {
-        dpiGen__setRefCount(var->buffer.references[pos].asLOB, error, -1);
-        var->buffer.references[pos].asLOB = NULL;
-    }
-
-    // add reference to passed object
-    dpiGen__setRefCount(lob, error, 1);
-    var->buffer.references[pos].asLOB = lob;
-    var->buffer.data.asLobLocator[pos] = lob->locator;
-    data->value.asLOB = lob;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__setFromObject() [PRIVATE]
-//   Set the value of the variable at the given array position from an object.
-// The variable and position are assumed to be valid at this point. A reference
-// to the object is retained by the variable.
-//-----------------------------------------------------------------------------
-static int dpiVar__setFromObject(dpiVar *var, uint32_t pos, dpiObject *obj,
-        dpiError *error)
-{
-    dpiData *data;
-
-    // validate the object
-    if (dpiGen__checkHandle(obj, DPI_HTYPE_OBJECT, "check obj", error) < 0)
-        return DPI_FAILURE;
-    if (obj->type->tdo != var->objectType->tdo)
-        return dpiError__set(error, "check type", DPI_ERR_WRONG_TYPE,
-                obj->type->schemaLength, obj->type->schema,
-                obj->type->nameLength, obj->type->name,
-                var->objectType->schemaLength, var->objectType->schema,
-                var->objectType->nameLength, var->objectType->name);
-
-    // mark the value as not null
-    data = &var->buffer.externalData[pos];
-    data->isNull = 0;
-
-    // if values are the same, nothing to do
-    if (var->buffer.references[pos].asObject == obj)
-        return DPI_SUCCESS;
-
-    // clear original value, if needed
-    if (var->buffer.references[pos].asObject) {
-        dpiGen__setRefCount(var->buffer.references[pos].asObject, error, -1);
-        var->buffer.references[pos].asObject = NULL;
-    }
-
-    // add reference to passed object
-    dpiGen__setRefCount(obj, error, 1);
-    var->buffer.references[pos].asObject = obj;
-    var->buffer.data.asObject[pos] = obj->instance;
-    var->buffer.objectIndicator[pos] = obj->indicator;
-    data->value.asObject = obj;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__setFromRowid() [PRIVATE]
-//   Set the value of the variable at the given array position from a rowid.
-// A reference to the rowid is retained by the variable.
-//-----------------------------------------------------------------------------
-static int dpiVar__setFromRowid(dpiVar *var, uint32_t pos, dpiRowid *rowid,
-        dpiError *error)
-{
-    dpiData *data;
-
-    // validate the rowid
-    if (dpiGen__checkHandle(rowid, DPI_HTYPE_ROWID, "check rowid", error) < 0)
-        return DPI_FAILURE;
-
-    // mark the value as not null
-    data = &var->buffer.externalData[pos];
-    data->isNull = 0;
-
-    // if values are the same, nothing to do
-    if (var->buffer.references[pos].asRowid == rowid)
-        return DPI_SUCCESS;
-
-    // clear original value, if needed
-    if (var->buffer.references[pos].asRowid) {
-        dpiGen__setRefCount(var->buffer.references[pos].asRowid, error, -1);
-        var->buffer.references[pos].asRowid = NULL;
-    }
-
-    // add reference to passed object
-    dpiGen__setRefCount(rowid, error, 1);
-    var->buffer.references[pos].asRowid = rowid;
-    var->buffer.data.asRowid[pos] = rowid->handle;
-    data->value.asRowid = rowid;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__setFromStmt() [PRIVATE]
-//   Set the value of the variable at the given array position from a
-// statement. A reference to the statement is retained by the variable.
-//-----------------------------------------------------------------------------
-static int dpiVar__setFromStmt(dpiVar *var, uint32_t pos, dpiStmt *stmt,
-        dpiError *error)
-{
-    dpiData *data;
-    uint32_t i;
-
-    // validate the statement
-    if (dpiGen__checkHandle(stmt, DPI_HTYPE_STMT, "check stmt", error) < 0)
-        return DPI_FAILURE;
-
-    // prevent attempts to bind a statement to itself
-    for (i = 0; i < stmt->numBindVars; i++) {
-        if (stmt->bindVars[i].var == var)
-            return dpiError__set(error, "bind to self", DPI_ERR_NOT_SUPPORTED);
-    }
-
-    // mark the value as not null
-    data = &var->buffer.externalData[pos];
-    data->isNull = 0;
-
-    // if values are the same, nothing to do
-    if (var->buffer.references[pos].asStmt == stmt)
-        return DPI_SUCCESS;
-
-    // clear original value, if needed
-    if (var->buffer.references[pos].asStmt) {
-        dpiGen__setRefCount(var->buffer.references[pos].asStmt, error, -1);
-        var->buffer.references[pos].asStmt = NULL;
-    }
-
-    // add reference to passed object
-    dpiGen__setRefCount(stmt, error, 1);
-    var->buffer.references[pos].asStmt = stmt;
-    var->buffer.data.asStmt[pos] = stmt->handle;
-    data->value.asStmt = stmt;
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__setValue() [PRIVATE]
-//   Sets the contents of the variable using the type specified, if possible.
-//-----------------------------------------------------------------------------
-int dpiVar__setValue(dpiVar *var, dpiVarBuffer *buffer, uint32_t pos,
-        dpiData *data, dpiError *error)
-{
-    dpiOracleTypeNum oracleTypeNum;
-    dpiObject *obj;
-
-    // if value is null, no need to proceed further
-    // however, when binding objects a value MUST be present or OCI will
-    // segfault!
-    if (data->isNull) {
-        buffer->indicator[pos] = DPI_OCI_IND_NULL;
-        if (buffer->objectIndicator && !buffer->data.asObject[pos]) {
-            if (dpiObject__allocate(var->objectType, NULL, NULL, NULL, &obj,
-                    error) < 0)
-                return DPI_FAILURE;
-            buffer->references[pos].asObject = obj;
-            data->value.asObject = obj;
-            buffer->data.asObject[pos] = obj->instance;
-            buffer->objectIndicator[pos] = obj->indicator;
-            if (buffer->objectIndicator[pos])
-                *((int16_t*) buffer->objectIndicator[pos]) = DPI_OCI_IND_NULL;
-        }
-        return DPI_SUCCESS;
-    }
-
-    // transform the various types
-    buffer->indicator[pos] = DPI_OCI_IND_NOTNULL;
-    oracleTypeNum = var->type->oracleTypeNum;
-    switch (var->nativeTypeNum) {
-        case DPI_NATIVE_TYPE_INT64:
-        case DPI_NATIVE_TYPE_UINT64:
-            switch (oracleTypeNum) {
-                case DPI_ORACLE_TYPE_NATIVE_INT:
-                    buffer->data.asInt64[pos] = data->value.asInt64;
-                    return DPI_SUCCESS;
-                case DPI_ORACLE_TYPE_NATIVE_UINT:
-                    buffer->data.asUint64[pos] = data->value.asUint64;
-                    return DPI_SUCCESS;
-                case DPI_ORACLE_TYPE_NUMBER:
-                    if (var->nativeTypeNum == DPI_NATIVE_TYPE_INT64)
-                        return dpiDataBuffer__toOracleNumberFromInteger(
-                                &data->value, error,
-                                &buffer->data.asNumber[pos]);
-                    return dpiDataBuffer__toOracleNumberFromUnsignedInteger(
-                            &data->value, error, &buffer->data.asNumber[pos]);
-                default:
-                    break;
-            }
-            break;
-        case DPI_NATIVE_TYPE_FLOAT:
-            buffer->data.asFloat[pos] = data->value.asFloat;
-            return DPI_SUCCESS;
-        case DPI_NATIVE_TYPE_DOUBLE:
-            switch (oracleTypeNum) {
-                case DPI_ORACLE_TYPE_NATIVE_DOUBLE:
-                    buffer->data.asDouble[pos] = data->value.asDouble;
-                    return DPI_SUCCESS;
-                case DPI_ORACLE_TYPE_NUMBER:
-                    return dpiDataBuffer__toOracleNumberFromDouble(
-                            &data->value, error, &buffer->data.asNumber[pos]);
-                case DPI_ORACLE_TYPE_DATE:
-                    return dpiDataBuffer__toOracleDateFromDouble(
-                            &data->value, var->env, error,
-                            &buffer->data.asDate[pos]);
-                case DPI_ORACLE_TYPE_TIMESTAMP:
-                case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
-                case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
-                    return dpiDataBuffer__toOracleTimestampFromDouble(
-                            &data->value, oracleTypeNum, var->env, error,
-                            buffer->data.asTimestamp[pos]);
-                default:
-                    break;
-            }
-            break;
-        case DPI_NATIVE_TYPE_BYTES:
-            if (oracleTypeNum == DPI_ORACLE_TYPE_NUMBER)
-                return dpiDataBuffer__toOracleNumberFromText(&data->value,
-                        var->env, error, &buffer->data.asNumber[pos]);
-            if (buffer->actualLength32)
-                buffer->actualLength32[pos] = data->value.asBytes.length;
-            else if (buffer->actualLength16)
-                buffer->actualLength16[pos] =
-                        (uint16_t) data->value.asBytes.length;
-            if (buffer->returnCode)
-                buffer->returnCode[pos] = 0;
-            break;
-        case DPI_NATIVE_TYPE_TIMESTAMP:
-            if (oracleTypeNum == DPI_ORACLE_TYPE_DATE)
-                return dpiDataBuffer__toOracleDate(&data->value,
-                        &buffer->data.asDate[pos]);
-            else if (oracleTypeNum == DPI_ORACLE_TYPE_TIMESTAMP)
-                return dpiDataBuffer__toOracleTimestamp(&data->value,
-                        var->env, error, buffer->data.asTimestamp[pos], 0);
-            else if (oracleTypeNum == DPI_ORACLE_TYPE_TIMESTAMP_TZ ||
-                    oracleTypeNum == DPI_ORACLE_TYPE_TIMESTAMP_LTZ)
-                return dpiDataBuffer__toOracleTimestamp(&data->value,
-                        var->env, error, buffer->data.asTimestamp[pos], 1);
-            break;
-        case DPI_NATIVE_TYPE_INTERVAL_DS:
-            return dpiDataBuffer__toOracleIntervalDS(&data->value, var->env,
-                    error, buffer->data.asInterval[pos]);
-        case DPI_NATIVE_TYPE_INTERVAL_YM:
-            return dpiDataBuffer__toOracleIntervalYM(&data->value, var->env,
-                    error, buffer->data.asInterval[pos]);
-        case DPI_NATIVE_TYPE_BOOLEAN:
-            buffer->data.asBoolean[pos] = data->value.asBoolean;
-            return DPI_SUCCESS;
-        case DPI_NATIVE_TYPE_STMT:
-            return dpiOci__attrSet(data->value.asStmt->handle,
-                    DPI_OCI_HTYPE_STMT, &data->value.asStmt->prefetchRows,
-                    sizeof(data->value.asStmt->prefetchRows),
-                    DPI_OCI_ATTR_PREFETCH_ROWS,
-                    "set prefetch rows for REF cursor", error);
-        default:
-            break;
-    }
-    return DPI_SUCCESS;
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar__validateTypes() [PRIVATE]
-//   Validate that the Oracle type and the native type are compatible with
-// each other when the native type is not already the default native type.
-//-----------------------------------------------------------------------------
-static int dpiVar__validateTypes(const dpiOracleType *oracleType,
-        dpiNativeTypeNum nativeTypeNum, dpiError *error)
-{
-    switch (oracleType->oracleTypeNum) {
-        case DPI_ORACLE_TYPE_DATE:
-        case DPI_ORACLE_TYPE_TIMESTAMP:
-        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
-        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
-                return DPI_SUCCESS;
-            break;
-        case DPI_ORACLE_TYPE_NUMBER:
-            if (nativeTypeNum == DPI_NATIVE_TYPE_INT64 ||
-                    nativeTypeNum == DPI_NATIVE_TYPE_UINT64 ||
-                    nativeTypeNum == DPI_NATIVE_TYPE_BYTES)
-                return DPI_SUCCESS;
-            break;
-        default:
-            break;
-    }
-    return dpiError__set(error, "validate types", DPI_ERR_UNHANDLED_CONVERSION,
-            oracleType->oracleTypeNum, nativeTypeNum);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar_addRef() [PUBLIC]
-//   Add a reference to the variable.
-//-----------------------------------------------------------------------------
-int dpiVar_addRef(dpiVar *var)
-{
-    return dpiGen__addRef(var, DPI_HTYPE_VAR, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar_copyData() [PUBLIC]
-//   Copy the data from the source variable to the target variable at the given
-// array position. The variables must use the same native type. If the
-// variables contain variable length data, the source length must not exceed
-// the target allocated memory.
-//-----------------------------------------------------------------------------
-int dpiVar_copyData(dpiVar *var, uint32_t pos, dpiVar *sourceVar,
-        uint32_t sourcePos)
-{
-    dpiData *sourceData;
-    dpiError error;
-    int status;
-
-    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    if (dpiGen__checkHandle(sourceVar, DPI_HTYPE_VAR, "check source var",
-            &error) < 0)
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    if (sourcePos >= sourceVar->buffer.maxArraySize) {
-        dpiError__set(&error, "check source size",
-                DPI_ERR_INVALID_ARRAY_POSITION, sourcePos,
-                sourceVar->buffer.maxArraySize);
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    }
-    if (var->nativeTypeNum != sourceVar->nativeTypeNum) {
-        dpiError__set(&error, "check types match", DPI_ERR_NOT_SUPPORTED);
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    }
-    sourceData = &sourceVar->buffer.externalData[sourcePos];
-    status = dpiVar__copyData(var, pos, sourceData, &error);
-    return dpiGen__endPublicFn(var, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar_getNumElementsInArray() [PUBLIC]
-//   Return the actual number of elements in the array. This value is only
-// relevant if the variable is bound as an array.
-//-----------------------------------------------------------------------------
-int dpiVar_getNumElementsInArray(dpiVar *var, uint32_t *numElements)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(var, DPI_HTYPE_VAR, __func__, &error) < 0)
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(var, numElements)
-    if (var->dynBindBuffers)
-        *numElements = var->dynBindBuffers->actualArraySize;
-    else *numElements = var->buffer.actualArraySize;
-    return dpiGen__endPublicFn(var, DPI_SUCCESS, &error);
-}
-
-//-----------------------------------------------------------------------------
-// dpiVar_getReturnedData() [PUBLIC]
-//   Return a pointer to the array of dpiData structures allocated for the
-// given row that have been returned by a DML returning statement. The number
-// of returned rows is also provided. If the bind variable had no data
-// returned, the number of rows returned will be 0 and the pointer to the array
-// of dpiData structures will be NULL. This will also be the case if the
-// variable was only bound IN or was not bound to a DML returning statement.
-// There is no way to differentiate between the two.
-//-----------------------------------------------------------------------------
-int dpiVar_getReturnedData(dpiVar *var, uint32_t pos, uint32_t *numElements,
-        dpiData **data)
-{
-    dpiError error;
-
-    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(var, numElements)
-    DPI_CHECK_PTR_NOT_NULL(var, data)
-    if (var->dynBindBuffers) {
-        *numElements = var->dynBindBuffers[pos].actualArraySize;
-        *data = var->dynBindBuffers[pos].externalData;
-    } else {
-        *numElements = 0;
-        *data = NULL;
-    }
-    return dpiGen__endPublicFn(var, DPI_SUCCESS, &error);
-}
-
-
-
-//-----------------------------------------------------------------------------
-// dpiVar_getSizeInBytes() [PUBLIC]
-//   Returns the size in bytes of the buffer allocated for the variable.
-//-----------------------------------------------------------------------------
-int dpiVar_getSizeInBytes(dpiVar *var, uint32_t *sizeInBytes)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(var, DPI_HTYPE_VAR, __func__, &error) < 0)
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_NOT_NULL(var, sizeInBytes)
-    *sizeInBytes = var->sizeInBytes;
-    return dpiGen__endPublicFn(var, DPI_SUCCESS, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar_release() [PUBLIC]
-//   Release a reference to the variable.
-//-----------------------------------------------------------------------------
-int dpiVar_release(dpiVar *var)
-{
-    return dpiGen__release(var, DPI_HTYPE_VAR, __func__);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar_setFromBytes() [PUBLIC]
-//   Set the value of the variable at the given array position from a byte
-// string. Checks on the array position, the size of the string and the type of
-// variable will be made. The byte string is not retained in any way. A copy
-// will be made into buffers allocated by ODPI-C.
-//-----------------------------------------------------------------------------
-int dpiVar_setFromBytes(dpiVar *var, uint32_t pos, const char *value,
-        uint32_t valueLength)
-{
-    dpiError error;
-    int status;
-
-    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    DPI_CHECK_PTR_AND_LENGTH(var, value)
-    if (var->nativeTypeNum != DPI_NATIVE_TYPE_BYTES &&
-            var->nativeTypeNum != DPI_NATIVE_TYPE_LOB) {
-        dpiError__set(&error, "native type", DPI_ERR_NOT_SUPPORTED);
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    }
-    if (valueLength > DPI_MAX_VAR_BUFFER_SIZE) {
-        dpiError__set(&error, "check buffer", DPI_ERR_BUFFER_SIZE_TOO_LARGE,
-                valueLength, DPI_MAX_VAR_BUFFER_SIZE);
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    }
-    status = dpiVar__setFromBytes(var, pos, value, valueLength, &error);
-    return dpiGen__endPublicFn(var, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar_setFromJson() [PUBLIC]
-//  Set the value of the variable at the given position from a JSON value.
-// Checks on the array position and the validity of the passed value.
-// A reference to the JSON value is retained by the variable.
-//-----------------------------------------------------------------------------
-int dpiVar_setFromJson( dpiVar *var, uint32_t pos, dpiJson *json)
-{
-    dpiError error;
-    int status;
-
-    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    if (var->nativeTypeNum != DPI_NATIVE_TYPE_JSON) {
-        dpiError__set(&error, "native type", DPI_ERR_NOT_SUPPORTED);
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    }
-    status = dpiVar__setFromJson(var, pos, json, &error);
-    return dpiGen__endPublicFn(var, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar_setFromLob() [PUBLIC]
-//   Set the value of the variable at the given array position from a LOB.
-// Checks on the array position and the validity of the passed handle. A
-// reference to the LOB is retained by the variable.
-//-----------------------------------------------------------------------------
-int dpiVar_setFromLob(dpiVar *var, uint32_t pos, dpiLob *lob)
-{
-    dpiError error;
-    int status;
-
-    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    if (var->nativeTypeNum != DPI_NATIVE_TYPE_LOB) {
-        dpiError__set(&error, "native type", DPI_ERR_NOT_SUPPORTED);
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    }
-    status = dpiVar__setFromLob(var, pos, lob, &error);
-    return dpiGen__endPublicFn(var, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar_setFromObject() [PUBLIC]
-//   Set the value of the variable at the given array position from an object.
-// Checks on the array position and the validity of the passed handle. A
-// reference to the object is retained by the variable.
-//-----------------------------------------------------------------------------
-int dpiVar_setFromObject(dpiVar *var, uint32_t pos, dpiObject *obj)
-{
-    dpiError error;
-    int status;
-
-    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    if (var->nativeTypeNum != DPI_NATIVE_TYPE_OBJECT) {
-        dpiError__set(&error, "native type", DPI_ERR_NOT_SUPPORTED);
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    }
-    status = dpiVar__setFromObject(var, pos, obj, &error);
-    return dpiGen__endPublicFn(var, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar_setFromRowid() [PUBLIC]
-//   Set the value of the variable at the given array position from a rowid.
-// Checks on the array position and the validity of the passed handle. A
-// reference to the rowid is retained by the variable.
-//-----------------------------------------------------------------------------
-int dpiVar_setFromRowid(dpiVar *var, uint32_t pos, dpiRowid *rowid)
-{
-    dpiError error;
-    int status;
-
-    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    if (var->nativeTypeNum != DPI_NATIVE_TYPE_ROWID) {
-        dpiError__set(&error, "native type", DPI_ERR_NOT_SUPPORTED);
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    }
-    status = dpiVar__setFromRowid(var, pos, rowid, &error);
-    return dpiGen__endPublicFn(var, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar_setFromStmt() [PUBLIC]
-//   Set the value of the variable at the given array position from a
-// statement. Checks on the array position and the validity of the passed
-// handle. A reference to the statement is retained by the variable.
-//-----------------------------------------------------------------------------
-int dpiVar_setFromStmt(dpiVar *var, uint32_t pos, dpiStmt *stmt)
-{
-    dpiError error;
-    int status;
-
-    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    if (var->nativeTypeNum != DPI_NATIVE_TYPE_STMT) {
-        dpiError__set(&error, "native type", DPI_ERR_NOT_SUPPORTED);
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    }
-    status = dpiVar__setFromStmt(var, pos, stmt, &error);
-    return dpiGen__endPublicFn(var, status, &error);
-}
-
-
-//-----------------------------------------------------------------------------
-// dpiVar_setNumElementsInArray() [PUBLIC]
-//   Set the number of elements in the array (different from the number of
-// allocated elements).
-//-----------------------------------------------------------------------------
-int dpiVar_setNumElementsInArray(dpiVar *var, uint32_t numElements)
-{
-    dpiError error;
-
-    if (dpiGen__startPublicFn(var, DPI_HTYPE_VAR, __func__, &error) < 0)
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    if (numElements > var->buffer.maxArraySize) {
-        dpiError__set(&error, "check num elements",
-                DPI_ERR_ARRAY_SIZE_TOO_SMALL, var->buffer.maxArraySize);
-        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
-    }
-    var->buffer.actualArraySize = numElements;
-    return dpiGen__endPublicFn(var, DPI_SUCCESS, &error);
-}
diff -ruN -x .git/* patched-godror/odpi/src/dpiVar.h ./odpi/src/dpiVar.h
--- patched-godror/odpi/src/dpiVar.h	1970-01-01 01:00:00
+++ ./odpi/src/dpiVar.h	2024-05-14 14:55:13
@@ -0,0 +1,1921 @@
+//-----------------------------------------------------------------------------
+// Copyright (c) 2016, 2022, Oracle and/or its affiliates.
+//
+// This software is dual-licensed to you under the Universal Permissive License
+// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License
+// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose
+// either license.
+//
+// If you elect to accept the software under the Apache License, Version 2.0,
+// the following applies:
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    https://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//-----------------------------------------------------------------------------
+
+//-----------------------------------------------------------------------------
+// dpiVar.c
+//   Implementation of variables.
+//-----------------------------------------------------------------------------
+
+#include "dpiImpl.h"
+
+// forward declarations of internal functions only used in this file
+static int dpiVar__initBuffer(dpiVar *var, dpiVarBuffer *buffer,
+        dpiError *error);
+static int dpiVar__setBytesFromDynamicBytes(dpiBytes *bytes,
+        dpiDynamicBytes *dynBytes, dpiError *error);
+static int dpiVar__setBytesFromLob(dpiBytes *bytes, dpiDynamicBytes *dynBytes,
+        dpiLob *lob, dpiError *error);
+static int dpiVar__setFromBytes(dpiVar *var, uint32_t pos, const char *value,
+        uint32_t valueLength, dpiError *error);
+static int dpiVar__setFromJson(dpiVar *var, uint32_t pos, dpiJson *json,
+        dpiError *error);
+static int dpiVar__setFromLob(dpiVar *var, uint32_t pos, dpiLob *lob,
+        dpiError *error);
+static int dpiVar__setFromObject(dpiVar *var, uint32_t pos, dpiObject *obj,
+        dpiError *error);
+static int dpiVar__setFromRowid(dpiVar *var, uint32_t pos, dpiRowid *rowid,
+        dpiError *error);
+static int dpiVar__setFromStmt(dpiVar *var, uint32_t pos, dpiStmt *stmt,
+        dpiError *error);
+static int dpiVar__validateTypes(const dpiOracleType *oracleType,
+        dpiNativeTypeNum nativeTypeNum, dpiError *error);
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__allocate() [INTERNAL]
+//   Create a new variable object and return it. In case of error NULL is
+// returned.
+//-----------------------------------------------------------------------------
+int dpiVar__allocate(dpiConn *conn, dpiOracleTypeNum oracleTypeNum,
+        dpiNativeTypeNum nativeTypeNum, uint32_t maxArraySize, uint32_t size,
+        int sizeIsBytes, int isArray, dpiObjectType *objType, dpiVar **var,
+        dpiData **data, dpiError *error)
+{
+    const dpiOracleType *type;
+    uint32_t sizeInBytes;
+    dpiVar *tempVar;
+
+    // validate arguments
+    *var = NULL;
+    type = dpiOracleType__getFromNum(oracleTypeNum, error);
+    if (!type)
+        return DPI_FAILURE;
+    if (maxArraySize == 0)
+        return dpiError__set(error, "check max array size",
+                DPI_ERR_ARRAY_SIZE_ZERO);
+    if (isArray && !type->canBeInArray)
+        return dpiError__set(error, "check can be in array",
+                DPI_ERR_NOT_SUPPORTED);
+    if (oracleTypeNum == DPI_ORACLE_TYPE_BOOLEAN &&
+            dpiUtils__checkClientVersion(conn->env->versionInfo, 12, 1,
+                    error) < 0)
+        return DPI_FAILURE;
+    if (nativeTypeNum != type->defaultNativeTypeNum) {
+        if (dpiVar__validateTypes(type, nativeTypeNum, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // calculate size in bytes
+    if (size == 0)
+        size = 1;
+    if (type->sizeInBytes)
+        sizeInBytes = type->sizeInBytes;
+    else if (sizeIsBytes || !type->isCharacterData)
+        sizeInBytes = size;
+    else if (type->charsetForm == DPI_SQLCS_IMPLICIT)
+        sizeInBytes = size * conn->env->maxBytesPerCharacter;
+    else sizeInBytes = size * conn->env->nmaxBytesPerCharacter;
+
+    // allocate memory for variable type
+    if (dpiGen__allocate(DPI_HTYPE_VAR, conn->env, (void**) &tempVar,
+            error) < 0)
+        return DPI_FAILURE;
+
+    // basic initialization
+    tempVar->buffer.maxArraySize = maxArraySize;
+    if (!isArray)
+        tempVar->buffer.actualArraySize = maxArraySize;
+    tempVar->sizeInBytes = sizeInBytes;
+    if (sizeInBytes > DPI_MAX_BASIC_BUFFER_SIZE) {
+        tempVar->sizeInBytes = 0;
+        tempVar->isDynamic = 1;
+        tempVar->requiresPreFetch = 1;
+    }
+    tempVar->type = type;
+    tempVar->nativeTypeNum = nativeTypeNum;
+    tempVar->isArray = isArray;
+    dpiGen__setRefCount(conn, error, 1);
+    tempVar->conn = conn;
+    if (objType) {
+        if (dpiGen__checkHandle(objType, DPI_HTYPE_OBJECT_TYPE,
+                "check object type", error) < 0) {
+            dpiVar__free(tempVar, error);
+            return DPI_FAILURE;
+        }
+        dpiGen__setRefCount(objType, error, 1);
+        tempVar->objectType = objType;
+    }
+
+    // allocate the data for the variable
+    if (dpiVar__initBuffer(tempVar, &tempVar->buffer, error) < 0) {
+        dpiVar__free(tempVar, error);
+        return DPI_FAILURE;
+    }
+
+    *var = tempVar;
+    *data = tempVar->buffer.externalData;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__allocateChunks() [INTERNAL]
+//   Allocate more chunks for handling dynamic bytes.
+//-----------------------------------------------------------------------------
+static int dpiVar__allocateChunks(dpiDynamicBytes *dynBytes, dpiError *error)
+{
+    dpiDynamicBytesChunk *chunks;
+    uint32_t allocatedChunks;
+
+    allocatedChunks = dynBytes->allocatedChunks + 8;
+    if (dpiUtils__allocateMemory(allocatedChunks, sizeof(dpiDynamicBytesChunk),
+            1, "allocate chunks", (void**) &chunks, error) < 0)
+        return DPI_FAILURE;
+    if (dynBytes->chunks) {
+        memcpy(chunks, dynBytes->chunks,
+                dynBytes->numChunks * sizeof(dpiDynamicBytesChunk));
+        dpiUtils__freeMemory(dynBytes->chunks);
+    }
+    dynBytes->chunks = chunks;
+    dynBytes->allocatedChunks = allocatedChunks;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__allocateDynamicBytes() [INTERNAL]
+//   Allocate space in the dynamic bytes structure for the specified number of
+// bytes. When complete, there will be exactly one allocated chunk of the
+// specified size or greater in the dynamic bytes structure.
+//-----------------------------------------------------------------------------
+static int dpiVar__allocateDynamicBytes(dpiDynamicBytes *dynBytes,
+        uint32_t size, dpiError *error)
+{
+    // if an error occurs, none of the original space is valid
+    dynBytes->numChunks = 0;
+
+    // if there are no chunks at all, make sure some exist
+    if (dynBytes->allocatedChunks == 0 &&
+            dpiVar__allocateChunks(dynBytes, error) < 0)
+        return DPI_FAILURE;
+
+    // at this point there should be 0 or 1 chunks as any retrieval that
+    // resulted in multiple chunks would have been consolidated already
+    // make sure that chunk has enough space in it
+    if (size > dynBytes->chunks->allocatedLength) {
+        if (dynBytes->chunks->ptr)
+            dpiUtils__freeMemory(dynBytes->chunks->ptr);
+        dynBytes->chunks->allocatedLength =
+                (size + DPI_DYNAMIC_BYTES_CHUNK_SIZE - 1) &
+                        ~(DPI_DYNAMIC_BYTES_CHUNK_SIZE - 1);
+        if (dpiUtils__allocateMemory(1, dynBytes->chunks->allocatedLength, 0,
+                "allocate chunk", (void**) &dynBytes->chunks->ptr, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__assignCallbackBuffer() [INTERNAL]
+//   Assign callback pointers during OCI statement execution. This is used with
+// the callack functions used for dynamic binding during DML returning
+// statement execution.
+//-----------------------------------------------------------------------------
+static void dpiVar__assignCallbackBuffer(dpiVar *var, dpiVarBuffer *buffer,
+        uint32_t index, void **bufpp)
+{
+    switch (var->type->oracleTypeNum) {
+        case DPI_ORACLE_TYPE_TIMESTAMP:
+        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
+        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
+            *bufpp = buffer->data.asTimestamp[index];
+            break;
+        case DPI_ORACLE_TYPE_INTERVAL_DS:
+        case DPI_ORACLE_TYPE_INTERVAL_YM:
+            *bufpp = buffer->data.asInterval[index];
+            break;
+        case DPI_ORACLE_TYPE_CLOB:
+        case DPI_ORACLE_TYPE_BLOB:
+        case DPI_ORACLE_TYPE_NCLOB:
+        case DPI_ORACLE_TYPE_BFILE:
+            *bufpp = buffer->data.asLobLocator[index];
+            break;
+        case DPI_ORACLE_TYPE_ROWID:
+            *bufpp = buffer->data.asRowid[index];
+            break;
+        case DPI_ORACLE_TYPE_JSON:
+            *bufpp = buffer->data.asJsonDescriptor[index];
+            break;
+        case DPI_ORACLE_TYPE_STMT:
+            *bufpp = buffer->data.asStmt[index];
+            break;
+        default:
+            *bufpp = buffer->data.asBytes + index * var->sizeInBytes;
+            break;
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__checkArraySize() [INTERNAL]
+//   Verifies that the array size has not been exceeded.
+//-----------------------------------------------------------------------------
+static int dpiVar__checkArraySize(dpiVar *var, uint32_t pos,
+        const char *fnName, dpiError *error)
+{
+    if (dpiGen__startPublicFn(var, DPI_HTYPE_VAR, fnName, error) < 0)
+        return DPI_FAILURE;
+    if (pos >= var->buffer.maxArraySize)
+        return dpiError__set(error, "check array size",
+                DPI_ERR_INVALID_ARRAY_POSITION, pos,
+                var->buffer.maxArraySize);
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__convertToLob() [INTERNAL]
+//   Convert the variable from using dynamic bytes for a long string to using a
+// LOB instead. This is needed for PL/SQL which cannot handle more than 32K
+// without the use of a LOB.
+//-----------------------------------------------------------------------------
+int dpiVar__convertToLob(dpiVar *var, dpiError *error)
+{
+    dpiDynamicBytes *dynBytes;
+    dpiLob *lob;
+    uint32_t i;
+
+    // change type based on the original Oracle type
+    if (var->type->oracleTypeNum == DPI_ORACLE_TYPE_RAW ||
+            var->type->oracleTypeNum == DPI_ORACLE_TYPE_LONG_RAW)
+        var->type = dpiOracleType__getFromNum(DPI_ORACLE_TYPE_BLOB, error);
+    else if (var->type->oracleTypeNum == DPI_ORACLE_TYPE_NCHAR)
+        var->type = dpiOracleType__getFromNum(DPI_ORACLE_TYPE_NCLOB,
+                error);
+    else var->type = dpiOracleType__getFromNum(DPI_ORACLE_TYPE_CLOB,
+            error);
+
+    // adjust attributes and re-initialize buffers
+    // the dynamic bytes structures will not be removed
+    var->sizeInBytes = var->type->sizeInBytes;
+    var->isDynamic = 0;
+    if (dpiVar__initBuffer(var, &var->buffer, error) < 0)
+        return DPI_FAILURE;
+
+    // copy any values already set
+    for (i = 0; i < var->buffer.maxArraySize; i++) {
+        dynBytes = &var->buffer.dynamicBytes[i];
+        lob = var->buffer.references[i].asLOB;
+        if (dynBytes->numChunks == 0)
+            continue;
+        if (dpiLob__setFromBytes(lob, dynBytes->chunks->ptr,
+                dynBytes->chunks->length, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__copyData() [INTERNAL]
+//   Copy the data from the source to the target variable at the given array
+// position.
+//-----------------------------------------------------------------------------
+int dpiVar__copyData(dpiVar *var, uint32_t pos, dpiData *sourceData,
+        dpiError *error)
+{
+    dpiData *targetData = &var->buffer.externalData[pos];
+
+    // handle null case
+    targetData->isNull = sourceData->isNull;
+    if (sourceData->isNull)
+        return DPI_SUCCESS;
+
+    // handle copying of value from source to target
+    switch (var->nativeTypeNum) {
+        case DPI_NATIVE_TYPE_BYTES:
+            return dpiVar__setFromBytes(var, pos,
+                    sourceData->value.asBytes.ptr,
+                    sourceData->value.asBytes.length, error);
+        case DPI_NATIVE_TYPE_JSON:
+            return dpiVar__setFromJson(var, pos, sourceData->value.asJson,
+                    error);
+        case DPI_NATIVE_TYPE_LOB:
+            return dpiVar__setFromLob(var, pos, sourceData->value.asLOB,
+                    error);
+        case DPI_NATIVE_TYPE_OBJECT:
+            return dpiVar__setFromObject(var, pos, sourceData->value.asObject,
+                    error);
+        case DPI_NATIVE_TYPE_STMT:
+            return dpiVar__setFromStmt(var, pos, sourceData->value.asStmt,
+                    error);
+        case DPI_NATIVE_TYPE_ROWID:
+            return dpiVar__setFromRowid(var, pos, sourceData->value.asRowid,
+                    error);
+        default:
+            memcpy(targetData, sourceData, sizeof(dpiData));
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__defineCallback() [INTERNAL]
+//   Callback which runs during OCI statement execution and allocates the
+// buffers required as well as provides that information to the OCI. This is
+// intended for handling string and raw columns for which the size is unknown.
+// These include LONG, LONG RAW and retrieving CLOB and BLOB as bytes, rather
+// than use the LOB API.
+//-----------------------------------------------------------------------------
+int32_t dpiVar__defineCallback(dpiVar *var, UNUSED void *defnp, uint32_t iter,
+        void **bufpp, uint32_t **alenpp, UNUSED uint8_t *piecep, void **indpp,
+        uint16_t **rcodepp)
+{
+    dpiDynamicBytesChunk *chunk;
+    dpiDynamicBytes *bytes;
+
+    // allocate more chunks, if necessary
+    bytes = &var->buffer.dynamicBytes[iter];
+    if (bytes->numChunks == bytes->allocatedChunks &&
+            dpiVar__allocateChunks(bytes, var->error) < 0)
+        return DPI_OCI_ERROR;
+
+    // allocate memory for the chunk, if needed
+    chunk = &bytes->chunks[bytes->numChunks];
+    if (!chunk->ptr) {
+        chunk->allocatedLength = DPI_DYNAMIC_BYTES_CHUNK_SIZE;
+        if (dpiUtils__allocateMemory(1, chunk->allocatedLength, 0,
+                "allocate chunk", (void**) &chunk->ptr, var->error) < 0)
+            return DPI_OCI_ERROR;
+    }
+
+    // return chunk to OCI
+    bytes->numChunks++;
+    chunk->length = chunk->allocatedLength;
+    *bufpp = chunk->ptr;
+    *alenpp = &chunk->length;
+    *indpp = &(var->buffer.indicator[iter]);
+    *rcodepp = NULL;
+    return DPI_OCI_CONTINUE;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__extendedPreFetch() [INTERNAL]
+//   Perform any necessary actions prior to fetching data.
+//-----------------------------------------------------------------------------
+int dpiVar__extendedPreFetch(dpiVar *var, dpiVarBuffer *buffer,
+        dpiError *error)
+{
+    dpiRowid *rowid;
+    dpiData *data;
+    dpiStmt *stmt;
+    dpiJson *json;
+    dpiLob *lob;
+    uint32_t i;
+
+    if (var->isDynamic) {
+        for (i = 0; i < buffer->maxArraySize; i++)
+            buffer->dynamicBytes[i].numChunks = 0;
+        return DPI_SUCCESS;
+    }
+
+    switch (var->type->oracleTypeNum) {
+        case DPI_ORACLE_TYPE_STMT:
+            for (i = 0; i < buffer->maxArraySize; i++) {
+                data = &buffer->externalData[i];
+                if (buffer->references[i].asStmt) {
+                    dpiGen__setRefCount(buffer->references[i].asStmt,
+                            error, -1);
+                    buffer->references[i].asStmt = NULL;
+                }
+                buffer->data.asStmt[i] = NULL;
+                data->value.asStmt = NULL;
+                if (dpiStmt__allocate(var->conn, 0, &stmt, error) < 0)
+                    return DPI_FAILURE;
+                if (dpiOci__handleAlloc(var->env->handle, &stmt->handle,
+                        DPI_OCI_HTYPE_STMT, "allocate statement", error) < 0) {
+                    dpiStmt__free(stmt, error);
+                    return DPI_FAILURE;
+                }
+                if (dpiHandleList__addHandle(var->conn->openStmts, stmt,
+                        &stmt->openSlotNum, error) < 0) {
+                    dpiOci__handleFree(stmt->handle, DPI_OCI_HTYPE_STMT);
+                    stmt->handle = NULL;
+                    dpiStmt__free(stmt, error);
+                    return DPI_FAILURE;
+                }
+                buffer->references[i].asStmt = stmt;
+                stmt->isOwned = 1;
+                buffer->data.asStmt[i] = stmt->handle;
+                data->value.asStmt = stmt;
+            }
+            break;
+        case DPI_ORACLE_TYPE_CLOB:
+        case DPI_ORACLE_TYPE_BLOB:
+        case DPI_ORACLE_TYPE_NCLOB:
+        case DPI_ORACLE_TYPE_BFILE:
+            for (i = 0; i < buffer->maxArraySize; i++) {
+                data = &buffer->externalData[i];
+                if (buffer->references[i].asLOB) {
+                    dpiGen__setRefCount(buffer->references[i].asLOB,
+                            error, -1);
+                    buffer->references[i].asLOB = NULL;
+                }
+                buffer->data.asLobLocator[i] = NULL;
+                data->value.asLOB = NULL;
+                if (dpiLob__allocate(var->conn, var->type, &lob, error) < 0)
+                    return DPI_FAILURE;
+                buffer->references[i].asLOB = lob;
+                buffer->data.asLobLocator[i] = lob->locator;
+                data->value.asLOB = lob;
+                if (buffer->dynamicBytes &&
+                        dpiOci__lobCreateTemporary(lob, error) < 0)
+                    return DPI_FAILURE;
+            }
+            break;
+        case DPI_ORACLE_TYPE_ROWID:
+            for (i = 0; i < buffer->maxArraySize; i++) {
+                data = &buffer->externalData[i];
+                if (buffer->references[i].asRowid) {
+                    dpiGen__setRefCount(buffer->references[i].asRowid,
+                            error, -1);
+                    buffer->references[i].asRowid = NULL;
+                }
+                buffer->data.asRowid[i] = NULL;
+                data->value.asRowid = NULL;
+                if (dpiRowid__allocate(var->conn, &rowid, error) < 0)
+                    return DPI_FAILURE;
+                buffer->references[i].asRowid = rowid;
+                buffer->data.asRowid[i] = rowid->handle;
+                data->value.asRowid = rowid;
+            }
+            break;
+        case DPI_ORACLE_TYPE_OBJECT:
+            for (i = 0; i < buffer->maxArraySize; i++) {
+                data = &buffer->externalData[i];
+                if (buffer->references[i].asObject) {
+                    dpiGen__setRefCount(buffer->references[i].asObject,
+                            error, -1);
+                    buffer->references[i].asObject = NULL;
+                }
+                buffer->data.asObject[i] = NULL;
+                buffer->objectIndicator[i] = NULL;
+                data->value.asObject = NULL;
+            }
+            break;
+        case DPI_ORACLE_TYPE_JSON:
+            for (i = 0; i < buffer->maxArraySize; i++) {
+                data = &buffer->externalData[i];
+                if (buffer->references[i].asJson) {
+                    dpiGen__setRefCount(buffer->references[i].asJson,
+                            error, -1);
+                    buffer->references[i].asJson = NULL;
+                }
+                buffer->data.asJsonDescriptor[i] = NULL;
+                data->value.asJson = NULL;
+                if (dpiJson__allocate(var->conn, &json, error) < 0)
+                    return DPI_FAILURE;
+                buffer->references[i].asJson = json;
+                buffer->data.asJsonDescriptor[i] = json->handle;
+                data->value.asJson = json;
+            }
+            break;
+        default:
+            break;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__finalizeBuffer() [INTERNAL]
+//   Finalize buffer used for passing data to/from Oracle.
+//-----------------------------------------------------------------------------
+static void dpiVar__finalizeBuffer(dpiVar *var, dpiVarBuffer *buffer,
+        dpiError *error)
+{
+    dpiDynamicBytes *dynBytes;
+    uint32_t i, j;
+
+    // free any descriptors that were created
+    switch (var->type->oracleTypeNum) {
+        case DPI_ORACLE_TYPE_TIMESTAMP:
+            dpiOci__arrayDescriptorFree(&buffer->data.asTimestamp[0],
+                    DPI_OCI_DTYPE_TIMESTAMP);
+            break;
+        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
+            dpiOci__arrayDescriptorFree(&buffer->data.asTimestamp[0],
+                    DPI_OCI_DTYPE_TIMESTAMP_TZ);
+            break;
+        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
+            dpiOci__arrayDescriptorFree(&buffer->data.asTimestamp[0],
+                    DPI_OCI_DTYPE_TIMESTAMP_LTZ);
+            break;
+        case DPI_ORACLE_TYPE_INTERVAL_DS:
+            dpiOci__arrayDescriptorFree(&buffer->data.asInterval[0],
+                    DPI_OCI_DTYPE_INTERVAL_DS);
+            break;
+        case DPI_ORACLE_TYPE_INTERVAL_YM:
+            dpiOci__arrayDescriptorFree(&buffer->data.asInterval[0],
+                    DPI_OCI_DTYPE_INTERVAL_YM);
+            break;
+        default:
+            break;
+    }
+
+    // release any references that were created
+    if (buffer->references) {
+        for (i = 0; i < buffer->maxArraySize; i++) {
+            if (buffer->references[i].asHandle) {
+                dpiGen__setRefCount(buffer->references[i].asHandle, error, -1);
+                buffer->references[i].asHandle = NULL;
+            }
+        }
+        dpiUtils__freeMemory(buffer->references);
+        buffer->references = NULL;
+    }
+
+    // free any dynamic buffers
+    if (buffer->dynamicBytes) {
+        for (i = 0; i < buffer->maxArraySize; i++) {
+            dynBytes = &buffer->dynamicBytes[i];
+            if (dynBytes->allocatedChunks > 0) {
+                for (j = 0; j < dynBytes->allocatedChunks; j++) {
+                    if (dynBytes->chunks[j].ptr) {
+                        dpiUtils__freeMemory(dynBytes->chunks[j].ptr);
+                        dynBytes->chunks[j].ptr = NULL;
+                    }
+                }
+                dpiUtils__freeMemory(dynBytes->chunks);
+                dynBytes->allocatedChunks = 0;
+                dynBytes->chunks = NULL;
+            }
+        }
+        dpiUtils__freeMemory(buffer->dynamicBytes);
+        buffer->dynamicBytes = NULL;
+    }
+
+    // free other memory allocated
+    if (buffer->indicator) {
+        dpiUtils__freeMemory(buffer->indicator);
+        buffer->indicator = NULL;
+    }
+    if (buffer->returnCode) {
+        dpiUtils__freeMemory(buffer->returnCode);
+        buffer->returnCode = NULL;
+    }
+    if (buffer->actualLength16) {
+        dpiUtils__freeMemory(buffer->actualLength16);
+        buffer->actualLength16 = NULL;
+    }
+    if (buffer->actualLength32) {
+        dpiUtils__freeMemory(buffer->actualLength32);
+        buffer->actualLength32 = NULL;
+    }
+    if (buffer->externalData) {
+        dpiUtils__freeMemory(buffer->externalData);
+        buffer->externalData = NULL;
+    }
+    if (buffer->data.asRaw) {
+        dpiUtils__freeMemory(buffer->data.asRaw);
+        buffer->data.asRaw = NULL;
+    }
+    if (buffer->objectIndicator) {
+        dpiUtils__freeMemory(buffer->objectIndicator);
+        buffer->objectIndicator = NULL;
+    }
+    if (buffer->tempBuffer) {
+        dpiUtils__freeMemory(buffer->tempBuffer);
+        buffer->tempBuffer = NULL;
+    }
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__free() [INTERNAL]
+//   Free the memory associated with the variable.
+//-----------------------------------------------------------------------------
+void dpiVar__free(dpiVar *var, dpiError *error)
+{
+    uint32_t i;
+
+    dpiVar__finalizeBuffer(var, &var->buffer, error);
+    if (var->dynBindBuffers) {
+        for (i = 0; i < var->buffer.maxArraySize; i++)
+            dpiVar__finalizeBuffer(var, &var->dynBindBuffers[i], error);
+        dpiUtils__freeMemory(var->dynBindBuffers);
+        var->dynBindBuffers = NULL;
+    }
+    if (var->objectType) {
+        dpiGen__setRefCount(var->objectType, error, -1);
+        var->objectType = NULL;
+    }
+    if (var->conn) {
+        dpiGen__setRefCount(var->conn, error, -1);
+        var->conn = NULL;
+    }
+    dpiUtils__freeMemory(var);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__getValue() [PRIVATE]
+//   Returns the contents of the variable in the type specified, if possible.
+//-----------------------------------------------------------------------------
+int dpiVar__getValue(dpiVar *var, dpiVarBuffer *buffer, uint32_t pos,
+        int inFetch, dpiError *error)
+{
+    dpiOracleTypeNum oracleTypeNum;
+    dpiBytes *bytes;
+    dpiData *data;
+    uint32_t i;
+
+    // check for dynamic binds first; if they exist, process them instead
+    if (var->dynBindBuffers && buffer == &var->buffer) {
+        buffer = &var->dynBindBuffers[pos];
+        for (i = 0; i < buffer->maxArraySize; i++) {
+            if (dpiVar__getValue(var, buffer, i, inFetch, error) < 0)
+                return DPI_FAILURE;
+        }
+        return DPI_SUCCESS;
+    }
+
+    // check for a NULL value; for objects the indicator is elsewhere
+    data = &buffer->externalData[pos];
+    if (!buffer->objectIndicator)
+        data->isNull = (buffer->indicator[pos] == DPI_OCI_IND_NULL);
+    else if (buffer->objectIndicator[pos])
+        data->isNull = (*((int16_t*) buffer->objectIndicator[pos]) ==
+                DPI_OCI_IND_NULL);
+    else data->isNull = 1;
+    if (data->isNull) {
+        if (inFetch && var->objectType && var->objectType->isCollection) {
+            if (dpiOci__objectFree(var->env->handle,
+                    buffer->data.asObject[pos], 1, error) < 0)
+                return DPI_FAILURE;
+            if (dpiOci__objectFree(var->env->handle,
+                    buffer->objectIndicator[pos], 1, error) < 0)
+                return DPI_FAILURE;
+        }
+        return DPI_SUCCESS;
+    }
+
+    // check return code for variable length data
+    if (buffer->returnCode) {
+        if (buffer->returnCode[pos] != 0) {
+            dpiError__set(error, "check return code", DPI_ERR_COLUMN_FETCH,
+                    pos, buffer->returnCode[pos]);
+            error->buffer->code = buffer->returnCode[pos];
+            return DPI_FAILURE;
+        }
+    }
+
+    // for 11g, dynamic lengths are 32-bit whereas static lengths are 16-bit
+    if (buffer->actualLength16 && buffer->actualLength32)
+        buffer->actualLength16[pos] = (uint16_t) buffer->actualLength32[pos];
+
+    // transform the various types
+    oracleTypeNum = var->type->oracleTypeNum;
+    switch (var->nativeTypeNum) {
+        case DPI_NATIVE_TYPE_INT64:
+        case DPI_NATIVE_TYPE_UINT64:
+            switch (oracleTypeNum) {
+                case DPI_ORACLE_TYPE_NATIVE_INT:
+                    data->value.asInt64 = buffer->data.asInt64[pos];
+                    return DPI_SUCCESS;
+                case DPI_ORACLE_TYPE_NATIVE_UINT:
+                    data->value.asUint64 = buffer->data.asUint64[pos];
+                    return DPI_SUCCESS;
+                case DPI_ORACLE_TYPE_NUMBER:
+                    if (var->nativeTypeNum == DPI_NATIVE_TYPE_INT64)
+                        return dpiDataBuffer__fromOracleNumberAsInteger(
+                                &data->value, error,
+                                &buffer->data.asNumber[pos]);
+                    return dpiDataBuffer__fromOracleNumberAsUnsignedInteger(
+                            &data->value, error, &buffer->data.asNumber[pos]);
+                default:
+                    break;
+            }
+            break;
+        case DPI_NATIVE_TYPE_DOUBLE:
+            switch (oracleTypeNum) {
+                case DPI_ORACLE_TYPE_NUMBER:
+                    return dpiDataBuffer__fromOracleNumberAsDouble(
+                            &data->value, error, &buffer->data.asNumber[pos]);
+                case DPI_ORACLE_TYPE_NATIVE_DOUBLE:
+                    data->value.asDouble = buffer->data.asDouble[pos];
+                    return DPI_SUCCESS;
+                case DPI_ORACLE_TYPE_DATE:
+                    return dpiDataBuffer__fromOracleDateAsDouble(&data->value,
+                            var->env, error, &buffer->data.asDate[pos]);
+                case DPI_ORACLE_TYPE_TIMESTAMP:
+                case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
+                case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
+                    return dpiDataBuffer__fromOracleTimestampAsDouble(
+                            &data->value, oracleTypeNum, var->env, error,
+                            buffer->data.asTimestamp[pos]);
+                default:
+                    break;
+            }
+            break;
+        case DPI_NATIVE_TYPE_BYTES:
+            bytes = &data->value.asBytes;
+            switch (oracleTypeNum) {
+                case DPI_ORACLE_TYPE_VARCHAR:
+                case DPI_ORACLE_TYPE_NVARCHAR:
+                case DPI_ORACLE_TYPE_CHAR:
+                case DPI_ORACLE_TYPE_NCHAR:
+                case DPI_ORACLE_TYPE_ROWID:
+                case DPI_ORACLE_TYPE_RAW:
+                case DPI_ORACLE_TYPE_LONG_VARCHAR:
+                case DPI_ORACLE_TYPE_LONG_NVARCHAR:
+                case DPI_ORACLE_TYPE_LONG_RAW:
+                    if (buffer->dynamicBytes)
+                        return dpiVar__setBytesFromDynamicBytes(bytes,
+                                &buffer->dynamicBytes[pos], error);
+                    if (buffer->actualLength16)
+                        bytes->length = buffer->actualLength16[pos];
+                    else bytes->length = buffer->actualLength32[pos];
+                    return DPI_SUCCESS;
+                case DPI_ORACLE_TYPE_CLOB:
+                case DPI_ORACLE_TYPE_NCLOB:
+                case DPI_ORACLE_TYPE_BLOB:
+                case DPI_ORACLE_TYPE_BFILE:
+                    return dpiVar__setBytesFromLob(bytes,
+                            &buffer->dynamicBytes[pos],
+                            buffer->references[pos].asLOB, error);
+                case DPI_ORACLE_TYPE_NUMBER:
+                    bytes->length = DPI_NUMBER_AS_TEXT_CHARS;
+                    if (var->env->charsetId == DPI_CHARSET_ID_UTF16)
+                        bytes->length *= 2;
+                    return dpiDataBuffer__fromOracleNumberAsText(&data->value,
+                            var->env, error, &buffer->data.asNumber[pos]);
+                default:
+                    break;
+            }
+            break;
+        case DPI_NATIVE_TYPE_FLOAT:
+            data->value.asFloat = buffer->data.asFloat[pos];
+            break;
+        case DPI_NATIVE_TYPE_TIMESTAMP:
+            if (oracleTypeNum == DPI_ORACLE_TYPE_DATE)
+                return dpiDataBuffer__fromOracleDate(&data->value,
+                        &buffer->data.asDate[pos]);
+            return dpiDataBuffer__fromOracleTimestamp(&data->value, var->env,
+                    error, buffer->data.asTimestamp[pos],
+                    oracleTypeNum != DPI_ORACLE_TYPE_TIMESTAMP);
+            break;
+        case DPI_NATIVE_TYPE_INTERVAL_DS:
+            return dpiDataBuffer__fromOracleIntervalDS(&data->value, var->env,
+                    error, buffer->data.asInterval[pos]);
+        case DPI_NATIVE_TYPE_INTERVAL_YM:
+            return dpiDataBuffer__fromOracleIntervalYM(&data->value, var->env,
+                    error, buffer->data.asInterval[pos]);
+        case DPI_NATIVE_TYPE_OBJECT:
+            data->value.asObject = NULL;
+            if (!buffer->references[pos].asObject) {
+                if (dpiObject__allocate(var->objectType,
+                        buffer->data.asObject[pos],
+                        buffer->objectIndicator[pos], NULL,
+                        &buffer->references[pos].asObject, error) < 0)
+                    return DPI_FAILURE;
+                if (inFetch && var->objectType->isCollection)
+                    buffer->references[pos].asObject->freeIndicator = 1;
+            }
+            data->value.asObject = buffer->references[pos].asObject;
+            break;
+        case DPI_NATIVE_TYPE_STMT:
+            data->value.asStmt = buffer->references[pos].asStmt;
+            break;
+        case DPI_NATIVE_TYPE_BOOLEAN:
+            data->value.asBoolean = buffer->data.asBoolean[pos];
+            break;
+        default:
+            break;
+    }
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__inBindCallback() [INTERNAL]
+//   Callback which runs during OCI statement execution and provides buffers to
+// OCI for binding data IN. This is not used with DML returning so this method
+// does nothing useful except satisfy OCI requirements.
+//-----------------------------------------------------------------------------
+int32_t dpiVar__inBindCallback(dpiVar *var, UNUSED void *bindp,
+        UNUSED uint32_t iter, UNUSED uint32_t index, void **bufpp,
+        uint32_t *alenp, uint8_t *piecep, void **indpp)
+{
+    dpiDynamicBytes *dynBytes;
+
+    if (var->isDynamic) {
+        dynBytes = &var->buffer.dynamicBytes[iter];
+        if (dynBytes->allocatedChunks == 0) {
+            *bufpp = NULL;
+            *alenp = 0;
+        } else {
+            *bufpp = dynBytes->chunks->ptr;
+            *alenp = dynBytes->chunks->length;
+        }
+    } else {
+        dpiVar__assignCallbackBuffer(var, &var->buffer, iter, bufpp);
+        if (var->buffer.actualLength16)
+            *alenp = var->buffer.actualLength16[iter];
+        else if (var->buffer.actualLength32)
+            *alenp = var->buffer.actualLength32[iter];
+        else *alenp = var->type->sizeInBytes;
+    }
+    *piecep = DPI_OCI_ONE_PIECE;
+    if (var->buffer.objectIndicator)
+        *indpp = var->buffer.objectIndicator[iter];
+    else *indpp = &var->buffer.indicator[iter];
+    return DPI_OCI_CONTINUE;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__initBuffer() [INTERNAL]
+//   Initialize buffers necessary for passing data to/from Oracle.
+//-----------------------------------------------------------------------------
+static int dpiVar__initBuffer(dpiVar *var, dpiVarBuffer *buffer,
+        dpiError *error)
+{
+    uint32_t i, tempBufferSize = 0;
+    unsigned long long dataLength;
+    dpiBytes *bytes;
+
+    // initialize dynamic buffers for dynamic variables
+    if (var->isDynamic) {
+        if (dpiUtils__allocateMemory(buffer->maxArraySize,
+                sizeof(dpiDynamicBytes), 1, "allocate dynamic bytes",
+                (void**) &buffer->dynamicBytes, error) < 0)
+            return DPI_FAILURE;
+
+    // for all other variables, validate length and allocate buffers
+    } else {
+        dataLength = (unsigned long long) buffer->maxArraySize *
+                (unsigned long long) var->sizeInBytes;
+        if (dataLength > INT_MAX)
+            return dpiError__set(error, "check max array size",
+                    DPI_ERR_ARRAY_SIZE_TOO_BIG, buffer->maxArraySize);
+        if (dpiUtils__allocateMemory(1, (size_t) dataLength, 0,
+                "allocate buffer", (void**) &buffer->data.asRaw, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // allocate the indicator for the variable
+    // ensure all values start out as null
+    if (!buffer->indicator) {
+        if (dpiUtils__allocateMemory(buffer->maxArraySize, sizeof(int16_t), 0,
+                "allocate indicator", (void**) &buffer->indicator, error) < 0)
+            return DPI_FAILURE;
+        for (i = 0; i < buffer->maxArraySize; i++)
+            buffer->indicator[i] = DPI_OCI_IND_NULL;
+    }
+
+    // allocate the actual length buffers for all but dynamic bytes which are
+    // handled differently; ensure actual length starts out as maximum value
+    if (!var->isDynamic && !buffer->actualLength16 &&
+            !buffer->actualLength32) {
+        if (var->env->versionInfo->versionNum < 12 && buffer == &var->buffer) {
+            if (dpiUtils__allocateMemory(buffer->maxArraySize,
+                    sizeof(uint16_t), 0, "allocate actual length",
+                    (void**) &buffer->actualLength16, error) < 0)
+                return DPI_FAILURE;
+            for (i = 0; i < buffer->maxArraySize; i++)
+                buffer->actualLength16[i] = (uint16_t) var->sizeInBytes;
+        } else {
+            if (dpiUtils__allocateMemory(buffer->maxArraySize,
+                    sizeof(uint32_t), 0, "allocate actual length",
+                    (void**) &buffer->actualLength32, error) < 0)
+                return DPI_FAILURE;
+            for (i = 0; i < buffer->maxArraySize; i++)
+                buffer->actualLength32[i] = var->sizeInBytes;
+        }
+    }
+
+    // for variable length data, also allocate the return code array
+    if (var->type->defaultNativeTypeNum == DPI_NATIVE_TYPE_BYTES &&
+            !var->isDynamic && !buffer->returnCode) {
+        if (dpiUtils__allocateMemory(buffer->maxArraySize, sizeof(uint16_t), 0,
+                "allocate return code", (void**) &buffer->returnCode,
+                error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // for numbers transferred to/from Oracle as bytes, allocate an additional
+    // set of buffers
+    if (var->type->oracleTypeNum == DPI_ORACLE_TYPE_NUMBER &&
+            var->nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
+        tempBufferSize = DPI_NUMBER_AS_TEXT_CHARS;
+        if (var->env->charsetId == DPI_CHARSET_ID_UTF16)
+            tempBufferSize *= 2;
+        if (!buffer->tempBuffer) {
+            if (dpiUtils__allocateMemory(buffer->maxArraySize, tempBufferSize,
+                    0, "allocate temp buffer", (void**) &buffer->tempBuffer,
+                    error) < 0)
+                return DPI_FAILURE;
+        }
+    }
+
+    // allocate the external data array, if needed
+    if (!buffer->externalData) {
+        if (dpiUtils__allocateMemory(buffer->maxArraySize, sizeof(dpiData), 1,
+                "allocate external data", (void**) &buffer->externalData,
+                error) < 0)
+            return DPI_FAILURE;
+        for (i = 0; i < buffer->maxArraySize; i++)
+            buffer->externalData[i].isNull = 1;
+    }
+
+    // for bytes transfers, set encoding and pointers for small strings
+    if (var->nativeTypeNum == DPI_NATIVE_TYPE_BYTES) {
+        for (i = 0; i < buffer->maxArraySize; i++) {
+            bytes = &buffer->externalData[i].value.asBytes;
+            if (var->type->charsetForm == DPI_SQLCS_IMPLICIT)
+                bytes->encoding = var->env->encoding;
+            else bytes->encoding = var->env->nencoding;
+            if (buffer->tempBuffer)
+                bytes->ptr = buffer->tempBuffer + i * tempBufferSize;
+            else if (!var->isDynamic && !buffer->dynamicBytes)
+                bytes->ptr = buffer->data.asBytes + i * var->sizeInBytes;
+        }
+    }
+
+    // create array of references, if applicable
+    if (var->type->requiresPreFetch && !var->isDynamic) {
+        if (dpiUtils__allocateMemory(buffer->maxArraySize,
+                sizeof(dpiReferenceBuffer), 1, "allocate references",
+                (void**) &buffer->references, error) < 0)
+            return DPI_FAILURE;
+    }
+
+    // perform variable specific initialization
+    switch (var->type->oracleTypeNum) {
+        case DPI_ORACLE_TYPE_TIMESTAMP:
+            return dpiOci__arrayDescriptorAlloc(var->env->handle,
+                    &buffer->data.asTimestamp[0], DPI_OCI_DTYPE_TIMESTAMP,
+                    buffer->maxArraySize, error);
+        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
+            return dpiOci__arrayDescriptorAlloc(var->env->handle,
+                    &buffer->data.asTimestamp[0], DPI_OCI_DTYPE_TIMESTAMP_TZ,
+                    buffer->maxArraySize, error);
+        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
+            return dpiOci__arrayDescriptorAlloc(var->env->handle,
+                    &buffer->data.asTimestamp[0], DPI_OCI_DTYPE_TIMESTAMP_LTZ,
+                    buffer->maxArraySize, error);
+        case DPI_ORACLE_TYPE_INTERVAL_DS:
+            return dpiOci__arrayDescriptorAlloc(var->env->handle,
+                    &buffer->data.asInterval[0], DPI_OCI_DTYPE_INTERVAL_DS,
+                    buffer->maxArraySize, error);
+        case DPI_ORACLE_TYPE_INTERVAL_YM:
+            return dpiOci__arrayDescriptorAlloc(var->env->handle,
+                    &buffer->data.asInterval[0], DPI_OCI_DTYPE_INTERVAL_YM,
+                    buffer->maxArraySize, error);
+        case DPI_ORACLE_TYPE_CLOB:
+        case DPI_ORACLE_TYPE_BLOB:
+        case DPI_ORACLE_TYPE_NCLOB:
+        case DPI_ORACLE_TYPE_BFILE:
+        case DPI_ORACLE_TYPE_STMT:
+        case DPI_ORACLE_TYPE_ROWID:
+        case DPI_ORACLE_TYPE_JSON:
+            return dpiVar__extendedPreFetch(var, buffer, error);
+        case DPI_ORACLE_TYPE_OBJECT:
+            if (!var->objectType)
+                return dpiError__set(error, "check object type",
+                        DPI_ERR_NO_OBJECT_TYPE);
+            if (dpiUtils__allocateMemory(buffer->maxArraySize, sizeof(void*),
+                    0, "allocate object indicator",
+                    (void**) &buffer->objectIndicator, error) < 0)
+                return DPI_FAILURE;
+            return dpiVar__extendedPreFetch(var, buffer, error);
+        default:
+            break;
+    }
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__outBindCallback() [INTERNAL]
+//   Callback which runs during OCI statement execution and allocates the
+// buffers required as well as provides that information to the OCI. This is
+// intended for use with DML returning only.
+//-----------------------------------------------------------------------------
+int32_t dpiVar__outBindCallback(dpiVar *var, void *bindp, UNUSED uint32_t iter,
+        uint32_t index, void **bufpp, uint32_t **alenpp, uint8_t *piecep,
+        void **indpp, uint16_t **rcodepp)
+{
+    dpiDynamicBytesChunk *chunk;
+    uint32_t numRowsReturned;
+    dpiDynamicBytes *bytes;
+    dpiVarBuffer *buffer;
+
+    // determine which variable buffer to use
+    if (!var->dynBindBuffers) {
+        if (dpiUtils__allocateMemory(var->buffer.maxArraySize,
+                sizeof(dpiVarBuffer), 1, "allocate DML returning buffers",
+                (void**) &var->dynBindBuffers, var->error) < 0)
+            return DPI_FAILURE;
+    }
+    buffer = &var->dynBindBuffers[iter];
+
+    // special processing during first value returned for each iteration
+    if (index == 0) {
+
+        // determine number of rows returned
+        if (dpiOci__attrGet(bindp, DPI_OCI_HTYPE_BIND, &numRowsReturned, 0,
+                DPI_OCI_ATTR_ROWS_RETURNED, "get rows returned",
+                var->error) < 0)
+            return DPI_OCI_ERROR;
+
+        // reallocate buffers, if needed
+        if (numRowsReturned > buffer->maxArraySize) {
+            dpiVar__finalizeBuffer(var, buffer, var->error);
+            buffer->maxArraySize = numRowsReturned;
+            if (dpiVar__initBuffer(var, buffer, var->error) < 0)
+                return DPI_OCI_ERROR;
+        }
+
+        // set actual array size to number of rows returned
+        buffer->actualArraySize = numRowsReturned;
+
+    }
+
+    // handle dynamically allocated strings (multiple piece)
+    // index is the current index into the chunks
+    if (var->isDynamic) {
+
+        // allocate more chunks, if necessary
+        bytes = &buffer->dynamicBytes[index];
+        if (*piecep == DPI_OCI_ONE_PIECE)
+            bytes->numChunks = 0;
+        if (bytes->numChunks == bytes->allocatedChunks &&
+                dpiVar__allocateChunks(bytes, var->error) < 0)
+            return DPI_OCI_ERROR;
+
+        // allocate memory for the chunk, if needed
+        chunk = &bytes->chunks[bytes->numChunks];
+        if (!chunk->ptr) {
+            chunk->allocatedLength = DPI_DYNAMIC_BYTES_CHUNK_SIZE;
+            if (dpiUtils__allocateMemory(1, chunk->allocatedLength, 0,
+                    "allocate chunk", (void**) &chunk->ptr, var->error) < 0)
+                return DPI_OCI_ERROR;
+        }
+
+        // return chunk to OCI
+        bytes->numChunks++;
+        chunk->length = chunk->allocatedLength;
+        *bufpp = chunk->ptr;
+        *alenpp = &chunk->length;
+        *indpp = &(buffer->indicator[index]);
+        *rcodepp = NULL;
+
+    // handle normally allocated variables (one piece)
+    } else {
+
+        *piecep = DPI_OCI_ONE_PIECE;
+        if (dpiVar__setValue(var, buffer, index, &buffer->externalData[index],
+                var->error) < 0)
+            return DPI_OCI_ERROR;
+        dpiVar__assignCallbackBuffer(var, buffer, index, bufpp);
+        if (buffer->actualLength32 || buffer->actualLength16) {
+            if (!buffer->actualLength32) {
+                if (dpiUtils__allocateMemory(buffer->maxArraySize,
+                        sizeof(uint32_t), 1, "allocate 11g lengths",
+                        (void**) &buffer->actualLength32, var->error) < 0)
+                    return DPI_OCI_ERROR;
+            }
+            buffer->actualLength32[index] = var->sizeInBytes;
+            *alenpp = &(buffer->actualLength32[index]);
+        } else if (*alenpp && var->type->sizeInBytes)
+            **alenpp = var->type->sizeInBytes;
+        if (buffer->objectIndicator)
+            *indpp = buffer->objectIndicator[index];
+        else *indpp = &(buffer->indicator[index]);
+        if (buffer->returnCode)
+            *rcodepp = &buffer->returnCode[index];
+
+    }
+
+    return DPI_OCI_CONTINUE;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__setBytesFromDynamicBytes() [PRIVATE]
+//   Set the pointer and length in the dpiBytes structure to the values
+// retrieved from the database. At this point, if multiple chunks exist, they
+// are combined into one.
+//-----------------------------------------------------------------------------
+static int dpiVar__setBytesFromDynamicBytes(dpiBytes *bytes,
+        dpiDynamicBytes *dynBytes, dpiError *error)
+{
+    uint32_t i, totalAllocatedLength;
+
+    // if only one chunk is available, make use of it
+    if (dynBytes->numChunks == 1) {
+        bytes->ptr = dynBytes->chunks->ptr;
+        bytes->length = dynBytes->chunks->length;
+        return DPI_SUCCESS;
+    }
+
+    // determine total allocated size of all chunks
+    totalAllocatedLength = 0;
+    for (i = 0; i < dynBytes->numChunks; i++)
+        totalAllocatedLength += dynBytes->chunks[i].allocatedLength;
+
+    // allocate new memory consolidating all of the chunks
+    if (dpiUtils__allocateMemory(1, totalAllocatedLength, 0,
+            "allocate consolidated chunk", (void**) &bytes->ptr, error) < 0)
+        return DPI_FAILURE;
+
+    // copy memory from chunks to consolidated chunk
+    bytes->length = 0;
+    for (i = 0; i < dynBytes->numChunks; i++) {
+        memcpy(bytes->ptr + bytes->length, dynBytes->chunks[i].ptr,
+                dynBytes->chunks[i].length);
+        bytes->length += dynBytes->chunks[i].length;
+        dpiUtils__freeMemory(dynBytes->chunks[i].ptr);
+        dynBytes->chunks[i].ptr = NULL;
+        dynBytes->chunks[i].length = 0;
+        dynBytes->chunks[i].allocatedLength = 0;
+    }
+
+    // populate first chunk with consolidated information
+    dynBytes->numChunks = 1;
+    dynBytes->chunks->ptr = bytes->ptr;
+    dynBytes->chunks->length = bytes->length;
+    dynBytes->chunks->allocatedLength = totalAllocatedLength;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__setBytesFromLob() [PRIVATE]
+//   Populate the dynamic bytes structure with the data from the LOB and then
+// populate the bytes structure.
+//-----------------------------------------------------------------------------
+static int dpiVar__setBytesFromLob(dpiBytes *bytes, dpiDynamicBytes *dynBytes,
+        dpiLob *lob, dpiError *error)
+{
+    uint64_t length, lengthInBytes, lengthReadInBytes;
+
+    // determine length of LOB in bytes
+    if (dpiOci__lobGetLength2(lob, &length, error) < 0)
+        return DPI_FAILURE;
+    if (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_CLOB)
+        lengthInBytes = length * lob->env->maxBytesPerCharacter;
+    else if (lob->type->oracleTypeNum == DPI_ORACLE_TYPE_NCLOB)
+        lengthInBytes = length * lob->env->nmaxBytesPerCharacter;
+    else lengthInBytes = length;
+
+    // ensure there is enough space to store the entire LOB value
+    if (lengthInBytes > UINT_MAX)
+        return dpiError__set(error, "check max length", DPI_ERR_NOT_SUPPORTED);
+    if (dpiVar__allocateDynamicBytes(dynBytes, (uint32_t) lengthInBytes,
+            error) < 0)
+        return DPI_FAILURE;
+
+    // read data from the LOB
+    lengthReadInBytes = lengthInBytes;
+    if (length > 0 && dpiLob__readBytes(lob, 1, length, dynBytes->chunks->ptr,
+            &lengthReadInBytes, error) < 0)
+        return DPI_FAILURE;
+
+    dynBytes->chunks->length = (uint32_t) lengthReadInBytes;
+    bytes->ptr = dynBytes->chunks->ptr;
+    bytes->length = dynBytes->chunks->length;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__setFromBytes() [PRIVATE]
+//   Set the value of the variable at the given array position from a byte
+// string. The byte string is not retained in any way. A copy will be made into
+// buffers allocated by ODPI-C.
+//-----------------------------------------------------------------------------
+static int dpiVar__setFromBytes(dpiVar *var, uint32_t pos, const char *value,
+        uint32_t valueLength, dpiError *error)
+{
+    dpiData *data = &var->buffer.externalData[pos];
+    dpiDynamicBytes *dynBytes;
+    dpiBytes *bytes;
+
+    // for internally used LOBs, write the data directly
+    if (var->buffer.references) {
+        data->isNull = 0;
+        return dpiLob__setFromBytes(var->buffer.references[pos].asLOB, value,
+                valueLength, error);
+    }
+
+    // validate the target can accept the input
+    if ((var->buffer.tempBuffer &&
+                    var->env->charsetId == DPI_CHARSET_ID_UTF16 &&
+                    valueLength > DPI_NUMBER_AS_TEXT_CHARS * 2) ||
+            (var->buffer.tempBuffer &&
+                    var->env->charsetId != DPI_CHARSET_ID_UTF16 &&
+                    valueLength > DPI_NUMBER_AS_TEXT_CHARS) ||
+            (!var->buffer.dynamicBytes && !var->buffer.tempBuffer &&
+                    valueLength > var->sizeInBytes))
+        return dpiError__set(error, "check source length",
+                DPI_ERR_BUFFER_SIZE_TOO_SMALL, var->sizeInBytes);
+
+    // for dynamic bytes, allocate space as needed
+    bytes = &data->value.asBytes;
+    if (var->buffer.dynamicBytes) {
+        dynBytes = &var->buffer.dynamicBytes[pos];
+        if (dpiVar__allocateDynamicBytes(dynBytes, valueLength, error) < 0)
+            return DPI_FAILURE;
+        if (valueLength > 0)
+            memcpy(dynBytes->chunks->ptr, value, valueLength);
+        dynBytes->numChunks = 1;
+        dynBytes->chunks->length = valueLength;
+        bytes->ptr = dynBytes->chunks->ptr;
+        bytes->length = valueLength;
+
+    // for everything else, space has already been allocated
+    } else {
+        bytes->length = valueLength;
+        if (valueLength > 0)
+            memcpy(bytes->ptr, value, valueLength);
+        if (var->type->sizeInBytes == 0) {
+            if (var->buffer.actualLength32)
+                var->buffer.actualLength32[pos] = valueLength;
+            else if (var->buffer.actualLength16)
+                var->buffer.actualLength16[pos] = (uint16_t) valueLength;
+        }
+        if (var->buffer.returnCode)
+            var->buffer.returnCode[pos] = 0;
+    }
+    data->isNull = 0;
+
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__setFromJson() [PRIVATE]
+//   Set the value of the variable at the given array position from a JSON
+// value. A reference to the JSON value is retained by the variable.
+//-----------------------------------------------------------------------------
+static int dpiVar__setFromJson(dpiVar *var, uint32_t pos, dpiJson *json,
+        dpiError *error)
+{
+    dpiData *data;
+
+    // validate the JSON value
+    if (dpiGen__checkHandle(json, DPI_HTYPE_JSON, "check JSON", error) < 0)
+        return DPI_FAILURE;
+
+    // mark the value as not null
+    data = &var->buffer.externalData[pos];
+    data->isNull = 0;
+
+    // if values are the same, nothing to do
+    if (var->buffer.references[pos].asJson == json)
+        return DPI_SUCCESS;
+
+    // clear original value, if needed
+    if (var->buffer.references[pos].asJson) {
+        dpiGen__setRefCount(var->buffer.references[pos].asJson, error, -1);
+        var->buffer.references[pos].asJson = NULL;
+    }
+
+    // add reference to passed object
+    dpiGen__setRefCount(json, error, 1);
+    var->buffer.references[pos].asJson = json;
+    var->buffer.data.asJsonDescriptor[pos] = json->handle;
+    data->value.asJson = json;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__setFromLob() [PRIVATE]
+//   Set the value of the variable at the given array position from a LOB.
+// A reference to the LOB is retained by the variable.
+//-----------------------------------------------------------------------------
+static int dpiVar__setFromLob(dpiVar *var, uint32_t pos, dpiLob *lob,
+        dpiError *error)
+{
+    dpiData *data;
+
+    // validate the LOB object
+    if (dpiGen__checkHandle(lob, DPI_HTYPE_LOB, "check LOB", error) < 0)
+        return DPI_FAILURE;
+
+    // mark the value as not null
+    data = &var->buffer.externalData[pos];
+    data->isNull = 0;
+
+    // if values are the same, nothing to do
+    if (var->buffer.references[pos].asLOB == lob)
+        return DPI_SUCCESS;
+
+    // clear original value, if needed
+    if (var->buffer.references[pos].asLOB) {
+        dpiGen__setRefCount(var->buffer.references[pos].asLOB, error, -1);
+        var->buffer.references[pos].asLOB = NULL;
+    }
+
+    // add reference to passed object
+    dpiGen__setRefCount(lob, error, 1);
+    var->buffer.references[pos].asLOB = lob;
+    var->buffer.data.asLobLocator[pos] = lob->locator;
+    data->value.asLOB = lob;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__setFromObject() [PRIVATE]
+//   Set the value of the variable at the given array position from an object.
+// The variable and position are assumed to be valid at this point. A reference
+// to the object is retained by the variable.
+//-----------------------------------------------------------------------------
+static int dpiVar__setFromObject(dpiVar *var, uint32_t pos, dpiObject *obj,
+        dpiError *error)
+{
+    dpiData *data;
+
+    // validate the object
+    if (dpiGen__checkHandle(obj, DPI_HTYPE_OBJECT, "check obj", error) < 0)
+        return DPI_FAILURE;
+    if (obj->type->tdo != var->objectType->tdo)
+        return dpiError__set(error, "check type", DPI_ERR_WRONG_TYPE,
+                obj->type->schemaLength, obj->type->schema,
+                obj->type->nameLength, obj->type->name,
+                var->objectType->schemaLength, var->objectType->schema,
+                var->objectType->nameLength, var->objectType->name);
+
+    // mark the value as not null
+    data = &var->buffer.externalData[pos];
+    data->isNull = 0;
+
+    // if values are the same, nothing to do
+    if (var->buffer.references[pos].asObject == obj)
+        return DPI_SUCCESS;
+
+    // clear original value, if needed
+    if (var->buffer.references[pos].asObject) {
+        dpiGen__setRefCount(var->buffer.references[pos].asObject, error, -1);
+        var->buffer.references[pos].asObject = NULL;
+    }
+
+    // add reference to passed object
+    dpiGen__setRefCount(obj, error, 1);
+    var->buffer.references[pos].asObject = obj;
+    var->buffer.data.asObject[pos] = obj->instance;
+    var->buffer.objectIndicator[pos] = obj->indicator;
+    data->value.asObject = obj;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__setFromRowid() [PRIVATE]
+//   Set the value of the variable at the given array position from a rowid.
+// A reference to the rowid is retained by the variable.
+//-----------------------------------------------------------------------------
+static int dpiVar__setFromRowid(dpiVar *var, uint32_t pos, dpiRowid *rowid,
+        dpiError *error)
+{
+    dpiData *data;
+
+    // validate the rowid
+    if (dpiGen__checkHandle(rowid, DPI_HTYPE_ROWID, "check rowid", error) < 0)
+        return DPI_FAILURE;
+
+    // mark the value as not null
+    data = &var->buffer.externalData[pos];
+    data->isNull = 0;
+
+    // if values are the same, nothing to do
+    if (var->buffer.references[pos].asRowid == rowid)
+        return DPI_SUCCESS;
+
+    // clear original value, if needed
+    if (var->buffer.references[pos].asRowid) {
+        dpiGen__setRefCount(var->buffer.references[pos].asRowid, error, -1);
+        var->buffer.references[pos].asRowid = NULL;
+    }
+
+    // add reference to passed object
+    dpiGen__setRefCount(rowid, error, 1);
+    var->buffer.references[pos].asRowid = rowid;
+    var->buffer.data.asRowid[pos] = rowid->handle;
+    data->value.asRowid = rowid;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__setFromStmt() [PRIVATE]
+//   Set the value of the variable at the given array position from a
+// statement. A reference to the statement is retained by the variable.
+//-----------------------------------------------------------------------------
+static int dpiVar__setFromStmt(dpiVar *var, uint32_t pos, dpiStmt *stmt,
+        dpiError *error)
+{
+    dpiData *data;
+    uint32_t i;
+
+    // validate the statement
+    if (dpiGen__checkHandle(stmt, DPI_HTYPE_STMT, "check stmt", error) < 0)
+        return DPI_FAILURE;
+
+    // prevent attempts to bind a statement to itself
+    for (i = 0; i < stmt->numBindVars; i++) {
+        if (stmt->bindVars[i].var == var)
+            return dpiError__set(error, "bind to self", DPI_ERR_NOT_SUPPORTED);
+    }
+
+    // mark the value as not null
+    data = &var->buffer.externalData[pos];
+    data->isNull = 0;
+
+    // if values are the same, nothing to do
+    if (var->buffer.references[pos].asStmt == stmt)
+        return DPI_SUCCESS;
+
+    // clear original value, if needed
+    if (var->buffer.references[pos].asStmt) {
+        dpiGen__setRefCount(var->buffer.references[pos].asStmt, error, -1);
+        var->buffer.references[pos].asStmt = NULL;
+    }
+
+    // add reference to passed object
+    dpiGen__setRefCount(stmt, error, 1);
+    var->buffer.references[pos].asStmt = stmt;
+    var->buffer.data.asStmt[pos] = stmt->handle;
+    data->value.asStmt = stmt;
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__setValue() [PRIVATE]
+//   Sets the contents of the variable using the type specified, if possible.
+//-----------------------------------------------------------------------------
+int dpiVar__setValue(dpiVar *var, dpiVarBuffer *buffer, uint32_t pos,
+        dpiData *data, dpiError *error)
+{
+    dpiOracleTypeNum oracleTypeNum;
+    dpiObject *obj;
+
+    // if value is null, no need to proceed further
+    // however, when binding objects a value MUST be present or OCI will
+    // segfault!
+    if (data->isNull) {
+        buffer->indicator[pos] = DPI_OCI_IND_NULL;
+        if (buffer->objectIndicator && !buffer->data.asObject[pos]) {
+            if (dpiObject__allocate(var->objectType, NULL, NULL, NULL, &obj,
+                    error) < 0)
+                return DPI_FAILURE;
+            buffer->references[pos].asObject = obj;
+            data->value.asObject = obj;
+            buffer->data.asObject[pos] = obj->instance;
+            buffer->objectIndicator[pos] = obj->indicator;
+            if (buffer->objectIndicator[pos])
+                *((int16_t*) buffer->objectIndicator[pos]) = DPI_OCI_IND_NULL;
+        }
+        return DPI_SUCCESS;
+    }
+
+    // transform the various types
+    buffer->indicator[pos] = DPI_OCI_IND_NOTNULL;
+    oracleTypeNum = var->type->oracleTypeNum;
+    switch (var->nativeTypeNum) {
+        case DPI_NATIVE_TYPE_INT64:
+        case DPI_NATIVE_TYPE_UINT64:
+            switch (oracleTypeNum) {
+                case DPI_ORACLE_TYPE_NATIVE_INT:
+                    buffer->data.asInt64[pos] = data->value.asInt64;
+                    return DPI_SUCCESS;
+                case DPI_ORACLE_TYPE_NATIVE_UINT:
+                    buffer->data.asUint64[pos] = data->value.asUint64;
+                    return DPI_SUCCESS;
+                case DPI_ORACLE_TYPE_NUMBER:
+                    if (var->nativeTypeNum == DPI_NATIVE_TYPE_INT64)
+                        return dpiDataBuffer__toOracleNumberFromInteger(
+                                &data->value, error,
+                                &buffer->data.asNumber[pos]);
+                    return dpiDataBuffer__toOracleNumberFromUnsignedInteger(
+                            &data->value, error, &buffer->data.asNumber[pos]);
+                default:
+                    break;
+            }
+            break;
+        case DPI_NATIVE_TYPE_FLOAT:
+            buffer->data.asFloat[pos] = data->value.asFloat;
+            return DPI_SUCCESS;
+        case DPI_NATIVE_TYPE_DOUBLE:
+            switch (oracleTypeNum) {
+                case DPI_ORACLE_TYPE_NATIVE_DOUBLE:
+                    buffer->data.asDouble[pos] = data->value.asDouble;
+                    return DPI_SUCCESS;
+                case DPI_ORACLE_TYPE_NUMBER:
+                    return dpiDataBuffer__toOracleNumberFromDouble(
+                            &data->value, error, &buffer->data.asNumber[pos]);
+                case DPI_ORACLE_TYPE_DATE:
+                    return dpiDataBuffer__toOracleDateFromDouble(
+                            &data->value, var->env, error,
+                            &buffer->data.asDate[pos]);
+                case DPI_ORACLE_TYPE_TIMESTAMP:
+                case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
+                case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
+                    return dpiDataBuffer__toOracleTimestampFromDouble(
+                            &data->value, oracleTypeNum, var->env, error,
+                            buffer->data.asTimestamp[pos]);
+                default:
+                    break;
+            }
+            break;
+        case DPI_NATIVE_TYPE_BYTES:
+            if (oracleTypeNum == DPI_ORACLE_TYPE_NUMBER)
+                return dpiDataBuffer__toOracleNumberFromText(&data->value,
+                        var->env, error, &buffer->data.asNumber[pos]);
+            if (buffer->actualLength32)
+                buffer->actualLength32[pos] = data->value.asBytes.length;
+            else if (buffer->actualLength16)
+                buffer->actualLength16[pos] =
+                        (uint16_t) data->value.asBytes.length;
+            if (buffer->returnCode)
+                buffer->returnCode[pos] = 0;
+            break;
+        case DPI_NATIVE_TYPE_TIMESTAMP:
+            if (oracleTypeNum == DPI_ORACLE_TYPE_DATE)
+                return dpiDataBuffer__toOracleDate(&data->value,
+                        &buffer->data.asDate[pos]);
+            else if (oracleTypeNum == DPI_ORACLE_TYPE_TIMESTAMP)
+                return dpiDataBuffer__toOracleTimestamp(&data->value,
+                        var->env, error, buffer->data.asTimestamp[pos], 0);
+            else if (oracleTypeNum == DPI_ORACLE_TYPE_TIMESTAMP_TZ ||
+                    oracleTypeNum == DPI_ORACLE_TYPE_TIMESTAMP_LTZ)
+                return dpiDataBuffer__toOracleTimestamp(&data->value,
+                        var->env, error, buffer->data.asTimestamp[pos], 1);
+            break;
+        case DPI_NATIVE_TYPE_INTERVAL_DS:
+            return dpiDataBuffer__toOracleIntervalDS(&data->value, var->env,
+                    error, buffer->data.asInterval[pos]);
+        case DPI_NATIVE_TYPE_INTERVAL_YM:
+            return dpiDataBuffer__toOracleIntervalYM(&data->value, var->env,
+                    error, buffer->data.asInterval[pos]);
+        case DPI_NATIVE_TYPE_BOOLEAN:
+            buffer->data.asBoolean[pos] = data->value.asBoolean;
+            return DPI_SUCCESS;
+        case DPI_NATIVE_TYPE_STMT:
+            return dpiOci__attrSet(data->value.asStmt->handle,
+                    DPI_OCI_HTYPE_STMT, &data->value.asStmt->prefetchRows,
+                    sizeof(data->value.asStmt->prefetchRows),
+                    DPI_OCI_ATTR_PREFETCH_ROWS,
+                    "set prefetch rows for REF cursor", error);
+        default:
+            break;
+    }
+    return DPI_SUCCESS;
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar__validateTypes() [PRIVATE]
+//   Validate that the Oracle type and the native type are compatible with
+// each other when the native type is not already the default native type.
+//-----------------------------------------------------------------------------
+static int dpiVar__validateTypes(const dpiOracleType *oracleType,
+        dpiNativeTypeNum nativeTypeNum, dpiError *error)
+{
+    switch (oracleType->oracleTypeNum) {
+        case DPI_ORACLE_TYPE_DATE:
+        case DPI_ORACLE_TYPE_TIMESTAMP:
+        case DPI_ORACLE_TYPE_TIMESTAMP_TZ:
+        case DPI_ORACLE_TYPE_TIMESTAMP_LTZ:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_DOUBLE)
+                return DPI_SUCCESS;
+            break;
+        case DPI_ORACLE_TYPE_NUMBER:
+            if (nativeTypeNum == DPI_NATIVE_TYPE_INT64 ||
+                    nativeTypeNum == DPI_NATIVE_TYPE_UINT64 ||
+                    nativeTypeNum == DPI_NATIVE_TYPE_BYTES)
+                return DPI_SUCCESS;
+            break;
+        default:
+            break;
+    }
+    return dpiError__set(error, "validate types", DPI_ERR_UNHANDLED_CONVERSION,
+            oracleType->oracleTypeNum, nativeTypeNum);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar_addRef() [PUBLIC]
+//   Add a reference to the variable.
+//-----------------------------------------------------------------------------
+int dpiVar_addRef(dpiVar *var)
+{
+    return dpiGen__addRef(var, DPI_HTYPE_VAR, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar_copyData() [PUBLIC]
+//   Copy the data from the source variable to the target variable at the given
+// array position. The variables must use the same native type. If the
+// variables contain variable length data, the source length must not exceed
+// the target allocated memory.
+//-----------------------------------------------------------------------------
+int dpiVar_copyData(dpiVar *var, uint32_t pos, dpiVar *sourceVar,
+        uint32_t sourcePos)
+{
+    dpiData *sourceData;
+    dpiError error;
+    int status;
+
+    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    if (dpiGen__checkHandle(sourceVar, DPI_HTYPE_VAR, "check source var",
+            &error) < 0)
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    if (sourcePos >= sourceVar->buffer.maxArraySize) {
+        dpiError__set(&error, "check source size",
+                DPI_ERR_INVALID_ARRAY_POSITION, sourcePos,
+                sourceVar->buffer.maxArraySize);
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    }
+    if (var->nativeTypeNum != sourceVar->nativeTypeNum) {
+        dpiError__set(&error, "check types match", DPI_ERR_NOT_SUPPORTED);
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    }
+    sourceData = &sourceVar->buffer.externalData[sourcePos];
+    status = dpiVar__copyData(var, pos, sourceData, &error);
+    return dpiGen__endPublicFn(var, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar_getNumElementsInArray() [PUBLIC]
+//   Return the actual number of elements in the array. This value is only
+// relevant if the variable is bound as an array.
+//-----------------------------------------------------------------------------
+int dpiVar_getNumElementsInArray(dpiVar *var, uint32_t *numElements)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(var, DPI_HTYPE_VAR, __func__, &error) < 0)
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(var, numElements)
+    if (var->dynBindBuffers)
+        *numElements = var->dynBindBuffers->actualArraySize;
+    else *numElements = var->buffer.actualArraySize;
+    return dpiGen__endPublicFn(var, DPI_SUCCESS, &error);
+}
+
+//-----------------------------------------------------------------------------
+// dpiVar_getReturnedData() [PUBLIC]
+//   Return a pointer to the array of dpiData structures allocated for the
+// given row that have been returned by a DML returning statement. The number
+// of returned rows is also provided. If the bind variable had no data
+// returned, the number of rows returned will be 0 and the pointer to the array
+// of dpiData structures will be NULL. This will also be the case if the
+// variable was only bound IN or was not bound to a DML returning statement.
+// There is no way to differentiate between the two.
+//-----------------------------------------------------------------------------
+int dpiVar_getReturnedData(dpiVar *var, uint32_t pos, uint32_t *numElements,
+        dpiData **data)
+{
+    dpiError error;
+
+    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(var, numElements)
+    DPI_CHECK_PTR_NOT_NULL(var, data)
+    if (var->dynBindBuffers) {
+        *numElements = var->dynBindBuffers[pos].actualArraySize;
+        *data = var->dynBindBuffers[pos].externalData;
+    } else {
+        *numElements = 0;
+        *data = NULL;
+    }
+    return dpiGen__endPublicFn(var, DPI_SUCCESS, &error);
+}
+
+
+
+//-----------------------------------------------------------------------------
+// dpiVar_getSizeInBytes() [PUBLIC]
+//   Returns the size in bytes of the buffer allocated for the variable.
+//-----------------------------------------------------------------------------
+int dpiVar_getSizeInBytes(dpiVar *var, uint32_t *sizeInBytes)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(var, DPI_HTYPE_VAR, __func__, &error) < 0)
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_NOT_NULL(var, sizeInBytes)
+    *sizeInBytes = var->sizeInBytes;
+    return dpiGen__endPublicFn(var, DPI_SUCCESS, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar_release() [PUBLIC]
+//   Release a reference to the variable.
+//-----------------------------------------------------------------------------
+int dpiVar_release(dpiVar *var)
+{
+    return dpiGen__release(var, DPI_HTYPE_VAR, __func__);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar_setFromBytes() [PUBLIC]
+//   Set the value of the variable at the given array position from a byte
+// string. Checks on the array position, the size of the string and the type of
+// variable will be made. The byte string is not retained in any way. A copy
+// will be made into buffers allocated by ODPI-C.
+//-----------------------------------------------------------------------------
+int dpiVar_setFromBytes(dpiVar *var, uint32_t pos, const char *value,
+        uint32_t valueLength)
+{
+    dpiError error;
+    int status;
+
+    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    DPI_CHECK_PTR_AND_LENGTH(var, value)
+    if (var->nativeTypeNum != DPI_NATIVE_TYPE_BYTES &&
+            var->nativeTypeNum != DPI_NATIVE_TYPE_LOB) {
+        dpiError__set(&error, "native type", DPI_ERR_NOT_SUPPORTED);
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    }
+    if (valueLength > DPI_MAX_VAR_BUFFER_SIZE) {
+        dpiError__set(&error, "check buffer", DPI_ERR_BUFFER_SIZE_TOO_LARGE,
+                valueLength, DPI_MAX_VAR_BUFFER_SIZE);
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    }
+    status = dpiVar__setFromBytes(var, pos, value, valueLength, &error);
+    return dpiGen__endPublicFn(var, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar_setFromJson() [PUBLIC]
+//  Set the value of the variable at the given position from a JSON value.
+// Checks on the array position and the validity of the passed value.
+// A reference to the JSON value is retained by the variable.
+//-----------------------------------------------------------------------------
+int dpiVar_setFromJson( dpiVar *var, uint32_t pos, dpiJson *json)
+{
+    dpiError error;
+    int status;
+
+    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    if (var->nativeTypeNum != DPI_NATIVE_TYPE_JSON) {
+        dpiError__set(&error, "native type", DPI_ERR_NOT_SUPPORTED);
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    }
+    status = dpiVar__setFromJson(var, pos, json, &error);
+    return dpiGen__endPublicFn(var, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar_setFromLob() [PUBLIC]
+//   Set the value of the variable at the given array position from a LOB.
+// Checks on the array position and the validity of the passed handle. A
+// reference to the LOB is retained by the variable.
+//-----------------------------------------------------------------------------
+int dpiVar_setFromLob(dpiVar *var, uint32_t pos, dpiLob *lob)
+{
+    dpiError error;
+    int status;
+
+    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    if (var->nativeTypeNum != DPI_NATIVE_TYPE_LOB) {
+        dpiError__set(&error, "native type", DPI_ERR_NOT_SUPPORTED);
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    }
+    status = dpiVar__setFromLob(var, pos, lob, &error);
+    return dpiGen__endPublicFn(var, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar_setFromObject() [PUBLIC]
+//   Set the value of the variable at the given array position from an object.
+// Checks on the array position and the validity of the passed handle. A
+// reference to the object is retained by the variable.
+//-----------------------------------------------------------------------------
+int dpiVar_setFromObject(dpiVar *var, uint32_t pos, dpiObject *obj)
+{
+    dpiError error;
+    int status;
+
+    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    if (var->nativeTypeNum != DPI_NATIVE_TYPE_OBJECT) {
+        dpiError__set(&error, "native type", DPI_ERR_NOT_SUPPORTED);
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    }
+    status = dpiVar__setFromObject(var, pos, obj, &error);
+    return dpiGen__endPublicFn(var, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar_setFromRowid() [PUBLIC]
+//   Set the value of the variable at the given array position from a rowid.
+// Checks on the array position and the validity of the passed handle. A
+// reference to the rowid is retained by the variable.
+//-----------------------------------------------------------------------------
+int dpiVar_setFromRowid(dpiVar *var, uint32_t pos, dpiRowid *rowid)
+{
+    dpiError error;
+    int status;
+
+    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    if (var->nativeTypeNum != DPI_NATIVE_TYPE_ROWID) {
+        dpiError__set(&error, "native type", DPI_ERR_NOT_SUPPORTED);
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    }
+    status = dpiVar__setFromRowid(var, pos, rowid, &error);
+    return dpiGen__endPublicFn(var, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar_setFromStmt() [PUBLIC]
+//   Set the value of the variable at the given array position from a
+// statement. Checks on the array position and the validity of the passed
+// handle. A reference to the statement is retained by the variable.
+//-----------------------------------------------------------------------------
+int dpiVar_setFromStmt(dpiVar *var, uint32_t pos, dpiStmt *stmt)
+{
+    dpiError error;
+    int status;
+
+    if (dpiVar__checkArraySize(var, pos, __func__, &error) < 0)
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    if (var->nativeTypeNum != DPI_NATIVE_TYPE_STMT) {
+        dpiError__set(&error, "native type", DPI_ERR_NOT_SUPPORTED);
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    }
+    status = dpiVar__setFromStmt(var, pos, stmt, &error);
+    return dpiGen__endPublicFn(var, status, &error);
+}
+
+
+//-----------------------------------------------------------------------------
+// dpiVar_setNumElementsInArray() [PUBLIC]
+//   Set the number of elements in the array (different from the number of
+// allocated elements).
+//-----------------------------------------------------------------------------
+int dpiVar_setNumElementsInArray(dpiVar *var, uint32_t numElements)
+{
+    dpiError error;
+
+    if (dpiGen__startPublicFn(var, DPI_HTYPE_VAR, __func__, &error) < 0)
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    if (numElements > var->buffer.maxArraySize) {
+        dpiError__set(&error, "check num elements",
+                DPI_ERR_ARRAY_SIZE_TOO_SMALL, var->buffer.maxArraySize);
+        return dpiGen__endPublicFn(var, DPI_FAILURE, &error);
+    }
+    var->buffer.actualArraySize = numElements;
+    return dpiGen__endPublicFn(var, DPI_SUCCESS, &error);
+}
