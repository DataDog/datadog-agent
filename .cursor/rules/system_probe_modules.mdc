---
description: This rule serves for development of new system-probe modules that use eBPF, and need to send data to the backend
alwaysApply: false
---

# System-Probe Development Rules

## Overview

These rules provide a quick reference for developing new system-probe modules that use eBPF and send data to the backend. To avoid duplication, authoritative details live in the project AGENTS docs. Start here, then jump to the specific guides below:

- **System-Probe Modules guide**: `cmd/system-probe/modules/AGENTS.md` (module registration, router, lifecycle, HTTP endpoints)
- **eBPF simple checks guide**: `pkg/collector/corechecks/ebpf/AGENTS.md` (probe layout, agent-side checks, build integration)
- **Agent Core Checks rule**: `.cursor/rules/agent_corecheck.mdc` (agent-side check implementation details)
- **Project Overview**: Root `AGENTS.md`

Scope: This rule focuses on how the pieces connect and where to put code. For deep dives, follow the links above.

## Architecture: How System-Probe Checks Work

System-probe checks follow a two-process architecture that separates privileged operations from metric collection:

### System-Probe Module (Privileged Process)

Authoritative reference: see `cmd/system-probe/modules/AGENTS.md`.

Key responsibilities: privileged eBPF lifecycle, aggregation from maps, and HTTP endpoints for checks. Code location pattern: `cmd/system-probe/modules/<check>.go`.

### Agent Core Check (Unprivileged Process)

Authoritative reference: see `.cursor/rules/agent_corecheck.mdc` and `pkg/collector/corechecks/ebpf/AGENTS.md`.

Responsibilities: fetch from system-probe, convert to metrics/logs/events, schedule and configure checks. Typical locations: `pkg/collector/corechecks/ebpf/<check>/` (for simpler checks) or `pkg/collector/corechecks/<check>/` (for complex checks).

### Data Flow

```
┌─────────────────────────────────────────┐
│  Kernel Space                           │
│  eBPF Programs collect events           │
│  Store in eBPF data structures          │
└─────────────────┬───────────────────────┘
                  │
                  ▼
┌─────────────────────────────────────────┐
│  System-Probe Process (privileged)      │
│  - Probe reads/aggregates from maps     │
│  - Module exposes HTTP endpoint         │
│  - GetAndFlush() returns data           │
└─────────────────┬───────────────────────┘
                  │ HTTP Request
                  │ (e.g., GET /check)
                  ▼
┌─────────────────────────────────────────┐
│  Agent Process (unprivileged)           │
│  - Check queries system-probe           │
│  - Converts to metrics/logs/events      │
│  - Sends to Datadog backend             │
└─────────────────────────────────────────┘
```

**Example Flow**:

1. eBPF kprobe attached to `mark_oom_victim` collects OOM kill events
2. System-probe's `oomkill.Tracer` reads from eBPF map, aggregates per-CPU stats
3. System-probe's `oomkill` module exposes stats at `/check` endpoint
4. Agent's `oomkill.Check` calls `http://system-probe/check` periodically
5. Agent converts stats to `system.oom_kill.count` metric and submits to Datadog

**Note**: Not all system-probe modules have an agent-side check. Some features run entirely in system-probe for telemetry or background processing.

## File Naming Conventions

### eBPF Programs (C code)

See `pkg/collector/corechecks/ebpf/AGENTS.md` for full structure and examples. In brief:

- Simple checks: `pkg/collector/corechecks/ebpf/c/runtime/<check>-kern.c`
- Complex features: `pkg/<feature>/ebpf/c/runtime/<check>.c`
- Headers: `<check>-kern-user.h` or package `types.h`

### Go Probe Files

See `pkg/collector/corechecks/ebpf/AGENTS.md` for detailed file layout and build tags.

### Agent Check Files

If your system-probe module needs an agent-side check (to fetch data via HTTP and emit metrics), see `.cursor/rules/agent_corecheck.mdc` for complete details on creating agent checks.

**Quick reference for system-probe checks**:

- **Simple checks**: `pkg/collector/corechecks/ebpf/<check>/<check>.go`
- **Complex/standalone**: `pkg/collector/corechecks/<check>/<check>.go`
- Typical pattern: Check fetches stats from system-probe module via HTTP and emits metrics

**Note**: Some complex features may not have an agent check if they only run in system-probe (pure telemetry/background processing).

### System-Probe Module

See `cmd/system-probe/modules/AGENTS.md` for module factory, router, and lifecycle details. Files typically live in `cmd/system-probe/modules/<check>.go` with `//go:build linux && linux_bpf`.

## Common Patterns

### eBPF C Code Header Template

```c
#ifndef __<CHECK>_KERN_USER_H
#define __<CHECK>_KERN_USER_H

#include "ktypes.h"

struct stats_key {
    char cgroup[128];
    __u32 field1;
    __u64 field2;
};

struct stats_value {
    __u64 count;
};

#endif
```

**Important**: Always use `__u32`, `__u64`, etc. (double underscore) and include `ktypes.h`.

### Go Generate Directives

```go
//go:generate $GOPATH/bin/include_headers pkg/collector/corechecks/ebpf/c/runtime/<check>-kern.c pkg/ebpf/bytecode/build/runtime/<check>.c pkg/ebpf/c
//go:generate $GOPATH/bin/integrity pkg/ebpf/bytecode/build/runtime/<check>.c pkg/ebpf/bytecode/runtime/<check>.go runtime
```

### Tracer Pattern

```go
type Tracer struct {
    m        *manager.Manager
    statsMap *ebpfmaps.GenericMap[StructStatsKey, []StructStatsValue]
}

func NewTracer(cfg *ebpf.Config) (*Tracer, error) {
    if cfg.EnableCORE {
        probe, err := loadCOREProbe(cfg)
        if err != nil && !cfg.AllowRuntimeCompiledFallback {
            return nil, fmt.Errorf("error loading CO-RE probe: %w", err)
        }
        if err == nil {
            return probe, nil
        }
        log.Warnf("CO-RE failed, falling back to runtime compilation: %s", err)
    }
    return loadRuntimeCompiledProbe(cfg)
}

func (t *Tracer) GetAndFlush() model.Stats {
    nbCpus, _ := kernel.PossibleCPUs()
    result := make(model.Stats)

    var statsKey StructStatsKey
    var keys []StructStatsKey
    statsValue := make([]StructStatsValue, nbCpus)

    it := t.statsMap.Iterate()
    for it.Next(&statsKey, &statsValue) {
        // Aggregate per-CPU values
        var total uint64
        for cpu := 0; cpu < nbCpus; cpu++ {
            total += statsValue[cpu].Count
        }

        result[convertKey(statsKey)] = model.Value{Count: total}
        keys = append(keys, statsKey)
    }

    // Clean up
    for _, k := range keys {
        t.statsMap.Delete(&k)
    }

    return result
}
```

### System-Probe Module Pattern

```go
var MyModule = &module.Factory{
    Name:             config.MyModuleName,
    ConfigNamespaces: []string{},
    Fn: func(_ *sysconfigtypes.Config, _ module.FactoryDependencies) (module.Module, error) {
        t, err := probe.NewTracer(ebpf.NewConfig())
        if err != nil {
            return nil, fmt.Errorf("unable to start tracer: %w", err)
        }
        return &myModule{Tracer: t}, nil
    },
    NeedsEBPF: func() bool { return true },
}

type myModule struct {
    *probe.Tracer
    lastCheck atomic.Int64
}

func (m *myModule) Register(httpMux *module.Router) error {
    httpMux.HandleFunc("/check", func(w http.ResponseWriter, _ *http.Request) {
        m.lastCheck.Store(time.Now().Unix())
        stats := m.Tracer.GetAndFlush()
        utils.WriteAsJSON(w, stats, utils.CompactOutput)
    })
    return nil
}

func (m *myModule) GetStats() map[string]interface{} {
    return map[string]interface{}{
        "last_check": m.lastCheck.Load(),
    }
}
```

## Build System Integration Checklist

When adding a new eBPF check, update `tasks/system_probe.py`. The specific function depends on your check type:

### Simple Checks

Use `ninja_container_integrations_ebpf_programs()` (line ~413):

```python
container_integrations_co_re_programs = ["oom-kill", "tcp-queue-length", "ebpf", "seccomp-tracer"]
```

- File must be in `pkg/collector/corechecks/ebpf/c/runtime/<check>-kern.c`
- Automatically builds CO-RE and debug versions
- **Pattern**: Simple, single-purpose checks
- **Examples**: oom-kill, tcp-queue-length, seccomp-tracer

### Complex/Standalone Features

Create or use a dedicated `ninja_<feature>_ebpf_programs()` function:

**Example - GPU monitoring** (line ~399):

```python
def ninja_gpu_ebpf_programs(nw: NinjaWriter, co_re_build_dir: Path | str):
    gpu_headers_dir = Path("pkg/gpu/ebpf/c")
    gpu_c_dir = gpu_headers_dir / "runtime"
    gpu_flags = f"-I{gpu_headers_dir} -I{gpu_c_dir} -Ipkg/network/ebpf/c"
    gpu_programs = ["gpu"]

    for prog in gpu_programs:
        infile = os.path.join(gpu_c_dir, f"{prog}.c")
        outfile = os.path.join(co_re_build_dir, f"{prog}.o")
        ninja_ebpf_co_re_program(nw, infile, outfile, {"flags": gpu_flags})
        # Build debug version
        root, ext = os.path.splitext(outfile)
        ninja_ebpf_co_re_program(nw, infile, f"{root}-debug{ext}", {"flags": gpu_flags + " -DDEBUG=1"})
```

Then call it in `ninja_generate()` (line ~653):

```python
ninja_gpu_ebpf_programs(nw, co_re_build_dir)
```

### Runtime Compiler Files (Optional)

**Runtime compilation is optional** if your check can rely entirely on CO-RE programs (kernels 5.4+ with BTF). For broader kernel compatibility, provide a runtime compilation fallback:

```python
runtime_compiler_files = {
    "pkg/path/to/your_check.go": "output-name",
}
```

**Note**: Most production checks include runtime compilation for older kernel support, but CO-RE-only is acceptable if your use case targets modern kernels.

**Examples**:

```python
# Simple checks
"pkg/collector/corechecks/ebpf/probe/oomkill/oom_kill.go": "oom-kill",
"pkg/collector/corechecks/ebpf/probe/seccomptracer/seccomp_tracer.go": "seccomp-tracer",

# Complex/standalone
"pkg/gpu/compile.go": "gpu",
```

### CGO Type Files (Optional)

**Only if you use CGO types** for BPF map keys/values:

```python
def_files = {
    "pkg/path/to/your_kern_types.go": [
        "pkg/path/to/your-header.h",
    ],
}
```

**Examples**:

```python
# Simple checks
"pkg/collector/corechecks/ebpf/probe/tcpqueuelength/tcp_queue_length_kern_types.go": [
    "pkg/collector/corechecks/ebpf/c/runtime/tcp-queue-length-kern-user.h",
],

# Complex/standalone
"pkg/gpu/ebpf/kprobe_types.go": [
    "pkg/gpu/ebpf/c/types.h",
],
```

## Configuration Registration

### System-Probe Configuration

#### Step 1: Add Module Name

In `pkg/system-probe/config/config.go`:

```go
const (
    YourCheckModule types.ModuleName = "your_check"
)
```

#### Step 2: Bind Configuration

In `pkg/config/setup/system_probe.go`:

```go
const yourCheckNS = "your_check"
cfg.BindEnvAndSetDefault(join(yourCheckNS, "enabled"), false)
// Add any additional config options:
cfg.BindEnvAndSetDefault(join(yourCheckNS, "option1"), defaultValue)
```

### Agent Check Registration

If your system-probe module has an agent-side component (most do), see `.cursor/rules/agent_corecheck.mdc` for complete details on:

- Creating check configuration files (`conf.yaml.example` or `conf.yaml.default`)
- Parsing configuration in Go
- Registering the check in `pkg/commonchecks/corechecks_sysprobe.go`
- Adding to autodiscovery static config listener
- Adding to `tasks/agent.py` build system

**Quick summary for system-probe checks**: Add check registration to `pkg/commonchecks/corechecks_sysprobe.go` and autodiscovery listener if needed.

## Testing Patterns

### Test Suite Structure

```go
//go:build linux_bpf

type myCheckTestSuite struct {
    suite.Suite
}

func TestMyCheck(t *testing.T) {
    ebpftest.TestBuildModes(t, []ebpftest.BuildMode{ebpftest.CORE, ebpftest.RuntimeCompiled}, "",
        func(t *testing.T) {
            suite.Run(t, new(myCheckTestSuite))
        })
}

func (s *myCheckTestSuite) getTracer() *Tracer {
    t := s.T()
    cfg := ebpf.NewConfig()
    tracer, err := NewTracer(cfg)
    require.NoError(t, err)
    t.Cleanup(tracer.Close)
    return tracer
}

func (s *myCheckTestSuite) TestCanLoad() {
    s.getTracer() // Just verify it loads
}
```

### Running Tests

```bash
# Run with proper command
dda inv system-probe.test -s -p ./pkg/collector/corechecks/ebpf/probe/yourcheck

# Run specific test
dda inv system-probe.test -s -p ./pkg/path -r TestName

# Build object files first if needed
dda inv system-probe.build-object-files
```

## Quick Command Reference

```bash
# Build eBPF object files
dda inv system-probe.object-files

# Build system-probe binary
dda inv system-probe.build

# Run tests (handles privileges internally, no sudo needed)
dda inv system-probe.test -p <path>

# Generate runtime compilation files
go generate ./pkg/collector/corechecks/ebpf/probe/<check>/<check>.go

# Generate CGO types
cd pkg/collector/corechecks/ebpf/probe/<check> && \
  CC=clang go tool cgo -godefs -- \
  -I ../../../../../network/ebpf/c -I ../../../../../ebpf/c \
  -fsigned-char <check>_kern_types.go | \
  go run /path/to/genpost.go <check>_kern_types_linux_test <package> \
  > <check>_kern_types_linux.go

# Check for linter errors
dda inv linter.go --targets=./pkg/collector/corechecks/ebpf/<check>
```

## eBPF C Code Best Practices

### Use Per-CPU Maps

```c
BPF_PERCPU_HASH_MAP(stats_map, struct stats_key, struct stats_value, 1024)
```

Avoids lock contention, requires aggregation in Go.

### Atomic Operations for Counters

```c
__sync_fetch_and_add(&value->count, 1);
```

### Cgroup Extraction

```c
#include "cgroup.h"

struct stats_key k = {};
if (!get_cgroup_name(k.cgroup, sizeof(k.cgroup))) {
    return 0; // Failed to get cgroup
}
```

### Proper Kprobe Signature

```c
SEC("kprobe/function_name")
int BPF_KPROBE(kprobe__function_name, arg1_type arg1, arg2_type arg2) {
    // implementation
}
```

## Error Handling Standards

### Wrap Errors with Context

```go
// ❌ Bad
return nil, err

// ✓ Good
return nil, fmt.Errorf("failed to initialize tracer: %w", err)
```

### Log Appropriately

```go
log.Debugf("detailed debug info: %v", detail)
log.Warnf("recoverable issue: %s", issue)
log.Errorf("serious error: %s", err)
```

### Startup Errors vs Runtime Errors

```go
// In agent check
if err != nil {
    return sysprobeclient.IgnoreStartupError(err)
}
```

## Performance Considerations

1. **Use per-CPU maps** for lockless updates
2. **Batch map operations** in GetAndFlush()
3. **Set appropriate map sizes** (don't make them too small)
4. **Use `BPF_ANY`** for map updates when possible
5. **Avoid string operations** in eBPF kernel code

## Build Tags Reference

- `linux_bpf` - eBPF probe implementation
- `linux` - Linux-specific code (checks, utilities)
- `!linux_bpf` - Stub implementations for non-eBPF builds
- `!linux` - Cross-platform stubs

## Key Files to Always Check

When modifying system-probe:

1. ✓ `tasks/system_probe.py` - Build system (choose appropriate `ninja_*_ebpf_programs` function)
2. ✓ `pkg/system-probe/config/config.go` - Module names
3. ✓ `pkg/config/setup/system_probe.go` - Configuration
4. ✓ If agent-side check: See `.cursor/rules/agent_corecheck.mdc` for registration checklist

## Decision Tree: Where Does My Code Go?

eBPF-based system-probe features fall into two categories based on scope and complexity:

**Simple checks** are single-purpose monitoring features that live under `pkg/collector/corechecks/ebpf/`. They're sometimes called "container integration checks" because they typically monitor per-container kernel events. These follow a standardized structure documented in `pkg/collector/corechecks/ebpf/AGENTS.md`.

**Complex/standalone features** are multi-component systems that deserve their own top-level package (e.g., `pkg/gpu/`, `pkg/network/`). They may have multiple eBPF programs, significant non-eBPF logic, or serve as infrastructure for other components.

### Simple Checks Pattern

**When to use**:
- Single kernel event or metric (e.g., OOM kills, TCP queue depth)
- One eBPF program with straightforward map aggregation
- Primarily emits metrics to Datadog backend
- Container-focused monitoring

**File structure**:
- eBPF: `pkg/collector/corechecks/ebpf/c/runtime/<check>-kern.c`
- Probe: `pkg/collector/corechecks/ebpf/probe/<check>/`
- Check: `pkg/collector/corechecks/ebpf/<check>/`
- Module: `cmd/system-probe/modules/<check>.go`
- Build: Add to `ninja_container_integrations_ebpf_programs()`

**Examples**: oom-kill, tcp-queue-length, seccomp-tracer

**Documentation**: See `pkg/collector/corechecks/ebpf/AGENTS.md` for complete implementation guide.

### Complex/Standalone Pattern

**When to use**:
- Multiple eBPF programs working together
- Significant non-eBPF logic (parsers, state machines, protocol handling)
- Provides infrastructure/APIs for other components
- Would clutter `pkg/collector/corechecks/ebpf/` if placed there

**File structure**:
- eBPF: `pkg/<feature>/ebpf/c/runtime/<program>.c` (or similar)
- Probe: `pkg/<feature>/probe.go` and related files
- Check: `pkg/collector/corechecks/<feature>/` (if agent-side component needed)
- Module: `cmd/system-probe/modules/<feature>.go`
- Build: Create dedicated `ninja_<feature>_ebpf_programs()` function

**Examples**:
- **GPU monitoring** (`pkg/gpu/`): CUDA/kernel event tracking, complex state management
- **Network tracer** (`pkg/network/`): Connection tracking, protocol parsing, service discovery
- **Dynamic instrumentation** (`pkg/dyninst/`): Runtime code injection infrastructure

**Key differences from simple checks**:
- Custom package namespace under `pkg/<feature>/`
- May have subdirectories for organization (e.g., `pkg/gpu/ebpf/`, `pkg/gpu/cuda/`)
- Dedicated build function in `tasks/system_probe.py`
- May not have an agent-side check (pure system-probe feature)
- Often has custom configuration beyond simple enable/disable

## Additional Resources

- eBPF Program Reference: <https://ebpf.io/>
- Datadog eBPF Guidelines: Internal docs
- Build System: See `tasks/system_probe.py` docstrings
- Testing Framework: `pkg/ebpf/ebpftest` package
