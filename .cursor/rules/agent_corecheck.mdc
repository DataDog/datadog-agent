---
description: This rule serves for development of agent core checks.
alwaysApply: false
---

# Creating Agent Core Checks

## Required Interfaces and Boilerplate

Core checks implement the `check.Check` interface. The recommended pattern embeds `core.CheckBase` and exposes a `Factory()` for registration.

```go
package <checkname>

import (
    "fmt"

    "github.com/DataDog/datadog-agent/comp/core/autodiscovery/integration"
    "github.com/DataDog/datadog-agent/pkg/aggregator/sender"
    "github.com/DataDog/datadog-agent/pkg/collector/check"
    core "github.com/DataDog/datadog-agent/pkg/collector/corechecks"
    "github.com/DataDog/datadog-agent/pkg/util/option"
)

const CheckName = "<checkname>"

type Check struct {
    core.CheckBase
    // add your dependencies/state here
}

func Factory() option.Option[func() check.Check] {
    return option.New(func() check.Check { return newCheck() })
}

func newCheck() check.Check {
    return &Check{ CheckBase: core.NewCheckBase(CheckName) }
}

// Configure is called when the check instance is created
func (c *Check) Configure(senderManager sender.SenderManager, _ uint64, conf, initConf integration.Data, source string) error {
    if err := c.CommonConfigure(senderManager, initConf, conf, source); err != nil {
        return fmt.Errorf("configure %s: %w", CheckName, err)
    }
    // parse conf/initConf if needed, initialize deps
    return nil
}

// Run is called on each scheduled execution
func (c *Check) Run() error {
    s, err := c.GetSender()
    if err != nil {
        return fmt.Errorf("get sender: %w", err)
    }
    // collect data
    value := 1.0
    tags := []string{"example:tag"}
    s.Gauge("<namespace>.<metric>", value, "", tags)
    // optionally: s.Rate, s.Count, s.MonotonicCount, s.Gauge, s.Distribution
    // optionally: s.ServiceCheck("<sc_name>", status, host, tags, message)
    // optionally: s.Event(event)
    s.Commit()
    return nil
}

// Interval is optional; use config or default scheduler interval if not set
// func (c *Check) Interval() time.Duration { return 15 * time.Second }
```

Key points:

- Always wrap errors with context using `fmt.Errorf("...: %w", err)`.
- Call `CommonConfigure` in `Configure`.
- Acquire a `Sender` via `GetSender()` inside `Run()` and call `Commit()` once per run.
- Use a constant `CheckName` as the public identifier.

---

## Submitting Data

Use the `sender.Sender` API obtained via `GetSender()`:

```go
// Metrics
s.Gauge("<ns>.<metric>", 42.0, "", []string{"k:v"})
s.Count("<ns>.<count>", 1, "", nil)
s.Rate("<ns>.<rate>", 3.14, "", nil)
s.Distribution("<ns>.<distr>", 7.0, "", nil)

// Service checks
// status: servicecheck.ServiceCheckOK/WARNING/CRITICAL/UNKNOWN
// s.ServiceCheck("<ns>.<sc>", status, "", []string{"k:v"}, "message")

// Events
// e := &metrics.Event{Title: "title", Text: "text", Tags: []string{"k:v"}}
// s.Event(e)

s.Commit()
```

Guidelines:

- Keep metric namespaces consistent (e.g., `<product>.<feature>.<metric>`).
- Prefer stable tag keys; avoid high-cardinality values unless necessary.
- Submit all points before a single `Commit()` call.

---

## Configuration Files

### Creating Config Templates

Create a configuration template file in `cmd/agent/dist/conf.d/<checkname>.d/`:

**For manually-enabled checks** (most checks), create `conf.yaml.example`:

```yaml
init_config:
    ## @param global_option - type - optional - default: value
    ## Description of the global option that applies to all instances.
    #
    # global_option: value

instances:
  - ## @param required_param - string - required
    ## Description of a required parameter.
    #
    required_param: <VALUE>

    ## @param optional_param - integer - optional - default: 60
    ## Description of an optional parameter with a default value.
    #
    # optional_param: 60

    ## @param list_param - list of strings - optional
    ## Description of a list parameter.
    #
    # list_param:
    #   - item1
    #   - item2

    ## @param tags - list of strings following the pattern: "key:value" - optional
    ## List of tags to attach to every metric, event, and service check emitted by this integration.
    ##
    ## Learn more about tagging: https://docs.datadoghq.com/tagging/
    #
    # tags:
    #   - <KEY_1>:<VALUE_1>
    #   - <KEY_2>:<VALUE_2>
```

**For Autodiscovery-enabled checks**, create `conf.yaml.default`:

```yaml
ad_identifiers:
  - <container_image_or_identifier>
instances:
  - {}
```

The annotation format `## @param name - type - required/optional - default: value` is used for documentation generation. Users will copy the example/default to `/etc/datadog-agent/conf.d/<checkname>.d/conf.yaml` and uncomment/customize values.

### Parsing Configuration in Go

Define structs for your configuration and parse using `yaml.Unmarshal`:

```go
package checkname

import (
    "fmt"
    "gopkg.in/yaml.v2"
    "github.com/DataDog/datadog-agent/comp/core/autodiscovery/integration"
)

// Instance config for each instance in the config file
type instanceConfig struct {
    RequiredParam string   `yaml:"required_param"`
    OptionalParam int      `yaml:"optional_param"`
    ListParam     []string `yaml:"list_param"`
}

// Init config applies to all instances
type initConfig struct {
    GlobalOption string `yaml:"global_option"`
}

// Combined config structure
type checkConfig struct {
    instance instanceConfig
    initConf initConfig
}

func (c *checkConfig) parse(instanceData, initData integration.Data) error {
    // Set defaults before unmarshalling
    c.instance.OptionalParam = 60  // default value

    // Parse init_config
    if err := yaml.Unmarshal(initData, &c.initConf); err != nil {
        return fmt.Errorf("parse init_config: %w", err)
    }

    // Parse instance config
    if err := yaml.Unmarshal(instanceData, &c.instance); err != nil {
        return fmt.Errorf("parse instance: %w", err)
    }

    // Validate required fields
    if c.instance.RequiredParam == "" {
        return fmt.Errorf("required_param is required")
    }

    return nil
}

// Configure method in your check
func (c *Check) Configure(senderManager sender.SenderManager, _ uint64, instanceData, initData integration.Data, source string) error {
    // Parse check-specific config
    cfg := &checkConfig{}
    if err := cfg.parse(instanceData, initData); err != nil {
        return fmt.Errorf("config parse failed: %w", err)
    }
    c.cfg = cfg

    // Always call CommonConfigure for standard options
    if err := c.CommonConfigure(senderManager, initData, instanceData, source); err != nil {
        return fmt.Errorf("common configure: %w", err)
    }

    return nil
}
```

### Common Configuration Options

`CommonConfigure` automatically handles these standard options:

- `min_collection_interval` (int) - Collection interval in seconds
- `empty_default_hostname` (bool) - Disable default hostname
- `tags` ([]string) - Custom tags for this check instance
- `service` (string) - Service name override
- `no_index` (bool) - Skip metric indexing

These options are available in all checks without additional code.

---

## Registration (Make the Check Runnable)

### 1. Register the check implementation

Add a `RegisterCheck` line in the appropriate registration file:

```go
// In pkg/commonchecks/corechecks.go (or dedicated area file like corechecks_sysprobe.go)
import (
    corecheckLoader "github.com/DataDog/datadog-agent/pkg/collector/corechecks"
    "github.com/DataDog/datadog-agent/pkg/collector/corechecks/<checkname>"
)

func RegisterChecks(/* existing deps */) {
    // ... existing registrations ...
    corecheckLoader.RegisterCheck(<checkname>.CheckName, <checkname>.Factory())
}
```

Notes:

- Look for an existing registration function for your feature area; many checks are registered in `pkg/commonchecks/corechecks.go` or area-specific files.
- Some checks require components (e.g., tagger, telemetry, workloadmeta). Match the signature used by neighboring checks and pass the same dependencies into your `Factory` if needed.

### 2. Register in build system

Add your check name to `tasks/agent.py` in the `AGENT_CORECHECKS` list:

```python
AGENT_CORECHECKS = [
    "containerd",
    "cpu",
    # ... other checks ...
    "<checkname>",  # ADD YOUR CHECK HERE
    # ... rest of list ...
]
```

This ensures the configuration files are copied to `cmd/agent/dist/conf.d/` during the build process. Without this step, your configuration template won't be included in the agent package.

---

## Build Tags and Stubs (Optional)

If your check is platform-specific, guard files with build tags and provide stubs:

```go
//go:build linux
```

Provide a `stub.go` with a `Factory()` returning `option.None[...]()` and a warning log for unsupported platforms.

---

## Ensuring the Check Runs

1. Add the config template in `cmd/agent/dist/conf.d/<checkname>.d/conf.yaml.example` (or `.default` for Autodiscovery).
2. Add check name to `AGENT_CORECHECKS` list in `tasks/agent.py`.
3. Confirm registration is in a file that compiles in your agent flavor/build tags.
4. Build the Agent:

   ```bash
   dda inv agent.build --build-exclude=systemd
   ```

5. Create a dev config and run the Agent:

   ```bash
   echo "api_key: 0000001" > dev/dist/datadog.yaml
   # Copy and customize the config template if needed
   cp bin/agent/dist/conf.d/<checkname>.d/conf.yaml.example bin/agent/dist/conf.d/<checkname>.d/conf.yaml
   ./bin/agent/agent run -c bin/agent/dist/datadog.yaml
   ```

6. Validate the check can run:

   ```bash
   ./bin/agent/agent check <checkname>
   ```

If the check renders output or errors, iterate on `Run()` and configuration accordingly.

---

## Testing

Add standard Go tests under your package:

```go
func TestRun(t *testing.T) {
    c := newCheck().(*Check)
    // You can inject a test sender using mocksender if needed
    // s := mocksender.NewMockSender(c.ID())
    // s.SetupAcceptAll()
    // c.SetSender(s)
    err := c.Run()
    if err != nil {
        t.Fatalf("run failed: %v", err)
    }
}
```

For configuration parsing, unit test `Configure` with representative `integration.Data` payloads.

---

## Style and Error Handling

- Wrap errors with context: `fmt.Errorf("<action> <subject>: %w", err)`.
- Avoid deep nesting; prefer guard clauses.
- Use meaningful metric names and tags; keep cardinality under control.
- Follow existing code formatting and conventions in this repository.

---

## Quick Checklist

- [ ] `pkg/collector/corechecks/<checkname>/<checkname>.go` with `Check`, `Factory`, `Configure`, `Run`
- [ ] Registration via `corecheckLoader.RegisterCheck(...)` in `pkg/commonchecks/corechecks.go`
- [ ] Add check name to `AGENT_CORECHECKS` list in `tasks/agent.py`
- [ ] `cmd/agent/dist/conf.d/<checkname>.d/conf.yaml.example` (or `.default` for Autodiscovery)
- [ ] Optional: platform build tags and stubs
- [ ] Unit tests for `Run()` and `Configure`

---

## References in Repository

- Registration pattern: `pkg/commonchecks/corechecks.go`
- Sender API: `pkg/aggregator/sender`
- Core check base: `pkg/collector/corechecks`
- Example checks:
  - Simple check: `pkg/collector/corechecks/system/cpu/cpu.go`
  - Check with configuration: `pkg/collector/corechecks/net/ntp/ntp.go`
  - Example config files: `cmd/agent/dist/conf.d/ntp.d/conf.yaml.default`, `cmd/agent/dist/conf.d/network_path.d/conf.yaml.example`
  - Complex checks: `pkg/collector/corechecks/network/*`, `pkg/collector/corechecks/gpu/*`
