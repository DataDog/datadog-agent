# Global build settings

load("@bazel_lib//lib:write_source_files.bzl", "write_source_file")
load("@bazel_skylib//rules:common_settings.bzl", "string_flag")
load("@bazel_skylib//rules:run_binary.bzl", "run_binary")
load("@gazelle//:def.bzl", "gazelle")

package(default_visibility = ["//visibility:public"])

# gazelle:prefix github.com/DataDog/datadog-agent
gazelle(
    name = "gazelle",
    args = ["-external=static"],  # don't use the network: https://github.com/bazel-contrib/bazel-gazelle/issues/1385
)

# bazel run //:go -- ...
alias(
    name = "go",
    actual = "@rules_go//go",
)

# bazel run //:go_mod_tidy_all -- -x
alias(
    name = "go_mod_tidy_all",
    actual = "//bazel/tools:go_mod_tidy_all",
)

run_binary(
    name = "gen_go_work",
    srcs = [
        ":go.work",
        ":modules.yml",
    ],
    outs = ["go.work.new"],
    args = [
        "--path",
        "$(location go.work)",
        "--modules-file",
        "$(location modules.yml)",
        "--output",
        "$(location go.work.new)",
    ],
    tool = "//internal/tools/worksynchronizer",
)

# bazel run //:write_go_work
write_source_file(
    name = "write_go_work",
    in_file = ":gen_go_work",
    out_file = "go.work",
)

filegroup(
    name = "python_version",
    srcs = [".python-version"],
)

config_setting(
    name = "macos_arm64",
    constraint_values = [
        "@platforms//os:macos",
        "@platforms//cpu:arm64",
    ],
)

config_setting(
    name = "macos_x86_64",
    constraint_values = [
        "@platforms//os:macos",
        "@platforms//cpu:x86_64",
    ],
)

config_setting(
    name = "linux_x86_64",
    constraint_values = [
        "@platforms//os:linux",
        "@platforms//cpu:x86_64",
    ],
)

config_setting(
    name = "linux_arm64",
    constraint_values = [
        "@platforms//os:linux",
        "@platforms//cpu:arm64",
    ],
)

config_setting(
    name = "windows_x86_64",
    constraint_values = [
        "@platforms//os:windows",
        "@platforms//cpu:x86_64",
    ],
)

# The location that the bulk of the agent gets installed to. Like most *nix tools, this
# is in /opt. That will hold shared libraries, and python packages.  It is not the
# complete installation, becuase some things go to /etc or /usr.
#
# Migration to bazel warning:
# The goal we are aiming for is that output base is always passed to build
# scripts and we install artifacts to output_base + install_dir. Unfortunately,
# many existing scripts only use install_dir, without regard to a a base. They
# put etc files under opt/datadog, then move them to /etc in the final part of the
# build.
# TODO: We need to learn how people expect to use install dir to create custom
# builds for local testing that do not wipe out their local installation.
string_flag(
    name = "install_dir",
    build_setting_default = "/opt/datadog-agent",
    make_variable = "INSTALL_DIR",
)

# Configuration value to determine if we are using the standard install path.
# This can be used to detect custom builds, where we might not to create some pieces.
# Currently this is used only for installer symlinks. It is likely that we should not
# continue to do that. My hunch is that it was only done to prevent disk stomping in
# developer builds.
config_setting(
    name = "is_standard_install",
    flag_values = {
        "//:install_dir": "/opt/datadog-agent",
    },
)

# This seems to be the base of where to write config files during
# the build. That is, if we were creating /etc/foo, it would be
# the path prepended to /etc to get a safe place to write.
# We can set this from the omnibus variable OUTPUT_CONFIG_DIR.
# But, it seems to be empty in CI runs, so we end up writing to /.
# The default is /tmp so we don't shoot our feet off in local testing.
# If we end up keeping this flag, let's give it a better name and
# git it a better value.
string_flag(
    name = "output_config_dir",
    build_setting_default = "/tmp",
    make_variable = "OUTPUT_CONFIG_DIR",
)
