load("@@//bazel/rules:dd_agent_expand_template.bzl", "dd_agent_expand_template")
load("@//deps/openssl:version.bzl", "OPENSSL_VERSION")
load("@bazel_lib//lib:copy_to_directory.bzl", "copy_to_directory")
load("@bazel_lib//lib:run_binary.bzl", "run_binary")
load("@bazel_skylib//rules:select_file.bzl", "select_file")
load("@rules_foreign_cc//foreign_cc:defs.bzl", "configure_make")
load("@rules_pkg//pkg:install.bzl", "pkg_install")
load("@rules_pkg//pkg:mappings.bzl", "REMOVE_BASE_DIRECTORY", "pkg_attributes", "pkg_filegroup", "pkg_files", "pkg_mklink")

# Keep in sync with the ones on repos.MODULE.bazel
python_externals = {
    "bzip2": "1.0.8",
    "mpdecimal": "4.0.0",
    "sqlite": "3.50.4.0",
    "xz": "5.2.5",
    "zlib": "1.3.1",
    "libffi": "3.4.4",
    "tcltk": "8.6.15.0",
}

VERSION_STR = "3.13"
VERSION_STR_FLAT = VERSION_STR.replace(".", "")

# These rules will make it easier to get a reference to their folder via $(location)
# and they add the version in the folder name (as some of the vcxproj stuff relies on that)
[
    copy_to_directory(
        name = "{}_win_dir".format(dep),
        srcs = ["@{}_win".format(dep)],
        out = "{}-{}".format(dep, version),
        include_external_repositories = ["*"],
    )
    for dep, version in python_externals.items()
]

# This sets up OpenSSL files in a layout such as the Python build system for Windows expects
copy_to_directory(
    name = "openssl-bin_win_dir",
    srcs = ["@openssl"],
    # TODO(team:agent-build): Single source of truth for dependency versions
    out = "openssl-bin-{}/amd64".format(OPENSSL_VERSION),
    include_external_repositories = ["*openssl*"],
    # This reproduces the expected layout (libs at root, includes under `include`)
    root_paths = [
        "openssl/bin",
        "openssl/lib",
        "openssl",
    ],
)

run_binary(
    name = "python_win",
    srcs = (
        glob(
            ["**"],
            exclude = ["**/*.pyc", "BUILD.bazel"],
        ) + [
            "bzip2_win_dir",
            "mpdecimal_win_dir",
            "sqlite_win_dir",
            "xz_win_dir",
            "zlib_win_dir",
            "libffi_win_dir",
            "openssl-bin_win_dir",
            "tcltk_win_dir",
            "@visual_studio//:msbuild",
        ]
    ),
    env = {
        "PROCESSOR_ARCHITECTURE": "AMD64",
        # Input and output paths
        "SRCFILE": r"$(location LICENSE)",  # Any file at the root of the repo works here
        "OUTDIR": "$(@D)/build",
        # Paths to dependencies:
        "BZ2_DIR": "$(location bzip2_win_dir)",
        "MPDECIMAL_DIR": "$(location mpdecimal_win_dir)",
        "SQLITE3_DIR": "$(location sqlite_win_dir)",
        "XZ_DIR": "$(location xz_win_dir)",
        "ZLIB_DIR": "$(location zlib_win_dir)",
        "LIBFFI_DIR": "$(location libffi_win_dir)",
        "OPENSSL_DIR": r"$(location openssl-bin_win_dir)",
        "TCLTK_DIR": r"$(location tcltk_win_dir)\amd64",
        "TCL_VERSION": python_externals["tcltk"],
        "MSBUILD": "$(location @visual_studio//:msbuild)",
    },
    outs = [
        "build/{}".format(file)
        for file in [
            "python.exe",
            "python3.dll",
            "python{}.dll".format(VERSION_STR_FLAT),
            "pythonw.exe",
            "vcruntime140.dll",
            "vcruntime140_1.dll",
            "LICENSE.txt",
        ]
    ],
    out_dirs = [
        "build/{}".format(dir)
        for dir in [
            "DLLs",
            "include",
            "Lib",
            "libs",
            "Scripts",
        ]
    ],
    tool = "build_python.bat",
    visibility = ["//visibility:public"],
)

filegroup(
    name = "all_srcs",
    srcs = glob(["**"], exclude = ["BUILD.bazel"]),
)

UNIX_BINS = [
    "pip{}".format(VERSION_STR),
    "python{}".format(VERSION_STR),
]

LINUX_SO = "libpython{}.so.1.0".format(VERSION_STR)
MACOS_DYLIB = "libpython{}.dylib".format(VERSION_STR)

python_deps = {
    "libffi": "-lffi",
    "libsqlite3": "-lsqlite3",
    "zlib": "-lz",
    "bzip2": "-lbz2",
    "liblzma": "-llzma",
}

# The list of build tools we want to override in sysconfigdata.py
# as they will not be available when building custom integrations without bazel
to_override_build_tools = [
    "ar",
    "gcc",
    "g++",
    "ld",
]

to_override_flags = [
    "CFLAGS",
    "CXXFLAGS",
    "LDFLAGS",
]

configure_make(
    name = "python_unix",
    configure_options = [
        "--enable-ipv6",
        "--with-ensurepip=yes",
        "--enable-shared",
        "--without-static-libpython",
        "--with-dbmliborder=",
        # Fixes an issue with __DATE__ being set to undefined `redacted`
        # https://github.com/bazelbuild/rules_foreign_cc/issues/239#issuecomment-478167267
        "CPPFLAGS='-Dredacted=\\\"redacted\\\"'",
        "--with-openssl=$$EXT_BUILD_DEPS/openssl",
        "--with-openssl-rpath=yes",
    ] + select({
        "@@//:macos_arm64": ["--with-universal-archs=universal2"],
        "@@//:macos_x86_64": ["--with-universal-archs=intel"],
        "//conditions:default": [],
    }),
    copts = [
        "-O2",
    ],
    env = {
        "OPT": "-DNDEBUG -fwrapv",
        # Ensure we don't use the system provided .pc
        "PKG_CONFIG_LIBDIR": "/does/not/exist",
        # We need to pass linker flags here instead of `linkopts` because we don't want these to be
        # propagated to dependent targets, as `linkopts` would do.
        # This is meant to allow python to find its dependency during its modules import test.
        # We will use the install_dir rpath later on
        "LDFLAGS": "-Wl,-rpath,$$EXT_BUILD_DEPS/lib",
    } | {
        dep.upper() + "_CFLAGS": "-I$$EXT_BUILD_DEPS/include"
        for dep in python_deps.keys()
    } | {
        dep.upper() + "_LIBS": lib
        for dep, lib in python_deps.items()
    } | select({
        "@platforms//os:macos": {
            # https://github.com/bazelbuild/bazel/issues/5127
            "AR": "/usr/bin/ar",
        },
        "//conditions:default": {},
    }),
    lib_source = ":all_srcs",
    out_binaries = UNIX_BINS,
    out_data_dirs = [
        "lib/python{}".format(VERSION_STR),
    ],
    out_data_files = select({
        "@platforms//os:linux": [
            # Even though this is a shared lib, we generally don't want to link against this.
            # When linking against Python, one must decide between the "Stable" API (libpython3.so)
            # or the minor-version specific libpython3.y.so. In the context of the Agent, we've always
            # linked against the latter, but shipped both (in case there are extension modules requiring
            # the Stable API). Therefore, we mark this one as "data".
            # See https://peps.python.org/pep-0384/#linkage
            "lib/libpython3.so",
        ],
        "@platforms//os:macos": [],
    }),
    out_shared_libs = select({
        "@platforms//os:linux": [
            LINUX_SO,
        ],
        "@platforms//os:macos": [
            MACOS_DYLIB,
        ],
    }),
    out_include_dir = "include",
    visibility = ["//visibility:public"],
    deps = [
        "@bzip2//:libbz2",
        "@libffi//:ffi",
        "@openssl//:openssl",
        "@sqlite3//:libsqlite3",
        "@xz//:liblzma",
        "@zlib//:zlib",
    ],
    dynamic_deps = [
        "@bzip2//:bz2",
        "@sqlite3//:sqlite3",
        "@xz//:lzma",
        "@zlib//:z",
    ],
    includes = ["python{}".format(VERSION_STR)],
    targets = [
        # Build in parallel but install without parallel execution
        # (see https://github.com/python/cpython/issues/109796)
        "-j 16",
        "install",
    ],
    target_compatible_with = select({
        "@platforms//os:macos": [],
        "@platforms//os:linux": [],
        "//conditions:default": ["@platforms//:incompatible"],
    }),
    # python's build system will output the entire build config to _sysconfigdata_xxx.py
    # This is later used to build extensions with the same tools/compiler/flags/config as the interpreter
    # However, in our case, that means using tools that are stored in the build sandbox, so they aren't
    # usable when building an extension, causing all builds to fail.
    # Ideally we would want to explicitly replace bazel paths with known alternatives, but we don't
    # have an environment variable holding the value we want to replace so we have to resort to
    # a regular expression replacing paths to tools.
    # We also unset the flags listed in to_override_flags.
    # If we start using some specific build flags that need to be propagated, we will need to include
    # them here instead of replacing them by an empty string.
    postfix_script = " && ".join([
                         "perl -i -pe 's/(:?[a-zA-Z0-9_+.\\/-]+)\\/{tool}\\b/{tool}/g' $$INSTALLDIR/lib/python{version}/_sysconfigdata__*.py".format(
                             tool = tool,
                             version = VERSION_STR,
                         )
                         for tool in to_override_build_tools
                     ]) + " && " +
                     " && ".join([
                         "perl -i -pe \"s/\'{flag}\': \'.*\',$$/\'{flag}\': \'\',/g\" $$INSTALLDIR/lib/python{version}/_sysconfigdata__*.py".format(
                             flag = flag,
                             version = VERSION_STR,
                         )
                         for flag in to_override_flags
                     ]),
)

pkg_files(
    name = "install_files_win",
    srcs = [":python_win"],
)

# We resort to select_file here instead of picking the output groups with filegroup
# because configure_make names its output groups by "basename", for which we have a conflict:
# both the versioned python binary as well as the library root (under lib) share the same name.
# select_file lets us be more specific and remove ambiguity
select_file(
    name = "python_lib_dir_group_unix",
    srcs = ":python_unix",
    subpath = "lib/python{}".format(VERSION_STR),
)

select_file(
    name = "python3_bin",
    srcs = ":python_unix",
    subpath = "bin/python{}".format(VERSION_STR),
)

# Using a copy here is the most convenient way to exclude a bunch of things for the final package
copy_to_directory(
    name = "python_lib_dir_unix",
    srcs = [":python_lib_dir_group_unix"],
    exclude_srcs_patterns = [
        "test/**/*",
        "**/*.exe",
        "**/Makefile",
    ],
    root_paths = ["python_unix/lib/python{}".format(VERSION_STR)],
    out = "python{}".format(VERSION_STR),
)

filegroup(
    name = "pip_exec",
    srcs = [":python_unix"],
    output_group = "pip{}".format(VERSION_STR),
)

genrule(
    name = "patch_pip_shebang",
    srcs = [":pip_exec"],
    outs = ["pip_patched_tmp"],
    cmd = "{ echo '#!{install_dir}/embedded/bin/python3\n' ; tail -n +4 $(location :pip_exec) ;} > $@",
)

dd_agent_expand_template(
    name = "patch_pip_interpreter",
    template = ":patch_pip_shebang",
    out = "pip{}".format(VERSION_STR),
)

# Create symlinks for libpython (rules_pkg 1.2+ supports symlinks in pkg_install)
pkg_mklink(
    name = "libpython_symlink",
    link_name = "lib/libpython{}.so".format(VERSION_STR),
    target = LINUX_SO,
    attributes = pkg_attributes("0644"),
)

BIN_SYMLINKS = {
    "bin/python3": "python{}".format(VERSION_STR),
    "bin/python": "python3",
    "bin/pip3": "pip{}".format(VERSION_STR),
    "bin/pip": "pip3",
}

[
    pkg_mklink(
        name = "python_bin_symlink_" + target,
        link_name = link,
        target = target,
        attributes = pkg_attributes("0755"),
    )
    for link, target in BIN_SYMLINKS.items()
]

filegroup(
    name = "headers_unix",
    srcs = [":python_unix"],
    output_group = "include",
)

filegroup(
    name = "python_lib_unix",
    srcs = [":python_unix"],
    output_group = select({
        "@platforms//os:linux": LINUX_SO,
        "@platforms//os:macos": MACOS_DYLIB,
    }),
    target_compatible_with = select({
        "@platforms//os:macos": [],
        "@platforms//os:linux": [],
        "//conditions:default": ["@platforms//:incompatible"],
    }),
)

# configure_make doesn't provide output groups for "data files", so we use select_file instead
select_file(
    name = "python_stable_lib_linux",
    srcs = ":python_unix",
    subpath = "lib/libpython3.so",
)

pkg_files(
    name = "install_libs_unix",
    srcs = [
        ":python_lib_dir_unix",
        ":python_lib_unix",
    ] + select({
        "@platforms//os:linux": [":python_stable_lib_linux"],
        "//conditions:default": [],
    }),
    attributes = pkg_attributes("0755"),
    prefix = "lib",
)

pkg_files(
    name = "install_headers_unix",
    srcs = [":headers_unix"],
)

pkg_files(
    name = "install_bins_unix",
    srcs = [
        ":python3_bin",
        ":patch_pip_interpreter",
    ],
    prefix = "bin",
    attributes = pkg_attributes("0755"),
)

pkg_filegroup(
    name = "all_files",
    srcs = select({
        "@platforms//os:windows": [
            ":install_files_win",
        ],
        "//conditions:default": [
            ":install_libs_unix",
            ":install_headers_unix",
            ":install_bins_unix",
        ] + [":python_bin_symlink_" + name for name in BIN_SYMLINKS.values()],
    }) + select({
        "@platforms//os:linux": [":libpython_symlink"],
        "//conditions:default": [],
    }),
    prefix = select({
        "@platforms//os:windows": "embedded3",
        "//conditions:default": "embedded",
    }),
)

pkg_install(
    name = "install",
    srcs = [
        ":all_files",
    ],
)
