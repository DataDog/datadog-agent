// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2024-present Datadog, Inc.

// Package common provides common utilities that are useful when interacting with the tagger.
package common

import (
	"context"
	"strings"

	"github.com/DataDog/datadog-agent/comp/core/config"
	"github.com/DataDog/datadog-agent/pkg/config/env"
	configUtils "github.com/DataDog/datadog-agent/pkg/config/utils"
	"github.com/DataDog/datadog-agent/pkg/util/fargate"
	"github.com/DataDog/datadog-agent/pkg/util/flavor"
	"github.com/DataDog/datadog-agent/pkg/util/kubernetes/clustername"
	"github.com/DataDog/datadog-agent/pkg/util/log"
)

// GetStaticTags gets the "static tags" for this agent.  These are tags
// that are attached directly to everything the agent produces, but _not_
// included in host tags.  In environments with no host metadata (such as where
// the hostname is empty), tags that would otherwise be included in host
// metadata are generated by this function.
func GetStaticTags(ctx context.Context, datadogConfig config.Reader) map[string][]string {
	tags := []string{}

	if flavor.GetFlavor() == flavor.ClusterAgent {
		// DD_CLUSTER_CHECKS_EXTRA_TAGS / DD_ORCHESTRATOR_EXPLORER_EXTRA_TAGS
		tags = append(tags, configUtils.GetConfiguredDCATags(datadogConfig)...)
	}

	if flavor.GetFlavor() == flavor.ClusterAgent || fargate.IsFargateInstance() {
		// Fargate (ECS/EKS) + Cluster Agent does not have host tag resolution so
		// we must manually add the following tags that are typically host tags.

		// DD_TAGS / DD_EXTRA_TAGS
		tags = append(tags, configUtils.GetConfiguredTags(datadogConfig, false)...)

		// kube_cluster_name
		clusterTagNamePrefix := "kube_cluster_name:"
		var tag string
		var found bool
		for _, tag = range tags {
			if strings.HasPrefix(tag, clusterTagNamePrefix) {
				found = true
				break
			}
		}
		if found {
			log.Infof("'%s' was set manually via DD_TAGS, not changing it", clusterTagNamePrefix+tag)
		} else {
			cluster := clustername.GetClusterNameTagValue(ctx, "")
			if cluster == "" {
				log.Infof("Couldn't build the %q.. tag, DD_CLUSTER_NAME can be used to set it", clusterTagNamePrefix)
			} else {
				tags = append(tags, clusterTagNamePrefix+cluster)
			}
		}
	}

	// EKS Fargate specific tags
	if env.IsFeaturePresent(env.EKSFargate) {
		// eks_fargate_node
		node, err := fargate.GetEKSFargateNodename()
		if err != nil {
			log.Infof("Couldn't build the 'eks_fargate_node' tag: %v", err)
		} else {
			tags = append(tags, "eks_fargate_node:"+node)
		}
	}

	return ConvertTagSliceToMap(tags)
}

// ConvertTagSliceToMap converts a slice of tags to a map of tags
// eg. ["key1:value1", "key2:value2", "key1:value3"] -> {"key1": ["value1", "value3"], "key2": ["value2"]}
func ConvertTagSliceToMap(tags []string) map[string][]string {
	tagsMap := make(map[string][]string)
	for _, tag := range tags {
		parts := strings.SplitN(tag, ":", 2)
		if len(parts) != 2 {
			continue
		}
		key := parts[0]
		value := parts[1]
		tagsMap[key] = append(tagsMap[key], value)
	}
	return tagsMap
}
