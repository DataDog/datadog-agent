// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2024-present Datadog, Inc.

package guiimpl

import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/base64"
	"encoding/binary"
	"fmt"
	"strings"
	"time"
)

const tokenVersion = "v1"

// authenticator represents an authentication mechanism.
type authenticator struct {
	duration   time.Duration // The duration for which the authentication token is valid.
	signingKey []byte        // The key used for signing the authentication token.
}

func newAuthenticator(authToken string, duration time.Duration) authenticator {
	return authenticator{
		duration:   duration,
		signingKey: []byte(authToken),
	}
}

func (a *authenticator) GenerateAccessToken() string {
	now := time.Now()
	return hmacToken(a.signingKey, now, now.Add(a.duration))
}

func (a *authenticator) ValidateToken(token string) error {
	// Split the token into the payload and HMAC sum
	parts := strings.Split(token, ".")
	if len(parts) != 3 {
		return fmt.Errorf("invalid token format")
	}

	// Check token version
	if parts[0] != tokenVersion {
		return fmt.Errorf("token version mismatch: got %s, expected %s", parts[0], tokenVersion)
	}

	// Decode the payload from base64
	payloadBytes, err := base64.StdEncoding.DecodeString(parts[1])
	if err != nil {
		return fmt.Errorf("failed to decode payload: %w", err)
	}

	// Ensure the payload contains enough bytes for issued and expiration times
	if len(payloadBytes) < 16 {
		return fmt.Errorf("invalid payload")
	}

	// Extract the issued and expiration times from the payload
	issuedTime := int64(binary.LittleEndian.Uint64(payloadBytes[:8]))
	expirationTime := int64(binary.LittleEndian.Uint64(payloadBytes[8:]))

	// Decode the HMAC sum from base64
	hmacSum, err := base64.StdEncoding.DecodeString(parts[2])
	if err != nil {
		return fmt.Errorf("failed to decode HMAC sum: %w", err)
	}

	// Calculate the expected HMAC sum
	mac := hmac.New(sha256.New, a.signingKey)
	mac.Write(payloadBytes)
	expectedHmacSum := mac.Sum(nil)

	now := time.Now()

	// Check if the current time is before the issued time
	if now.Before(time.Unix(issuedTime, 0)) {
		return fmt.Errorf("token is invalid")
	}

	// special case: ignore expirationTime if duration is equal to 0
	// Check if the current time is after the expiration time
	if expirationTime != issuedTime && now.After(time.Unix(expirationTime, 0)) {
		return fmt.Errorf("token is expired")
	}

	if a.duration != 0 && now.After(time.Unix(issuedTime, 0).Add(a.duration)) {
		return fmt.Errorf("token is expired")
	}

	// Check if the HMAC sum matches the expected HMAC sum
	if !hmac.Equal(hmacSum, expectedHmacSum) {
		return fmt.Errorf("invalid token signature")
	}

	return nil
}

// hmacToken generates an HMAC token using the provided key, issued time, and expiration time.
// The token is generated by converting the issued time and expiration time to base64 unixTime format,
// creating an HMAC sum using the key and payload, and combining the token version, the payload and HMAC sum with a "." separator.
// The generated token is returned as a string.
//
// Token representation:
// +----------------+----------------+--------------------------------+----------------+----------------------------------+
// | Token Version  | "." Separator  | Base64 Encoded Payload         | "." Separator  | Base64 Encoded HMAC Sum          |
// +----------------+----------------+--------------------------------+----------------+----------------------------------+
// | ~3 characters  | 1 character    | ~24 characters                 | 1 character    | ~44 characters                   |
// +----------------+----------------+--------------------------------+----------------+----------------------------------+
// with Payload:
// +----------------+----------------+
// | Issued Time    | Expiration Time|
// +----------------+----------------+
// | 8 bytes        | 8 bytes        |
// +----------------+----------------+
func hmacToken(key []byte, issued time.Time, expiration time.Time) string {
	// Convert the issued time to base64 unixTime format
	payloadBytes := make([]byte, 16)
	binary.LittleEndian.PutUint64(payloadBytes, uint64(issued.Unix()))
	binary.LittleEndian.PutUint64(payloadBytes[8:], uint64(expiration.Unix()))
	payloadBase64 := base64.StdEncoding.EncodeToString(payloadBytes)

	// Create the HMAC sum
	mac := hmac.New(sha256.New, key)
	mac.Write(payloadBytes)
	hmacSum := mac.Sum(nil)

	// Convert the HMAC sum to base64 format
	hmacBase64 := base64.StdEncoding.EncodeToString(hmacSum)

	// Combine the issued time and HMAC sum with a "." separator
	return tokenVersion + "." + payloadBase64 + "." + hmacBase64
}
