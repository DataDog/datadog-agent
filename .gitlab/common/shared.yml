---
# Sets up a cache for gems used by Omnibus
# Usage:
# !reference [.cache_omnibus_ruby_deps, setup] somewhere ahead of invoking bundle
# !reference [.cache_omnibus_ruby_deps, cache] under `cache` for the same job
.cache_omnibus_ruby_deps:
  setup:
    - pushd omnibus && bundle config set --local path 'vendor/bundle' && popd
  cache:
    key:
      files:
        - omnibus/Gemfile
        # This is coarser than needed, but there's no more convenient way
        # to get a hold of OMNIBUS_RUBY_VERSION
        - release.json
      # We still need to add the environment omnibus-related variables so that triggered pipelines
      # don't get undesired cache hits
      prefix: omnibus-deps-$CI_JOB_IMAGE-$CI_JOB_NAME-$OMNIBUS_RUBY_VERSION
    paths:
      - omnibus/vendor/bundle

.setup_macos_github_app:
  # GitHub App rate-limits are per-app.
  # This balances the requests made to GitHub between the two apps we have set up.
  - |
    if [[ "$(( RANDOM % 2 ))" == "1" ]]; then
      GITHUB_KEY_B64=$($CI_PROJECT_DIR/tools/ci/fetch_secret.sh $MACOS_GITHUB_APP_1 key_b64) || exit $?; export GITHUB_KEY_B64
      GITHUB_APP_ID=$($CI_PROJECT_DIR/tools/ci/fetch_secret.sh $MACOS_GITHUB_APP_1 app_id) || exit $?; export GITHUB_APP_ID
      GITHUB_INSTALLATION_ID=$($CI_PROJECT_DIR/tools/ci/fetch_secret.sh $MACOS_GITHUB_APP_1 installation_id) || exit $?; export GITHUB_INSTALLATION_ID
      echo "Using GitHub App instance 1"
    else
      GITHUB_KEY_B64=$($CI_PROJECT_DIR/tools/ci/fetch_secret.sh $MACOS_GITHUB_APP_2 key_b64) || exit $?; export GITHUB_KEY_B64
      GITHUB_APP_ID=$($CI_PROJECT_DIR/tools/ci/fetch_secret.sh $MACOS_GITHUB_APP_2 app_id) || exit $?; export GITHUB_APP_ID
      GITHUB_INSTALLATION_ID=$($CI_PROJECT_DIR/tools/ci/fetch_secret.sh $MACOS_GITHUB_APP_2 installation_id) || exit $?; export GITHUB_INSTALLATION_ID
      echo "Using GitHub App instance 2"
    fi

.setup_agent_github_app:
  - GITHUB_KEY_B64=$($CI_PROJECT_DIR/tools/ci/fetch_secret.sh $AGENT_GITHUB_APP key_b64) || exit $?; export GITHUB_KEY_B64
  - GITHUB_APP_ID=$($CI_PROJECT_DIR/tools/ci/fetch_secret.sh $AGENT_GITHUB_APP app_id) || exit $?; export GITHUB_APP_ID
  - GITHUB_INSTALLATION_ID=$($CI_PROJECT_DIR/tools/ci/fetch_secret.sh $AGENT_GITHUB_APP installation_id) || exit $?; export GITHUB_INSTALLATION_ID
  - echo "Using agent GitHub App"

## Shared `dd-pkg` steps:
# - Install `dd-pkg`, logging the version in use for the job
.setup_dd_pkg:
  - curl --retry 5 -sSL "https://dd-package-tools.s3.amazonaws.com/dd-pkg/${DD_PKG_VERSION}/dd-pkg_Linux_${DD_PKG_ARCH}.tar.gz" | tar -xz -C /usr/local/bin dd-pkg
  - dd-pkg version

# - Lint packages produced by Omnibus (supports only deb and rpm packages)
# - Create detached signatures for packages produced by Omnibus, to be used by agent-release-management in downstream pipelines
.create_signature_and_lint_linux_packages:
  - !reference [.setup_dd_pkg]
  - find $OMNIBUS_PACKAGE_DIR -iregex '.*\.\(deb\|rpm\)' | xargs dd-pkg lint
  - |
    if [ -n "$PACKAGE_REQUIRED_FILES_LIST" ]; then
      find $OMNIBUS_PACKAGE_DIR \( -name '*.deb' -or -name '*.rpm' \) -a -not -name '*-dbg[_-]*' | xargs dd-pkg check-files --required-files ${PACKAGE_REQUIRED_FILES_LIST}
    fi
  - dd-pkg sign --key-id "${PIPELINE_KEY_ALIAS}" "${OMNIBUS_PACKAGE_DIR}"

# Upload debug symbol packages to Datadog symbol server using datadog-ci to enable
# remote symbolication when using ddprof (datadog's native profiler)
.upload_debug_symbols: |
  # Find debug symbol packages (dbgsym or -dbg packages)
  DEBUG_PACKAGES=$(find $OMNIBUS_PACKAGE_DIR -name '*-dbg*.deb' 2>/dev/null || true)

  if [ -n "$DEBUG_PACKAGES" ]; then
    echo "Found debug symbol packages to upload:"
    echo "$DEBUG_PACKAGES"

    # Get Datadog API key for datadog-ci authentication
    DATADOG_API_KEY=$($CI_PROJECT_DIR/tools/ci/fetch_secret.sh $AGENT_API_KEY_ORG2 token) || exit $?
    export DATADOG_API_KEY

    # Enable beta commands for elf-symbols upload
    export DD_BETA_COMMANDS_ENABLED=1

    # Verify datadog-ci is available
    if ! command -v datadog-ci &> /dev/null; then
      echo "WARNING: datadog-ci not found in PATH, skipping symbol upload"
      exit 0
    fi

    # Upload each debug package using datadog-ci
    for pkg in $DEBUG_PACKAGES; do
      echo "Uploading symbols from: $(basename $pkg)"

      # Extract package to temporary directory
      EXTRACT_DIR=$(mktemp -d)
      dpkg-deb -x "$pkg" "$EXTRACT_DIR" || {
        echo "WARNING: Failed to extract package: $pkg"
        rm -rf "$EXTRACT_DIR"
        continue
      }

      # Upload debug symbols using datadog-ci elf-symbols upload
      # This command scans recursively for ELF files and extracts build IDs automatically
      DEBUG_DIR="$EXTRACT_DIR/opt/datadog-agent/.debug"
      if [ -d "$DEBUG_DIR" ]; then
        echo "Uploading symbols from $DEBUG_DIR"
        datadog-ci elf-symbols upload "$DEBUG_DIR" || {
          echo "WARNING: Symbol upload failed for $pkg (non-fatal)"
        }
      else
        echo "WARNING: No .debug directory found in package at expected location"
        echo "Searching for debug files in package:"
        find "$EXTRACT_DIR" -type f \( -name "*.debug" -o -name "*.dbg" \) | head -10
      fi

      # Cleanup
      rm -rf "$EXTRACT_DIR"
    done

    echo "Debug symbols upload process completed"
  else
    echo "No debug symbol packages matching '*-dbg*.deb' found in $OMNIBUS_PACKAGE_DIR"
  fi

# Login to docker with read-only credentials to avoid rate-limiting
.login_to_docker_readonly:
  - DOCKER_LOGIN=$($CI_PROJECT_DIR/tools/ci/fetch_secret.sh $DOCKER_REGISTRY_RO user) || exit $?
  - $CI_PROJECT_DIR/tools/ci/fetch_secret.sh $DOCKER_REGISTRY_RO token | docker login --username "$DOCKER_LOGIN" --password-stdin "$DOCKER_REGISTRY_URL"
  - EXIT="${PIPESTATUS[0]}"; if [ $EXIT -ne 0 ]; then echo "Unable to locate credentials needs gitlab runner restart"; exit $EXIT; fi

.login_to_docker_readonly_crane:
  - DOCKER_LOGIN=$($CI_PROJECT_DIR/tools/ci/fetch_secret.sh $DOCKER_REGISTRY_RO user) || exit $?
  - $CI_PROJECT_DIR/tools/ci/fetch_secret.sh $DOCKER_REGISTRY_RO token | crane auth login --username "$DOCKER_LOGIN" --password-stdin "$DOCKER_REGISTRY_URL"
  - EXIT="${PIPESTATUS[0]}"; if [ $EXIT -ne 0 ]; then echo "Unable to locate credentials needs gitlab runner restart"; exit $EXIT; fi


.docker_pull_winbuildimage_instrumented:
  - $tmpfile = [System.IO.Path]::GetTempFileName()
  - (& "$CI_PROJECT_DIR\tools\ci\fetch_secret.ps1" -parameterName "$API_KEY_ORG2" -tempFile "$tmpfile")
  - If ($lastExitCode -ne "0") { exit "$lastExitCode" }
  - $Env:DATADOG_API_KEY=$(cat "$tmpfile")
  - C:\datadog-ci.exe trace -- docker pull ${WINBUILDIMAGE}
