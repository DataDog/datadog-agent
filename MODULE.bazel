# Foundational packages

http_archive = use_repo_rule("//third_party/bazel/tools/build_defs/repo:http.bzl", "http_archive")

# package_metadata and rules_license are dependencies of every module in the
# Bazel ecosystem.  We pin those first to get the versions we require.
# Instead of the canonical rules_license, we use the version from supply-chain.
# This allows mixing both old and new license rules during the multi-year
# migration between the two styles.
bazel_dep(name = "package_metadata", version = "0.0.5")

# We are currently using one that is ahead of the latest BCR release
archive_override(
    module_name = "package_metadata",
    sha256 = "5bd0cc7594ea528fd28f98d82457f157827d48cc20e07bcfdbb56072f35c8f67",
    strip_prefix = "supply-chain-0.0.6/metadata",
    urls = ["https://github.com/bazel-contrib/supply-chain/archive/refs/tags/v0.0.6.tar.gz"],
)

# The rules_license overlay will never be available in the BCR, for obvious name confusion reasons.
# We are temporarily using a development fork
bazel_dep(name = "rules_license", version = "1.0.0")
archive_override(
    module_name = "rules_license",
    # sha256 = TBD,
    strip_prefix = "supply-chain-dd_test/rules_license",
    urls = ["https://github.com/aiuto/supply-chain/archive/refs/tags/dd_test.tar.gz"],
)

# supply-chain will not be available in the BCR for the foreseable future.
include("//deps/supply_chain:supply_chain.MODULE.bazel")

bazel_dep(name = "platforms", version = "1.0.0")
bazel_dep(name = "bazel_features", version = "1.34.0")
bazel_dep(name = "bazel_skylib", version = "1.8.1")
bazel_dep(name = "rules_pkg", version = "1.1.0")
bazel_dep(name = "rules_shell", version = "0.6.1")

# Temporary until a future rules_pkg release
git_override(
    module_name = "rules_pkg",
    commit = "4eed5466fb7062e196c4fa01495e1dfe0cf5c850",
    remote = "https://github.com/bazelbuild/rules_pkg",
)

#########################
## Prebuilt binaries   ##
#########################

http_archive(
    name = "com_github_bazelbuild_buildtools",
    patch_strip = 1,
    patches = [
        "//bazel/patches:buildifier-build.patch",  # bazelbuild/buildtools#1398
        "//bazel/patches:buildifier-internal-factory.patch",  # bazelbuild/buildtools#1399
        "//bazel/patches:buildifier-runner-bat-template.patch",  # bazelbuild/buildtools#1400 bazelbuild/buildtools#1404
    ],
    sha256 = "53119397bbce1cd7e4c590e117dcda343c2086199de62932106c80733526c261",
    strip_prefix = "buildtools-8.2.1",
    urls = ["https://github.com/bazelbuild/buildtools/archive/refs/tags/v8.2.1.tar.gz"],
)

bazel_dep(name = "rules_multitool", version = "1.9.0")

multitool = use_extension("@rules_multitool//multitool:extension.bzl", "multitool")
multitool.hub(lockfile = "//bazel:prebuilt_buildtools.json")
multitool.hub(lockfile = "//bazel:prebuilt_jq.json")
use_repo(multitool, "multitool")

######################################
## Compilers and toolchains        ##
####################################

bazel_dep(name = "rules_cc", version = "0.2.8")
bazel_dep(name = "rules_python", version = "1.6.1")
bazel_dep(name = "rules_flex", version = "0.4")
bazel_dep(name = "rules_m4", version = "0.3")
bazel_dep(name = "gcc_toolchain", version = "0.9.0")
git_override(
    module_name = "gcc_toolchain",
    commit = "0e2242b07961107d2b05a6552d70b2ef4ef485fb",
    patch_args = ["-p1"],
    patches = [
        "//bazel/patches:datadog_agent_toolchain.patch",
        "//bazel/patches:0001-fix-c-x86_64-header-locations-with-our-ctng-toolchai.patch",
    ],
    remote = "https://github.com/f0rmiga/gcc-toolchain.git",
)

gcc_toolchains = use_extension("@gcc_toolchain//toolchain:module_extensions.bzl", "gcc_toolchains", dev_dependency = True)
gcc_toolchains.toolchain(
    name = "gcc_toolchain_x86_64",
    binary_prefix = "x86_64-unknown-linux-gnu-",
    gcc_version = "11.4.0",
    target_arch = "x86_64",
)
gcc_toolchains.toolchain(
    name = "gcc_toolchain_aarch64",
    binary_prefix = "aarch64-unknown-linux-gnu-",
    gcc_version = "12.3.0",
    target_arch = "aarch64",
)
use_repo(gcc_toolchains, "gcc_toolchain_x86_64")
use_repo(gcc_toolchains, "gcc_toolchain_aarch64")

# TODO{agent-build}: Find a way to register platform-specific toolchains dynamically
register_toolchains(
    "@gcc_toolchain_x86_64//:cc_toolchain",
    "@gcc_toolchain_aarch64//:cc_toolchain",
    "//bazel/toolchains/mingw:mingw_cc_toolchain",
)

# =========================================
# Python dependencies
# =========================================

# Use the toolchain from the container, as if it was hermetic.
# from https://rules-python.readthedocs.io/en/latest/toolchains.html

local_runtime_repo = use_repo_rule(
    "@rules_python//python/local_toolchains:repos.bzl",
    "local_runtime_repo",
)

local_runtime_toolchains_repo = use_repo_rule(
    "@rules_python//python/local_toolchains:repos.bzl",
    "local_runtime_toolchains_repo",
)

# Step 1: Define the Python runtime
local_runtime_repo(
    name = "local_python3",
    dev_dependency = True,
    interpreter_path = "python3",
    on_failure = "fail",
)

# Step 2: Create toolchains for the runtimes
local_runtime_toolchains_repo(
    name = "local_python_toolchains",
    dev_dependency = True,
    runtimes = ["local_python3"],
)

# Step 3: Register the toolchains
register_toolchains(
    "@local_python_toolchains//:all",
    dev_dependency = True,
)

#########################
## Native dependencies ##
#########################

# Make our 3rd parties depencency repositories known
include("//deps:repos.MODULE.bazel")
