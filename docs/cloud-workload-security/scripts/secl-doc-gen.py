import argparse
import json
import os
from dataclasses import dataclass

import jinja2


@dataclass
class EventTypeProperty:
    name: str
    datatype: str
    definition: str


@dataclass
class EventType:
    name: str
    kind: str
    definition: str
    min_agent_version: str
    properties: list[EventTypeProperty]


class Translator:
    def __init__(self, translation_path: str):
        if translation_path:
            translation_file = open(translation_path)
            self.keys = json.load(translation_file)
            translation_file.close()

    def get_or_default(self, key: str, default):
        return self.keys.get(key, default)

    def build_event_type(self, name: str, kind: str, definition: str, min_agent_version: str):
        definition = self.get_or_default(f"{name}_definition", definition)
        return EventType(name, kind, definition, min_agent_version, [])

    def build_event_type_property(self, name: str, datatype: str, definition: str):
        normalized_name = name.replace(".", "_")
        definition = self.get_or_default(f"{normalized_name}_definition", definition)
        return EventTypeProperty(name, datatype, definition)


def build_event_types(translator: Translator, json_top_node):
    event_types = []
    for et in json_top_node["secl"]:
        event_type = translator.build_event_type(et["name"], et["type"], et["definition"], et["from_agent_version"])
        for p in et["properties"]:
            prop = translator.build_event_type_property(p["name"], p["type"], p["definition"])
            event_type.properties.append(prop)
        event_types.append(event_type)
    return event_types


def fill_template(event_types, template_name):
    env = jinja2.Environment(
        loader=jinja2.FileSystemLoader(os.path.join(os.path.dirname(__file__), "templates")),
        autoescape=jinja2.select_autoescape(),
        trim_blocks=True,
    )
    templ = env.get_template(template_name)
    return templ.render(event_types=event_types)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Generate SECL documentation")
    parser.add_argument("--input", type=str, help="input json file generated by the accessors generator")
    parser.add_argument("--output", type=str, help="output file")
    parser.add_argument("--output-et-partial", type=str, help="output file for the event types partial")
    parser.add_argument("--translation", type=str, help="translation file path")
    parser.add_argument("--template", type=str, default="secl.md", help="template used for the generation")
    parser.add_argument("--et-partial-template", type=str, default="secl_event_types.md", help="template used for the generation")
    args = parser.parse_args()

    translator = Translator(args.translation)

    secl_json_file = open(args.input)
    json_top_node = json.load(secl_json_file)
    secl_json_file.close()

    event_types = build_event_types(translator, json_top_node)

    output_file = open(args.output, "w")
    print(fill_template(event_types, args.template), file=output_file)
    output_file.close()

    partial_et_file = open(args.output_et_partial, "w")
    print(fill_template(event_types, args.et_partial_template), file=partial_et_file)
    partial_et_file.close()
